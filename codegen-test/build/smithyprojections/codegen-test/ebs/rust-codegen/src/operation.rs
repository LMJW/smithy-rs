// Code generated by software.amazon.smithy.rust.codegen.smithy-rs. DO NOT EDIT.
use crate::input::CompleteSnapshotInput;
use crate::input::GetSnapshotBlockInput;
use crate::input::ListChangedBlocksInput;
use crate::input::ListSnapshotBlocksInput;
use crate::input::PutSnapshotBlockInput;
use crate::input::StartSnapshotInput;
use crate::output::CompleteSnapshotOutput;
use crate::output::GetSnapshotBlockOutput;
use crate::output::ListChangedBlocksOutput;
use crate::output::ListSnapshotBlocksOutput;
use crate::output::PutSnapshotBlockOutput;
use crate::output::StartSnapshotOutput;
/// <p>Seals and completes the snapshot after all of the required blocks of data have been
/// written to it. Completing the snapshot changes the status to <code>completed</code>. You
/// cannot write new blocks to a snapshot after it has been completed.</p>
pub struct CompleteSnapshot {
    input: CompleteSnapshotInput,
}
impl CompleteSnapshot {
    /// Creates a new builder-style object to manufacture [`CompleteSnapshotInput`](crate::input::CompleteSnapshotInput)
    pub fn builder() -> crate::input::complete_snapshot_input::Builder {
        crate::input::complete_snapshot_input::Builder::default()
    }
    pub fn build_http_request(&self) -> ::http::request::Request<Vec<u8>> {
        CompleteSnapshotInput::assemble(self.input.request_builder_base(), self.input.build_body())
    }
    fn from_response(
        response: &::http::response::Response<impl AsRef<[u8]>>,
    ) -> Result<CompleteSnapshotOutput, crate::error::CompleteSnapshotError> {
        let _ = response;
        todo!()
    }
    pub fn parse_response(
        &self,
        response: &::http::response::Response<impl AsRef<[u8]>>,
    ) -> Result<CompleteSnapshotOutput, crate::error::CompleteSnapshotError> {
        Self::from_response(&response)
    }
    pub fn new(input: CompleteSnapshotInput) -> Self {
        Self { input }
    }
}

/// <p>Returns the data in a block in an Amazon Elastic Block Store snapshot.</p>
pub struct GetSnapshotBlock {
    input: GetSnapshotBlockInput,
}
impl GetSnapshotBlock {
    /// Creates a new builder-style object to manufacture [`GetSnapshotBlockInput`](crate::input::GetSnapshotBlockInput)
    pub fn builder() -> crate::input::get_snapshot_block_input::Builder {
        crate::input::get_snapshot_block_input::Builder::default()
    }
    pub fn build_http_request(&self) -> ::http::request::Request<Vec<u8>> {
        GetSnapshotBlockInput::assemble(self.input.request_builder_base(), self.input.build_body())
    }
    fn from_response(
        response: &::http::response::Response<impl AsRef<[u8]>>,
    ) -> Result<GetSnapshotBlockOutput, crate::error::GetSnapshotBlockError> {
        let _ = response;
        todo!()
    }
    pub fn parse_response(
        &self,
        response: &::http::response::Response<impl AsRef<[u8]>>,
    ) -> Result<GetSnapshotBlockOutput, crate::error::GetSnapshotBlockError> {
        Self::from_response(&response)
    }
    pub fn new(input: GetSnapshotBlockInput) -> Self {
        Self { input }
    }
}

/// <p>Returns information about the blocks that are different between two
/// Amazon Elastic Block Store snapshots of the same volume/snapshot lineage.</p>
pub struct ListChangedBlocks {
    input: ListChangedBlocksInput,
}
impl ListChangedBlocks {
    /// Creates a new builder-style object to manufacture [`ListChangedBlocksInput`](crate::input::ListChangedBlocksInput)
    pub fn builder() -> crate::input::list_changed_blocks_input::Builder {
        crate::input::list_changed_blocks_input::Builder::default()
    }
    pub fn build_http_request(&self) -> ::http::request::Request<Vec<u8>> {
        ListChangedBlocksInput::assemble(self.input.request_builder_base(), self.input.build_body())
    }
    fn from_response(
        response: &::http::response::Response<impl AsRef<[u8]>>,
    ) -> Result<ListChangedBlocksOutput, crate::error::ListChangedBlocksError> {
        let _ = response;
        todo!()
    }
    pub fn parse_response(
        &self,
        response: &::http::response::Response<impl AsRef<[u8]>>,
    ) -> Result<ListChangedBlocksOutput, crate::error::ListChangedBlocksError> {
        Self::from_response(&response)
    }
    pub fn new(input: ListChangedBlocksInput) -> Self {
        Self { input }
    }
}

/// <p>Returns information about the blocks in an Amazon Elastic Block Store snapshot.</p>
pub struct ListSnapshotBlocks {
    input: ListSnapshotBlocksInput,
}
impl ListSnapshotBlocks {
    /// Creates a new builder-style object to manufacture [`ListSnapshotBlocksInput`](crate::input::ListSnapshotBlocksInput)
    pub fn builder() -> crate::input::list_snapshot_blocks_input::Builder {
        crate::input::list_snapshot_blocks_input::Builder::default()
    }
    pub fn build_http_request(&self) -> ::http::request::Request<Vec<u8>> {
        ListSnapshotBlocksInput::assemble(
            self.input.request_builder_base(),
            self.input.build_body(),
        )
    }
    fn from_response(
        response: &::http::response::Response<impl AsRef<[u8]>>,
    ) -> Result<ListSnapshotBlocksOutput, crate::error::ListSnapshotBlocksError> {
        let _ = response;
        todo!()
    }
    pub fn parse_response(
        &self,
        response: &::http::response::Response<impl AsRef<[u8]>>,
    ) -> Result<ListSnapshotBlocksOutput, crate::error::ListSnapshotBlocksError> {
        Self::from_response(&response)
    }
    pub fn new(input: ListSnapshotBlocksInput) -> Self {
        Self { input }
    }
}

/// <p>Writes a block of data to a snapshot. If the specified block contains
/// data, the existing data is overwritten. The target snapshot must be in the
/// <code>pending</code> state.</p>    
/// <p>Data written to a snapshot must be aligned with 512-byte sectors.</p>
pub struct PutSnapshotBlock {
    input: PutSnapshotBlockInput,
}
impl PutSnapshotBlock {
    /// Creates a new builder-style object to manufacture [`PutSnapshotBlockInput`](crate::input::PutSnapshotBlockInput)
    pub fn builder() -> crate::input::put_snapshot_block_input::Builder {
        crate::input::put_snapshot_block_input::Builder::default()
    }
    pub fn build_http_request(&self) -> ::http::request::Request<Vec<u8>> {
        PutSnapshotBlockInput::assemble(self.input.request_builder_base(), self.input.build_body())
    }
    fn from_response(
        response: &::http::response::Response<impl AsRef<[u8]>>,
    ) -> Result<PutSnapshotBlockOutput, crate::error::PutSnapshotBlockError> {
        let _ = response;
        todo!()
    }
    pub fn parse_response(
        &self,
        response: &::http::response::Response<impl AsRef<[u8]>>,
    ) -> Result<PutSnapshotBlockOutput, crate::error::PutSnapshotBlockError> {
        Self::from_response(&response)
    }
    pub fn new(input: PutSnapshotBlockInput) -> Self {
        Self { input }
    }
}

/// <p>Creates a new Amazon EBS snapshot. The new snapshot enters the <code>pending</code> state
/// after the request completes. </p>
/// <p>After creating the snapshot, use <a href="https://docs.aws.amazon.com/ebs/latest/APIReference/API_PutSnapshotBlock.html"> PutSnapshotBlock</a> to
/// write blocks of data to the snapshot.</p>
pub struct StartSnapshot {
    input: StartSnapshotInput,
}
impl StartSnapshot {
    /// Creates a new builder-style object to manufacture [`StartSnapshotInput`](crate::input::StartSnapshotInput)
    pub fn builder() -> crate::input::start_snapshot_input::Builder {
        crate::input::start_snapshot_input::Builder::default()
    }
    pub fn build_http_request(&self) -> ::http::request::Request<Vec<u8>> {
        StartSnapshotInput::assemble(self.input.request_builder_base(), self.input.build_body())
    }
    fn from_response(
        response: &::http::response::Response<impl AsRef<[u8]>>,
    ) -> Result<StartSnapshotOutput, crate::error::StartSnapshotError> {
        let _ = response;
        todo!()
    }
    pub fn parse_response(
        &self,
        response: &::http::response::Response<impl AsRef<[u8]>>,
    ) -> Result<StartSnapshotOutput, crate::error::StartSnapshotError> {
        Self::from_response(&response)
    }
    pub fn new(input: StartSnapshotInput) -> Self {
        Self { input }
    }
}
