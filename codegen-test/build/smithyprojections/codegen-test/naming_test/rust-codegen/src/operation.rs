// Code generated by software.amazon.smithy.rust.codegen.smithy-rs. DO NOT EDIT.
use crate::model::String;
use crate::model::Vec;
use crate::serializer::ReservedWordsAsMembersInputBody;
use crate::serializer::StructureNamePunningInputBody;
impl ErrCollisionsInput {
    pub fn request_builder_base(&self) -> ::http::request::Builder {
        let builder = ::http::request::Builder::new();
        builder
            .method("POST")
            .header("Content-Type", "application/x-amz-json-1.1")
            .header("X-Amz-Target", "Config.ErrCollisions")
    }
    pub fn build_body(&self) -> ::std::vec::Vec<u8> {
        vec![]
    }
    pub fn assemble(
        builder: ::http::request::Builder,
        body: ::std::vec::Vec<u8>,
    ) -> ::http::request::Request<::std::vec::Vec<u8>> {
        builder
            .header(::http::header::CONTENT_LENGTH, body.len())
            .body(body)
            .expect("http request should be valid")
    }
}

impl ReservedWordsAsMembersInput {
    pub fn request_builder_base(&self) -> ::http::request::Builder {
        let builder = ::http::request::Builder::new();
        builder
            .method("POST")
            .header("Content-Type", "application/x-amz-json-1.1")
            .header("X-Amz-Target", "Config.ReservedWordsAsMembers")
    }
    fn body(&self) -> ReservedWordsAsMembersInputBody {
        ReservedWordsAsMembersInputBody {
            r#as: &self.r#as,
            r#async: &self.r#async,
        }
    }
    pub fn build_body(&self) -> ::std::vec::Vec<u8> {
        ::serde_json::to_vec(&self.body()).expect("serialization should succeed")
    }
    pub fn assemble(
        builder: ::http::request::Builder,
        body: ::std::vec::Vec<u8>,
    ) -> ::http::request::Request<::std::vec::Vec<u8>> {
        builder
            .header(::http::header::CONTENT_LENGTH, body.len())
            .body(body)
            .expect("http request should be valid")
    }
}
#[cfg(test)]
#[allow(unreachable_code, unused_variables)]
mod reserved_words_as_members_request_test {

    use crate::operation::ReservedWordsAsMembersInput;
    /// Test ID: reserved_words
    #[test]
    fn test_reserved_words_request() {
        let input = ReservedWordsAsMembersInput::builder()
            .r#as(5)
            .r#async(true)
            .build();
        let http_request =
            ReservedWordsAsMembersInput::assemble(input.request_builder_base(), input.build_body());

        assert_eq!(http_request.method(), "POST");
        assert_eq!(http_request.uri().path(), "/");

        ::protocol_test_helpers::assert_ok(::protocol_test_helpers::validate_body(
            input.build_body(),
            "{\"as\": 5, \"async\": true}",
            ::protocol_test_helpers::MediaType::from("application/json"),
        ));
    }
}

impl StructureNamePunningInput {
    pub fn request_builder_base(&self) -> ::http::request::Builder {
        let builder = ::http::request::Builder::new();
        builder
            .method("POST")
            .header("Content-Type", "application/x-amz-json-1.1")
            .header("X-Amz-Target", "Config.StructureNamePunning")
    }
    fn body(&self) -> StructureNamePunningInputBody {
        StructureNamePunningInputBody {
            regular_string: &self.regular_string,
            punned_string: &self.punned_string,
            punned_vec: &self.punned_vec,
        }
    }
    pub fn build_body(&self) -> ::std::vec::Vec<u8> {
        ::serde_json::to_vec(&self.body()).expect("serialization should succeed")
    }
    pub fn assemble(
        builder: ::http::request::Builder,
        body: ::std::vec::Vec<u8>,
    ) -> ::http::request::Request<::std::vec::Vec<u8>> {
        builder
            .header(::http::header::CONTENT_LENGTH, body.len())
            .body(body)
            .expect("http request should be valid")
    }
}
#[cfg(test)]
#[allow(unreachable_code, unused_variables)]
mod structure_name_punning_request_test {

    use crate::model::String;
    use crate::operation::StructureNamePunningInput;
    /// Test ID: structure_punning
    #[test]
    fn test_structure_punning_request() {
        let input = StructureNamePunningInput::builder()
            .regular_string("hello!".to_string())
            .punned_string(String::builder().ps_member(true).build())
            .build();
        let http_request =
            StructureNamePunningInput::assemble(input.request_builder_base(), input.build_body());

        assert_eq!(http_request.method(), "POST");
        assert_eq!(http_request.uri().path(), "/");

        ::protocol_test_helpers::assert_ok(::protocol_test_helpers::validate_body(
            input.build_body(),
            "{\"regular_string\": \"hello!\", \"punned_string\": { \"ps_member\": true }}",
            ::protocol_test_helpers::MediaType::from("application/json"),
        ));
    }
}

#[non_exhaustive]
#[derive(::std::clone::Clone, ::std::cmp::PartialEq, ::std::fmt::Debug)]
pub struct ErrCollisionsOutput {}
impl ErrCollisionsOutput {
    /// Creates a new builder-style object to manufacture [`ErrCollisionsOutput`](crate::operation::ErrCollisionsOutput)
    pub fn builder() -> crate::operation::err_collisions_output::Builder {
        crate::operation::err_collisions_output::Builder::default()
    }
}
/// See [`ErrCollisionsOutput`](crate::operation::ErrCollisionsOutput)
pub mod err_collisions_output {

    use crate::operation::ErrCollisionsOutput;
    /// A builder for [`ErrCollisionsOutput`](crate::operation::ErrCollisionsOutput)
    #[non_exhaustive]
    #[derive(Debug, Clone, Default)]
    pub struct Builder {}
    impl Builder {
        /// Consumes the builder and constructs a [`ErrCollisionsOutput`](crate::operation::ErrCollisionsOutput)
        pub fn build(self) -> ErrCollisionsOutput {
            ErrCollisionsOutput {}
        }
    }
}

#[non_exhaustive]
#[derive(::std::clone::Clone, ::std::cmp::PartialEq, ::std::fmt::Debug)]
pub struct ErrCollisionsInput {}
impl ErrCollisionsInput {
    /// Creates a new builder-style object to manufacture [`ErrCollisionsInput`](crate::operation::ErrCollisionsInput)
    pub fn builder() -> crate::operation::err_collisions_input::Builder {
        crate::operation::err_collisions_input::Builder::default()
    }
}
/// See [`ErrCollisionsInput`](crate::operation::ErrCollisionsInput)
pub mod err_collisions_input {

    use crate::operation::ErrCollisionsInput;
    /// A builder for [`ErrCollisionsInput`](crate::operation::ErrCollisionsInput)
    #[non_exhaustive]
    #[derive(Debug, Clone, Default)]
    pub struct Builder {}
    impl Builder {
        /// Consumes the builder and constructs a [`ErrCollisionsInput`](crate::operation::ErrCollisionsInput)
        pub fn build(self) -> ErrCollisionsInput {
            ErrCollisionsInput {}
        }
    }
}

#[non_exhaustive]
#[derive(::std::clone::Clone, ::std::cmp::PartialEq, ::std::fmt::Debug)]
pub struct StructureNamePunningOutput {}
impl StructureNamePunningOutput {
    /// Creates a new builder-style object to manufacture [`StructureNamePunningOutput`](crate::operation::StructureNamePunningOutput)
    pub fn builder() -> crate::operation::structure_name_punning_output::Builder {
        crate::operation::structure_name_punning_output::Builder::default()
    }
}
/// See [`StructureNamePunningOutput`](crate::operation::StructureNamePunningOutput)
pub mod structure_name_punning_output {

    use crate::operation::StructureNamePunningOutput;
    /// A builder for [`StructureNamePunningOutput`](crate::operation::StructureNamePunningOutput)
    #[non_exhaustive]
    #[derive(Debug, Clone, Default)]
    pub struct Builder {}
    impl Builder {
        /// Consumes the builder and constructs a [`StructureNamePunningOutput`](crate::operation::StructureNamePunningOutput)
        pub fn build(self) -> StructureNamePunningOutput {
            StructureNamePunningOutput {}
        }
    }
}

#[non_exhaustive]
#[derive(::std::clone::Clone, ::std::cmp::PartialEq, ::std::fmt::Debug)]
pub struct StructureNamePunningInput {
    pub regular_string: ::std::option::Option<::std::string::String>,
    pub punned_string: ::std::option::Option<String>,
    pub punned_vec: ::std::option::Option<Vec>,
}
impl StructureNamePunningInput {
    /// Creates a new builder-style object to manufacture [`StructureNamePunningInput`](crate::operation::StructureNamePunningInput)
    pub fn builder() -> crate::operation::structure_name_punning_input::Builder {
        crate::operation::structure_name_punning_input::Builder::default()
    }
}
/// See [`StructureNamePunningInput`](crate::operation::StructureNamePunningInput)
pub mod structure_name_punning_input {

    use crate::model::String;
    use crate::model::Vec;
    use crate::operation::StructureNamePunningInput;
    /// A builder for [`StructureNamePunningInput`](crate::operation::StructureNamePunningInput)
    #[non_exhaustive]
    #[derive(Debug, Clone, Default)]
    pub struct Builder {
        regular_string: ::std::option::Option<::std::string::String>,
        punned_string: ::std::option::Option<String>,
        punned_vec: ::std::option::Option<Vec>,
    }
    impl Builder {
        pub fn regular_string(mut self, inp: impl Into<::std::string::String>) -> Self {
            self.regular_string = Some(inp.into());
            self
        }
        pub fn punned_string(mut self, inp: String) -> Self {
            self.punned_string = Some(inp);
            self
        }
        pub fn punned_vec(mut self, inp: Vec) -> Self {
            self.punned_vec = Some(inp);
            self
        }
        /// Consumes the builder and constructs a [`StructureNamePunningInput`](crate::operation::StructureNamePunningInput)
        pub fn build(self) -> StructureNamePunningInput {
            StructureNamePunningInput {
                regular_string: self.regular_string,
                punned_string: self.punned_string,
                punned_vec: self.punned_vec,
            }
        }
    }
}

#[non_exhaustive]
#[derive(::std::clone::Clone, ::std::cmp::PartialEq, ::std::fmt::Debug)]
pub struct ReservedWordsAsMembersOutput {}
impl ReservedWordsAsMembersOutput {
    /// Creates a new builder-style object to manufacture [`ReservedWordsAsMembersOutput`](crate::operation::ReservedWordsAsMembersOutput)
    pub fn builder() -> crate::operation::reserved_words_as_members_output::Builder {
        crate::operation::reserved_words_as_members_output::Builder::default()
    }
}
/// See [`ReservedWordsAsMembersOutput`](crate::operation::ReservedWordsAsMembersOutput)
pub mod reserved_words_as_members_output {

    use crate::operation::ReservedWordsAsMembersOutput;
    /// A builder for [`ReservedWordsAsMembersOutput`](crate::operation::ReservedWordsAsMembersOutput)
    #[non_exhaustive]
    #[derive(Debug, Clone, Default)]
    pub struct Builder {}
    impl Builder {
        /// Consumes the builder and constructs a [`ReservedWordsAsMembersOutput`](crate::operation::ReservedWordsAsMembersOutput)
        pub fn build(self) -> ReservedWordsAsMembersOutput {
            ReservedWordsAsMembersOutput {}
        }
    }
}

#[non_exhaustive]
#[derive(::std::clone::Clone, ::std::cmp::PartialEq, ::std::fmt::Debug)]
pub struct ReservedWordsAsMembersInput {
    pub r#as: ::std::option::Option<i32>,
    pub r#async: ::std::option::Option<bool>,
}
impl ReservedWordsAsMembersInput {
    /// Creates a new builder-style object to manufacture [`ReservedWordsAsMembersInput`](crate::operation::ReservedWordsAsMembersInput)
    pub fn builder() -> crate::operation::reserved_words_as_members_input::Builder {
        crate::operation::reserved_words_as_members_input::Builder::default()
    }
}
/// See [`ReservedWordsAsMembersInput`](crate::operation::ReservedWordsAsMembersInput)
pub mod reserved_words_as_members_input {

    use crate::operation::ReservedWordsAsMembersInput;
    /// A builder for [`ReservedWordsAsMembersInput`](crate::operation::ReservedWordsAsMembersInput)
    #[non_exhaustive]
    #[derive(Debug, Clone, Default)]
    pub struct Builder {
        r#as: ::std::option::Option<i32>,
        r#async: ::std::option::Option<bool>,
    }
    impl Builder {
        pub fn r#as(mut self, inp: i32) -> Self {
            self.r#as = Some(inp);
            self
        }
        pub fn r#async(mut self, inp: bool) -> Self {
            self.r#async = Some(inp);
            self
        }
        /// Consumes the builder and constructs a [`ReservedWordsAsMembersInput`](crate::operation::ReservedWordsAsMembersInput)
        pub fn build(self) -> ReservedWordsAsMembersInput {
            ReservedWordsAsMembersInput {
                r#as: self.r#as,
                r#async: self.r#async,
            }
        }
    }
}
