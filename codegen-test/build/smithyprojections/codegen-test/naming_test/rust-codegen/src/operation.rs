// Code generated by software.amazon.smithy.rust.codegen.smithy-rs. DO NOT EDIT.
use crate::input::ErrCollisionsInput;
use crate::input::ReservedWordsAsMembersInput;
use crate::input::StructureNamePunningInput;
use crate::output::ErrCollisionsOutput;
use crate::output::ReservedWordsAsMembersOutput;
use crate::output::StructureNamePunningOutput;
pub struct ErrCollisions {
    input: ErrCollisionsInput,
}
impl ErrCollisions {
    /// Creates a new builder-style object to manufacture [`ErrCollisionsInput`](crate::input::ErrCollisionsInput)
    pub fn builder() -> crate::input::err_collisions_input::Builder {
        crate::input::err_collisions_input::Builder::default()
    }
    pub fn build_http_request(&self) -> ::http::request::Request<Vec<u8>> {
        ErrCollisionsInput::assemble(self.input.request_builder_base(), self.input.build_body())
    }
    fn from_response(
        response: &::http::response::Response<impl AsRef<[u8]>>,
    ) -> Result<ErrCollisionsOutput, crate::error::ErrCollisionsError> {
        if crate::aws_json_errors::is_error(&response) {
            let body = ::serde_json::from_slice(response.body().as_ref())
                .unwrap_or_else(|_| ::serde_json::json!({}));
            let generic = crate::aws_json_errors::parse_generic_error(&response, &body);

            let error_code = match generic.code() {
                Some(code) => code,
                None => return Err(crate::error::ErrCollisionsError::unhandled(generic)),
            };
            return Err(match error_code {
                "CollidingError" => match ::serde_json::from_value(body) {
                    Ok(body) => crate::error::ErrCollisionsError::CollidingError(body),
                    Err(e) => crate::error::ErrCollisionsError::unhandled(e),
                },
                "CollidingException" => match ::serde_json::from_value(body) {
                    Ok(body) => crate::error::ErrCollisionsError::CollidingException(body),
                    Err(e) => crate::error::ErrCollisionsError::unhandled(e),
                },
                _ => crate::error::ErrCollisionsError::unhandled(generic),
            });
        }
        Ok(ErrCollisionsOutput {})
    }
    pub fn parse_response(
        &self,
        response: &::http::response::Response<impl AsRef<[u8]>>,
    ) -> Result<ErrCollisionsOutput, crate::error::ErrCollisionsError> {
        Self::from_response(&response)
    }
    pub fn new(input: ErrCollisionsInput) -> Self {
        Self { input }
    }
}

pub struct ReservedWordsAsMembers {
    input: ReservedWordsAsMembersInput,
}
impl ReservedWordsAsMembers {
    /// Creates a new builder-style object to manufacture [`ReservedWordsAsMembersInput`](crate::input::ReservedWordsAsMembersInput)
    pub fn builder() -> crate::input::reserved_words_as_members_input::Builder {
        crate::input::reserved_words_as_members_input::Builder::default()
    }
    pub fn build_http_request(&self) -> ::http::request::Request<Vec<u8>> {
        ReservedWordsAsMembersInput::assemble(
            self.input.request_builder_base(),
            self.input.build_body(),
        )
    }
    fn from_response(
        response: &::http::response::Response<impl AsRef<[u8]>>,
    ) -> Result<ReservedWordsAsMembersOutput, crate::error::ReservedWordsAsMembersError> {
        if crate::aws_json_errors::is_error(&response) {
            let body = ::serde_json::from_slice(response.body().as_ref())
                .unwrap_or_else(|_| ::serde_json::json!({}));
            let generic = crate::aws_json_errors::parse_generic_error(&response, &body);

            return Err(crate::error::ReservedWordsAsMembersError::unhandled(
                generic,
            ));
        }
        Ok(ReservedWordsAsMembersOutput {})
    }
    pub fn parse_response(
        &self,
        response: &::http::response::Response<impl AsRef<[u8]>>,
    ) -> Result<ReservedWordsAsMembersOutput, crate::error::ReservedWordsAsMembersError> {
        Self::from_response(&response)
    }
    pub fn new(input: ReservedWordsAsMembersInput) -> Self {
        Self { input }
    }
}
#[cfg(test)]
#[allow(unreachable_code, unused_variables)]
mod reserved_words_as_members_request_test {

    use crate::input::ReservedWordsAsMembersInput;
    /// Test ID: reserved_words
    #[test]
    fn reserved_words_request() {
        let input = {
            let config = crate::config::Config::builder().build();
            ReservedWordsAsMembersInput::builder()
                .r#as(5)
                .r#async(true)
                .build(&config)
        };
        let http_request = input.build_http_request();

        assert_eq!(http_request.method(), "POST");
        assert_eq!(http_request.uri().path(), "/");

        ::protocol_test_helpers::assert_ok(::protocol_test_helpers::validate_body(
            &http_request.body(),
            "{\"as\": 5, \"async\": true}",
            ::protocol_test_helpers::MediaType::from("application/json"),
        ));
    }
}

pub struct StructureNamePunning {
    input: StructureNamePunningInput,
}
impl StructureNamePunning {
    /// Creates a new builder-style object to manufacture [`StructureNamePunningInput`](crate::input::StructureNamePunningInput)
    pub fn builder() -> crate::input::structure_name_punning_input::Builder {
        crate::input::structure_name_punning_input::Builder::default()
    }
    pub fn build_http_request(&self) -> ::http::request::Request<Vec<u8>> {
        StructureNamePunningInput::assemble(
            self.input.request_builder_base(),
            self.input.build_body(),
        )
    }
    fn from_response(
        response: &::http::response::Response<impl AsRef<[u8]>>,
    ) -> Result<StructureNamePunningOutput, crate::error::StructureNamePunningError> {
        if crate::aws_json_errors::is_error(&response) {
            let body = ::serde_json::from_slice(response.body().as_ref())
                .unwrap_or_else(|_| ::serde_json::json!({}));
            let generic = crate::aws_json_errors::parse_generic_error(&response, &body);

            return Err(crate::error::StructureNamePunningError::unhandled(generic));
        }
        Ok(StructureNamePunningOutput {})
    }
    pub fn parse_response(
        &self,
        response: &::http::response::Response<impl AsRef<[u8]>>,
    ) -> Result<StructureNamePunningOutput, crate::error::StructureNamePunningError> {
        Self::from_response(&response)
    }
    pub fn new(input: StructureNamePunningInput) -> Self {
        Self { input }
    }
}
#[cfg(test)]
#[allow(unreachable_code, unused_variables)]
mod structure_name_punning_request_test {

    use crate::input::StructureNamePunningInput;
    use crate::model::String;
    /// Test ID: structure_punning
    #[test]
    fn structure_punning_request() {
        let input = {
            let config = crate::config::Config::builder().build();
            StructureNamePunningInput::builder()
                .regular_string("hello!".to_string())
                .punned_string({
                    let _ = 5;
                    String::builder().ps_member(true).build()
                })
                .build(&config)
        };
        let http_request = input.build_http_request();

        assert_eq!(http_request.method(), "POST");
        assert_eq!(http_request.uri().path(), "/");

        ::protocol_test_helpers::assert_ok(::protocol_test_helpers::validate_body(
            &http_request.body(),
            "{\"regular_string\": \"hello!\", \"punned_string\": { \"ps_member\": true }}",
            ::protocol_test_helpers::MediaType::from("application/json"),
        ));
    }
}
