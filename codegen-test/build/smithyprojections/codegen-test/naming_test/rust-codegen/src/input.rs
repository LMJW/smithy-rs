// Code generated by software.amazon.smithy.rust.codegen.smithy-rs. DO NOT EDIT.
use crate::model::String;
use crate::model::Vec;
use crate::serializer::ReservedWordsAsMembersInputBody;
use crate::serializer::StructureNamePunningInputBody;
/// See [`ErrCollisionsInput`](crate::input::ErrCollisionsInput)
pub mod err_collisions_input {

    use crate::input::ErrCollisionsInput;
    use crate::operation::ErrCollisions;
    /// A builder for [`ErrCollisionsInput`](crate::input::ErrCollisionsInput)
    #[non_exhaustive]
    #[derive(Debug, Clone, Default)]
    pub struct Builder {}
    impl Builder {
        /// Consumes the builder and constructs a [`ErrCollisions`](crate::operation::ErrCollisions)
        pub fn build(self, _config: &crate::config::Config) -> ErrCollisions {
            ErrCollisions::new(ErrCollisionsInput {})
        }
    }
}
impl ErrCollisionsInput {
    pub fn request_builder_base(&self) -> ::http::request::Builder {
        let builder = ::http::request::Builder::new();

        builder
            .method("POST")
            .header("Content-Type", "application/x-amz-json-1.1")
            .header("X-Amz-Target", "Config.ErrCollisions")
    }
    pub fn build_body(&self) -> ::std::vec::Vec<u8> {
        vec![]
    }
    pub fn assemble(
        builder: ::http::request::Builder,
        body: ::std::vec::Vec<u8>,
    ) -> ::http::request::Request<::std::vec::Vec<u8>> {
        builder
            .header(::http::header::CONTENT_LENGTH, body.len())
            .body(body)
            .expect("http request should be valid")
    }
    /// Creates a new builder-style object to manufacture [`ErrCollisionsInput`](crate::input::ErrCollisionsInput)
    pub fn builder() -> crate::input::err_collisions_input::Builder {
        crate::input::err_collisions_input::Builder::default()
    }
}

/// See [`ReservedWordsAsMembersInput`](crate::input::ReservedWordsAsMembersInput)
pub mod reserved_words_as_members_input {

    use crate::input::ReservedWordsAsMembersInput;
    use crate::operation::ReservedWordsAsMembers;
    /// A builder for [`ReservedWordsAsMembersInput`](crate::input::ReservedWordsAsMembersInput)
    #[non_exhaustive]
    #[derive(Debug, Clone, Default)]
    pub struct Builder {
        r#as: ::std::option::Option<i32>,
        r#async: ::std::option::Option<bool>,
    }
    impl Builder {
        pub fn r#as(mut self, inp: i32) -> Self {
            self.r#as = Some(inp);
            self
        }
        pub fn r#async(mut self, inp: bool) -> Self {
            self.r#async = Some(inp);
            self
        }
        /// Consumes the builder and constructs a [`ReservedWordsAsMembers`](crate::operation::ReservedWordsAsMembers)
        pub fn build(self, _config: &crate::config::Config) -> ReservedWordsAsMembers {
            ReservedWordsAsMembers::new(ReservedWordsAsMembersInput {
                r#as: self.r#as,
                r#async: self.r#async,
            })
        }
    }
}
impl ReservedWordsAsMembersInput {
    pub fn request_builder_base(&self) -> ::http::request::Builder {
        let builder = ::http::request::Builder::new();

        builder
            .method("POST")
            .header("Content-Type", "application/x-amz-json-1.1")
            .header("X-Amz-Target", "Config.ReservedWordsAsMembers")
    }
    fn body(&self) -> ReservedWordsAsMembersInputBody {
        ReservedWordsAsMembersInputBody {
            r#as: &self.r#as,
            r#async: &self.r#async,
        }
    }
    pub fn build_body(&self) -> ::std::vec::Vec<u8> {
        ::serde_json::to_vec(&self.body()).expect("serialization should succeed")
    }
    pub fn assemble(
        builder: ::http::request::Builder,
        body: ::std::vec::Vec<u8>,
    ) -> ::http::request::Request<::std::vec::Vec<u8>> {
        builder
            .header(::http::header::CONTENT_LENGTH, body.len())
            .body(body)
            .expect("http request should be valid")
    }
    /// Creates a new builder-style object to manufacture [`ReservedWordsAsMembersInput`](crate::input::ReservedWordsAsMembersInput)
    pub fn builder() -> crate::input::reserved_words_as_members_input::Builder {
        crate::input::reserved_words_as_members_input::Builder::default()
    }
}

/// See [`StructureNamePunningInput`](crate::input::StructureNamePunningInput)
pub mod structure_name_punning_input {

    use crate::input::StructureNamePunningInput;
    use crate::model::String;
    use crate::model::Vec;
    use crate::operation::StructureNamePunning;
    /// A builder for [`StructureNamePunningInput`](crate::input::StructureNamePunningInput)
    #[non_exhaustive]
    #[derive(Debug, Clone, Default)]
    pub struct Builder {
        regular_string: ::std::option::Option<::std::string::String>,
        punned_string: ::std::option::Option<String>,
        punned_vec: ::std::option::Option<Vec>,
    }
    impl Builder {
        pub fn regular_string(mut self, inp: impl Into<::std::string::String>) -> Self {
            self.regular_string = Some(inp.into());
            self
        }
        pub fn punned_string(mut self, inp: String) -> Self {
            self.punned_string = Some(inp);
            self
        }
        pub fn punned_vec(mut self, inp: Vec) -> Self {
            self.punned_vec = Some(inp);
            self
        }
        /// Consumes the builder and constructs a [`StructureNamePunning`](crate::operation::StructureNamePunning)
        pub fn build(self, _config: &crate::config::Config) -> StructureNamePunning {
            StructureNamePunning::new(StructureNamePunningInput {
                regular_string: self.regular_string,
                punned_string: self.punned_string,
                punned_vec: self.punned_vec,
            })
        }
    }
}
impl StructureNamePunningInput {
    pub fn request_builder_base(&self) -> ::http::request::Builder {
        let builder = ::http::request::Builder::new();

        builder
            .method("POST")
            .header("Content-Type", "application/x-amz-json-1.1")
            .header("X-Amz-Target", "Config.StructureNamePunning")
    }
    fn body(&self) -> StructureNamePunningInputBody {
        StructureNamePunningInputBody {
            regular_string: &self.regular_string,
            punned_string: &self.punned_string,
            punned_vec: &self.punned_vec,
        }
    }
    pub fn build_body(&self) -> ::std::vec::Vec<u8> {
        ::serde_json::to_vec(&self.body()).expect("serialization should succeed")
    }
    pub fn assemble(
        builder: ::http::request::Builder,
        body: ::std::vec::Vec<u8>,
    ) -> ::http::request::Request<::std::vec::Vec<u8>> {
        builder
            .header(::http::header::CONTENT_LENGTH, body.len())
            .body(body)
            .expect("http request should be valid")
    }
    /// Creates a new builder-style object to manufacture [`StructureNamePunningInput`](crate::input::StructureNamePunningInput)
    pub fn builder() -> crate::input::structure_name_punning_input::Builder {
        crate::input::structure_name_punning_input::Builder::default()
    }
}

#[non_exhaustive]
#[derive(::std::clone::Clone, ::std::cmp::PartialEq, ::std::fmt::Debug)]
pub struct ErrCollisionsInput {}

#[non_exhaustive]
#[derive(::std::clone::Clone, ::std::cmp::PartialEq, ::std::fmt::Debug)]
pub struct StructureNamePunningInput {
    pub regular_string: ::std::option::Option<::std::string::String>,
    pub punned_string: ::std::option::Option<String>,
    pub punned_vec: ::std::option::Option<Vec>,
}

#[non_exhaustive]
#[derive(::std::clone::Clone, ::std::cmp::PartialEq, ::std::fmt::Debug)]
pub struct ReservedWordsAsMembersInput {
    pub r#as: ::std::option::Option<i32>,
    pub r#async: ::std::option::Option<bool>,
}
