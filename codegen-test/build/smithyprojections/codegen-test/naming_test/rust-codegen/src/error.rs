// Code generated by software.amazon.smithy.rust.codegen.smithy-rs. DO NOT EDIT.

#[non_exhaustive]
#[derive(::std::fmt::Debug)]
pub enum ErrCollisionsError {
    CollidingError2(CollidingError2),
    CollidingError(CollidingError),

    /// An unexpected error, eg. invalid JSON returned by the service
    Unhandled(Box<dyn ::std::error::Error>),
}
impl ::std::fmt::Display for ErrCollisionsError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match self {
            ErrCollisionsError::CollidingError2(inner) => inner.fmt(f),
            ErrCollisionsError::CollidingError(inner) => inner.fmt(f),
            ErrCollisionsError::Unhandled(inner) => inner.fmt(f),
        }
    }
}
impl ::std::error::Error for ErrCollisionsError {
    fn source(&self) -> Option<&(dyn ::std::error::Error + 'static)> {
        match self {
            ErrCollisionsError::CollidingError2(inner) => Some(inner),
            ErrCollisionsError::CollidingError(inner) => Some(inner),
            ErrCollisionsError::Unhandled(inner) => Some(inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(::std::fmt::Debug)]
pub enum ReservedWordsAsMembersError {
    /// An unexpected error, eg. invalid JSON returned by the service
    Unhandled(Box<dyn ::std::error::Error>),
}
impl ::std::fmt::Display for ReservedWordsAsMembersError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match self {
            ReservedWordsAsMembersError::Unhandled(inner) => inner.fmt(f),
        }
    }
}
impl ::std::error::Error for ReservedWordsAsMembersError {
    fn source(&self) -> Option<&(dyn ::std::error::Error + 'static)> {
        match self {
            ReservedWordsAsMembersError::Unhandled(inner) => Some(inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(::std::fmt::Debug)]
pub enum StructureNamePunningError {
    /// An unexpected error, eg. invalid JSON returned by the service
    Unhandled(Box<dyn ::std::error::Error>),
}
impl ::std::fmt::Display for StructureNamePunningError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match self {
            StructureNamePunningError::Unhandled(inner) => inner.fmt(f),
        }
    }
}
impl ::std::error::Error for StructureNamePunningError {
    fn source(&self) -> Option<&(dyn ::std::error::Error + 'static)> {
        match self {
            StructureNamePunningError::Unhandled(inner) => Some(inner.as_ref()),
        }
    }
}

/// This will be renamed to CollidingError
#[non_exhaustive]
#[derive(
    ::serde::Deserialize,
    ::serde::Serialize,
    ::std::clone::Clone,
    ::std::cmp::PartialEq,
    ::std::fmt::Debug,
)]
pub struct CollidingError {}
impl CollidingError {
    /// Creates a new builder-style object to manufacture [`CollidingError`](crate::error::CollidingError)
    pub fn builder() -> crate::error::colliding_error::Builder {
        crate::error::colliding_error::Builder::default()
    }
}
impl CollidingError {
    pub fn retryable(&self) -> bool {
        false
    }
    pub fn throttling(&self) -> bool {
        false
    }
    pub fn code(&self) -> &str {
        "CollidingException"
    }
    pub fn message(&self) -> Option<&str> {
        None
    }
}
impl ::std::fmt::Display for CollidingError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "CollidingError")?;
        Ok(())
    }
}
impl ::std::error::Error for CollidingError {}
/// See [`CollidingError`](crate::error::CollidingError)
pub mod colliding_error {

    use crate::error::CollidingError;
    /// A builder for [`CollidingError`](crate::error::CollidingError)
    #[non_exhaustive]
    #[derive(Debug, Clone, Default)]
    pub struct Builder {}
    impl Builder {
        /// Consumes the builder and constructs a [`CollidingError`](crate::error::CollidingError)
        pub fn build(self) -> CollidingError {
            CollidingError {}
        }
    }
}

#[non_exhaustive]
#[derive(
    ::serde::Deserialize,
    ::serde::Serialize,
    ::std::clone::Clone,
    ::std::cmp::PartialEq,
    ::std::fmt::Debug,
)]
pub struct CollidingError2 {}
impl CollidingError2 {
    /// Creates a new builder-style object to manufacture [`CollidingError2`](crate::error::CollidingError2)
    pub fn builder() -> crate::error::colliding_error2::Builder {
        crate::error::colliding_error2::Builder::default()
    }
}
impl CollidingError2 {
    pub fn retryable(&self) -> bool {
        false
    }
    pub fn throttling(&self) -> bool {
        false
    }
    pub fn code(&self) -> &str {
        "CollidingError"
    }
    pub fn message(&self) -> Option<&str> {
        None
    }
}
impl ::std::fmt::Display for CollidingError2 {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "CollidingError2")?;
        Ok(())
    }
}
impl ::std::error::Error for CollidingError2 {}
/// See [`CollidingError2`](crate::error::CollidingError2)
pub mod colliding_error2 {

    use crate::error::CollidingError2;
    /// A builder for [`CollidingError2`](crate::error::CollidingError2)
    #[non_exhaustive]
    #[derive(Debug, Clone, Default)]
    pub struct Builder {}
    impl Builder {
        /// Consumes the builder and constructs a [`CollidingError2`](crate::error::CollidingError2)
        pub fn build(self) -> CollidingError2 {
            CollidingError2 {}
        }
    }
}
