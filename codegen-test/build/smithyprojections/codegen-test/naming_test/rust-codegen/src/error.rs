// Code generated by software.amazon.smithy.rust.codegen.smithy-rs. DO NOT EDIT.

#[non_exhaustive]
#[derive(::std::fmt::Debug)]
pub enum ErrCollisionsError {
    CollidingError(CollidingError),
    CollidingException(CollidingException),

    /// An unexpected error, eg. invalid JSON returned by the service
    Unhandled(Box<dyn ::std::error::Error>),
}
impl ::std::fmt::Display for ErrCollisionsError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match self {
            ErrCollisionsError::CollidingError(_inner) => _inner.fmt(f),
            ErrCollisionsError::CollidingException(_inner) => _inner.fmt(f),
            ErrCollisionsError::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl ErrCollisionsError {
    pub fn unhandled<E: Into<Box<dyn ::std::error::Error>>>(err: E) -> Self {
        ErrCollisionsError::Unhandled(err.into())
    }
    pub fn message(&self) -> Option<&str> {
        match self {
            ErrCollisionsError::CollidingError(_inner) => _inner.message(),
            ErrCollisionsError::CollidingException(_inner) => _inner.message(),
            ErrCollisionsError::Unhandled(_inner) => {
                match _inner.downcast_ref::<::smithy_types::Error>() {
                    Some(_inner) => _inner.message(),
                    None => None,
                }
            }
        }
    }
    pub fn code(&self) -> Option<&str> {
        match self {
            ErrCollisionsError::CollidingError(_inner) => Some(_inner.code()),
            ErrCollisionsError::CollidingException(_inner) => Some(_inner.code()),
            ErrCollisionsError::Unhandled(_inner) => {
                match _inner.downcast_ref::<::smithy_types::Error>() {
                    Some(_inner) => _inner.code(),
                    None => None,
                }
            }
        }
    }
}
impl ::std::error::Error for ErrCollisionsError {
    fn source(&self) -> Option<&(dyn ::std::error::Error + 'static)> {
        match self {
            ErrCollisionsError::CollidingError(_inner) => Some(_inner),
            ErrCollisionsError::CollidingException(_inner) => Some(_inner),
            ErrCollisionsError::Unhandled(_inner) => {
                match _inner.downcast_ref::<::smithy_types::Error>() {
                    Some(_inner) => Some(_inner),
                    None => Some(_inner.as_ref()),
                }
            }
        }
    }
}

#[non_exhaustive]
#[derive(::std::fmt::Debug)]
pub enum ReservedWordsAsMembersError {
    /// An unexpected error, eg. invalid JSON returned by the service
    Unhandled(Box<dyn ::std::error::Error>),
}
impl ::std::fmt::Display for ReservedWordsAsMembersError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match self {
            ReservedWordsAsMembersError::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl ReservedWordsAsMembersError {
    pub fn unhandled<E: Into<Box<dyn ::std::error::Error>>>(err: E) -> Self {
        ReservedWordsAsMembersError::Unhandled(err.into())
    }
    pub fn message(&self) -> Option<&str> {
        match self {
            ReservedWordsAsMembersError::Unhandled(_inner) => {
                match _inner.downcast_ref::<::smithy_types::Error>() {
                    Some(_inner) => _inner.message(),
                    None => None,
                }
            }
        }
    }
    pub fn code(&self) -> Option<&str> {
        match self {
            ReservedWordsAsMembersError::Unhandled(_inner) => {
                match _inner.downcast_ref::<::smithy_types::Error>() {
                    Some(_inner) => _inner.code(),
                    None => None,
                }
            }
        }
    }
}
impl ::std::error::Error for ReservedWordsAsMembersError {
    fn source(&self) -> Option<&(dyn ::std::error::Error + 'static)> {
        match self {
            ReservedWordsAsMembersError::Unhandled(_inner) => {
                match _inner.downcast_ref::<::smithy_types::Error>() {
                    Some(_inner) => Some(_inner),
                    None => Some(_inner.as_ref()),
                }
            }
        }
    }
}

#[non_exhaustive]
#[derive(::std::fmt::Debug)]
pub enum StructureNamePunningError {
    /// An unexpected error, eg. invalid JSON returned by the service
    Unhandled(Box<dyn ::std::error::Error>),
}
impl ::std::fmt::Display for StructureNamePunningError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match self {
            StructureNamePunningError::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl StructureNamePunningError {
    pub fn unhandled<E: Into<Box<dyn ::std::error::Error>>>(err: E) -> Self {
        StructureNamePunningError::Unhandled(err.into())
    }
    pub fn message(&self) -> Option<&str> {
        match self {
            StructureNamePunningError::Unhandled(_inner) => {
                match _inner.downcast_ref::<::smithy_types::Error>() {
                    Some(_inner) => _inner.message(),
                    None => None,
                }
            }
        }
    }
    pub fn code(&self) -> Option<&str> {
        match self {
            StructureNamePunningError::Unhandled(_inner) => {
                match _inner.downcast_ref::<::smithy_types::Error>() {
                    Some(_inner) => _inner.code(),
                    None => None,
                }
            }
        }
    }
}
impl ::std::error::Error for StructureNamePunningError {
    fn source(&self) -> Option<&(dyn ::std::error::Error + 'static)> {
        match self {
            StructureNamePunningError::Unhandled(_inner) => {
                match _inner.downcast_ref::<::smithy_types::Error>() {
                    Some(_inner) => Some(_inner),
                    None => Some(_inner.as_ref()),
                }
            }
        }
    }
}

/// This will be renamed to CollidingError
#[non_exhaustive]
#[derive(
    ::serde::Deserialize,
    ::serde::Serialize,
    ::std::clone::Clone,
    ::std::cmp::PartialEq,
    ::std::fmt::Debug,
)]
pub struct CollidingException {}
impl CollidingException {
    pub fn retryable(&self) -> bool {
        false
    }
    pub fn throttling(&self) -> bool {
        false
    }
    pub fn code(&self) -> &str {
        "CollidingException"
    }
    pub fn message(&self) -> Option<&str> {
        None
    }
}
impl ::std::fmt::Display for CollidingException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "CollidingException")?;
        Ok(())
    }
}
impl ::std::error::Error for CollidingException {}
/// See [`CollidingException`](crate::error::CollidingException)
pub mod colliding_exception {

    use crate::error::CollidingException;
    /// A builder for [`CollidingException`](crate::error::CollidingException)
    #[non_exhaustive]
    #[derive(Debug, Clone, Default)]
    pub struct Builder {}
    impl Builder {
        /// Consumes the builder and constructs a [`CollidingException`](crate::error::CollidingException)
        pub fn build(self) -> CollidingException {
            CollidingException {}
        }
    }
}
impl CollidingException {
    /// Creates a new builder-style object to manufacture [`CollidingException`](crate::error::CollidingException)
    pub fn builder() -> crate::error::colliding_exception::Builder {
        crate::error::colliding_exception::Builder::default()
    }
}

#[non_exhaustive]
#[derive(
    ::serde::Deserialize,
    ::serde::Serialize,
    ::std::clone::Clone,
    ::std::cmp::PartialEq,
    ::std::fmt::Debug,
)]
pub struct CollidingError {}
impl CollidingError {
    pub fn retryable(&self) -> bool {
        false
    }
    pub fn throttling(&self) -> bool {
        false
    }
    pub fn code(&self) -> &str {
        "CollidingError"
    }
    pub fn message(&self) -> Option<&str> {
        None
    }
}
impl ::std::fmt::Display for CollidingError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "CollidingError")?;
        Ok(())
    }
}
impl ::std::error::Error for CollidingError {}
/// See [`CollidingError`](crate::error::CollidingError)
pub mod colliding_error {

    use crate::error::CollidingError;
    /// A builder for [`CollidingError`](crate::error::CollidingError)
    #[non_exhaustive]
    #[derive(Debug, Clone, Default)]
    pub struct Builder {}
    impl Builder {
        /// Consumes the builder and constructs a [`CollidingError`](crate::error::CollidingError)
        pub fn build(self) -> CollidingError {
            CollidingError {}
        }
    }
}
impl CollidingError {
    /// Creates a new builder-style object to manufacture [`CollidingError`](crate::error::CollidingError)
    pub fn builder() -> crate::error::colliding_error::Builder {
        crate::error::colliding_error::Builder::default()
    }
}
