// Code generated by software.amazon.smithy.rust.codegen.smithy-rs. DO NOT EDIT.
use smithy_types::Blob;
use smithy_types::Document;
use smithy_types::Instant;
pub fn blob_ser<S>(
    _inp: &Blob,
    _serializer: S,
) -> Result<<S as ::serde::Serializer>::Ok, <S as ::serde::Serializer>::Error>
where
    S: ::serde::Serializer,
{
    use ::serde::Serialize;
    let el = _inp;
    crate::blob_serde::BlobSer(el).serialize(_serializer)
}

pub fn blob_deser<'de, D>(_deser: D) -> Result<Blob, D::Error>
where
    D: ::serde::Deserializer<'de>,
{
    use ::serde::Deserialize;
    Ok(crate::blob_serde::BlobDeser::deserialize(_deser)?.0)
}

pub fn instant_epoch_seconds_ser<S>(
    _inp: &Instant,
    _serializer: S,
) -> Result<<S as ::serde::Serializer>::Ok, <S as ::serde::Serializer>::Error>
where
    S: ::serde::Serializer,
{
    use ::serde::Serialize;
    let el = _inp;
    crate::instant_epoch::InstantEpoch(*el).serialize(_serializer)
}

pub fn instant_epoch_seconds_deser<'de, D>(_deser: D) -> Result<Instant, D::Error>
where
    D: ::serde::Deserializer<'de>,
{
    use ::serde::Deserialize;
    Ok(crate::instant_epoch::InstantEpoch::deserialize(_deser)?.0)
}

pub fn stdoptionoptionblob_ser<S>(
    _inp: &::std::option::Option<Blob>,
    _serializer: S,
) -> Result<<S as ::serde::Serializer>::Ok, <S as ::serde::Serializer>::Error>
where
    S: ::serde::Serializer,
{
    use ::serde::Serialize;
    let el = _inp;
    el.as_ref()
        .map(|el| crate::blob_serde::BlobSer(el))
        .serialize(_serializer)
}

pub fn stdoptionoptionblob_deser<'de, D>(_deser: D) -> Result<::std::option::Option<Blob>, D::Error>
where
    D: ::serde::Deserializer<'de>,
{
    use ::serde::Deserialize;
    Ok(::std::option::Option::<crate::blob_serde::BlobDeser>::deserialize(_deser)?.map(|el| el.0))
}

pub fn stdoptionoptioninstant_http_date_ser<S>(
    _inp: &::std::option::Option<Instant>,
    _serializer: S,
) -> Result<<S as ::serde::Serializer>::Ok, <S as ::serde::Serializer>::Error>
where
    S: ::serde::Serializer,
{
    use ::serde::Serialize;
    let el = _inp;
    el.as_ref()
        .map(|el| crate::instant_httpdate::InstantHttpDate(*el))
        .serialize(_serializer)
}

pub fn stdoptionoptioninstant_http_date_deser<'de, D>(
    _deser: D,
) -> Result<::std::option::Option<Instant>, D::Error>
where
    D: ::serde::Deserializer<'de>,
{
    use ::serde::Deserialize;
    Ok(
        ::std::option::Option::<crate::instant_httpdate::InstantHttpDate>::deserialize(_deser)?
            .map(|el| el.0),
    )
}

pub fn stdoptionoptioninstant_date_time_ser<S>(
    _inp: &::std::option::Option<Instant>,
    _serializer: S,
) -> Result<<S as ::serde::Serializer>::Ok, <S as ::serde::Serializer>::Error>
where
    S: ::serde::Serializer,
{
    use ::serde::Serialize;
    let el = _inp;
    el.as_ref()
        .map(|el| crate::instant_8601::InstantIso8601(*el))
        .serialize(_serializer)
}

pub fn stdoptionoptioninstant_date_time_deser<'de, D>(
    _deser: D,
) -> Result<::std::option::Option<Instant>, D::Error>
where
    D: ::serde::Deserializer<'de>,
{
    use ::serde::Deserialize;
    Ok(
        ::std::option::Option::<crate::instant_8601::InstantIso8601>::deserialize(_deser)?
            .map(|el| el.0),
    )
}

pub fn stdoptionoptioninstant_epoch_seconds_ser<S>(
    _inp: &::std::option::Option<Instant>,
    _serializer: S,
) -> Result<<S as ::serde::Serializer>::Ok, <S as ::serde::Serializer>::Error>
where
    S: ::serde::Serializer,
{
    use ::serde::Serialize;
    let el = _inp;
    el.as_ref()
        .map(|el| crate::instant_epoch::InstantEpoch(*el))
        .serialize(_serializer)
}

pub fn stdoptionoptioninstant_epoch_seconds_deser<'de, D>(
    _deser: D,
) -> Result<::std::option::Option<Instant>, D::Error>
where
    D: ::serde::Deserializer<'de>,
{
    use ::serde::Deserialize;
    Ok(
        ::std::option::Option::<crate::instant_epoch::InstantEpoch>::deserialize(_deser)?
            .map(|el| el.0),
    )
}

pub fn document_ser<S>(
    _inp: &Document,
    _serializer: S,
) -> Result<<S as ::serde::Serializer>::Ok, <S as ::serde::Serializer>::Error>
where
    S: ::serde::Serializer,
{
    use ::serde::Serialize;
    let el = _inp;
    crate::doc_json::SerDoc(el).serialize(_serializer)
}

pub fn document_deser<'de, D>(_deser: D) -> Result<Document, D::Error>
where
    D: ::serde::Deserializer<'de>,
{
    todo!()
}
