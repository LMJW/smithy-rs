// Code generated by software.amazon.smithy.rust.codegen.smithy-rs. DO NOT EDIT.
use crate::model::EmptyStruct;
use crate::model::FooEnum;
use crate::model::KitchenSink;
use crate::model::MyUnion;
use crate::model::SimpleStruct;
use crate::model::StructWithLocationName;
use smithy_types::Blob;
use smithy_types::Document;
use smithy_types::Instant;
use std::collections::BTreeSet;
use std::collections::HashMap;
/// A shared structure that contains a single union member.
#[non_exhaustive]
#[derive(::serde::Serialize, ::std::clone::Clone, ::std::cmp::PartialEq, ::std::fmt::Debug)]
pub struct JsonUnionsInputBody<'a> {
    /// A union with a representative set of types for members.
    #[serde(rename = "contents")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub contents: &'a Option<MyUnion>,
}

#[non_exhaustive]
#[derive(::serde::Serialize, ::std::clone::Clone, ::std::cmp::PartialEq, ::std::fmt::Debug)]
pub struct NullOperationInputBody<'a> {
    #[serde(rename = "string")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub string: &'a Option<String>,
    #[serde(rename = "sparseStringList")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub sparse_string_list: &'a Option<Vec<Option<String>>>,
    #[serde(rename = "sparseStringMap")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub sparse_string_map: &'a Option<HashMap<String, Option<String>>>,
}

#[non_exhaustive]
#[derive(::serde::Serialize, ::std::clone::Clone, ::std::cmp::PartialEq, ::std::fmt::Debug)]
pub struct JsonEnumsInputBody<'a> {
    #[serde(rename = "fooEnum1")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub foo_enum1: &'a Option<FooEnum>,
    #[serde(rename = "fooEnum2")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub foo_enum2: &'a Option<FooEnum>,
    #[serde(rename = "fooEnum3")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub foo_enum3: &'a Option<FooEnum>,
    #[serde(rename = "fooEnumList")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub foo_enum_list: &'a Option<Vec<FooEnum>>,
    #[serde(rename = "fooEnumSet")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub foo_enum_set: &'a Option<BTreeSet<FooEnum>>,
    #[serde(rename = "fooEnumMap")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub foo_enum_map: &'a Option<HashMap<String, FooEnum>>,
}

#[non_exhaustive]
#[derive(::serde::Serialize, ::std::clone::Clone, ::std::cmp::PartialEq, ::std::fmt::Debug)]
pub struct OperationWithOptionalInputOutputInputBody<'a> {
    #[serde(rename = "Value")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub value: &'a Option<String>,
}

#[non_exhaustive]
#[derive(::serde::Serialize, ::std::clone::Clone, ::std::cmp::PartialEq, ::std::fmt::Debug)]
pub struct KitchenSinkOperationInputBody<'a> {
    #[serde(rename = "Blob")]
    #[serde(skip_serializing_if = "Option::is_none")]
    #[serde(serialize_with = "crate::serde_util::optionblob_ser")]
    pub blob: &'a Option<Blob>,
    #[serde(rename = "Boolean")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub boolean: &'a Option<bool>,
    #[serde(rename = "Double")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub double: &'a Option<f64>,
    #[serde(rename = "EmptyStruct")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub empty_struct: &'a Option<EmptyStruct>,
    #[serde(rename = "Float")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub float: &'a Option<f32>,
    #[serde(rename = "HttpdateTimestamp")]
    #[serde(skip_serializing_if = "Option::is_none")]
    #[serde(serialize_with = "crate::serde_util::optioninstant_http_date_ser")]
    pub httpdate_timestamp: &'a Option<Instant>,
    #[serde(rename = "Integer")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub integer: &'a Option<i32>,
    #[serde(rename = "Iso8601Timestamp")]
    #[serde(skip_serializing_if = "Option::is_none")]
    #[serde(serialize_with = "crate::serde_util::optioninstant_date_time_ser")]
    pub iso8601_timestamp: &'a Option<Instant>,
    #[serde(rename = "JsonValue")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub json_value: &'a Option<String>,
    #[serde(rename = "ListOfLists")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub list_of_lists: &'a Option<Vec<Vec<String>>>,
    #[serde(rename = "ListOfMapsOfStrings")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub list_of_maps_of_strings: &'a Option<Vec<HashMap<String, String>>>,
    #[serde(rename = "ListOfStrings")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub list_of_strings: &'a Option<Vec<String>>,
    #[serde(rename = "ListOfStructs")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub list_of_structs: &'a Option<Vec<SimpleStruct>>,
    #[serde(rename = "Long")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub long: &'a Option<i64>,
    #[serde(rename = "MapOfListsOfStrings")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub map_of_lists_of_strings: &'a Option<HashMap<String, Vec<String>>>,
    #[serde(rename = "MapOfMaps")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub map_of_maps: &'a Option<HashMap<String, HashMap<String, String>>>,
    #[serde(rename = "MapOfStrings")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub map_of_strings: &'a Option<HashMap<String, String>>,
    #[serde(rename = "MapOfStructs")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub map_of_structs: &'a Option<HashMap<String, SimpleStruct>>,
    #[serde(rename = "RecursiveList")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub recursive_list: &'a Option<Vec<KitchenSink>>,
    #[serde(rename = "RecursiveMap")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub recursive_map: &'a Option<HashMap<String, KitchenSink>>,
    #[serde(rename = "RecursiveStruct")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub recursive_struct: &'a Option<Box<KitchenSink>>,
    #[serde(rename = "SimpleStruct")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub simple_struct: &'a Option<SimpleStruct>,
    #[serde(rename = "String")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub string: &'a Option<String>,
    #[serde(rename = "StructWithLocationName")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub struct_with_location_name: &'a Option<StructWithLocationName>,
    #[serde(rename = "Timestamp")]
    #[serde(skip_serializing_if = "Option::is_none")]
    #[serde(serialize_with = "crate::serde_util::optioninstant_epoch_seconds_ser")]
    pub timestamp: &'a Option<Instant>,
    #[serde(rename = "UnixTimestamp")]
    #[serde(skip_serializing_if = "Option::is_none")]
    #[serde(serialize_with = "crate::serde_util::optioninstant_epoch_seconds_ser")]
    pub unix_timestamp: &'a Option<Instant>,
}

#[non_exhaustive]
#[derive(::serde::Serialize, ::std::clone::Clone, ::std::cmp::PartialEq, ::std::fmt::Debug)]
pub struct PutAndGetInlineDocumentsInputBody<'a> {
    #[serde(rename = "inlineDocument")]
    #[serde(serialize_with = "crate::serde_util::document_ser")]
    pub inline_document: &'a Document,
}

#[non_exhaustive]
#[derive(::serde::Deserialize, ::std::clone::Clone, ::std::cmp::PartialEq, ::std::fmt::Debug)]
pub struct GreetingWithErrorsOutputBody {
    #[serde(rename = "greeting")]
    pub greeting: Option<String>,
}

/// A shared structure that contains a single union member.
#[non_exhaustive]
#[derive(::serde::Deserialize, ::std::clone::Clone, ::std::cmp::PartialEq, ::std::fmt::Debug)]
pub struct JsonUnionsOutputBody {
    /// A union with a representative set of types for members.
    #[serde(rename = "contents")]
    pub contents: Option<MyUnion>,
}

#[non_exhaustive]
#[derive(::serde::Deserialize, ::std::clone::Clone, ::std::cmp::PartialEq, ::std::fmt::Debug)]
pub struct NullOperationOutputBody {
    #[serde(rename = "string")]
    pub string: Option<String>,
    #[serde(rename = "sparseStringList")]
    pub sparse_string_list: Option<Vec<Option<String>>>,
    #[serde(rename = "sparseStringMap")]
    pub sparse_string_map: Option<HashMap<String, Option<String>>>,
}

#[non_exhaustive]
#[derive(::serde::Deserialize, ::std::clone::Clone, ::std::cmp::PartialEq, ::std::fmt::Debug)]
pub struct JsonEnumsOutputBody {
    #[serde(rename = "fooEnum1")]
    pub foo_enum1: Option<FooEnum>,
    #[serde(rename = "fooEnum2")]
    pub foo_enum2: Option<FooEnum>,
    #[serde(rename = "fooEnum3")]
    pub foo_enum3: Option<FooEnum>,
    #[serde(rename = "fooEnumList")]
    pub foo_enum_list: Option<Vec<FooEnum>>,
    #[serde(rename = "fooEnumSet")]
    pub foo_enum_set: Option<BTreeSet<FooEnum>>,
    #[serde(rename = "fooEnumMap")]
    pub foo_enum_map: Option<HashMap<String, FooEnum>>,
}

#[non_exhaustive]
#[derive(::serde::Deserialize, ::std::clone::Clone, ::std::cmp::PartialEq, ::std::fmt::Debug)]
pub struct OperationWithOptionalInputOutputOutputBody {
    #[serde(rename = "Value")]
    pub value: Option<String>,
}

#[non_exhaustive]
#[derive(::serde::Deserialize, ::std::clone::Clone, ::std::cmp::PartialEq, ::std::fmt::Debug)]
pub struct KitchenSinkOperationOutputBody {
    #[serde(rename = "Blob")]
    #[serde(deserialize_with = "crate::serde_util::optionblob_deser")]
    pub blob: Option<Blob>,
    #[serde(rename = "Boolean")]
    pub boolean: Option<bool>,
    #[serde(rename = "Double")]
    pub double: Option<f64>,
    #[serde(rename = "EmptyStruct")]
    pub empty_struct: Option<EmptyStruct>,
    #[serde(rename = "Float")]
    pub float: Option<f32>,
    #[serde(rename = "HttpdateTimestamp")]
    #[serde(deserialize_with = "crate::serde_util::optioninstant_http_date_deser")]
    pub httpdate_timestamp: Option<Instant>,
    #[serde(rename = "Integer")]
    pub integer: Option<i32>,
    #[serde(rename = "Iso8601Timestamp")]
    #[serde(deserialize_with = "crate::serde_util::optioninstant_date_time_deser")]
    pub iso8601_timestamp: Option<Instant>,
    #[serde(rename = "JsonValue")]
    pub json_value: Option<String>,
    #[serde(rename = "ListOfLists")]
    pub list_of_lists: Option<Vec<Vec<String>>>,
    #[serde(rename = "ListOfMapsOfStrings")]
    pub list_of_maps_of_strings: Option<Vec<HashMap<String, String>>>,
    #[serde(rename = "ListOfStrings")]
    pub list_of_strings: Option<Vec<String>>,
    #[serde(rename = "ListOfStructs")]
    pub list_of_structs: Option<Vec<SimpleStruct>>,
    #[serde(rename = "Long")]
    pub long: Option<i64>,
    #[serde(rename = "MapOfListsOfStrings")]
    pub map_of_lists_of_strings: Option<HashMap<String, Vec<String>>>,
    #[serde(rename = "MapOfMaps")]
    pub map_of_maps: Option<HashMap<String, HashMap<String, String>>>,
    #[serde(rename = "MapOfStrings")]
    pub map_of_strings: Option<HashMap<String, String>>,
    #[serde(rename = "MapOfStructs")]
    pub map_of_structs: Option<HashMap<String, SimpleStruct>>,
    #[serde(rename = "RecursiveList")]
    pub recursive_list: Option<Vec<KitchenSink>>,
    #[serde(rename = "RecursiveMap")]
    pub recursive_map: Option<HashMap<String, KitchenSink>>,
    #[serde(rename = "RecursiveStruct")]
    pub recursive_struct: Option<Box<KitchenSink>>,
    #[serde(rename = "SimpleStruct")]
    pub simple_struct: Option<SimpleStruct>,
    #[serde(rename = "String")]
    pub string: Option<String>,
    #[serde(rename = "StructWithLocationName")]
    pub struct_with_location_name: Option<StructWithLocationName>,
    #[serde(rename = "Timestamp")]
    #[serde(deserialize_with = "crate::serde_util::optioninstant_epoch_seconds_deser")]
    pub timestamp: Option<Instant>,
    #[serde(rename = "UnixTimestamp")]
    #[serde(deserialize_with = "crate::serde_util::optioninstant_epoch_seconds_deser")]
    pub unix_timestamp: Option<Instant>,
}

#[non_exhaustive]
#[derive(::serde::Deserialize, ::std::clone::Clone, ::std::cmp::PartialEq, ::std::fmt::Debug)]
pub struct PutAndGetInlineDocumentsOutputBody {
    #[serde(rename = "inlineDocument")]
    #[serde(deserialize_with = "crate::serde_util::document_deser")]
    pub inline_document: Document,
}
