// Code generated by software.amazon.smithy.rust.codegen.smithy-rs. DO NOT EDIT.
use smithy_types::Blob;
use smithy_types::Instant;
use std::collections::HashMap;
#[non_exhaustive]
#[derive(
    ::serde::Deserialize,
    ::serde::Serialize,
    ::std::clone::Clone,
    ::std::cmp::PartialEq,
    ::std::fmt::Debug,
)]
pub enum MyUnion {
    #[serde(rename = "blobValue")]
    #[serde(serialize_with = "crate::serde_util::blob_ser")]
    #[serde(deserialize_with = "crate::serde_util::blob_deser")]
    BlobValue(Blob),
    #[serde(rename = "booleanValue")]
    BooleanValue(bool),
    #[serde(rename = "enumValue")]
    EnumValue(FooEnum),
    #[serde(rename = "listValue")]
    ListValue(Vec<String>),
    #[serde(rename = "mapValue")]
    MapValue(HashMap<String, String>),
    #[serde(rename = "numberValue")]
    NumberValue(i32),
    #[serde(rename = "stringValue")]
    StringValue(String),
    #[serde(rename = "structureValue")]
    StructureValue(GreetingStruct),
    #[serde(rename = "timestampValue")]
    #[serde(serialize_with = "crate::serde_util::instant_epoch_seconds_ser")]
    #[serde(deserialize_with = "crate::serde_util::instant_epoch_seconds_deser")]
    TimestampValue(Instant),
}

#[non_exhaustive]
#[derive(
    ::serde::Deserialize,
    ::serde::Serialize,
    ::std::clone::Clone,
    ::std::cmp::PartialEq,
    ::std::fmt::Debug,
)]
pub struct GreetingStruct {
    #[serde(rename = "hi")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub hi: Option<String>,
}
impl GreetingStruct {
    /// Creates a new builder-style object to manufacture [`GreetingStruct`](crate::model::GreetingStruct)
    pub fn builder() -> crate::model::greeting_struct::Builder {
        crate::model::greeting_struct::Builder::default()
    }
}
/// See [`GreetingStruct`](crate::model::GreetingStruct)
pub mod greeting_struct {

    use crate::model::GreetingStruct;
    /// A builder for [`GreetingStruct`](crate::model::GreetingStruct)
    #[non_exhaustive]
    #[derive(Debug, Clone, Default)]
    pub struct Builder {
        hi: Option<String>,
    }
    impl Builder {
        pub fn hi(mut self, inp: impl Into<String>) -> Self {
            self.hi = Some(inp.into());
            self
        }
        /// Consumes the builder and constructs a [`GreetingStruct`](crate::model::GreetingStruct)
        pub fn build(self) -> GreetingStruct {
            GreetingStruct { hi: self.hi }
        }
    }
}

#[non_exhaustive]
#[derive(
    ::serde::Deserialize,
    ::serde::Serialize,
    ::std::clone::Clone,
    ::std::cmp::Eq,
    ::std::cmp::Ord,
    ::std::cmp::PartialEq,
    ::std::cmp::PartialOrd,
    ::std::fmt::Debug,
    ::std::hash::Hash,
)]
pub enum FooEnum {
    Zero,
    One,
    Bar,
    Baz,
    Foo,
    Unknown(String),
}
impl<T> ::std::convert::From<T> for FooEnum
where
    T: ::std::convert::AsRef<str>,
{
    fn from(s: T) -> Self {
        match s.as_ref() {
            "0" => FooEnum::Zero,
            "1" => FooEnum::One,
            "Bar" => FooEnum::Bar,
            "Baz" => FooEnum::Baz,
            "Foo" => FooEnum::Foo,
            other => FooEnum::Unknown(other.to_owned()),
        }
    }
}
impl FooEnum {
    pub fn as_str(&self) -> &str {
        match self {
            FooEnum::Zero => "0",
            FooEnum::One => "1",
            FooEnum::Bar => "Bar",
            FooEnum::Baz => "Baz",
            FooEnum::Foo => "Foo",
            FooEnum::Unknown(s) => s.as_ref(),
        }
    }
}

#[non_exhaustive]
#[derive(
    ::serde::Deserialize,
    ::serde::Serialize,
    ::std::clone::Clone,
    ::std::cmp::PartialEq,
    ::std::fmt::Debug,
)]
pub struct ComplexNestedErrorData {
    #[serde(rename = "Fooooo")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub foo: Option<String>,
}
impl ComplexNestedErrorData {
    /// Creates a new builder-style object to manufacture [`ComplexNestedErrorData`](crate::model::ComplexNestedErrorData)
    pub fn builder() -> crate::model::complex_nested_error_data::Builder {
        crate::model::complex_nested_error_data::Builder::default()
    }
}
/// See [`ComplexNestedErrorData`](crate::model::ComplexNestedErrorData)
pub mod complex_nested_error_data {

    use crate::model::ComplexNestedErrorData;
    /// A builder for [`ComplexNestedErrorData`](crate::model::ComplexNestedErrorData)
    #[non_exhaustive]
    #[derive(Debug, Clone, Default)]
    pub struct Builder {
        foo: Option<String>,
    }
    impl Builder {
        pub fn foo(mut self, inp: impl Into<String>) -> Self {
            self.foo = Some(inp.into());
            self
        }
        /// Consumes the builder and constructs a [`ComplexNestedErrorData`](crate::model::ComplexNestedErrorData)
        pub fn build(self) -> ComplexNestedErrorData {
            ComplexNestedErrorData { foo: self.foo }
        }
    }
}

#[non_exhaustive]
#[derive(
    ::serde::Deserialize,
    ::serde::Serialize,
    ::std::clone::Clone,
    ::std::cmp::PartialEq,
    ::std::fmt::Debug,
)]
pub struct KitchenSink {
    #[serde(rename = "Blob")]
    #[serde(skip_serializing_if = "Option::is_none")]
    #[serde(serialize_with = "crate::serde_util::optionblob_ser")]
    #[serde(deserialize_with = "crate::serde_util::optionblob_deser")]
    pub blob: Option<Blob>,
    #[serde(rename = "Boolean")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub boolean: Option<bool>,
    #[serde(rename = "Double")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub double: Option<f64>,
    #[serde(rename = "EmptyStruct")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub empty_struct: Option<EmptyStruct>,
    #[serde(rename = "Float")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub float: Option<f32>,
    #[serde(rename = "HttpdateTimestamp")]
    #[serde(skip_serializing_if = "Option::is_none")]
    #[serde(serialize_with = "crate::serde_util::optioninstant_http_date_ser")]
    #[serde(deserialize_with = "crate::serde_util::optioninstant_http_date_deser")]
    pub httpdate_timestamp: Option<Instant>,
    #[serde(rename = "Integer")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub integer: Option<i32>,
    #[serde(rename = "Iso8601Timestamp")]
    #[serde(skip_serializing_if = "Option::is_none")]
    #[serde(serialize_with = "crate::serde_util::optioninstant_date_time_ser")]
    #[serde(deserialize_with = "crate::serde_util::optioninstant_date_time_deser")]
    pub iso8601_timestamp: Option<Instant>,
    #[serde(rename = "JsonValue")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub json_value: Option<String>,
    #[serde(rename = "ListOfLists")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub list_of_lists: Option<Vec<Vec<String>>>,
    #[serde(rename = "ListOfMapsOfStrings")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub list_of_maps_of_strings: Option<Vec<HashMap<String, String>>>,
    #[serde(rename = "ListOfStrings")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub list_of_strings: Option<Vec<String>>,
    #[serde(rename = "ListOfStructs")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub list_of_structs: Option<Vec<SimpleStruct>>,
    #[serde(rename = "Long")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub long: Option<i64>,
    #[serde(rename = "MapOfListsOfStrings")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub map_of_lists_of_strings: Option<HashMap<String, Vec<String>>>,
    #[serde(rename = "MapOfMaps")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub map_of_maps: Option<HashMap<String, HashMap<String, String>>>,
    #[serde(rename = "MapOfStrings")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub map_of_strings: Option<HashMap<String, String>>,
    #[serde(rename = "MapOfStructs")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub map_of_structs: Option<HashMap<String, SimpleStruct>>,
    #[serde(rename = "RecursiveList")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub recursive_list: Option<Vec<KitchenSink>>,
    #[serde(rename = "RecursiveMap")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub recursive_map: Option<HashMap<String, KitchenSink>>,
    #[serde(rename = "RecursiveStruct")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub recursive_struct: Option<Box<KitchenSink>>,
    #[serde(rename = "SimpleStruct")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub simple_struct: Option<SimpleStruct>,
    #[serde(rename = "String")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub string: Option<String>,
    #[serde(rename = "StructWithLocationName")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub struct_with_location_name: Option<StructWithLocationName>,
    #[serde(rename = "Timestamp")]
    #[serde(skip_serializing_if = "Option::is_none")]
    #[serde(serialize_with = "crate::serde_util::optioninstant_epoch_seconds_ser")]
    #[serde(deserialize_with = "crate::serde_util::optioninstant_epoch_seconds_deser")]
    pub timestamp: Option<Instant>,
    #[serde(rename = "UnixTimestamp")]
    #[serde(skip_serializing_if = "Option::is_none")]
    #[serde(serialize_with = "crate::serde_util::optioninstant_epoch_seconds_ser")]
    #[serde(deserialize_with = "crate::serde_util::optioninstant_epoch_seconds_deser")]
    pub unix_timestamp: Option<Instant>,
}
impl KitchenSink {
    /// Creates a new builder-style object to manufacture [`KitchenSink`](crate::model::KitchenSink)
    pub fn builder() -> crate::model::kitchen_sink::Builder {
        crate::model::kitchen_sink::Builder::default()
    }
}
/// See [`KitchenSink`](crate::model::KitchenSink)
pub mod kitchen_sink {

    use crate::model::EmptyStruct;
    use crate::model::KitchenSink;
    use crate::model::SimpleStruct;
    use crate::model::StructWithLocationName;
    use smithy_types::Blob;
    use smithy_types::Instant;
    use std::collections::HashMap;
    /// A builder for [`KitchenSink`](crate::model::KitchenSink)
    #[non_exhaustive]
    #[derive(Debug, Clone, Default)]
    pub struct Builder {
        blob: Option<Blob>,
        boolean: Option<bool>,
        double: Option<f64>,
        empty_struct: Option<EmptyStruct>,
        float: Option<f32>,
        httpdate_timestamp: Option<Instant>,
        integer: Option<i32>,
        iso8601_timestamp: Option<Instant>,
        json_value: Option<String>,
        list_of_lists: Option<Vec<Vec<String>>>,
        list_of_maps_of_strings: Option<Vec<HashMap<String, String>>>,
        list_of_strings: Option<Vec<String>>,
        list_of_structs: Option<Vec<SimpleStruct>>,
        long: Option<i64>,
        map_of_lists_of_strings: Option<HashMap<String, Vec<String>>>,
        map_of_maps: Option<HashMap<String, HashMap<String, String>>>,
        map_of_strings: Option<HashMap<String, String>>,
        map_of_structs: Option<HashMap<String, SimpleStruct>>,
        recursive_list: Option<Vec<KitchenSink>>,
        recursive_map: Option<HashMap<String, KitchenSink>>,
        recursive_struct: Option<Box<KitchenSink>>,
        simple_struct: Option<SimpleStruct>,
        string: Option<String>,
        struct_with_location_name: Option<StructWithLocationName>,
        timestamp: Option<Instant>,
        unix_timestamp: Option<Instant>,
    }
    impl Builder {
        pub fn blob(mut self, inp: Blob) -> Self {
            self.blob = Some(inp);
            self
        }
        pub fn boolean(mut self, inp: bool) -> Self {
            self.boolean = Some(inp);
            self
        }
        pub fn double(mut self, inp: f64) -> Self {
            self.double = Some(inp);
            self
        }
        pub fn empty_struct(mut self, inp: EmptyStruct) -> Self {
            self.empty_struct = Some(inp);
            self
        }
        pub fn float(mut self, inp: f32) -> Self {
            self.float = Some(inp);
            self
        }
        pub fn httpdate_timestamp(mut self, inp: Instant) -> Self {
            self.httpdate_timestamp = Some(inp);
            self
        }
        pub fn integer(mut self, inp: i32) -> Self {
            self.integer = Some(inp);
            self
        }
        pub fn iso8601_timestamp(mut self, inp: Instant) -> Self {
            self.iso8601_timestamp = Some(inp);
            self
        }
        pub fn json_value(mut self, inp: impl Into<String>) -> Self {
            self.json_value = Some(inp.into());
            self
        }
        pub fn list_of_lists(mut self, inp: Vec<Vec<String>>) -> Self {
            self.list_of_lists = Some(inp);
            self
        }
        pub fn list_of_maps_of_strings(mut self, inp: Vec<HashMap<String, String>>) -> Self {
            self.list_of_maps_of_strings = Some(inp);
            self
        }
        pub fn list_of_strings(mut self, inp: Vec<String>) -> Self {
            self.list_of_strings = Some(inp);
            self
        }
        pub fn list_of_structs(mut self, inp: Vec<SimpleStruct>) -> Self {
            self.list_of_structs = Some(inp);
            self
        }
        pub fn long(mut self, inp: i64) -> Self {
            self.long = Some(inp);
            self
        }
        pub fn map_of_lists_of_strings(mut self, inp: HashMap<String, Vec<String>>) -> Self {
            self.map_of_lists_of_strings = Some(inp);
            self
        }
        pub fn map_of_maps(mut self, inp: HashMap<String, HashMap<String, String>>) -> Self {
            self.map_of_maps = Some(inp);
            self
        }
        pub fn map_of_strings(mut self, inp: HashMap<String, String>) -> Self {
            self.map_of_strings = Some(inp);
            self
        }
        pub fn map_of_structs(mut self, inp: HashMap<String, SimpleStruct>) -> Self {
            self.map_of_structs = Some(inp);
            self
        }
        pub fn recursive_list(mut self, inp: Vec<KitchenSink>) -> Self {
            self.recursive_list = Some(inp);
            self
        }
        pub fn recursive_map(mut self, inp: HashMap<String, KitchenSink>) -> Self {
            self.recursive_map = Some(inp);
            self
        }
        pub fn recursive_struct(mut self, inp: impl Into<Box<KitchenSink>>) -> Self {
            self.recursive_struct = Some(inp.into());
            self
        }
        pub fn simple_struct(mut self, inp: SimpleStruct) -> Self {
            self.simple_struct = Some(inp);
            self
        }
        pub fn string(mut self, inp: impl Into<String>) -> Self {
            self.string = Some(inp.into());
            self
        }
        pub fn struct_with_location_name(mut self, inp: StructWithLocationName) -> Self {
            self.struct_with_location_name = Some(inp);
            self
        }
        pub fn timestamp(mut self, inp: Instant) -> Self {
            self.timestamp = Some(inp);
            self
        }
        pub fn unix_timestamp(mut self, inp: Instant) -> Self {
            self.unix_timestamp = Some(inp);
            self
        }
        /// Consumes the builder and constructs a [`KitchenSink`](crate::model::KitchenSink)
        pub fn build(self) -> KitchenSink {
            KitchenSink {
                blob: self.blob,
                boolean: self.boolean,
                double: self.double,
                empty_struct: self.empty_struct,
                float: self.float,
                httpdate_timestamp: self.httpdate_timestamp,
                integer: self.integer,
                iso8601_timestamp: self.iso8601_timestamp,
                json_value: self.json_value,
                list_of_lists: self.list_of_lists,
                list_of_maps_of_strings: self.list_of_maps_of_strings,
                list_of_strings: self.list_of_strings,
                list_of_structs: self.list_of_structs,
                long: self.long,
                map_of_lists_of_strings: self.map_of_lists_of_strings,
                map_of_maps: self.map_of_maps,
                map_of_strings: self.map_of_strings,
                map_of_structs: self.map_of_structs,
                recursive_list: self.recursive_list,
                recursive_map: self.recursive_map,
                recursive_struct: self.recursive_struct,
                simple_struct: self.simple_struct,
                string: self.string,
                struct_with_location_name: self.struct_with_location_name,
                timestamp: self.timestamp,
                unix_timestamp: self.unix_timestamp,
            }
        }
    }
}

#[non_exhaustive]
#[derive(
    ::serde::Deserialize,
    ::serde::Serialize,
    ::std::clone::Clone,
    ::std::cmp::PartialEq,
    ::std::fmt::Debug,
)]
pub struct StructWithLocationName {
    #[serde(rename = "RenamedMember")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub value: Option<String>,
}
impl StructWithLocationName {
    /// Creates a new builder-style object to manufacture [`StructWithLocationName`](crate::model::StructWithLocationName)
    pub fn builder() -> crate::model::struct_with_location_name::Builder {
        crate::model::struct_with_location_name::Builder::default()
    }
}
/// See [`StructWithLocationName`](crate::model::StructWithLocationName)
pub mod struct_with_location_name {

    use crate::model::StructWithLocationName;
    /// A builder for [`StructWithLocationName`](crate::model::StructWithLocationName)
    #[non_exhaustive]
    #[derive(Debug, Clone, Default)]
    pub struct Builder {
        value: Option<String>,
    }
    impl Builder {
        pub fn value(mut self, inp: impl Into<String>) -> Self {
            self.value = Some(inp.into());
            self
        }
        /// Consumes the builder and constructs a [`StructWithLocationName`](crate::model::StructWithLocationName)
        pub fn build(self) -> StructWithLocationName {
            StructWithLocationName { value: self.value }
        }
    }
}

#[non_exhaustive]
#[derive(
    ::serde::Deserialize,
    ::serde::Serialize,
    ::std::clone::Clone,
    ::std::cmp::PartialEq,
    ::std::fmt::Debug,
)]
pub struct SimpleStruct {
    #[serde(rename = "Value")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub value: Option<String>,
}
impl SimpleStruct {
    /// Creates a new builder-style object to manufacture [`SimpleStruct`](crate::model::SimpleStruct)
    pub fn builder() -> crate::model::simple_struct::Builder {
        crate::model::simple_struct::Builder::default()
    }
}
/// See [`SimpleStruct`](crate::model::SimpleStruct)
pub mod simple_struct {

    use crate::model::SimpleStruct;
    /// A builder for [`SimpleStruct`](crate::model::SimpleStruct)
    #[non_exhaustive]
    #[derive(Debug, Clone, Default)]
    pub struct Builder {
        value: Option<String>,
    }
    impl Builder {
        pub fn value(mut self, inp: impl Into<String>) -> Self {
            self.value = Some(inp.into());
            self
        }
        /// Consumes the builder and constructs a [`SimpleStruct`](crate::model::SimpleStruct)
        pub fn build(self) -> SimpleStruct {
            SimpleStruct { value: self.value }
        }
    }
}

#[non_exhaustive]
#[derive(
    ::serde::Deserialize,
    ::serde::Serialize,
    ::std::clone::Clone,
    ::std::cmp::PartialEq,
    ::std::fmt::Debug,
)]
pub struct EmptyStruct {}
impl EmptyStruct {
    /// Creates a new builder-style object to manufacture [`EmptyStruct`](crate::model::EmptyStruct)
    pub fn builder() -> crate::model::empty_struct::Builder {
        crate::model::empty_struct::Builder::default()
    }
}
/// See [`EmptyStruct`](crate::model::EmptyStruct)
pub mod empty_struct {

    use crate::model::EmptyStruct;
    /// A builder for [`EmptyStruct`](crate::model::EmptyStruct)
    #[non_exhaustive]
    #[derive(Debug, Clone, Default)]
    pub struct Builder {}
    impl Builder {
        /// Consumes the builder and constructs a [`EmptyStruct`](crate::model::EmptyStruct)
        pub fn build(self) -> EmptyStruct {
            EmptyStruct {}
        }
    }
}
