// Code generated by software.amazon.smithy.rust.codegen.smithy-rs. DO NOT EDIT.
use crate::input::EmptyOperationInput;
use crate::input::GreetingWithErrorsInput;
use crate::input::JsonEnumsInput;
use crate::input::JsonUnionsInput;
use crate::input::KitchenSinkOperationInput;
use crate::input::NullOperationInput;
use crate::input::OperationWithOptionalInputOutputInput;
use crate::input::PutAndGetInlineDocumentsInput;
use crate::output::EmptyOperationOutput;
use crate::output::GreetingWithErrorsOutput;
use crate::output::JsonEnumsOutput;
use crate::output::JsonUnionsOutput;
use crate::output::KitchenSinkOperationOutput;
use crate::output::NullOperationOutput;
use crate::output::OperationWithOptionalInputOutputOutput;
use crate::output::PutAndGetInlineDocumentsOutput;
use crate::serializer::GreetingWithErrorsOutputBody;
use crate::serializer::JsonEnumsOutputBody;
use crate::serializer::JsonUnionsOutputBody;
use crate::serializer::KitchenSinkOperationOutputBody;
use crate::serializer::NullOperationOutputBody;
use crate::serializer::OperationWithOptionalInputOutputOutputBody;
use crate::serializer::PutAndGetInlineDocumentsOutputBody;
pub struct EmptyOperation {
    input: EmptyOperationInput,
}
impl EmptyOperation {
    /// Creates a new builder-style object to manufacture [`EmptyOperationInput`](crate::input::EmptyOperationInput)
    pub fn builder() -> crate::input::empty_operation_input::Builder {
        crate::input::empty_operation_input::Builder::default()
    }
    pub fn build_http_request(&self) -> ::http::request::Request<Vec<u8>> {
        EmptyOperationInput::assemble(self.input.request_builder_base(), self.input.build_body())
    }
    fn from_response(
        response: &::http::response::Response<impl AsRef<[u8]>>,
    ) -> Result<EmptyOperationOutput, crate::error::EmptyOperationError> {
        if crate::error_code::is_error(&response) {
            let body: ::serde_json::Value = ::serde_json::from_slice(response.body().as_ref())
                .unwrap_or_else(|_| ::serde_json::json!({}));
            let error_code = crate::error_code::error_type_from_header(&response)
                .map_err(crate::error::EmptyOperationError::unhandled)?;
            let error_code = error_code.or_else(|| crate::error_code::error_type_from_body(&body));
            let error_code = error_code.ok_or_else(|| {
                crate::error::EmptyOperationError::unhandled("no error code".to_string())
            })?;
            let error_code = crate::error_code::sanitize_error_code(error_code);

            return Err(crate::error::EmptyOperationError::unhandled(error_code));
        }
        Ok(EmptyOperationOutput {})
    }
    pub fn parse_response(
        &self,
        response: &::http::response::Response<impl AsRef<[u8]>>,
    ) -> Result<EmptyOperationOutput, crate::error::EmptyOperationError> {
        Self::from_response(&response)
    }
    pub fn new(input: EmptyOperationInput) -> Self {
        Self { input }
    }
}
#[cfg(test)]
#[allow(unreachable_code, unused_variables)]
mod empty_operation_request_test {

    use crate::input::EmptyOperationInput;
    use crate::operation::EmptyOperation;
    use crate::output::EmptyOperationOutput;
    /// Sends requests to /
    /// Test ID: sends_requests_to_slash
    #[test]
    fn sends_requests_to_slash_request() {
        let input = {
            let config = crate::config::Config::builder()
                .token_provider("00000000-0000-4000-8000-000000000000")
                .build();

            EmptyOperationInput::builder().build(&config)
        };
        let http_request = input.build_http_request();

        assert_eq!(http_request.method(), "POST");
        assert_eq!(http_request.uri().path(), "/");

        // No body
        assert!(&http_request.body().is_empty());
    }
    /// Includes X-Amz-Target header and Content-Type
    /// Test ID: includes_x_amz_target_and_content_type
    #[test]
    fn includes_x_amz_target_and_content_type_request() {
        let input = {
            let config = crate::config::Config::builder()
                .token_provider("00000000-0000-4000-8000-000000000000")
                .build();

            EmptyOperationInput::builder().build(&config)
        };
        let http_request = input.build_http_request();

        assert_eq!(http_request.method(), "POST");
        assert_eq!(http_request.uri().path(), "/");

        let expected_headers = &[
            ("Content-Type", "application/x-amz-json-1.1"),
            ("X-Amz-Target", "JsonProtocol.EmptyOperation"),
        ];
        ::protocol_test_helpers::assert_ok(::protocol_test_helpers::validate_headers(
            &http_request,
            expected_headers,
        ));
        // No body
        assert!(&http_request.body().is_empty());
    }
    /// Handles empty output shapes
    /// Test ID: handles_empty_output_shape
    #[test]
    fn handles_empty_output_shape_response() {
        let expected_output = {
            let _ = 5;
            EmptyOperationOutput::builder().build()
        };
        let http_response = ::http::response::Builder::new()
            .header("Content-Type", "application/x-amz-json-1.1")
            .status(200)
            .body("{}")
            .unwrap();

        let parsed = EmptyOperation::from_response(&http_response);
        assert_eq!(parsed.unwrap(), expected_output);
    }
}

/// This operation has three possible return values:
/// 1. A successful response in the form of GreetingWithErrorsOutput
/// 2. An InvalidGreeting error.
/// 3. A ComplexError error.
/// Implementations must be able to successfully take a response and
/// properly deserialize successful and error responses.
pub struct GreetingWithErrors {
    input: GreetingWithErrorsInput,
}
impl GreetingWithErrors {
    /// Creates a new builder-style object to manufacture [`GreetingWithErrorsInput`](crate::input::GreetingWithErrorsInput)
    pub fn builder() -> crate::input::greeting_with_errors_input::Builder {
        crate::input::greeting_with_errors_input::Builder::default()
    }
    pub fn build_http_request(&self) -> ::http::request::Request<Vec<u8>> {
        GreetingWithErrorsInput::assemble(
            self.input.request_builder_base(),
            self.input.build_body(),
        )
    }
    fn from_response(
        response: &::http::response::Response<impl AsRef<[u8]>>,
    ) -> Result<GreetingWithErrorsOutput, crate::error::GreetingWithErrorsError> {
        if crate::error_code::is_error(&response) {
            let body: ::serde_json::Value = ::serde_json::from_slice(response.body().as_ref())
                .unwrap_or_else(|_| ::serde_json::json!({}));
            let error_code = crate::error_code::error_type_from_header(&response)
                .map_err(crate::error::GreetingWithErrorsError::unhandled)?;
            let error_code = error_code.or_else(|| crate::error_code::error_type_from_body(&body));
            let error_code = error_code.ok_or_else(|| {
                crate::error::GreetingWithErrorsError::unhandled("no error code".to_string())
            })?;
            let error_code = crate::error_code::sanitize_error_code(error_code);

            return Err(match error_code {
                "InvalidGreeting" => match ::serde_json::from_value(body) {
                    Ok(body) => crate::error::GreetingWithErrorsError::InvalidGreeting(body),
                    Err(e) => crate::error::GreetingWithErrorsError::unhandled(e),
                },
                "ComplexError" => match ::serde_json::from_value(body) {
                    Ok(body) => crate::error::GreetingWithErrorsError::ComplexError(body),
                    Err(e) => crate::error::GreetingWithErrorsError::unhandled(e),
                },
                "FooError" => match ::serde_json::from_value(body) {
                    Ok(body) => crate::error::GreetingWithErrorsError::FooError(body),
                    Err(e) => crate::error::GreetingWithErrorsError::unhandled(e),
                },
                unknown => crate::error::GreetingWithErrorsError::unhandled(unknown),
            });
        }
        let body: GreetingWithErrorsOutputBody = ::serde_json::from_slice(response.body().as_ref())
            .map_err(crate::error::GreetingWithErrorsError::unhandled)?;
        Ok(GreetingWithErrorsOutput {
            greeting: body.greeting,
        })
    }
    pub fn parse_response(
        &self,
        response: &::http::response::Response<impl AsRef<[u8]>>,
    ) -> Result<GreetingWithErrorsOutput, crate::error::GreetingWithErrorsError> {
        Self::from_response(&response)
    }
    pub fn new(input: GreetingWithErrorsInput) -> Self {
        Self { input }
    }
}
#[cfg(test)]
#[allow(unreachable_code, unused_variables)]
mod greeting_with_errors_request_test {

    use crate::error::ComplexError;
    use crate::error::FooError;
    use crate::error::InvalidGreeting;
    use crate::model::ComplexNestedErrorData;
    use crate::operation::GreetingWithErrors;
    /// Parses simple JSON errors
    /// Test ID: AwsJson11InvalidGreetingError
    #[test]
    fn aws_json11_invalid_greeting_error_response() {
        let expected_output = {
            let _ = 5;
            InvalidGreeting::builder().message("Hi".to_string()).build()
        };
        let http_response = ::http::response::Builder::new()
            .header("Content-Type", "application/x-amz-json-1.1")
            .status(400)
            .body(
                "{
            \"__type\": \"InvalidGreeting\",
            \"Message\": \"Hi\"
        }",
            )
            .unwrap();

        let parsed = GreetingWithErrors::from_response(&http_response);
        if let Err(crate::error::GreetingWithErrorsError::InvalidGreeting(actual_error)) = parsed {
            assert_eq!(expected_output, actual_error);
        } else {
            panic!("wrong variant: {:?}", parsed);
        }
    }
    /// Parses a complex error with no message member
    /// Test ID: AwsJson11ComplexError
    #[test]
    fn aws_json11_complex_error_response() {
        let expected_output = {
            let _ = 5;
            ComplexError::builder()
                .top_level("Top level".to_string())
                .nested({
                    let _ = 5;
                    ComplexNestedErrorData::builder()
                        .foo("bar".to_string())
                        .build()
                })
                .build()
        };
        let http_response = ::http::response::Builder::new()
            .header("Content-Type", "application/x-amz-json-1.1")
            .status(400)
            .body(
                "{
            \"__type\": \"ComplexError\",
            \"TopLevel\": \"Top level\",
            \"Nested\": {
                \"Fooooo\": \"bar\"
            }
        }",
            )
            .unwrap();

        let parsed = GreetingWithErrors::from_response(&http_response);
        if let Err(crate::error::GreetingWithErrorsError::ComplexError(actual_error)) = parsed {
            assert_eq!(expected_output, actual_error);
        } else {
            panic!("wrong variant: {:?}", parsed);
        }
    }
    /// Test ID: AwsJson11EmptyComplexError
    #[test]
    fn aws_json11_empty_complex_error_response() {
        let expected_output = {
            let _ = 5;
            ComplexError::builder().build()
        };
        let http_response = ::http::response::Builder::new()
            .header("Content-Type", "application/x-amz-json-1.1")
            .status(400)
            .body(
                "{
            \"__type\": \"ComplexError\"
        }",
            )
            .unwrap();

        let parsed = GreetingWithErrors::from_response(&http_response);
        if let Err(crate::error::GreetingWithErrorsError::ComplexError(actual_error)) = parsed {
            assert_eq!(expected_output, actual_error);
        } else {
            panic!("wrong variant: {:?}", parsed);
        }
    }
    /// Serializes the X-Amzn-ErrorType header. For an example service, see Amazon EKS.
    /// Test ID: AwsJson11FooErrorUsingXAmznErrorType
    #[test]
    fn aws_json11_foo_error_using_x_amzn_error_type_response() {
        let expected_output = {
            let _ = 5;
            FooError::builder().build()
        };
        let http_response = ::http::response::Builder::new()
            .header("X-Amzn-Errortype", "FooError")
            .status(500)
            .body(vec![])
            .unwrap();

        let parsed = GreetingWithErrors::from_response(&http_response);
        if let Err(crate::error::GreetingWithErrorsError::FooError(actual_error)) = parsed {
            assert_eq!(expected_output, actual_error);
        } else {
            panic!("wrong variant: {:?}", parsed);
        }
    }
    /// Some X-Amzn-Errortype headers contain URLs. Clients need to split the URL on ':' and take only the first half of the string. For example, 'ValidationException:http://internal.amazon.com/coral/com.amazon.coral.validate/'
    /// is to be interpreted as 'ValidationException'.
    ///
    /// For an example service see Amazon Polly.
    /// Test ID: AwsJson11FooErrorUsingXAmznErrorTypeWithUri
    #[test]
    fn aws_json11_foo_error_using_x_amzn_error_type_with_uri_response() {
        let expected_output = {
            let _ = 5;
            FooError::builder().build()
        };
        let http_response = ::http::response::Builder::new()
            .header(
                "X-Amzn-Errortype",
                "FooError:http://internal.amazon.com/coral/com.amazon.coral.validate/",
            )
            .status(500)
            .body(vec![])
            .unwrap();

        let parsed = GreetingWithErrors::from_response(&http_response);
        if let Err(crate::error::GreetingWithErrorsError::FooError(actual_error)) = parsed {
            assert_eq!(expected_output, actual_error);
        } else {
            panic!("wrong variant: {:?}", parsed);
        }
    }
    /// X-Amzn-Errortype might contain a URL and a namespace. Client should extract only the shape name. This is a pathalogical case that might not actually happen in any deployed AWS service.
    /// Test ID: AwsJson11FooErrorUsingXAmznErrorTypeWithUriAndNamespace
    #[test]
    fn aws_json11_foo_error_using_x_amzn_error_type_with_uri_and_namespace_response() {
        let expected_output = {
            let _ = 5;
            FooError::builder().build()
        };
        let http_response = ::http::response::Builder::new()
        .header("X-Amzn-Errortype", "aws.protocoltests.restjson#FooError:http://internal.amazon.com/coral/com.amazon.coral.validate/")
        
                        .status(500)
                        .body(vec![])
                        .unwrap();

        let parsed = GreetingWithErrors::from_response(&http_response);
        if let Err(crate::error::GreetingWithErrorsError::FooError(actual_error)) = parsed {
            assert_eq!(expected_output, actual_error);
        } else {
            panic!("wrong variant: {:?}", parsed);
        }
    }
    /// This example uses the 'code' property in the output rather than X-Amzn-Errortype. Some services do this though it's preferable to send the X-Amzn-Errortype. Client implementations must first check for the X-Amzn-Errortype and then check for a top-level 'code' property.
    ///
    /// For example service see Amazon S3 Glacier.
    /// Test ID: AwsJson11FooErrorUsingCode
    #[test]
    fn aws_json11_foo_error_using_code_response() {
        let expected_output = {
            let _ = 5;
            FooError::builder().build()
        };
        let http_response = ::http::response::Builder::new()
            .header("Content-Type", "application/x-amz-json-1.1")
            .status(500)
            .body(
                "{
            \"code\": \"FooError\"
        }",
            )
            .unwrap();

        let parsed = GreetingWithErrors::from_response(&http_response);
        if let Err(crate::error::GreetingWithErrorsError::FooError(actual_error)) = parsed {
            assert_eq!(expected_output, actual_error);
        } else {
            panic!("wrong variant: {:?}", parsed);
        }
    }
    /// Some services serialize errors using code, and it might contain a namespace. Clients should just take the last part of the string after '#'.
    /// Test ID: AwsJson11FooErrorUsingCodeAndNamespace
    #[test]
    fn aws_json11_foo_error_using_code_and_namespace_response() {
        let expected_output = {
            let _ = 5;
            FooError::builder().build()
        };
        let http_response = ::http::response::Builder::new()
            .header("Content-Type", "application/x-amz-json-1.1")
            .status(500)
            .body(
                "{
            \"code\": \"aws.protocoltests.restjson#FooError\"
        }",
            )
            .unwrap();

        let parsed = GreetingWithErrors::from_response(&http_response);
        if let Err(crate::error::GreetingWithErrorsError::FooError(actual_error)) = parsed {
            assert_eq!(expected_output, actual_error);
        } else {
            panic!("wrong variant: {:?}", parsed);
        }
    }
    /// Some services serialize errors using code, and it might contain a namespace. It also might contain a URI. Clients should just take the last part of the string after '#' and before ":". This is a pathalogical case that might not occur in any deployed AWS service.
    /// Test ID: AwsJson11FooErrorUsingCodeUriAndNamespace
    #[test]
    fn aws_json11_foo_error_using_code_uri_and_namespace_response() {
        let expected_output = {
            let _ = 5;
            FooError::builder().build()
        };
        let http_response = ::http::response::Builder::new()
        .header("Content-Type", "application/x-amz-json-1.1")
        
                        .status(500)
                        .body("{
            \"code\": \"aws.protocoltests.restjson#FooError:http://internal.amazon.com/coral/com.amazon.coral.validate/\"
        }")
                        .unwrap();

        let parsed = GreetingWithErrors::from_response(&http_response);
        if let Err(crate::error::GreetingWithErrorsError::FooError(actual_error)) = parsed {
            assert_eq!(expected_output, actual_error);
        } else {
            panic!("wrong variant: {:?}", parsed);
        }
    }
    /// Some services serialize errors using __type.
    /// Test ID: AwsJson11FooErrorWithDunderType
    #[test]
    fn aws_json11_foo_error_with_dunder_type_response() {
        let expected_output = {
            let _ = 5;
            FooError::builder().build()
        };
        let http_response = ::http::response::Builder::new()
            .header("Content-Type", "application/x-amz-json-1.1")
            .status(500)
            .body(
                "{
            \"__type\": \"FooError\"
        }",
            )
            .unwrap();

        let parsed = GreetingWithErrors::from_response(&http_response);
        if let Err(crate::error::GreetingWithErrorsError::FooError(actual_error)) = parsed {
            assert_eq!(expected_output, actual_error);
        } else {
            panic!("wrong variant: {:?}", parsed);
        }
    }
    /// Some services serialize errors using __type, and it might contain a namespace. Clients should just take the last part of the string after '#'.
    /// Test ID: AwsJson11FooErrorWithDunderTypeAndNamespace
    #[test]
    fn aws_json11_foo_error_with_dunder_type_and_namespace_response() {
        let expected_output = {
            let _ = 5;
            FooError::builder().build()
        };
        let http_response = ::http::response::Builder::new()
            .header("Content-Type", "application/x-amz-json-1.1")
            .status(500)
            .body(
                "{
            \"__type\": \"aws.protocoltests.restjson#FooError\"
        }",
            )
            .unwrap();

        let parsed = GreetingWithErrors::from_response(&http_response);
        if let Err(crate::error::GreetingWithErrorsError::FooError(actual_error)) = parsed {
            assert_eq!(expected_output, actual_error);
        } else {
            panic!("wrong variant: {:?}", parsed);
        }
    }
    /// Some services serialize errors using __type, and it might contain a namespace. It also might contain a URI. Clients should just take the last part of the string after '#' and before ":". This is a pathalogical case that might not occur in any deployed AWS service.
    /// Test ID: AwsJson11FooErrorWithDunderTypeUriAndNamespace
    #[test]
    fn aws_json11_foo_error_with_dunder_type_uri_and_namespace_response() {
        let expected_output = {
            let _ = 5;
            FooError::builder().build()
        };
        let http_response = ::http::response::Builder::new()
        .header("Content-Type", "application/x-amz-json-1.1")
        
                        .status(500)
                        .body("{
            \"__type\": \"aws.protocoltests.restjson#FooError:http://internal.amazon.com/coral/com.amazon.coral.validate/\"
        }")
                        .unwrap();

        let parsed = GreetingWithErrors::from_response(&http_response);
        if let Err(crate::error::GreetingWithErrorsError::FooError(actual_error)) = parsed {
            assert_eq!(expected_output, actual_error);
        } else {
            panic!("wrong variant: {:?}", parsed);
        }
    }
}

/// This example serializes enums as top level properties, in lists, sets, and maps.
pub struct JsonEnums {
    input: JsonEnumsInput,
}
impl JsonEnums {
    /// Creates a new builder-style object to manufacture [`JsonEnumsInput`](crate::input::JsonEnumsInput)
    pub fn builder() -> crate::input::json_enums_input::Builder {
        crate::input::json_enums_input::Builder::default()
    }
    pub fn build_http_request(&self) -> ::http::request::Request<Vec<u8>> {
        JsonEnumsInput::assemble(self.input.request_builder_base(), self.input.build_body())
    }
    fn from_response(
        response: &::http::response::Response<impl AsRef<[u8]>>,
    ) -> Result<JsonEnumsOutput, crate::error::JsonEnumsError> {
        if crate::error_code::is_error(&response) {
            let body: ::serde_json::Value = ::serde_json::from_slice(response.body().as_ref())
                .unwrap_or_else(|_| ::serde_json::json!({}));
            let error_code = crate::error_code::error_type_from_header(&response)
                .map_err(crate::error::JsonEnumsError::unhandled)?;
            let error_code = error_code.or_else(|| crate::error_code::error_type_from_body(&body));
            let error_code = error_code.ok_or_else(|| {
                crate::error::JsonEnumsError::unhandled("no error code".to_string())
            })?;
            let error_code = crate::error_code::sanitize_error_code(error_code);

            return Err(crate::error::JsonEnumsError::unhandled(error_code));
        }
        let body: JsonEnumsOutputBody = ::serde_json::from_slice(response.body().as_ref())
            .map_err(crate::error::JsonEnumsError::unhandled)?;
        Ok(JsonEnumsOutput {
            foo_enum1: body.foo_enum1,
            foo_enum2: body.foo_enum2,
            foo_enum3: body.foo_enum3,
            foo_enum_list: body.foo_enum_list,
            foo_enum_set: body.foo_enum_set,
            foo_enum_map: body.foo_enum_map,
        })
    }
    pub fn parse_response(
        &self,
        response: &::http::response::Response<impl AsRef<[u8]>>,
    ) -> Result<JsonEnumsOutput, crate::error::JsonEnumsError> {
        Self::from_response(&response)
    }
    pub fn new(input: JsonEnumsInput) -> Self {
        Self { input }
    }
}

/// This operation uses unions for inputs and outputs.
pub struct JsonUnions {
    input: JsonUnionsInput,
}
impl JsonUnions {
    /// Creates a new builder-style object to manufacture [`JsonUnionsInput`](crate::input::JsonUnionsInput)
    pub fn builder() -> crate::input::json_unions_input::Builder {
        crate::input::json_unions_input::Builder::default()
    }
    pub fn build_http_request(&self) -> ::http::request::Request<Vec<u8>> {
        JsonUnionsInput::assemble(self.input.request_builder_base(), self.input.build_body())
    }
    fn from_response(
        response: &::http::response::Response<impl AsRef<[u8]>>,
    ) -> Result<JsonUnionsOutput, crate::error::JsonUnionsError> {
        if crate::error_code::is_error(&response) {
            let body: ::serde_json::Value = ::serde_json::from_slice(response.body().as_ref())
                .unwrap_or_else(|_| ::serde_json::json!({}));
            let error_code = crate::error_code::error_type_from_header(&response)
                .map_err(crate::error::JsonUnionsError::unhandled)?;
            let error_code = error_code.or_else(|| crate::error_code::error_type_from_body(&body));
            let error_code = error_code.ok_or_else(|| {
                crate::error::JsonUnionsError::unhandled("no error code".to_string())
            })?;
            let error_code = crate::error_code::sanitize_error_code(error_code);

            return Err(crate::error::JsonUnionsError::unhandled(error_code));
        }
        let body: JsonUnionsOutputBody = ::serde_json::from_slice(response.body().as_ref())
            .map_err(crate::error::JsonUnionsError::unhandled)?;
        Ok(JsonUnionsOutput {
            contents: body.contents,
        })
    }
    pub fn parse_response(
        &self,
        response: &::http::response::Response<impl AsRef<[u8]>>,
    ) -> Result<JsonUnionsOutput, crate::error::JsonUnionsError> {
        Self::from_response(&response)
    }
    pub fn new(input: JsonUnionsInput) -> Self {
        Self { input }
    }
}
#[cfg(test)]
#[allow(unreachable_code, unused_variables)]
mod json_unions_request_test {

    use crate::input::JsonUnionsInput;
    use crate::model::FooEnum;
    use crate::model::GreetingStruct;
    use crate::model::MyUnion;
    use crate::operation::JsonUnions;
    use crate::output::JsonUnionsOutput;
    /// Serializes a string union value
    /// Test ID: AwsJson11SerializeStringUnionValue
    #[test]
    fn aws_json11_serialize_string_union_value_request() {
        let input = {
            let config = crate::config::Config::builder()
                .token_provider("00000000-0000-4000-8000-000000000000")
                .build();

            JsonUnionsInput::builder()
                .contents(MyUnion::StringValue("foo".to_string()))
                .build(&config)
        };
        let http_request = input.build_http_request();

        assert_eq!(http_request.method(), "POST");
        assert_eq!(http_request.uri().path(), "/");

        let expected_headers = &[
            ("Content-Type", "application/x-amz-json-1.1"),
            ("X-Amz-Target", "JsonProtocol.JsonUnions"),
        ];
        ::protocol_test_helpers::assert_ok(::protocol_test_helpers::validate_headers(
            &http_request,
            expected_headers,
        ));
        ::protocol_test_helpers::assert_ok(::protocol_test_helpers::validate_body(
            &http_request.body(),
            "{
            \"contents\": {
                \"stringValue\": \"foo\"
            }
        }",
            ::protocol_test_helpers::MediaType::from("application/json"),
        ));
    }
    /// Serializes a boolean union value
    /// Test ID: AwsJson11SerializeBooleanUnionValue
    #[test]
    fn aws_json11_serialize_boolean_union_value_request() {
        let input = {
            let config = crate::config::Config::builder()
                .token_provider("00000000-0000-4000-8000-000000000000")
                .build();

            JsonUnionsInput::builder()
                .contents(MyUnion::BooleanValue(true))
                .build(&config)
        };
        let http_request = input.build_http_request();

        assert_eq!(http_request.method(), "POST");
        assert_eq!(http_request.uri().path(), "/");

        let expected_headers = &[
            ("Content-Type", "application/x-amz-json-1.1"),
            ("X-Amz-Target", "JsonProtocol.JsonUnions"),
        ];
        ::protocol_test_helpers::assert_ok(::protocol_test_helpers::validate_headers(
            &http_request,
            expected_headers,
        ));
        ::protocol_test_helpers::assert_ok(::protocol_test_helpers::validate_body(
            &http_request.body(),
            "{
            \"contents\": {
                \"booleanValue\": true
            }
        }",
            ::protocol_test_helpers::MediaType::from("application/json"),
        ));
    }
    /// Serializes a number union value
    /// Test ID: AwsJson11SerializeNumberUnionValue
    #[test]
    fn aws_json11_serialize_number_union_value_request() {
        let input = {
            let config = crate::config::Config::builder()
                .token_provider("00000000-0000-4000-8000-000000000000")
                .build();

            JsonUnionsInput::builder()
                .contents(MyUnion::NumberValue(1))
                .build(&config)
        };
        let http_request = input.build_http_request();

        assert_eq!(http_request.method(), "POST");
        assert_eq!(http_request.uri().path(), "/");

        let expected_headers = &[
            ("Content-Type", "application/x-amz-json-1.1"),
            ("X-Amz-Target", "JsonProtocol.JsonUnions"),
        ];
        ::protocol_test_helpers::assert_ok(::protocol_test_helpers::validate_headers(
            &http_request,
            expected_headers,
        ));
        ::protocol_test_helpers::assert_ok(::protocol_test_helpers::validate_body(
            &http_request.body(),
            "{
            \"contents\": {
                \"numberValue\": 1
            }
        }",
            ::protocol_test_helpers::MediaType::from("application/json"),
        ));
    }
    /// Serializes a blob union value
    /// Test ID: AwsJson11SerializeBlobUnionValue
    #[test]
    fn aws_json11_serialize_blob_union_value_request() {
        let input = {
            let config = crate::config::Config::builder()
                .token_provider("00000000-0000-4000-8000-000000000000")
                .build();

            JsonUnionsInput::builder()
                .contents(MyUnion::BlobValue(::smithy_types::Blob::new("foo")))
                .build(&config)
        };
        let http_request = input.build_http_request();

        assert_eq!(http_request.method(), "POST");
        assert_eq!(http_request.uri().path(), "/");

        let expected_headers = &[
            ("Content-Type", "application/x-amz-json-1.1"),
            ("X-Amz-Target", "JsonProtocol.JsonUnions"),
        ];
        ::protocol_test_helpers::assert_ok(::protocol_test_helpers::validate_headers(
            &http_request,
            expected_headers,
        ));
        ::protocol_test_helpers::assert_ok(::protocol_test_helpers::validate_body(
            &http_request.body(),
            "{
            \"contents\": {
                \"blobValue\": \"Zm9v\"
            }
        }",
            ::protocol_test_helpers::MediaType::from("application/json"),
        ));
    }
    /// Serializes a timestamp union value
    /// Test ID: AwsJson11SerializeTimestampUnionValue
    #[test]
    fn aws_json11_serialize_timestamp_union_value_request() {
        let input = {
            let config = crate::config::Config::builder()
                .token_provider("00000000-0000-4000-8000-000000000000")
                .build();

            JsonUnionsInput::builder()
                .contents(MyUnion::TimestampValue(
                    ::smithy_types::Instant::from_epoch_seconds(1398796238),
                ))
                .build(&config)
        };
        let http_request = input.build_http_request();

        assert_eq!(http_request.method(), "POST");
        assert_eq!(http_request.uri().path(), "/");

        let expected_headers = &[
            ("Content-Type", "application/x-amz-json-1.1"),
            ("X-Amz-Target", "JsonProtocol.JsonUnions"),
        ];
        ::protocol_test_helpers::assert_ok(::protocol_test_helpers::validate_headers(
            &http_request,
            expected_headers,
        ));
        ::protocol_test_helpers::assert_ok(::protocol_test_helpers::validate_body(
            &http_request.body(),
            "{
            \"contents\": {
                \"timestampValue\": 1398796238
            }
        }",
            ::protocol_test_helpers::MediaType::from("application/json"),
        ));
    }
    /// Serializes an enum union value
    /// Test ID: AwsJson11SerializeEnumUnionValue
    #[test]
    fn aws_json11_serialize_enum_union_value_request() {
        let input = {
            let config = crate::config::Config::builder()
                .token_provider("00000000-0000-4000-8000-000000000000")
                .build();

            JsonUnionsInput::builder()
                .contents(MyUnion::EnumValue(FooEnum::from("Foo")))
                .build(&config)
        };
        let http_request = input.build_http_request();

        assert_eq!(http_request.method(), "POST");
        assert_eq!(http_request.uri().path(), "/");

        let expected_headers = &[
            ("Content-Type", "application/x-amz-json-1.1"),
            ("X-Amz-Target", "JsonProtocol.JsonUnions"),
        ];
        ::protocol_test_helpers::assert_ok(::protocol_test_helpers::validate_headers(
            &http_request,
            expected_headers,
        ));
        ::protocol_test_helpers::assert_ok(::protocol_test_helpers::validate_body(
            &http_request.body(),
            "{
            \"contents\": {
                \"enumValue\": \"Foo\"
            }
        }",
            ::protocol_test_helpers::MediaType::from("application/json"),
        ));
    }
    /// Serializes a list union value
    /// Test ID: AwsJson11SerializeListUnionValue
    #[test]
    fn aws_json11_serialize_list_union_value_request() {
        let input = {
            let config = crate::config::Config::builder()
                .token_provider("00000000-0000-4000-8000-000000000000")
                .build();

            JsonUnionsInput::builder()
                .contents(MyUnion::ListValue(vec![
                    "foo".to_string(),
                    "bar".to_string(),
                ]))
                .build(&config)
        };
        let http_request = input.build_http_request();

        assert_eq!(http_request.method(), "POST");
        assert_eq!(http_request.uri().path(), "/");

        let expected_headers = &[
            ("Content-Type", "application/x-amz-json-1.1"),
            ("X-Amz-Target", "JsonProtocol.JsonUnions"),
        ];
        ::protocol_test_helpers::assert_ok(::protocol_test_helpers::validate_headers(
            &http_request,
            expected_headers,
        ));
        ::protocol_test_helpers::assert_ok(::protocol_test_helpers::validate_body(
            &http_request.body(),
            "{
            \"contents\": {
                \"listValue\": [\"foo\", \"bar\"]
            }
        }",
            ::protocol_test_helpers::MediaType::from("application/json"),
        ));
    }
    /// Serializes a map union value
    /// Test ID: AwsJson11SerializeMapUnionValue
    #[test]
    fn aws_json11_serialize_map_union_value_request() {
        let input = {
            let config = crate::config::Config::builder()
                .token_provider("00000000-0000-4000-8000-000000000000")
                .build();

            JsonUnionsInput::builder()
                .contents(MyUnion::MapValue({
                    let mut ret = ::std::collections::HashMap::new();
                    ret.insert("foo".to_string(), "bar".to_string());
                    ret.insert("spam".to_string(), "eggs".to_string());
                    ret
                }))
                .build(&config)
        };
        let http_request = input.build_http_request();

        assert_eq!(http_request.method(), "POST");
        assert_eq!(http_request.uri().path(), "/");

        let expected_headers = &[
            ("Content-Type", "application/x-amz-json-1.1"),
            ("X-Amz-Target", "JsonProtocol.JsonUnions"),
        ];
        ::protocol_test_helpers::assert_ok(::protocol_test_helpers::validate_headers(
            &http_request,
            expected_headers,
        ));
        ::protocol_test_helpers::assert_ok(::protocol_test_helpers::validate_body(
            &http_request.body(),
            "{
            \"contents\": {
                \"mapValue\": {
                    \"foo\": \"bar\",
                    \"spam\": \"eggs\"
                }
            }
        }",
            ::protocol_test_helpers::MediaType::from("application/json"),
        ));
    }
    /// Serializes a structure union value
    /// Test ID: AwsJson11SerializeStructureUnionValue
    #[test]
    fn aws_json11_serialize_structure_union_value_request() {
        let input = {
            let config = crate::config::Config::builder()
                .token_provider("00000000-0000-4000-8000-000000000000")
                .build();

            JsonUnionsInput::builder()
                .contents(MyUnion::StructureValue({
                    let _ = 5;
                    GreetingStruct::builder().hi("hello".to_string()).build()
                }))
                .build(&config)
        };
        let http_request = input.build_http_request();

        assert_eq!(http_request.method(), "POST");
        assert_eq!(http_request.uri().path(), "/");

        let expected_headers = &[
            ("Content-Type", "application/x-amz-json-1.1"),
            ("X-Amz-Target", "JsonProtocol.JsonUnions"),
        ];
        ::protocol_test_helpers::assert_ok(::protocol_test_helpers::validate_headers(
            &http_request,
            expected_headers,
        ));
        ::protocol_test_helpers::assert_ok(::protocol_test_helpers::validate_body(
            &http_request.body(),
            "{
            \"contents\": {
                \"structureValue\": {
                    \"hi\": \"hello\"
                }
            }
        }",
            ::protocol_test_helpers::MediaType::from("application/json"),
        ));
    }
    /// Deserializes a string union value
    /// Test ID: AwsJson11DeserializeStringUnionValue
    #[test]
    fn aws_json11_deserialize_string_union_value_response() {
        let expected_output = {
            let _ = 5;
            JsonUnionsOutput::builder()
                .contents(MyUnion::StringValue("foo".to_string()))
                .build()
        };
        let http_response = ::http::response::Builder::new()
            .header("Content-Type", "application/x-amz-json-1.1")
            .status(200)
            .body(
                "{
            \"contents\": {
                \"stringValue\": \"foo\"
            }
        }",
            )
            .unwrap();

        let parsed = JsonUnions::from_response(&http_response);
        assert_eq!(parsed.unwrap(), expected_output);
    }
    /// Deserializes a boolean union value
    /// Test ID: AwsJson11DeserializeBooleanUnionValue
    #[test]
    fn aws_json11_deserialize_boolean_union_value_response() {
        let expected_output = {
            let _ = 5;
            JsonUnionsOutput::builder()
                .contents(MyUnion::BooleanValue(true))
                .build()
        };
        let http_response = ::http::response::Builder::new()
            .header("Content-Type", "application/x-amz-json-1.1")
            .status(200)
            .body(
                "{
            \"contents\": {
                \"booleanValue\": true
            }
        }",
            )
            .unwrap();

        let parsed = JsonUnions::from_response(&http_response);
        assert_eq!(parsed.unwrap(), expected_output);
    }
    /// Deserializes a number union value
    /// Test ID: AwsJson11DeserializeNumberUnionValue
    #[test]
    fn aws_json11_deserialize_number_union_value_response() {
        let expected_output = {
            let _ = 5;
            JsonUnionsOutput::builder()
                .contents(MyUnion::NumberValue(1))
                .build()
        };
        let http_response = ::http::response::Builder::new()
            .header("Content-Type", "application/x-amz-json-1.1")
            .status(200)
            .body(
                "{
            \"contents\": {
                \"numberValue\": 1
            }
        }",
            )
            .unwrap();

        let parsed = JsonUnions::from_response(&http_response);
        assert_eq!(parsed.unwrap(), expected_output);
    }
    /// Deserializes a blob union value
    /// Test ID: AwsJson11DeserializeBlobUnionValue
    #[test]
    fn aws_json11_deserialize_blob_union_value_response() {
        let expected_output = {
            let _ = 5;
            JsonUnionsOutput::builder()
                .contents(MyUnion::BlobValue(::smithy_types::Blob::new("foo")))
                .build()
        };
        let http_response = ::http::response::Builder::new()
            .header("Content-Type", "application/x-amz-json-1.1")
            .status(200)
            .body(
                "{
            \"contents\": {
                \"blobValue\": \"Zm9v\"
            }
        }",
            )
            .unwrap();

        let parsed = JsonUnions::from_response(&http_response);
        assert_eq!(parsed.unwrap(), expected_output);
    }
    /// Deserializes a timestamp union value
    /// Test ID: AwsJson11DeserializeTimestampUnionValue
    #[test]
    fn aws_json11_deserialize_timestamp_union_value_response() {
        let expected_output = {
            let _ = 5;
            JsonUnionsOutput::builder()
                .contents(MyUnion::TimestampValue(
                    ::smithy_types::Instant::from_epoch_seconds(1398796238),
                ))
                .build()
        };
        let http_response = ::http::response::Builder::new()
            .header("Content-Type", "application/x-amz-json-1.1")
            .status(200)
            .body(
                "{
            \"contents\": {
                \"timestampValue\": 1398796238
            }
        }",
            )
            .unwrap();

        let parsed = JsonUnions::from_response(&http_response);
        assert_eq!(parsed.unwrap(), expected_output);
    }
    /// Deserializes an enum union value
    /// Test ID: AwsJson11DeserializeEnumUnionValue
    #[test]
    fn aws_json11_deserialize_enum_union_value_response() {
        let expected_output = {
            let _ = 5;
            JsonUnionsOutput::builder()
                .contents(MyUnion::EnumValue(FooEnum::from("Foo")))
                .build()
        };
        let http_response = ::http::response::Builder::new()
            .header("Content-Type", "application/x-amz-json-1.1")
            .status(200)
            .body(
                "{
            \"contents\": {
                \"enumValue\": \"Foo\"
            }
        }",
            )
            .unwrap();

        let parsed = JsonUnions::from_response(&http_response);
        assert_eq!(parsed.unwrap(), expected_output);
    }
    /// Deserializes a list union value
    /// Test ID: AwsJson11DeserializeListUnionValue
    #[test]
    fn aws_json11_deserialize_list_union_value_response() {
        let expected_output = {
            let _ = 5;
            JsonUnionsOutput::builder()
                .contents(MyUnion::ListValue(vec![
                    "foo".to_string(),
                    "bar".to_string(),
                ]))
                .build()
        };
        let http_response = ::http::response::Builder::new()
            .header("Content-Type", "application/x-amz-json-1.1")
            .status(200)
            .body(
                "{
            \"contents\": {
                \"listValue\": [\"foo\", \"bar\"]
            }
        }",
            )
            .unwrap();

        let parsed = JsonUnions::from_response(&http_response);
        assert_eq!(parsed.unwrap(), expected_output);
    }
    /// Deserializes a map union value
    /// Test ID: AwsJson11DeserializeMapUnionValue
    #[test]
    fn aws_json11_deserialize_map_union_value_response() {
        let expected_output = {
            let _ = 5;
            JsonUnionsOutput::builder()
                .contents(MyUnion::MapValue({
                    let mut ret = ::std::collections::HashMap::new();
                    ret.insert("foo".to_string(), "bar".to_string());
                    ret.insert("spam".to_string(), "eggs".to_string());
                    ret
                }))
                .build()
        };
        let http_response = ::http::response::Builder::new()
            .header("Content-Type", "application/x-amz-json-1.1")
            .status(200)
            .body(
                "{
            \"contents\": {
                \"mapValue\": {
                    \"foo\": \"bar\",
                    \"spam\": \"eggs\"
                }
            }
        }",
            )
            .unwrap();

        let parsed = JsonUnions::from_response(&http_response);
        assert_eq!(parsed.unwrap(), expected_output);
    }
    /// Deserializes a structure union value
    /// Test ID: AwsJson11DeserializeStructureUnionValue
    #[test]
    fn aws_json11_deserialize_structure_union_value_response() {
        let expected_output = {
            let _ = 5;
            JsonUnionsOutput::builder()
                .contents(MyUnion::StructureValue({
                    let _ = 5;
                    GreetingStruct::builder().hi("hello".to_string()).build()
                }))
                .build()
        };
        let http_response = ::http::response::Builder::new()
            .header("Content-Type", "application/x-amz-json-1.1")
            .status(200)
            .body(
                "{
            \"contents\": {
                \"structureValue\": {
                    \"hi\": \"hello\"
                }
            }
        }",
            )
            .unwrap();

        let parsed = JsonUnions::from_response(&http_response);
        assert_eq!(parsed.unwrap(), expected_output);
    }
}

pub struct KitchenSinkOperation {
    input: KitchenSinkOperationInput,
}
impl KitchenSinkOperation {
    /// Creates a new builder-style object to manufacture [`KitchenSinkOperationInput`](crate::input::KitchenSinkOperationInput)
    pub fn builder() -> crate::input::kitchen_sink_operation_input::Builder {
        crate::input::kitchen_sink_operation_input::Builder::default()
    }
    pub fn build_http_request(&self) -> ::http::request::Request<Vec<u8>> {
        KitchenSinkOperationInput::assemble(
            self.input.request_builder_base(),
            self.input.build_body(),
        )
    }
    fn from_response(
        response: &::http::response::Response<impl AsRef<[u8]>>,
    ) -> Result<KitchenSinkOperationOutput, crate::error::KitchenSinkOperationError> {
        if crate::error_code::is_error(&response) {
            let body: ::serde_json::Value = ::serde_json::from_slice(response.body().as_ref())
                .unwrap_or_else(|_| ::serde_json::json!({}));
            let error_code = crate::error_code::error_type_from_header(&response)
                .map_err(crate::error::KitchenSinkOperationError::unhandled)?;
            let error_code = error_code.or_else(|| crate::error_code::error_type_from_body(&body));
            let error_code = error_code.ok_or_else(|| {
                crate::error::KitchenSinkOperationError::unhandled("no error code".to_string())
            })?;
            let error_code = crate::error_code::sanitize_error_code(error_code);

            return Err(match error_code {
                "ErrorWithMembers" => match ::serde_json::from_value(body) {
                    Ok(body) => crate::error::KitchenSinkOperationError::ErrorWithMembers(body),
                    Err(e) => crate::error::KitchenSinkOperationError::unhandled(e),
                },
                "ErrorWithoutMembers" => match ::serde_json::from_value(body) {
                    Ok(body) => crate::error::KitchenSinkOperationError::ErrorWithoutMembers(body),
                    Err(e) => crate::error::KitchenSinkOperationError::unhandled(e),
                },
                unknown => crate::error::KitchenSinkOperationError::unhandled(unknown),
            });
        }
        let body: KitchenSinkOperationOutputBody =
            ::serde_json::from_slice(response.body().as_ref())
                .map_err(crate::error::KitchenSinkOperationError::unhandled)?;
        Ok(KitchenSinkOperationOutput {
            blob: body.blob,
            boolean: body.boolean,
            double: body.double,
            empty_struct: body.empty_struct,
            float: body.float,
            httpdate_timestamp: body.httpdate_timestamp,
            integer: body.integer,
            iso8601_timestamp: body.iso8601_timestamp,
            json_value: body.json_value,
            list_of_lists: body.list_of_lists,
            list_of_maps_of_strings: body.list_of_maps_of_strings,
            list_of_strings: body.list_of_strings,
            list_of_structs: body.list_of_structs,
            long: body.long,
            map_of_lists_of_strings: body.map_of_lists_of_strings,
            map_of_maps: body.map_of_maps,
            map_of_strings: body.map_of_strings,
            map_of_structs: body.map_of_structs,
            recursive_list: body.recursive_list,
            recursive_map: body.recursive_map,
            recursive_struct: body.recursive_struct,
            simple_struct: body.simple_struct,
            string: body.string,
            struct_with_location_name: body.struct_with_location_name,
            timestamp: body.timestamp,
            unix_timestamp: body.unix_timestamp,
        })
    }
    pub fn parse_response(
        &self,
        response: &::http::response::Response<impl AsRef<[u8]>>,
    ) -> Result<KitchenSinkOperationOutput, crate::error::KitchenSinkOperationError> {
        Self::from_response(&response)
    }
    pub fn new(input: KitchenSinkOperationInput) -> Self {
        Self { input }
    }
}
#[cfg(test)]
#[allow(unreachable_code, unused_variables)]
mod kitchen_sink_operation_request_test {

    use crate::input::KitchenSinkOperationInput;
    use crate::model::EmptyStruct;
    use crate::model::KitchenSink;
    use crate::model::SimpleStruct;
    use crate::model::StructWithLocationName;
    use crate::operation::KitchenSinkOperation;
    use crate::output::KitchenSinkOperationOutput;
    /// Serializes string shapes
    /// Test ID: serializes_string_shapes
    #[test]
    fn serializes_string_shapes_request() {
        let input = {
            let config = crate::config::Config::builder()
                .token_provider("00000000-0000-4000-8000-000000000000")
                .build();

            KitchenSinkOperationInput::builder()
                .string("abc xyz".to_string())
                .build(&config)
        };
        let http_request = input.build_http_request();

        assert_eq!(http_request.method(), "POST");
        assert_eq!(http_request.uri().path(), "/");

        let expected_headers = &[("Content-Type", "application/x-amz-json-1.1")];
        ::protocol_test_helpers::assert_ok(::protocol_test_helpers::validate_headers(
            &http_request,
            expected_headers,
        ));
        let required_headers = &["Content-Length"];
        ::protocol_test_helpers::assert_ok(::protocol_test_helpers::require_headers(
            &http_request,
            required_headers,
        ));
        ::protocol_test_helpers::assert_ok(::protocol_test_helpers::validate_body(
            &http_request.body(),
            "{\"String\":\"abc xyz\"}",
            ::protocol_test_helpers::MediaType::from("application/json"),
        ));
    }
    /// Serializes string shapes with jsonvalue trait
    /// Test ID: serializes_string_shapes_with_jsonvalue_trait
    #[test]
    fn serializes_string_shapes_with_jsonvalue_trait_request() {
        let input = {
            let config = crate::config::Config::builder()
                .token_provider("00000000-0000-4000-8000-000000000000")
                .build();

            KitchenSinkOperationInput::builder()
            .json_value(
                "{\"string\":\"value\",\"number\":1234.5,\"boolTrue\":true,\"boolFalse\":false,\"array\":[1,2,3,4],\"object\":{\"key\":\"value\"},\"null\":null}".to_string()
            )
            .build(&config)
        };
        let http_request = input.build_http_request();

        assert_eq!(http_request.method(), "POST");
        assert_eq!(http_request.uri().path(), "/");

        let expected_headers = &[("Content-Type", "application/x-amz-json-1.1")];
        ::protocol_test_helpers::assert_ok(::protocol_test_helpers::validate_headers(
            &http_request,
            expected_headers,
        ));
        let required_headers = &["Content-Length"];
        ::protocol_test_helpers::assert_ok(::protocol_test_helpers::require_headers(
            &http_request,
            required_headers,
        ));
        ::protocol_test_helpers::assert_ok(
        ::protocol_test_helpers::validate_body(&http_request.body(), "{\"JsonValue\":\"{\\\"string\\\":\\\"value\\\",\\\"number\\\":1234.5,\\\"boolTrue\\\":true,\\\"boolFalse\\\":false,\\\"array\\\":[1,2,3,4],\\\"object\\\":{\\\"key\\\":\\\"value\\\"},\\\"null\\\":null}\"}", ::protocol_test_helpers::MediaType::from("application/json"))
        );
    }
    /// Serializes integer shapes
    /// Test ID: serializes_integer_shapes
    #[test]
    fn serializes_integer_shapes_request() {
        let input = {
            let config = crate::config::Config::builder()
                .token_provider("00000000-0000-4000-8000-000000000000")
                .build();

            KitchenSinkOperationInput::builder()
                .integer(1234)
                .build(&config)
        };
        let http_request = input.build_http_request();

        assert_eq!(http_request.method(), "POST");
        assert_eq!(http_request.uri().path(), "/");

        let expected_headers = &[("Content-Type", "application/x-amz-json-1.1")];
        ::protocol_test_helpers::assert_ok(::protocol_test_helpers::validate_headers(
            &http_request,
            expected_headers,
        ));
        let required_headers = &["Content-Length"];
        ::protocol_test_helpers::assert_ok(::protocol_test_helpers::require_headers(
            &http_request,
            required_headers,
        ));
        ::protocol_test_helpers::assert_ok(::protocol_test_helpers::validate_body(
            &http_request.body(),
            "{\"Integer\":1234}",
            ::protocol_test_helpers::MediaType::from("application/json"),
        ));
    }
    /// Serializes long shapes
    /// Test ID: serializes_long_shapes
    #[test]
    fn serializes_long_shapes_request() {
        let input = {
            let config = crate::config::Config::builder()
                .token_provider("00000000-0000-4000-8000-000000000000")
                .build();

            KitchenSinkOperationInput::builder()
                .long(999999999999)
                .build(&config)
        };
        let http_request = input.build_http_request();

        assert_eq!(http_request.method(), "POST");
        assert_eq!(http_request.uri().path(), "/");

        let expected_headers = &[("Content-Type", "application/x-amz-json-1.1")];
        ::protocol_test_helpers::assert_ok(::protocol_test_helpers::validate_headers(
            &http_request,
            expected_headers,
        ));
        let required_headers = &["Content-Length"];
        ::protocol_test_helpers::assert_ok(::protocol_test_helpers::require_headers(
            &http_request,
            required_headers,
        ));
        ::protocol_test_helpers::assert_ok(::protocol_test_helpers::validate_body(
            &http_request.body(),
            "{\"Long\":999999999999}",
            ::protocol_test_helpers::MediaType::from("application/json"),
        ));
    }
    /// Serializes float shapes
    /// Test ID: serializes_float_shapes
    #[test]
    fn serializes_float_shapes_request() {
        let input = {
            let config = crate::config::Config::builder()
                .token_provider("00000000-0000-4000-8000-000000000000")
                .build();

            KitchenSinkOperationInput::builder()
                .float(1234.5)
                .build(&config)
        };
        let http_request = input.build_http_request();

        assert_eq!(http_request.method(), "POST");
        assert_eq!(http_request.uri().path(), "/");

        let expected_headers = &[("Content-Type", "application/x-amz-json-1.1")];
        ::protocol_test_helpers::assert_ok(::protocol_test_helpers::validate_headers(
            &http_request,
            expected_headers,
        ));
        let required_headers = &["Content-Length"];
        ::protocol_test_helpers::assert_ok(::protocol_test_helpers::require_headers(
            &http_request,
            required_headers,
        ));
        ::protocol_test_helpers::assert_ok(::protocol_test_helpers::validate_body(
            &http_request.body(),
            "{\"Float\":1234.5}",
            ::protocol_test_helpers::MediaType::from("application/json"),
        ));
    }
    /// Serializes double shapes
    /// Test ID: serializes_double_shapes
    #[test]
    fn serializes_double_shapes_request() {
        let input = {
            let config = crate::config::Config::builder()
                .token_provider("00000000-0000-4000-8000-000000000000")
                .build();

            KitchenSinkOperationInput::builder()
                .double(1234.5)
                .build(&config)
        };
        let http_request = input.build_http_request();

        assert_eq!(http_request.method(), "POST");
        assert_eq!(http_request.uri().path(), "/");

        let expected_headers = &[("Content-Type", "application/x-amz-json-1.1")];
        ::protocol_test_helpers::assert_ok(::protocol_test_helpers::validate_headers(
            &http_request,
            expected_headers,
        ));
        let required_headers = &["Content-Length"];
        ::protocol_test_helpers::assert_ok(::protocol_test_helpers::require_headers(
            &http_request,
            required_headers,
        ));
        ::protocol_test_helpers::assert_ok(::protocol_test_helpers::validate_body(
            &http_request.body(),
            "{\"Double\":1234.5}",
            ::protocol_test_helpers::MediaType::from("application/json"),
        ));
    }
    /// Serializes blob shapes
    /// Test ID: serializes_blob_shapes
    #[test]
    fn serializes_blob_shapes_request() {
        let input = {
            let config = crate::config::Config::builder()
                .token_provider("00000000-0000-4000-8000-000000000000")
                .build();

            KitchenSinkOperationInput::builder()
                .blob(::smithy_types::Blob::new("binary-value"))
                .build(&config)
        };
        let http_request = input.build_http_request();

        assert_eq!(http_request.method(), "POST");
        assert_eq!(http_request.uri().path(), "/");

        let expected_headers = &[("Content-Type", "application/x-amz-json-1.1")];
        ::protocol_test_helpers::assert_ok(::protocol_test_helpers::validate_headers(
            &http_request,
            expected_headers,
        ));
        let required_headers = &["Content-Length"];
        ::protocol_test_helpers::assert_ok(::protocol_test_helpers::require_headers(
            &http_request,
            required_headers,
        ));
        ::protocol_test_helpers::assert_ok(::protocol_test_helpers::validate_body(
            &http_request.body(),
            "{\"Blob\":\"YmluYXJ5LXZhbHVl\"}",
            ::protocol_test_helpers::MediaType::from("application/json"),
        ));
    }
    /// Serializes boolean shapes (true)
    /// Test ID: serializes_boolean_shapes_true
    #[test]
    fn serializes_boolean_shapes_true_request() {
        let input = {
            let config = crate::config::Config::builder()
                .token_provider("00000000-0000-4000-8000-000000000000")
                .build();

            KitchenSinkOperationInput::builder()
                .boolean(true)
                .build(&config)
        };
        let http_request = input.build_http_request();

        assert_eq!(http_request.method(), "POST");
        assert_eq!(http_request.uri().path(), "/");

        let expected_headers = &[("Content-Type", "application/x-amz-json-1.1")];
        ::protocol_test_helpers::assert_ok(::protocol_test_helpers::validate_headers(
            &http_request,
            expected_headers,
        ));
        let required_headers = &["Content-Length"];
        ::protocol_test_helpers::assert_ok(::protocol_test_helpers::require_headers(
            &http_request,
            required_headers,
        ));
        ::protocol_test_helpers::assert_ok(::protocol_test_helpers::validate_body(
            &http_request.body(),
            "{\"Boolean\":true}",
            ::protocol_test_helpers::MediaType::from("application/json"),
        ));
    }
    /// Serializes boolean shapes (false)
    /// Test ID: serializes_boolean_shapes_false
    #[test]
    fn serializes_boolean_shapes_false_request() {
        let input = {
            let config = crate::config::Config::builder()
                .token_provider("00000000-0000-4000-8000-000000000000")
                .build();

            KitchenSinkOperationInput::builder()
                .boolean(false)
                .build(&config)
        };
        let http_request = input.build_http_request();

        assert_eq!(http_request.method(), "POST");
        assert_eq!(http_request.uri().path(), "/");

        let expected_headers = &[("Content-Type", "application/x-amz-json-1.1")];
        ::protocol_test_helpers::assert_ok(::protocol_test_helpers::validate_headers(
            &http_request,
            expected_headers,
        ));
        let required_headers = &["Content-Length"];
        ::protocol_test_helpers::assert_ok(::protocol_test_helpers::require_headers(
            &http_request,
            required_headers,
        ));
        ::protocol_test_helpers::assert_ok(::protocol_test_helpers::validate_body(
            &http_request.body(),
            "{\"Boolean\":false}",
            ::protocol_test_helpers::MediaType::from("application/json"),
        ));
    }
    /// Serializes timestamp shapes
    /// Test ID: serializes_timestamp_shapes
    #[test]
    fn serializes_timestamp_shapes_request() {
        let input = {
            let config = crate::config::Config::builder()
                .token_provider("00000000-0000-4000-8000-000000000000")
                .build();

            KitchenSinkOperationInput::builder()
                .timestamp(::smithy_types::Instant::from_epoch_seconds(946845296))
                .build(&config)
        };
        let http_request = input.build_http_request();

        assert_eq!(http_request.method(), "POST");
        assert_eq!(http_request.uri().path(), "/");

        let expected_headers = &[("Content-Type", "application/x-amz-json-1.1")];
        ::protocol_test_helpers::assert_ok(::protocol_test_helpers::validate_headers(
            &http_request,
            expected_headers,
        ));
        let required_headers = &["Content-Length"];
        ::protocol_test_helpers::assert_ok(::protocol_test_helpers::require_headers(
            &http_request,
            required_headers,
        ));
        ::protocol_test_helpers::assert_ok(::protocol_test_helpers::validate_body(
            &http_request.body(),
            "{\"Timestamp\":946845296}",
            ::protocol_test_helpers::MediaType::from("application/json"),
        ));
    }
    /// Serializes timestamp shapes with iso8601 timestampFormat
    /// Test ID: serializes_timestamp_shapes_with_iso8601_timestampformat
    #[test]
    fn serializes_timestamp_shapes_with_iso8601_timestampformat_request() {
        let input = {
            let config = crate::config::Config::builder()
                .token_provider("00000000-0000-4000-8000-000000000000")
                .build();

            KitchenSinkOperationInput::builder()
                .iso8601_timestamp(::smithy_types::Instant::from_epoch_seconds(946845296))
                .build(&config)
        };
        let http_request = input.build_http_request();

        assert_eq!(http_request.method(), "POST");
        assert_eq!(http_request.uri().path(), "/");

        let expected_headers = &[("Content-Type", "application/x-amz-json-1.1")];
        ::protocol_test_helpers::assert_ok(::protocol_test_helpers::validate_headers(
            &http_request,
            expected_headers,
        ));
        let required_headers = &["Content-Length"];
        ::protocol_test_helpers::assert_ok(::protocol_test_helpers::require_headers(
            &http_request,
            required_headers,
        ));
        ::protocol_test_helpers::assert_ok(::protocol_test_helpers::validate_body(
            &http_request.body(),
            "{\"Iso8601Timestamp\":\"2000-01-02T20:34:56Z\"}",
            ::protocol_test_helpers::MediaType::from("application/json"),
        ));
    }
    /// Serializes timestamp shapes with httpdate timestampFormat
    /// Test ID: serializes_timestamp_shapes_with_httpdate_timestampformat
    #[test]
    fn serializes_timestamp_shapes_with_httpdate_timestampformat_request() {
        let input = {
            let config = crate::config::Config::builder()
                .token_provider("00000000-0000-4000-8000-000000000000")
                .build();

            KitchenSinkOperationInput::builder()
                .httpdate_timestamp(::smithy_types::Instant::from_epoch_seconds(946845296))
                .build(&config)
        };
        let http_request = input.build_http_request();

        assert_eq!(http_request.method(), "POST");
        assert_eq!(http_request.uri().path(), "/");

        let expected_headers = &[("Content-Type", "application/x-amz-json-1.1")];
        ::protocol_test_helpers::assert_ok(::protocol_test_helpers::validate_headers(
            &http_request,
            expected_headers,
        ));
        let required_headers = &["Content-Length"];
        ::protocol_test_helpers::assert_ok(::protocol_test_helpers::require_headers(
            &http_request,
            required_headers,
        ));
        ::protocol_test_helpers::assert_ok(::protocol_test_helpers::validate_body(
            &http_request.body(),
            "{\"HttpdateTimestamp\":\"Sun, 02 Jan 2000 20:34:56 GMT\"}",
            ::protocol_test_helpers::MediaType::from("application/json"),
        ));
    }
    /// Serializes timestamp shapes with unixTimestamp timestampFormat
    /// Test ID: serializes_timestamp_shapes_with_unixtimestamp_timestampformat
    #[test]
    fn serializes_timestamp_shapes_with_unixtimestamp_timestampformat_request() {
        let input = {
            let config = crate::config::Config::builder()
                .token_provider("00000000-0000-4000-8000-000000000000")
                .build();

            KitchenSinkOperationInput::builder()
                .unix_timestamp(::smithy_types::Instant::from_epoch_seconds(946845296))
                .build(&config)
        };
        let http_request = input.build_http_request();

        assert_eq!(http_request.method(), "POST");
        assert_eq!(http_request.uri().path(), "/");

        let expected_headers = &[("Content-Type", "application/x-amz-json-1.1")];
        ::protocol_test_helpers::assert_ok(::protocol_test_helpers::validate_headers(
            &http_request,
            expected_headers,
        ));
        let required_headers = &["Content-Length"];
        ::protocol_test_helpers::assert_ok(::protocol_test_helpers::require_headers(
            &http_request,
            required_headers,
        ));
        ::protocol_test_helpers::assert_ok(::protocol_test_helpers::validate_body(
            &http_request.body(),
            "{\"UnixTimestamp\":946845296}",
            ::protocol_test_helpers::MediaType::from("application/json"),
        ));
    }
    /// Serializes list shapes
    /// Test ID: serializes_list_shapes
    #[test]
    fn serializes_list_shapes_request() {
        let input = {
            let config = crate::config::Config::builder()
                .token_provider("00000000-0000-4000-8000-000000000000")
                .build();

            KitchenSinkOperationInput::builder()
                .list_of_strings(vec![
                    "abc".to_string(),
                    "mno".to_string(),
                    "xyz".to_string(),
                ])
                .build(&config)
        };
        let http_request = input.build_http_request();

        assert_eq!(http_request.method(), "POST");
        assert_eq!(http_request.uri().path(), "/");

        let expected_headers = &[("Content-Type", "application/x-amz-json-1.1")];
        ::protocol_test_helpers::assert_ok(::protocol_test_helpers::validate_headers(
            &http_request,
            expected_headers,
        ));
        let required_headers = &["Content-Length"];
        ::protocol_test_helpers::assert_ok(::protocol_test_helpers::require_headers(
            &http_request,
            required_headers,
        ));
        ::protocol_test_helpers::assert_ok(::protocol_test_helpers::validate_body(
            &http_request.body(),
            "{\"ListOfStrings\":[\"abc\",\"mno\",\"xyz\"]}",
            ::protocol_test_helpers::MediaType::from("application/json"),
        ));
    }
    /// Serializes empty list shapes
    /// Test ID: serializes_empty_list_shapes
    #[test]
    fn serializes_empty_list_shapes_request() {
        let input = {
            let config = crate::config::Config::builder()
                .token_provider("00000000-0000-4000-8000-000000000000")
                .build();

            KitchenSinkOperationInput::builder()
                .list_of_strings(vec![])
                .build(&config)
        };
        let http_request = input.build_http_request();

        assert_eq!(http_request.method(), "POST");
        assert_eq!(http_request.uri().path(), "/");

        let expected_headers = &[("Content-Type", "application/x-amz-json-1.1")];
        ::protocol_test_helpers::assert_ok(::protocol_test_helpers::validate_headers(
            &http_request,
            expected_headers,
        ));
        let required_headers = &["Content-Length"];
        ::protocol_test_helpers::assert_ok(::protocol_test_helpers::require_headers(
            &http_request,
            required_headers,
        ));
        ::protocol_test_helpers::assert_ok(::protocol_test_helpers::validate_body(
            &http_request.body(),
            "{\"ListOfStrings\":[]}",
            ::protocol_test_helpers::MediaType::from("application/json"),
        ));
    }
    /// Serializes list of map shapes
    /// Test ID: serializes_list_of_map_shapes
    #[test]
    fn serializes_list_of_map_shapes_request() {
        let input = {
            let config = crate::config::Config::builder()
                .token_provider("00000000-0000-4000-8000-000000000000")
                .build();

            KitchenSinkOperationInput::builder()
                .list_of_maps_of_strings(vec![
                    {
                        let mut ret = ::std::collections::HashMap::new();
                        ret.insert("foo".to_string(), "bar".to_string());
                        ret
                    },
                    {
                        let mut ret = ::std::collections::HashMap::new();
                        ret.insert("abc".to_string(), "xyz".to_string());
                        ret
                    },
                    {
                        let mut ret = ::std::collections::HashMap::new();
                        ret.insert("red".to_string(), "blue".to_string());
                        ret
                    },
                ])
                .build(&config)
        };
        let http_request = input.build_http_request();

        assert_eq!(http_request.method(), "POST");
        assert_eq!(http_request.uri().path(), "/");

        let expected_headers = &[("Content-Type", "application/x-amz-json-1.1")];
        ::protocol_test_helpers::assert_ok(::protocol_test_helpers::validate_headers(
            &http_request,
            expected_headers,
        ));
        let required_headers = &["Content-Length"];
        ::protocol_test_helpers::assert_ok(::protocol_test_helpers::require_headers(
            &http_request,
            required_headers,
        ));
        ::protocol_test_helpers::assert_ok(::protocol_test_helpers::validate_body(
            &http_request.body(),
            "{\"ListOfMapsOfStrings\":[{\"foo\":\"bar\"},{\"abc\":\"xyz\"},{\"red\":\"blue\"}]}",
            ::protocol_test_helpers::MediaType::from("application/json"),
        ));
    }
    /// Serializes list of structure shapes
    /// Test ID: serializes_list_of_structure_shapes
    #[test]
    fn serializes_list_of_structure_shapes_request() {
        let input = {
            let config = crate::config::Config::builder()
                .token_provider("00000000-0000-4000-8000-000000000000")
                .build();

            KitchenSinkOperationInput::builder()
                .list_of_structs(vec![
                    {
                        let _ = 5;
                        SimpleStruct::builder().value("abc".to_string()).build()
                    },
                    {
                        let _ = 5;
                        SimpleStruct::builder().value("mno".to_string()).build()
                    },
                    {
                        let _ = 5;
                        SimpleStruct::builder().value("xyz".to_string()).build()
                    },
                ])
                .build(&config)
        };
        let http_request = input.build_http_request();

        assert_eq!(http_request.method(), "POST");
        assert_eq!(http_request.uri().path(), "/");

        let expected_headers = &[("Content-Type", "application/x-amz-json-1.1")];
        ::protocol_test_helpers::assert_ok(::protocol_test_helpers::validate_headers(
            &http_request,
            expected_headers,
        ));
        let required_headers = &["Content-Length"];
        ::protocol_test_helpers::assert_ok(::protocol_test_helpers::require_headers(
            &http_request,
            required_headers,
        ));
        ::protocol_test_helpers::assert_ok(::protocol_test_helpers::validate_body(
            &http_request.body(),
            "{\"ListOfStructs\":[{\"Value\":\"abc\"},{\"Value\":\"mno\"},{\"Value\":\"xyz\"}]}",
            ::protocol_test_helpers::MediaType::from("application/json"),
        ));
    }
    /// Serializes list of recursive structure shapes
    /// Test ID: serializes_list_of_recursive_structure_shapes
    #[test]
    fn serializes_list_of_recursive_structure_shapes_request() {
        let input = {
            let config = crate::config::Config::builder()
                .token_provider("00000000-0000-4000-8000-000000000000")
                .build();

            KitchenSinkOperationInput::builder()
                .recursive_list(vec![{
                    let _ = 5;
                    KitchenSink::builder()
                        .recursive_list(vec![{
                            let _ = 5;
                            KitchenSink::builder()
                                .recursive_list(vec![{
                                    let _ = 5;
                                    KitchenSink::builder().integer(123).build()
                                }])
                                .build()
                        }])
                        .build()
                }])
                .build(&config)
        };
        let http_request = input.build_http_request();

        assert_eq!(http_request.method(), "POST");
        assert_eq!(http_request.uri().path(), "/");

        let expected_headers = &[("Content-Type", "application/x-amz-json-1.1")];
        ::protocol_test_helpers::assert_ok(::protocol_test_helpers::validate_headers(
            &http_request,
            expected_headers,
        ));
        let required_headers = &["Content-Length"];
        ::protocol_test_helpers::assert_ok(::protocol_test_helpers::require_headers(
            &http_request,
            required_headers,
        ));
        ::protocol_test_helpers::assert_ok(::protocol_test_helpers::validate_body(
            &http_request.body(),
            "{\"RecursiveList\":[{\"RecursiveList\":[{\"RecursiveList\":[{\"Integer\":123}]}]}]}",
            ::protocol_test_helpers::MediaType::from("application/json"),
        ));
    }
    /// Serializes map shapes
    /// Test ID: serializes_map_shapes
    #[test]
    fn serializes_map_shapes_request() {
        let input = {
            let config = crate::config::Config::builder()
                .token_provider("00000000-0000-4000-8000-000000000000")
                .build();

            KitchenSinkOperationInput::builder()
                .map_of_strings({
                    let mut ret = ::std::collections::HashMap::new();
                    ret.insert("abc".to_string(), "xyz".to_string());
                    ret.insert("mno".to_string(), "hjk".to_string());
                    ret
                })
                .build(&config)
        };
        let http_request = input.build_http_request();

        assert_eq!(http_request.method(), "POST");
        assert_eq!(http_request.uri().path(), "/");

        let expected_headers = &[("Content-Type", "application/x-amz-json-1.1")];
        ::protocol_test_helpers::assert_ok(::protocol_test_helpers::validate_headers(
            &http_request,
            expected_headers,
        ));
        let required_headers = &["Content-Length"];
        ::protocol_test_helpers::assert_ok(::protocol_test_helpers::require_headers(
            &http_request,
            required_headers,
        ));
        ::protocol_test_helpers::assert_ok(::protocol_test_helpers::validate_body(
            &http_request.body(),
            "{\"MapOfStrings\":{\"abc\":\"xyz\",\"mno\":\"hjk\"}}",
            ::protocol_test_helpers::MediaType::from("application/json"),
        ));
    }
    /// Serializes empty map shapes
    /// Test ID: serializes_empty_map_shapes
    #[test]
    fn serializes_empty_map_shapes_request() {
        let input = {
            let config = crate::config::Config::builder()
                .token_provider("00000000-0000-4000-8000-000000000000")
                .build();

            KitchenSinkOperationInput::builder()
                .map_of_strings(::std::collections::HashMap::new())
                .build(&config)
        };
        let http_request = input.build_http_request();

        assert_eq!(http_request.method(), "POST");
        assert_eq!(http_request.uri().path(), "/");

        let expected_headers = &[("Content-Type", "application/x-amz-json-1.1")];
        ::protocol_test_helpers::assert_ok(::protocol_test_helpers::validate_headers(
            &http_request,
            expected_headers,
        ));
        let required_headers = &["Content-Length"];
        ::protocol_test_helpers::assert_ok(::protocol_test_helpers::require_headers(
            &http_request,
            required_headers,
        ));
        ::protocol_test_helpers::assert_ok(::protocol_test_helpers::validate_body(
            &http_request.body(),
            "{\"MapOfStrings\":{}}",
            ::protocol_test_helpers::MediaType::from("application/json"),
        ));
    }
    /// Serializes map of list shapes
    /// Test ID: serializes_map_of_list_shapes
    #[test]
    fn serializes_map_of_list_shapes_request() {
        let input = {
            let config = crate::config::Config::builder()
                .token_provider("00000000-0000-4000-8000-000000000000")
                .build();

            KitchenSinkOperationInput::builder()
                .map_of_lists_of_strings({
                    let mut ret = ::std::collections::HashMap::new();
                    ret.insert(
                        "abc".to_string(),
                        vec!["abc".to_string(), "xyz".to_string()],
                    );
                    ret.insert(
                        "mno".to_string(),
                        vec!["xyz".to_string(), "abc".to_string()],
                    );
                    ret
                })
                .build(&config)
        };
        let http_request = input.build_http_request();

        assert_eq!(http_request.method(), "POST");
        assert_eq!(http_request.uri().path(), "/");

        let expected_headers = &[("Content-Type", "application/x-amz-json-1.1")];
        ::protocol_test_helpers::assert_ok(::protocol_test_helpers::validate_headers(
            &http_request,
            expected_headers,
        ));
        let required_headers = &["Content-Length"];
        ::protocol_test_helpers::assert_ok(::protocol_test_helpers::require_headers(
            &http_request,
            required_headers,
        ));
        ::protocol_test_helpers::assert_ok(::protocol_test_helpers::validate_body(
            &http_request.body(),
            "{\"MapOfListsOfStrings\":{\"abc\":[\"abc\",\"xyz\"],\"mno\":[\"xyz\",\"abc\"]}}",
            ::protocol_test_helpers::MediaType::from("application/json"),
        ));
    }
    /// Serializes map of structure shapes
    /// Test ID: serializes_map_of_structure_shapes
    #[test]
    fn serializes_map_of_structure_shapes_request() {
        let input = {
            let config = crate::config::Config::builder()
                .token_provider("00000000-0000-4000-8000-000000000000")
                .build();

            KitchenSinkOperationInput::builder()
                .map_of_structs({
                    let mut ret = ::std::collections::HashMap::new();
                    ret.insert("key1".to_string(), {
                        let _ = 5;
                        SimpleStruct::builder().value("value-1".to_string()).build()
                    });
                    ret.insert("key2".to_string(), {
                        let _ = 5;
                        SimpleStruct::builder().value("value-2".to_string()).build()
                    });
                    ret
                })
                .build(&config)
        };
        let http_request = input.build_http_request();

        assert_eq!(http_request.method(), "POST");
        assert_eq!(http_request.uri().path(), "/");

        let expected_headers = &[("Content-Type", "application/x-amz-json-1.1")];
        ::protocol_test_helpers::assert_ok(::protocol_test_helpers::validate_headers(
            &http_request,
            expected_headers,
        ));
        let required_headers = &["Content-Length"];
        ::protocol_test_helpers::assert_ok(::protocol_test_helpers::require_headers(
            &http_request,
            required_headers,
        ));
        ::protocol_test_helpers::assert_ok(
        ::protocol_test_helpers::validate_body(&http_request.body(), "{\"MapOfStructs\":{\"key1\":{\"Value\":\"value-1\"},\"key2\":{\"Value\":\"value-2\"}}}", ::protocol_test_helpers::MediaType::from("application/json"))
        );
    }
    /// Serializes map of recursive structure shapes
    /// Test ID: serializes_map_of_recursive_structure_shapes
    #[test]
    fn serializes_map_of_recursive_structure_shapes_request() {
        let input = {
            let config = crate::config::Config::builder()
                .token_provider("00000000-0000-4000-8000-000000000000")
                .build();

            KitchenSinkOperationInput::builder()
                .recursive_map({
                    let mut ret = ::std::collections::HashMap::new();
                    ret.insert("key1".to_string(), {
                        let _ = 5;
                        KitchenSink::builder()
                            .recursive_map({
                                let mut ret = ::std::collections::HashMap::new();
                                ret.insert("key2".to_string(), {
                                    let _ = 5;
                                    KitchenSink::builder()
                                        .recursive_map({
                                            let mut ret = ::std::collections::HashMap::new();
                                            ret.insert("key3".to_string(), {
                                                let _ = 5;
                                                KitchenSink::builder().boolean(false).build()
                                            });
                                            ret
                                        })
                                        .build()
                                });
                                ret
                            })
                            .build()
                    });
                    ret
                })
                .build(&config)
        };
        let http_request = input.build_http_request();

        assert_eq!(http_request.method(), "POST");
        assert_eq!(http_request.uri().path(), "/");

        let expected_headers = &[("Content-Type", "application/x-amz-json-1.1")];
        ::protocol_test_helpers::assert_ok(::protocol_test_helpers::validate_headers(
            &http_request,
            expected_headers,
        ));
        let required_headers = &["Content-Length"];
        ::protocol_test_helpers::assert_ok(::protocol_test_helpers::require_headers(
            &http_request,
            required_headers,
        ));
        ::protocol_test_helpers::assert_ok(
        ::protocol_test_helpers::validate_body(&http_request.body(), "{\"RecursiveMap\":{\"key1\":{\"RecursiveMap\":{\"key2\":{\"RecursiveMap\":{\"key3\":{\"Boolean\":false}}}}}}}", ::protocol_test_helpers::MediaType::from("application/json"))
        );
    }
    /// Serializes structure shapes
    /// Test ID: serializes_structure_shapes
    #[test]
    fn serializes_structure_shapes_request() {
        let input = {
            let config = crate::config::Config::builder()
                .token_provider("00000000-0000-4000-8000-000000000000")
                .build();

            KitchenSinkOperationInput::builder()
                .simple_struct({
                    let _ = 5;
                    SimpleStruct::builder().value("abc".to_string()).build()
                })
                .build(&config)
        };
        let http_request = input.build_http_request();

        assert_eq!(http_request.method(), "POST");
        assert_eq!(http_request.uri().path(), "/");

        let expected_headers = &[("Content-Type", "application/x-amz-json-1.1")];
        ::protocol_test_helpers::assert_ok(::protocol_test_helpers::validate_headers(
            &http_request,
            expected_headers,
        ));
        let required_headers = &["Content-Length"];
        ::protocol_test_helpers::assert_ok(::protocol_test_helpers::require_headers(
            &http_request,
            required_headers,
        ));
        ::protocol_test_helpers::assert_ok(::protocol_test_helpers::validate_body(
            &http_request.body(),
            "{\"SimpleStruct\":{\"Value\":\"abc\"}}",
            ::protocol_test_helpers::MediaType::from("application/json"),
        ));
    }
    /// Serializes structure members with locationName traits
    /// Test ID: serializes_structure_members_with_locationname_traits
    #[test]
    fn serializes_structure_members_with_locationname_traits_request() {
        let input = {
            let config = crate::config::Config::builder()
                .token_provider("00000000-0000-4000-8000-000000000000")
                .build();

            KitchenSinkOperationInput::builder()
                .struct_with_location_name({
                    let _ = 5;
                    StructWithLocationName::builder()
                        .value("some-value".to_string())
                        .build()
                })
                .build(&config)
        };
        let http_request = input.build_http_request();

        assert_eq!(http_request.method(), "POST");
        assert_eq!(http_request.uri().path(), "/");

        let expected_headers = &[("Content-Type", "application/x-amz-json-1.1")];
        ::protocol_test_helpers::assert_ok(::protocol_test_helpers::validate_headers(
            &http_request,
            expected_headers,
        ));
        let required_headers = &["Content-Length"];
        ::protocol_test_helpers::assert_ok(::protocol_test_helpers::require_headers(
            &http_request,
            required_headers,
        ));
        ::protocol_test_helpers::assert_ok(::protocol_test_helpers::validate_body(
            &http_request.body(),
            "{\"StructWithLocationName\":{\"RenamedMember\":\"some-value\"}}",
            ::protocol_test_helpers::MediaType::from("application/json"),
        ));
    }
    /// Serializes empty structure shapes
    /// Test ID: serializes_empty_structure_shapes
    #[test]
    fn serializes_empty_structure_shapes_request() {
        let input = {
            let config = crate::config::Config::builder()
                .token_provider("00000000-0000-4000-8000-000000000000")
                .build();

            KitchenSinkOperationInput::builder()
                .simple_struct({
                    let _ = 5;
                    SimpleStruct::builder().build()
                })
                .build(&config)
        };
        let http_request = input.build_http_request();

        assert_eq!(http_request.method(), "POST");
        assert_eq!(http_request.uri().path(), "/");

        let expected_headers = &[("Content-Type", "application/x-amz-json-1.1")];
        ::protocol_test_helpers::assert_ok(::protocol_test_helpers::validate_headers(
            &http_request,
            expected_headers,
        ));
        let required_headers = &["Content-Length"];
        ::protocol_test_helpers::assert_ok(::protocol_test_helpers::require_headers(
            &http_request,
            required_headers,
        ));
        ::protocol_test_helpers::assert_ok(::protocol_test_helpers::validate_body(
            &http_request.body(),
            "{\"SimpleStruct\":{}}",
            ::protocol_test_helpers::MediaType::from("application/json"),
        ));
    }
    /// Serializes structure which have no members
    /// Test ID: serializes_structure_which_have_no_members
    #[test]
    fn serializes_structure_which_have_no_members_request() {
        let input = {
            let config = crate::config::Config::builder()
                .token_provider("00000000-0000-4000-8000-000000000000")
                .build();

            KitchenSinkOperationInput::builder()
                .empty_struct({
                    let _ = 5;
                    EmptyStruct::builder().build()
                })
                .build(&config)
        };
        let http_request = input.build_http_request();

        assert_eq!(http_request.method(), "POST");
        assert_eq!(http_request.uri().path(), "/");

        let expected_headers = &[("Content-Type", "application/x-amz-json-1.1")];
        ::protocol_test_helpers::assert_ok(::protocol_test_helpers::validate_headers(
            &http_request,
            expected_headers,
        ));
        let required_headers = &["Content-Length"];
        ::protocol_test_helpers::assert_ok(::protocol_test_helpers::require_headers(
            &http_request,
            required_headers,
        ));
        ::protocol_test_helpers::assert_ok(::protocol_test_helpers::validate_body(
            &http_request.body(),
            "{\"EmptyStruct\":{}}",
            ::protocol_test_helpers::MediaType::from("application/json"),
        ));
    }
    /// Serializes recursive structure shapes
    /// Test ID: serializes_recursive_structure_shapes
    #[test]
    fn serializes_recursive_structure_shapes_request() {
        let input = {
            let config = crate::config::Config::builder()
                .token_provider("00000000-0000-4000-8000-000000000000")
                .build();

            KitchenSinkOperationInput::builder()
                .string("top-value".to_string())
                .boolean(false)
                .recursive_struct({
                    let _ = 5;
                    KitchenSink::builder()
                        .string("nested-value".to_string())
                        .boolean(true)
                        .recursive_list(vec![
                            {
                                let _ = 5;
                                KitchenSink::builder()
                                    .string("string-only".to_string())
                                    .build()
                            },
                            {
                                let _ = 5;
                                KitchenSink::builder()
                                    .recursive_struct({
                                        let _ = 5;
                                        KitchenSink::builder()
                                            .map_of_strings({
                                                let mut ret = ::std::collections::HashMap::new();
                                                ret.insert("color".to_string(), "red".to_string());
                                                ret.insert("size".to_string(), "large".to_string());
                                                ret
                                            })
                                            .build()
                                    })
                                    .build()
                            },
                        ])
                        .build()
                })
                .build(&config)
        };
        let http_request = input.build_http_request();

        assert_eq!(http_request.method(), "POST");
        assert_eq!(http_request.uri().path(), "/");

        let expected_headers = &[("Content-Type", "application/x-amz-json-1.1")];
        ::protocol_test_helpers::assert_ok(::protocol_test_helpers::validate_headers(
            &http_request,
            expected_headers,
        ));
        let required_headers = &["Content-Length"];
        ::protocol_test_helpers::assert_ok(::protocol_test_helpers::require_headers(
            &http_request,
            required_headers,
        ));
        ::protocol_test_helpers::assert_ok(
        ::protocol_test_helpers::validate_body(&http_request.body(), "{\"String\":\"top-value\",\"Boolean\":false,\"RecursiveStruct\":{\"String\":\"nested-value\",\"Boolean\":true,\"RecursiveList\":[{\"String\":\"string-only\"},{\"RecursiveStruct\":{\"MapOfStrings\":{\"color\":\"red\",\"size\":\"large\"}}}]}}", ::protocol_test_helpers::MediaType::from("application/json"))
        );
    }
    /// Parses operations with empty JSON bodies
    /// Test ID: parses_operations_with_empty_json_bodies
    #[test]
    fn parses_operations_with_empty_json_bodies_response() {
        let expected_output = {
            let _ = 5;
            KitchenSinkOperationOutput::builder().build()
        };
        let http_response = ::http::response::Builder::new()
            .header("Content-Type", "application/x-amz-json-1.1")
            .status(200)
            .body("{}")
            .unwrap();

        let parsed = KitchenSinkOperation::from_response(&http_response);
        assert_eq!(parsed.unwrap(), expected_output);
    }
    /// Parses string shapes
    /// Test ID: parses_string_shapes
    #[test]
    fn parses_string_shapes_response() {
        let expected_output = {
            let _ = 5;
            KitchenSinkOperationOutput::builder()
                .string("string-value".to_string())
                .build()
        };
        let http_response = ::http::response::Builder::new()
            .header("Content-Type", "application/x-amz-json-1.1")
            .status(200)
            .body("{\"String\":\"string-value\"}")
            .unwrap();

        let parsed = KitchenSinkOperation::from_response(&http_response);
        assert_eq!(parsed.unwrap(), expected_output);
    }
    /// Parses integer shapes
    /// Test ID: parses_integer_shapes
    #[test]
    fn parses_integer_shapes_response() {
        let expected_output = {
            let _ = 5;
            KitchenSinkOperationOutput::builder().integer(1234).build()
        };
        let http_response = ::http::response::Builder::new()
            .header("Content-Type", "application/x-amz-json-1.1")
            .status(200)
            .body("{\"Integer\":1234}")
            .unwrap();

        let parsed = KitchenSinkOperation::from_response(&http_response);
        assert_eq!(parsed.unwrap(), expected_output);
    }
    /// Parses long shapes
    /// Test ID: parses_long_shapes
    #[test]
    fn parses_long_shapes_response() {
        let expected_output = {
            let _ = 5;
            KitchenSinkOperationOutput::builder()
                .long(1234567890123456789)
                .build()
        };
        let http_response = ::http::response::Builder::new()
            .header("Content-Type", "application/x-amz-json-1.1")
            .status(200)
            .body("{\"Long\":1234567890123456789}")
            .unwrap();

        let parsed = KitchenSinkOperation::from_response(&http_response);
        assert_eq!(parsed.unwrap(), expected_output);
    }
    /// Parses float shapes
    /// Test ID: parses_float_shapes
    #[test]
    fn parses_float_shapes_response() {
        let expected_output = {
            let _ = 5;
            KitchenSinkOperationOutput::builder().float(1234.5).build()
        };
        let http_response = ::http::response::Builder::new()
            .header("Content-Type", "application/x-amz-json-1.1")
            .status(200)
            .body("{\"Float\":1234.5}")
            .unwrap();

        let parsed = KitchenSinkOperation::from_response(&http_response);
        assert_eq!(parsed.unwrap(), expected_output);
    }
    /// Parses double shapes
    /// Test ID: parses_double_shapes
    #[test]
    fn parses_double_shapes_response() {
        let expected_output = {
            let _ = 5;
            KitchenSinkOperationOutput::builder()
                .double(1.2345678912345679E8)
                .build()
        };
        let http_response = ::http::response::Builder::new()
            .header("Content-Type", "application/x-amz-json-1.1")
            .status(200)
            .body("{\"Double\":123456789.12345679}")
            .unwrap();

        let parsed = KitchenSinkOperation::from_response(&http_response);
        assert_eq!(parsed.unwrap(), expected_output);
    }
    /// Parses boolean shapes (true)
    /// Test ID: parses_boolean_shapes_true
    #[test]
    fn parses_boolean_shapes_true_response() {
        let expected_output = {
            let _ = 5;
            KitchenSinkOperationOutput::builder().boolean(true).build()
        };
        let http_response = ::http::response::Builder::new()
            .header("Content-Type", "application/x-amz-json-1.1")
            .status(200)
            .body("{\"Boolean\":true}")
            .unwrap();

        let parsed = KitchenSinkOperation::from_response(&http_response);
        assert_eq!(parsed.unwrap(), expected_output);
    }
    /// Parses boolean (false)
    /// Test ID: parses_boolean_false
    #[test]
    fn parses_boolean_false_response() {
        let expected_output = {
            let _ = 5;
            KitchenSinkOperationOutput::builder().boolean(false).build()
        };
        let http_response = ::http::response::Builder::new()
            .header("Content-Type", "application/x-amz-json-1.1")
            .status(200)
            .body("{\"Boolean\":false}")
            .unwrap();

        let parsed = KitchenSinkOperation::from_response(&http_response);
        assert_eq!(parsed.unwrap(), expected_output);
    }
    /// Parses blob shapes
    /// Test ID: parses_blob_shapes
    #[test]
    fn parses_blob_shapes_response() {
        let expected_output = {
            let _ = 5;
            KitchenSinkOperationOutput::builder()
                .blob(::smithy_types::Blob::new("binary-value"))
                .build()
        };
        let http_response = ::http::response::Builder::new()
            .header("Content-Type", "application/x-amz-json-1.1")
            .status(200)
            .body("{\"Blob\":\"YmluYXJ5LXZhbHVl\"}")
            .unwrap();

        let parsed = KitchenSinkOperation::from_response(&http_response);
        assert_eq!(parsed.unwrap(), expected_output);
    }
    /// Parses timestamp shapes
    /// Test ID: parses_timestamp_shapes
    #[test]
    fn parses_timestamp_shapes_response() {
        let expected_output = {
            let _ = 5;
            KitchenSinkOperationOutput::builder()
                .timestamp(::smithy_types::Instant::from_epoch_seconds(946845296))
                .build()
        };
        let http_response = ::http::response::Builder::new()
            .header("Content-Type", "application/x-amz-json-1.1")
            .status(200)
            .body("{\"Timestamp\":946845296}")
            .unwrap();

        let parsed = KitchenSinkOperation::from_response(&http_response);
        assert_eq!(parsed.unwrap(), expected_output);
    }
    /// Parses iso8601 timestamps
    /// Test ID: parses_iso8601_timestamps
    #[test]
    fn parses_iso8601_timestamps_response() {
        let expected_output = {
            let _ = 5;
            KitchenSinkOperationOutput::builder()
                .iso8601_timestamp(::smithy_types::Instant::from_epoch_seconds(946845296))
                .build()
        };
        let http_response = ::http::response::Builder::new()
            .header("Content-Type", "application/x-amz-json-1.1")
            .status(200)
            .body("{\"Iso8601Timestamp\":\"2000-01-02T20:34:56.000Z\"}")
            .unwrap();

        let parsed = KitchenSinkOperation::from_response(&http_response);
        assert_eq!(parsed.unwrap(), expected_output);
    }
    /// Parses httpdate timestamps
    /// Test ID: parses_httpdate_timestamps
    #[test]
    fn parses_httpdate_timestamps_response() {
        let expected_output = {
            let _ = 5;
            KitchenSinkOperationOutput::builder()
                .httpdate_timestamp(::smithy_types::Instant::from_epoch_seconds(946845296))
                .build()
        };
        let http_response = ::http::response::Builder::new()
            .header("Content-Type", "application/x-amz-json-1.1")
            .status(200)
            .body("{\"HttpdateTimestamp\":\"Sun, 02 Jan 2000 20:34:56.000 GMT\"}")
            .unwrap();

        let parsed = KitchenSinkOperation::from_response(&http_response);
        assert_eq!(parsed.unwrap(), expected_output);
    }
    /// Parses list shapes
    /// Test ID: parses_list_shapes
    #[test]
    fn parses_list_shapes_response() {
        let expected_output = {
            let _ = 5;
            KitchenSinkOperationOutput::builder()
                .list_of_strings(vec![
                    "abc".to_string(),
                    "mno".to_string(),
                    "xyz".to_string(),
                ])
                .build()
        };
        let http_response = ::http::response::Builder::new()
            .header("Content-Type", "application/x-amz-json-1.1")
            .status(200)
            .body("{\"ListOfStrings\":[\"abc\",\"mno\",\"xyz\"]}")
            .unwrap();

        let parsed = KitchenSinkOperation::from_response(&http_response);
        assert_eq!(parsed.unwrap(), expected_output);
    }
    /// Parses list of map shapes
    /// Test ID: parses_list_of_map_shapes
    #[test]
    fn parses_list_of_map_shapes_response() {
        let expected_output = {
            let _ = 5;
            KitchenSinkOperationOutput::builder()
                .list_of_maps_of_strings(vec![
                    {
                        let mut ret = ::std::collections::HashMap::new();
                        ret.insert("size".to_string(), "large".to_string());
                        ret
                    },
                    {
                        let mut ret = ::std::collections::HashMap::new();
                        ret.insert("color".to_string(), "red".to_string());
                        ret
                    },
                ])
                .build()
        };
        let http_response = ::http::response::Builder::new()
            .header("Content-Type", "application/x-amz-json-1.1")
            .status(200)
            .body("{\"ListOfMapsOfStrings\":[{\"size\":\"large\"},{\"color\":\"red\"}]}")
            .unwrap();

        let parsed = KitchenSinkOperation::from_response(&http_response);
        assert_eq!(parsed.unwrap(), expected_output);
    }
    /// Parses list of list shapes
    /// Test ID: parses_list_of_list_shapes
    #[test]
    fn parses_list_of_list_shapes_response() {
        let expected_output = {
            let _ = 5;
            KitchenSinkOperationOutput::builder()
                .list_of_lists(vec![
                    vec!["abc".to_string(), "mno".to_string(), "xyz".to_string()],
                    vec!["hjk".to_string(), "qrs".to_string(), "tuv".to_string()],
                ])
                .build()
        };
        let http_response = ::http::response::Builder::new()
            .header("Content-Type", "application/x-amz-json-1.1")
            .status(200)
            .body("{\"ListOfLists\":[[\"abc\",\"mno\",\"xyz\"],[\"hjk\",\"qrs\",\"tuv\"]]}")
            .unwrap();

        let parsed = KitchenSinkOperation::from_response(&http_response);
        assert_eq!(parsed.unwrap(), expected_output);
    }
    /// Parses list of structure shapes
    /// Test ID: parses_list_of_structure_shapes
    #[test]
    fn parses_list_of_structure_shapes_response() {
        let expected_output = {
            let _ = 5;
            KitchenSinkOperationOutput::builder()
                .list_of_structs(vec![
                    {
                        let _ = 5;
                        SimpleStruct::builder().value("value-1".to_string()).build()
                    },
                    {
                        let _ = 5;
                        SimpleStruct::builder().value("value-2".to_string()).build()
                    },
                ])
                .build()
        };
        let http_response = ::http::response::Builder::new()
            .header("Content-Type", "application/x-amz-json-1.1")
            .status(200)
            .body("{\"ListOfStructs\":[{\"Value\":\"value-1\"},{\"Value\":\"value-2\"}]}")
            .unwrap();

        let parsed = KitchenSinkOperation::from_response(&http_response);
        assert_eq!(parsed.unwrap(), expected_output);
    }
    /// Parses list of recursive structure shapes
    /// Test ID: parses_list_of_recursive_structure_shapes
    #[test]
    fn parses_list_of_recursive_structure_shapes_response() {
        let expected_output = {
            let _ = 5;
            KitchenSinkOperationOutput::builder()
                .recursive_list(vec![{
                    let _ = 5;
                    KitchenSink::builder()
                        .recursive_list(vec![{
                            let _ = 5;
                            KitchenSink::builder()
                                .recursive_list(vec![{
                                    let _ = 5;
                                    KitchenSink::builder().string("value".to_string()).build()
                                }])
                                .build()
                        }])
                        .build()
                }])
                .build()
        };
        let http_response = ::http::response::Builder::new()
        .header("Content-Type", "application/x-amz-json-1.1")
        
                        .status(200)
                        .body("{\"RecursiveList\":[{\"RecursiveList\":[{\"RecursiveList\":[{\"String\":\"value\"}]}]}]}")
                        .unwrap();

        let parsed = KitchenSinkOperation::from_response(&http_response);
        assert_eq!(parsed.unwrap(), expected_output);
    }
    /// Parses map shapes
    /// Test ID: parses_map_shapes
    #[test]
    fn parses_map_shapes_response() {
        let expected_output = {
            let _ = 5;
            KitchenSinkOperationOutput::builder()
                .map_of_strings({
                    let mut ret = ::std::collections::HashMap::new();
                    ret.insert("size".to_string(), "large".to_string());
                    ret.insert("color".to_string(), "red".to_string());
                    ret
                })
                .build()
        };
        let http_response = ::http::response::Builder::new()
            .header("Content-Type", "application/x-amz-json-1.1")
            .status(200)
            .body("{\"MapOfStrings\":{\"size\":\"large\",\"color\":\"red\"}}")
            .unwrap();

        let parsed = KitchenSinkOperation::from_response(&http_response);
        assert_eq!(parsed.unwrap(), expected_output);
    }
    /// Parses map of list shapes
    /// Test ID: parses_map_of_list_shapes
    #[test]
    fn parses_map_of_list_shapes_response() {
        let expected_output = {
            let _ = 5;
            KitchenSinkOperationOutput::builder()
                .map_of_lists_of_strings({
                    let mut ret = ::std::collections::HashMap::new();
                    ret.insert(
                        "sizes".to_string(),
                        vec!["large".to_string(), "small".to_string()],
                    );
                    ret.insert(
                        "colors".to_string(),
                        vec!["red".to_string(), "green".to_string()],
                    );
                    ret
                })
                .build()
        };
        let http_response = ::http::response::Builder::new()
        .header("Content-Type", "application/x-amz-json-1.1")
        
                        .status(200)
                        .body("{\"MapOfListsOfStrings\":{\"sizes\":[\"large\",\"small\"],\"colors\":[\"red\",\"green\"]}}")
                        .unwrap();

        let parsed = KitchenSinkOperation::from_response(&http_response);
        assert_eq!(parsed.unwrap(), expected_output);
    }
    /// Parses map of map shapes
    /// Test ID: parses_map_of_map_shapes
    #[test]
    fn parses_map_of_map_shapes_response() {
        let expected_output = {
            let _ = 5;
            KitchenSinkOperationOutput::builder()
                .map_of_maps({
                    let mut ret = ::std::collections::HashMap::new();
                    ret.insert("sizes".to_string(), {
                        let mut ret = ::std::collections::HashMap::new();
                        ret.insert("large".to_string(), "L".to_string());
                        ret.insert("medium".to_string(), "M".to_string());
                        ret
                    });
                    ret.insert("colors".to_string(), {
                        let mut ret = ::std::collections::HashMap::new();
                        ret.insert("red".to_string(), "R".to_string());
                        ret.insert("blue".to_string(), "B".to_string());
                        ret
                    });
                    ret
                })
                .build()
        };
        let http_response = ::http::response::Builder::new()
        .header("Content-Type", "application/x-amz-json-1.1")
        
                        .status(200)
                        .body("{\"MapOfMaps\":{\"sizes\":{\"large\":\"L\",\"medium\":\"M\"},\"colors\":{\"red\":\"R\",\"blue\":\"B\"}}}")
                        .unwrap();

        let parsed = KitchenSinkOperation::from_response(&http_response);
        assert_eq!(parsed.unwrap(), expected_output);
    }
    /// Parses map of structure shapes
    /// Test ID: parses_map_of_structure_shapes
    #[test]
    fn parses_map_of_structure_shapes_response() {
        let expected_output = {
            let _ = 5;
            KitchenSinkOperationOutput::builder()
                .map_of_structs({
                    let mut ret = ::std::collections::HashMap::new();
                    ret.insert("size".to_string(), {
                        let _ = 5;
                        SimpleStruct::builder().value("small".to_string()).build()
                    });
                    ret.insert("color".to_string(), {
                        let _ = 5;
                        SimpleStruct::builder().value("red".to_string()).build()
                    });
                    ret
                })
                .build()
        };
        let http_response = ::http::response::Builder::new()
            .header("Content-Type", "application/x-amz-json-1.1")
            .status(200)
            .body(
                "{\"MapOfStructs\":{\"size\":{\"Value\":\"small\"},\"color\":{\"Value\":\"red\"}}}",
            )
            .unwrap();

        let parsed = KitchenSinkOperation::from_response(&http_response);
        assert_eq!(parsed.unwrap(), expected_output);
    }
    /// Parses map of recursive structure shapes
    /// Test ID: parses_map_of_recursive_structure_shapes
    #[test]
    fn parses_map_of_recursive_structure_shapes_response() {
        let expected_output = {
            let _ = 5;
            KitchenSinkOperationOutput::builder()
                .recursive_map({
                    let mut ret = ::std::collections::HashMap::new();
                    ret.insert("key-1".to_string(), {
                        let _ = 5;
                        KitchenSink::builder()
                            .recursive_map({
                                let mut ret = ::std::collections::HashMap::new();
                                ret.insert("key-2".to_string(), {
                                    let _ = 5;
                                    KitchenSink::builder()
                                        .recursive_map({
                                            let mut ret = ::std::collections::HashMap::new();
                                            ret.insert("key-3".to_string(), {
                                                let _ = 5;
                                                KitchenSink::builder()
                                                    .string("value".to_string())
                                                    .build()
                                            });
                                            ret
                                        })
                                        .build()
                                });
                                ret
                            })
                            .build()
                    });
                    ret
                })
                .build()
        };
        let http_response = ::http::response::Builder::new()
        .header("Content-Type", "application/x-amz-json-1.1")
        
                        .status(200)
                        .body("{\"RecursiveMap\":{\"key-1\":{\"RecursiveMap\":{\"key-2\":{\"RecursiveMap\":{\"key-3\":{\"String\":\"value\"}}}}}}}")
                        .unwrap();

        let parsed = KitchenSinkOperation::from_response(&http_response);
        assert_eq!(parsed.unwrap(), expected_output);
    }
    /// Parses the request id from the response
    /// Test ID: parses_the_request_id_from_the_response
    #[test]
    fn parses_the_request_id_from_the_response_response() {
        let expected_output = {
            let _ = 5;
            KitchenSinkOperationOutput::builder().build()
        };
        let http_response = ::http::response::Builder::new()
            .header("Content-Type", "application/x-amz-json-1.1")
            .header("X-Amzn-Requestid", "amazon-uniq-request-id")
            .status(200)
            .body("{}")
            .unwrap();

        let parsed = KitchenSinkOperation::from_response(&http_response);
        assert_eq!(parsed.unwrap(), expected_output);
    }
}

pub struct NullOperation {
    input: NullOperationInput,
}
impl NullOperation {
    /// Creates a new builder-style object to manufacture [`NullOperationInput`](crate::input::NullOperationInput)
    pub fn builder() -> crate::input::null_operation_input::Builder {
        crate::input::null_operation_input::Builder::default()
    }
    pub fn build_http_request(&self) -> ::http::request::Request<Vec<u8>> {
        NullOperationInput::assemble(self.input.request_builder_base(), self.input.build_body())
    }
    fn from_response(
        response: &::http::response::Response<impl AsRef<[u8]>>,
    ) -> Result<NullOperationOutput, crate::error::NullOperationError> {
        if crate::error_code::is_error(&response) {
            let body: ::serde_json::Value = ::serde_json::from_slice(response.body().as_ref())
                .unwrap_or_else(|_| ::serde_json::json!({}));
            let error_code = crate::error_code::error_type_from_header(&response)
                .map_err(crate::error::NullOperationError::unhandled)?;
            let error_code = error_code.or_else(|| crate::error_code::error_type_from_body(&body));
            let error_code = error_code.ok_or_else(|| {
                crate::error::NullOperationError::unhandled("no error code".to_string())
            })?;
            let error_code = crate::error_code::sanitize_error_code(error_code);

            return Err(crate::error::NullOperationError::unhandled(error_code));
        }
        let body: NullOperationOutputBody = ::serde_json::from_slice(response.body().as_ref())
            .map_err(crate::error::NullOperationError::unhandled)?;
        Ok(NullOperationOutput {
            string: body.string,
            sparse_string_list: body.sparse_string_list,
            sparse_string_map: body.sparse_string_map,
        })
    }
    pub fn parse_response(
        &self,
        response: &::http::response::Response<impl AsRef<[u8]>>,
    ) -> Result<NullOperationOutput, crate::error::NullOperationError> {
        Self::from_response(&response)
    }
    pub fn new(input: NullOperationInput) -> Self {
        Self { input }
    }
}
#[cfg(test)]
#[allow(unreachable_code, unused_variables)]
mod null_operation_request_test {

    use crate::input::NullOperationInput;
    use crate::operation::NullOperation;
    use crate::output::NullOperationOutput;
    /// Null structure values are dropped
    /// Test ID: AwsJson11StructuresDontSerializeNullValues
    #[test]
    fn aws_json11_structures_dont_serialize_null_values_request() {
        let input = {
            let config = crate::config::Config::builder()
                .token_provider("00000000-0000-4000-8000-000000000000")
                .build();

            NullOperationInput::builder().build(&config)
        };
        let http_request = input.build_http_request();

        assert_eq!(http_request.method(), "POST");
        assert_eq!(http_request.uri().path(), "/");

        let expected_headers = &[("Content-Type", "application/x-amz-json-1.1")];
        ::protocol_test_helpers::assert_ok(::protocol_test_helpers::validate_headers(
            &http_request,
            expected_headers,
        ));
        ::protocol_test_helpers::assert_ok(::protocol_test_helpers::validate_body(
            &http_request.body(),
            "{}",
            ::protocol_test_helpers::MediaType::from("application/json"),
        ));
    }
    /// Serializes null values in maps
    /// Test ID: AwsJson11MapsSerializeNullValues
    #[test]
    fn aws_json11_maps_serialize_null_values_request() {
        let input = {
            let config = crate::config::Config::builder()
                .token_provider("00000000-0000-4000-8000-000000000000")
                .build();

            NullOperationInput::builder()
                .sparse_string_map({
                    let mut ret = ::std::collections::HashMap::new();
                    ret.insert("foo".to_string(), None);
                    ret
                })
                .build(&config)
        };
        let http_request = input.build_http_request();

        assert_eq!(http_request.method(), "POST");
        assert_eq!(http_request.uri().path(), "/");

        let expected_headers = &[("Content-Type", "application/x-amz-json-1.1")];
        ::protocol_test_helpers::assert_ok(::protocol_test_helpers::validate_headers(
            &http_request,
            expected_headers,
        ));
        ::protocol_test_helpers::assert_ok(::protocol_test_helpers::validate_body(
            &http_request.body(),
            "{
            \"sparseStringMap\": {
                \"foo\": null
            }
        }",
            ::protocol_test_helpers::MediaType::from("application/json"),
        ));
    }
    /// Serializes null values in lists
    /// Test ID: AwsJson11ListsSerializeNull
    #[test]
    fn aws_json11_lists_serialize_null_request() {
        let input = {
            let config = crate::config::Config::builder()
                .token_provider("00000000-0000-4000-8000-000000000000")
                .build();

            NullOperationInput::builder()
                .sparse_string_list(vec![None])
                .build(&config)
        };
        let http_request = input.build_http_request();

        assert_eq!(http_request.method(), "POST");
        assert_eq!(http_request.uri().path(), "/");

        let expected_headers = &[("Content-Type", "application/x-amz-json-1.1")];
        ::protocol_test_helpers::assert_ok(::protocol_test_helpers::validate_headers(
            &http_request,
            expected_headers,
        ));
        ::protocol_test_helpers::assert_ok(::protocol_test_helpers::validate_body(
            &http_request.body(),
            "{
            \"sparseStringList\": [
                null
            ]
        }",
            ::protocol_test_helpers::MediaType::from("application/json"),
        ));
    }
    /// Null structure values are dropped
    /// Test ID: AwsJson11StructuresDontDeserializeNullValues
    #[test]
    fn aws_json11_structures_dont_deserialize_null_values_response() {
        let expected_output = {
            let _ = 5;
            NullOperationOutput::builder().build()
        };
        let http_response = ::http::response::Builder::new()
            .header("Content-Type", "application/x-amz-json-1.1")
            .status(200)
            .body(
                "{
            \"string\": null
        }",
            )
            .unwrap();

        let parsed = NullOperation::from_response(&http_response);
        assert_eq!(parsed.unwrap(), expected_output);
    }
    /// Deserializes null values in maps
    /// Test ID: AwsJson11MapsDeserializeNullValues
    #[test]
    fn aws_json11_maps_deserialize_null_values_response() {
        let expected_output = {
            let _ = 5;
            NullOperationOutput::builder()
                .sparse_string_map({
                    let mut ret = ::std::collections::HashMap::new();
                    ret.insert("foo".to_string(), None);
                    ret
                })
                .build()
        };
        let http_response = ::http::response::Builder::new()
            .header("Content-Type", "application/x-amz-json-1.1")
            .status(200)
            .body(
                "{
            \"sparseStringMap\": {
                \"foo\": null
            }
        }",
            )
            .unwrap();

        let parsed = NullOperation::from_response(&http_response);
        assert_eq!(parsed.unwrap(), expected_output);
    }
    /// Deserializes null values in lists
    /// Test ID: AwsJson11ListsDeserializeNull
    #[test]
    fn aws_json11_lists_deserialize_null_response() {
        let expected_output = {
            let _ = 5;
            NullOperationOutput::builder()
                .sparse_string_list(vec![None])
                .build()
        };
        let http_response = ::http::response::Builder::new()
            .header("Content-Type", "application/x-amz-json-1.1")
            .status(200)
            .body(
                "{
            \"sparseStringList\": [
                null
            ]
        }",
            )
            .unwrap();

        let parsed = NullOperation::from_response(&http_response);
        assert_eq!(parsed.unwrap(), expected_output);
    }
}

pub struct OperationWithOptionalInputOutput {
    input: OperationWithOptionalInputOutputInput,
}
impl OperationWithOptionalInputOutput {
    /// Creates a new builder-style object to manufacture [`OperationWithOptionalInputOutputInput`](crate::input::OperationWithOptionalInputOutputInput)
    pub fn builder() -> crate::input::operation_with_optional_input_output_input::Builder {
        crate::input::operation_with_optional_input_output_input::Builder::default()
    }
    pub fn build_http_request(&self) -> ::http::request::Request<Vec<u8>> {
        OperationWithOptionalInputOutputInput::assemble(
            self.input.request_builder_base(),
            self.input.build_body(),
        )
    }
    fn from_response(
        response: &::http::response::Response<impl AsRef<[u8]>>,
    ) -> Result<
        OperationWithOptionalInputOutputOutput,
        crate::error::OperationWithOptionalInputOutputError,
    > {
        if crate::error_code::is_error(&response) {
            let body: ::serde_json::Value = ::serde_json::from_slice(response.body().as_ref())
                .unwrap_or_else(|_| ::serde_json::json!({}));
            let error_code = crate::error_code::error_type_from_header(&response)
                .map_err(crate::error::OperationWithOptionalInputOutputError::unhandled)?;
            let error_code = error_code.or_else(|| crate::error_code::error_type_from_body(&body));
            let error_code = error_code.ok_or_else(|| {
                crate::error::OperationWithOptionalInputOutputError::unhandled(
                    "no error code".to_string(),
                )
            })?;
            let error_code = crate::error_code::sanitize_error_code(error_code);

            return Err(crate::error::OperationWithOptionalInputOutputError::unhandled(error_code));
        }
        let body: OperationWithOptionalInputOutputOutputBody =
            ::serde_json::from_slice(response.body().as_ref())
                .map_err(crate::error::OperationWithOptionalInputOutputError::unhandled)?;
        Ok(OperationWithOptionalInputOutputOutput { value: body.value })
    }
    pub fn parse_response(
        &self,
        response: &::http::response::Response<impl AsRef<[u8]>>,
    ) -> Result<
        OperationWithOptionalInputOutputOutput,
        crate::error::OperationWithOptionalInputOutputError,
    > {
        Self::from_response(&response)
    }
    pub fn new(input: OperationWithOptionalInputOutputInput) -> Self {
        Self { input }
    }
}
#[cfg(test)]
#[allow(unreachable_code, unused_variables)]
mod operation_with_optional_input_output_request_test {

    use crate::input::OperationWithOptionalInputOutputInput;
    /// Can call operations with no input or output
    /// Test ID: can_call_operation_with_no_input_or_output
    #[test]
    fn can_call_operation_with_no_input_or_output_request() {
        let input = {
            let config = crate::config::Config::builder()
                .token_provider("00000000-0000-4000-8000-000000000000")
                .build();

            OperationWithOptionalInputOutputInput::builder().build(&config)
        };
        let http_request = input.build_http_request();

        assert_eq!(http_request.method(), "POST");
        assert_eq!(http_request.uri().path(), "/");

        let expected_headers = &[
            ("Content-Type", "application/x-amz-json-1.1"),
            (
                "X-Amz-Target",
                "JsonProtocol.OperationWithOptionalInputOutput",
            ),
        ];
        ::protocol_test_helpers::assert_ok(::protocol_test_helpers::validate_headers(
            &http_request,
            expected_headers,
        ));
        ::protocol_test_helpers::assert_ok(::protocol_test_helpers::validate_body(
            &http_request.body(),
            "{}",
            ::protocol_test_helpers::MediaType::from("application/json"),
        ));
    }
    /// Can invoke operations with optional input
    /// Test ID: can_call_operation_with_optional_input
    #[test]
    fn can_call_operation_with_optional_input_request() {
        let input = {
            let config = crate::config::Config::builder()
                .token_provider("00000000-0000-4000-8000-000000000000")
                .build();

            OperationWithOptionalInputOutputInput::builder()
                .value("Hi".to_string())
                .build(&config)
        };
        let http_request = input.build_http_request();

        assert_eq!(http_request.method(), "POST");
        assert_eq!(http_request.uri().path(), "/");

        let expected_headers = &[
            ("Content-Type", "application/x-amz-json-1.1"),
            (
                "X-Amz-Target",
                "JsonProtocol.OperationWithOptionalInputOutput",
            ),
        ];
        ::protocol_test_helpers::assert_ok(::protocol_test_helpers::validate_headers(
            &http_request,
            expected_headers,
        ));
        ::protocol_test_helpers::assert_ok(::protocol_test_helpers::validate_body(
            &http_request.body(),
            "{\"Value\":\"Hi\"}",
            ::protocol_test_helpers::MediaType::from("application/json"),
        ));
    }
}

/// This example serializes an inline document as part of the payload.
pub struct PutAndGetInlineDocuments {
    input: PutAndGetInlineDocumentsInput,
}
impl PutAndGetInlineDocuments {
    /// Creates a new builder-style object to manufacture [`PutAndGetInlineDocumentsInput`](crate::input::PutAndGetInlineDocumentsInput)
    pub fn builder() -> crate::input::put_and_get_inline_documents_input::Builder {
        crate::input::put_and_get_inline_documents_input::Builder::default()
    }
    pub fn build_http_request(&self) -> ::http::request::Request<Vec<u8>> {
        PutAndGetInlineDocumentsInput::assemble(
            self.input.request_builder_base(),
            self.input.build_body(),
        )
    }
    fn from_response(
        response: &::http::response::Response<impl AsRef<[u8]>>,
    ) -> Result<PutAndGetInlineDocumentsOutput, crate::error::PutAndGetInlineDocumentsError> {
        if crate::error_code::is_error(&response) {
            let body: ::serde_json::Value = ::serde_json::from_slice(response.body().as_ref())
                .unwrap_or_else(|_| ::serde_json::json!({}));
            let error_code = crate::error_code::error_type_from_header(&response)
                .map_err(crate::error::PutAndGetInlineDocumentsError::unhandled)?;
            let error_code = error_code.or_else(|| crate::error_code::error_type_from_body(&body));
            let error_code = error_code.ok_or_else(|| {
                crate::error::PutAndGetInlineDocumentsError::unhandled("no error code".to_string())
            })?;
            let error_code = crate::error_code::sanitize_error_code(error_code);

            return Err(crate::error::PutAndGetInlineDocumentsError::unhandled(
                error_code,
            ));
        }
        let body: PutAndGetInlineDocumentsOutputBody =
            ::serde_json::from_slice(response.body().as_ref())
                .map_err(crate::error::PutAndGetInlineDocumentsError::unhandled)?;
        Ok(PutAndGetInlineDocumentsOutput {
            inline_document: body.inline_document,
        })
    }
    pub fn parse_response(
        &self,
        response: &::http::response::Response<impl AsRef<[u8]>>,
    ) -> Result<PutAndGetInlineDocumentsOutput, crate::error::PutAndGetInlineDocumentsError> {
        Self::from_response(&response)
    }
    pub fn new(input: PutAndGetInlineDocumentsInput) -> Self {
        Self { input }
    }
}
#[cfg(test)]
#[allow(unreachable_code, unused_variables)]
mod put_and_get_inline_documents_request_test {

    use crate::input::PutAndGetInlineDocumentsInput;
    use crate::operation::PutAndGetInlineDocuments;
    use crate::output::PutAndGetInlineDocumentsOutput;
    /// Serializes inline documents in a JSON request.
    /// Test ID: PutAndGetInlineDocumentsInput
    #[test]
    fn put_and_get_inline_documents_input_request() {
        let input = {
            let config = crate::config::Config::builder()
                .token_provider("00000000-0000-4000-8000-000000000000")
                .build();

            PutAndGetInlineDocumentsInput::builder()
                .inline_document({
                    let as_json = ::serde_json::json! { {
                        "foo": "bar"
                    } };
                    crate::doc_json::json_to_doc(as_json)
                })
                .build(&config)
                .unwrap()
        };
        let http_request = input.build_http_request();

        assert_eq!(http_request.method(), "POST");
        assert_eq!(http_request.uri().path(), "/");

        let expected_headers = &[("Content-Type", "application/x-amz-json-1.1")];
        ::protocol_test_helpers::assert_ok(::protocol_test_helpers::validate_headers(
            &http_request,
            expected_headers,
        ));
        let required_headers = &["Content-Length"];
        ::protocol_test_helpers::assert_ok(::protocol_test_helpers::require_headers(
            &http_request,
            required_headers,
        ));
        ::protocol_test_helpers::assert_ok(::protocol_test_helpers::validate_body(
            &http_request.body(),
            "{
            \"inlineDocument\": {\"foo\": \"bar\"}
        }",
            ::protocol_test_helpers::MediaType::from("application/json"),
        ));
    }
    /// Serializes inline documents in a JSON response.
    /// Test ID: PutAndGetInlineDocumentsInput
    #[test]
    #[should_panic]
    fn put_and_get_inline_documents_input_response() {
        let expected_output = {
            let _ = 5;
            PutAndGetInlineDocumentsOutput::builder()
                .inline_document({
                    let as_json = ::serde_json::json! { {
                        "foo": "bar"
                    } };
                    crate::doc_json::json_to_doc(as_json)
                })
                .build()
                .unwrap()
        };
        let http_response = ::http::response::Builder::new()
            .header("Content-Type", "application/x-amz-json-1.1")
            .status(200)
            .body(
                "{
            \"inlineDocument\": {\"foo\": \"bar\"}
        }",
            )
            .unwrap();

        let parsed = PutAndGetInlineDocuments::from_response(&http_response);
        assert_eq!(parsed.unwrap(), expected_output);
    }
}
