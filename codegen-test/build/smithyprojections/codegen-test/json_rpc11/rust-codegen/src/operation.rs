// Code generated by software.amazon.smithy.rust.codegen.smithy-rs. DO NOT EDIT.
use crate::input::EmptyOperationInput;
use crate::input::GreetingWithErrorsInput;
use crate::input::JsonEnumsInput;
use crate::input::JsonUnionsInput;
use crate::input::KitchenSinkOperationInput;
use crate::input::NullOperationInput;
use crate::input::OperationWithOptionalInputOutputInput;
use crate::input::PutAndGetInlineDocumentsInput;
pub struct EmptyOperation {
    input: EmptyOperationInput,
}
impl EmptyOperation {
    /// Creates a new builder-style object to manufacture [`EmptyOperationInput`](crate::input::EmptyOperationInput)
    pub fn builder() -> crate::input::empty_operation_input::Builder {
        crate::input::empty_operation_input::Builder::default()
    }
    pub fn build_http_request(&self) -> ::http::request::Request<Vec<u8>> {
        EmptyOperationInput::assemble(self.input.request_builder_base(), self.input.build_body())
    }
    pub fn new(input: EmptyOperationInput) -> Self {
        Self { input }
    }
}
#[cfg(test)]
#[allow(unreachable_code, unused_variables)]
mod empty_operation_request_test {

    use crate::input::EmptyOperationInput;
    /// Sends requests to /
    /// Test ID: sends_requests_to_slash
    #[test]
    fn test_sends_requests_to_slash_request() {
        let input = EmptyOperationInput::builder().build();
        let http_request = input.build_http_request();

        assert_eq!(http_request.method(), "POST");
        assert_eq!(http_request.uri().path(), "/");

        // No body
        assert!(&http_request.body().is_empty());
    }
    /// Includes X-Amz-Target header and Content-Type
    /// Test ID: includes_x_amz_target_and_content_type
    #[test]
    fn test_includes_x_amz_target_and_content_type_request() {
        let input = EmptyOperationInput::builder().build();
        let http_request = input.build_http_request();

        assert_eq!(http_request.method(), "POST");
        assert_eq!(http_request.uri().path(), "/");

        let expected_headers = &[
            ("Content-Type", "application/x-amz-json-1.1"),
            ("X-Amz-Target", "JsonProtocol.EmptyOperation"),
        ];
        ::protocol_test_helpers::assert_ok(::protocol_test_helpers::validate_headers(
            &http_request,
            expected_headers,
        ));
        // No body
        assert!(&http_request.body().is_empty());
    }
    /// Handles empty output shapes
    /// Test ID: handles_empty_output_shape
    #[test]
    fn test_handles_empty_output_shape_response() {
        /* test case disabled for this protocol (not yet supported) */
    }
}

/// This operation has three possible return values:
/// 1. A successful response in the form of GreetingWithErrorsOutput
/// 2. An InvalidGreeting error.
/// 3. A ComplexError error.
/// Implementations must be able to successfully take a response and
/// properly deserialize successful and error responses.
pub struct GreetingWithErrors {
    input: GreetingWithErrorsInput,
}
impl GreetingWithErrors {
    /// Creates a new builder-style object to manufacture [`GreetingWithErrorsInput`](crate::input::GreetingWithErrorsInput)
    pub fn builder() -> crate::input::greeting_with_errors_input::Builder {
        crate::input::greeting_with_errors_input::Builder::default()
    }
    pub fn build_http_request(&self) -> ::http::request::Request<Vec<u8>> {
        GreetingWithErrorsInput::assemble(
            self.input.request_builder_base(),
            self.input.build_body(),
        )
    }
    pub fn new(input: GreetingWithErrorsInput) -> Self {
        Self { input }
    }
}
#[cfg(test)]
#[allow(unreachable_code, unused_variables)]
mod greeting_with_errors_request_test {

    /// Parses simple JSON errors
    /// Test ID: AwsJson11InvalidGreetingError
    #[test]
    fn test_aws_json11_invalid_greeting_error_response() {
        /* test case disabled for this protocol (not yet supported) */
    }
    /// Parses a complex error with no message member
    /// Test ID: AwsJson11ComplexError
    #[test]
    fn test_aws_json11_complex_error_response() {
        /* test case disabled for this protocol (not yet supported) */
    }
    /// Test ID: AwsJson11EmptyComplexError
    #[test]
    fn test_aws_json11_empty_complex_error_response() {
        /* test case disabled for this protocol (not yet supported) */
    }
    /// Serializes the X-Amzn-ErrorType header. For an example service, see Amazon EKS.
    /// Test ID: AwsJson11FooErrorUsingXAmznErrorType
    #[test]
    fn test_aws_json11_foo_error_using_x_amzn_error_type_response() {
        /* test case disabled for this protocol (not yet supported) */
    }
    /// Some X-Amzn-Errortype headers contain URLs. Clients need to split the URL on ':' and take only the first half of the string. For example, 'ValidationException:http://internal.amazon.com/coral/com.amazon.coral.validate/'
    /// is to be interpreted as 'ValidationException'.
    ///
    /// For an example service see Amazon Polly.
    /// Test ID: AwsJson11FooErrorUsingXAmznErrorTypeWithUri
    #[test]
    fn test_aws_json11_foo_error_using_x_amzn_error_type_with_uri_response() {
        /* test case disabled for this protocol (not yet supported) */
    }
    /// X-Amzn-Errortype might contain a URL and a namespace. Client should extract only the shape name. This is a pathalogical case that might not actually happen in any deployed AWS service.
    /// Test ID: AwsJson11FooErrorUsingXAmznErrorTypeWithUriAndNamespace
    #[test]
    fn test_aws_json11_foo_error_using_x_amzn_error_type_with_uri_and_namespace_response() {
        /* test case disabled for this protocol (not yet supported) */
    }
    /// This example uses the 'code' property in the output rather than X-Amzn-Errortype. Some services do this though it's preferable to send the X-Amzn-Errortype. Client implementations must first check for the X-Amzn-Errortype and then check for a top-level 'code' property.
    ///
    /// For example service see Amazon S3 Glacier.
    /// Test ID: AwsJson11FooErrorUsingCode
    #[test]
    fn test_aws_json11_foo_error_using_code_response() {
        /* test case disabled for this protocol (not yet supported) */
    }
    /// Some services serialize errors using code, and it might contain a namespace. Clients should just take the last part of the string after '#'.
    /// Test ID: AwsJson11FooErrorUsingCodeAndNamespace
    #[test]
    fn test_aws_json11_foo_error_using_code_and_namespace_response() {
        /* test case disabled for this protocol (not yet supported) */
    }
    /// Some services serialize errors using code, and it might contain a namespace. It also might contain a URI. Clients should just take the last part of the string after '#' and before ":". This is a pathalogical case that might not occur in any deployed AWS service.
    /// Test ID: AwsJson11FooErrorUsingCodeUriAndNamespace
    #[test]
    fn test_aws_json11_foo_error_using_code_uri_and_namespace_response() {
        /* test case disabled for this protocol (not yet supported) */
    }
    /// Some services serialize errors using __type.
    /// Test ID: AwsJson11FooErrorWithDunderType
    #[test]
    fn test_aws_json11_foo_error_with_dunder_type_response() {
        /* test case disabled for this protocol (not yet supported) */
    }
    /// Some services serialize errors using __type, and it might contain a namespace. Clients should just take the last part of the string after '#'.
    /// Test ID: AwsJson11FooErrorWithDunderTypeAndNamespace
    #[test]
    fn test_aws_json11_foo_error_with_dunder_type_and_namespace_response() {
        /* test case disabled for this protocol (not yet supported) */
    }
    /// Some services serialize errors using __type, and it might contain a namespace. It also might contain a URI. Clients should just take the last part of the string after '#' and before ":". This is a pathalogical case that might not occur in any deployed AWS service.
    /// Test ID: AwsJson11FooErrorWithDunderTypeUriAndNamespace
    #[test]
    fn test_aws_json11_foo_error_with_dunder_type_uri_and_namespace_response() {
        /* test case disabled for this protocol (not yet supported) */
    }
}

/// This example serializes enums as top level properties, in lists, sets, and maps.
pub struct JsonEnums {
    input: JsonEnumsInput,
}
impl JsonEnums {
    /// Creates a new builder-style object to manufacture [`JsonEnumsInput`](crate::input::JsonEnumsInput)
    pub fn builder() -> crate::input::json_enums_input::Builder {
        crate::input::json_enums_input::Builder::default()
    }
    pub fn build_http_request(&self) -> ::http::request::Request<Vec<u8>> {
        JsonEnumsInput::assemble(self.input.request_builder_base(), self.input.build_body())
    }
    pub fn new(input: JsonEnumsInput) -> Self {
        Self { input }
    }
}

/// This operation uses unions for inputs and outputs.
pub struct JsonUnions {
    input: JsonUnionsInput,
}
impl JsonUnions {
    /// Creates a new builder-style object to manufacture [`JsonUnionsInput`](crate::input::JsonUnionsInput)
    pub fn builder() -> crate::input::json_unions_input::Builder {
        crate::input::json_unions_input::Builder::default()
    }
    pub fn build_http_request(&self) -> ::http::request::Request<Vec<u8>> {
        JsonUnionsInput::assemble(self.input.request_builder_base(), self.input.build_body())
    }
    pub fn new(input: JsonUnionsInput) -> Self {
        Self { input }
    }
}
#[cfg(test)]
#[allow(unreachable_code, unused_variables)]
mod json_unions_request_test {

    use crate::input::JsonUnionsInput;
    use crate::model::FooEnum;
    use crate::model::GreetingStruct;
    use crate::model::MyUnion;
    /// Serializes a string union value
    /// Test ID: AwsJson11SerializeStringUnionValue
    #[test]
    fn test_aws_json11_serialize_string_union_value_request() {
        let input = JsonUnionsInput::builder()
            .contents(MyUnion::StringValue("foo".to_string()))
            .build();
        let http_request = input.build_http_request();

        assert_eq!(http_request.method(), "POST");
        assert_eq!(http_request.uri().path(), "/");

        let expected_headers = &[
            ("Content-Type", "application/x-amz-json-1.1"),
            ("X-Amz-Target", "JsonProtocol.JsonUnions"),
        ];
        ::protocol_test_helpers::assert_ok(::protocol_test_helpers::validate_headers(
            &http_request,
            expected_headers,
        ));
        ::protocol_test_helpers::assert_ok(::protocol_test_helpers::validate_body(
            &http_request.body(),
            "{
            \"contents\": {
                \"stringValue\": \"foo\"
            }
        }",
            ::protocol_test_helpers::MediaType::from("application/json"),
        ));
    }
    /// Serializes a boolean union value
    /// Test ID: AwsJson11SerializeBooleanUnionValue
    #[test]
    fn test_aws_json11_serialize_boolean_union_value_request() {
        let input = JsonUnionsInput::builder()
            .contents(MyUnion::BooleanValue(true))
            .build();
        let http_request = input.build_http_request();

        assert_eq!(http_request.method(), "POST");
        assert_eq!(http_request.uri().path(), "/");

        let expected_headers = &[
            ("Content-Type", "application/x-amz-json-1.1"),
            ("X-Amz-Target", "JsonProtocol.JsonUnions"),
        ];
        ::protocol_test_helpers::assert_ok(::protocol_test_helpers::validate_headers(
            &http_request,
            expected_headers,
        ));
        ::protocol_test_helpers::assert_ok(::protocol_test_helpers::validate_body(
            &http_request.body(),
            "{
            \"contents\": {
                \"booleanValue\": true
            }
        }",
            ::protocol_test_helpers::MediaType::from("application/json"),
        ));
    }
    /// Serializes a number union value
    /// Test ID: AwsJson11SerializeNumberUnionValue
    #[test]
    fn test_aws_json11_serialize_number_union_value_request() {
        let input = JsonUnionsInput::builder()
            .contents(MyUnion::NumberValue(1))
            .build();
        let http_request = input.build_http_request();

        assert_eq!(http_request.method(), "POST");
        assert_eq!(http_request.uri().path(), "/");

        let expected_headers = &[
            ("Content-Type", "application/x-amz-json-1.1"),
            ("X-Amz-Target", "JsonProtocol.JsonUnions"),
        ];
        ::protocol_test_helpers::assert_ok(::protocol_test_helpers::validate_headers(
            &http_request,
            expected_headers,
        ));
        ::protocol_test_helpers::assert_ok(::protocol_test_helpers::validate_body(
            &http_request.body(),
            "{
            \"contents\": {
                \"numberValue\": 1
            }
        }",
            ::protocol_test_helpers::MediaType::from("application/json"),
        ));
    }
    /// Serializes a blob union value
    /// Test ID: AwsJson11SerializeBlobUnionValue
    #[test]
    fn test_aws_json11_serialize_blob_union_value_request() {
        let input = JsonUnionsInput::builder()
            .contents(MyUnion::BlobValue(::smithy_types::Blob::new("foo")))
            .build();
        let http_request = input.build_http_request();

        assert_eq!(http_request.method(), "POST");
        assert_eq!(http_request.uri().path(), "/");

        let expected_headers = &[
            ("Content-Type", "application/x-amz-json-1.1"),
            ("X-Amz-Target", "JsonProtocol.JsonUnions"),
        ];
        ::protocol_test_helpers::assert_ok(::protocol_test_helpers::validate_headers(
            &http_request,
            expected_headers,
        ));
        ::protocol_test_helpers::assert_ok(::protocol_test_helpers::validate_body(
            &http_request.body(),
            "{
            \"contents\": {
                \"blobValue\": \"Zm9v\"
            }
        }",
            ::protocol_test_helpers::MediaType::from("application/json"),
        ));
    }
    /// Serializes a timestamp union value
    /// Test ID: AwsJson11SerializeTimestampUnionValue
    #[test]
    fn test_aws_json11_serialize_timestamp_union_value_request() {
        let input = JsonUnionsInput::builder()
            .contents(MyUnion::TimestampValue(
                ::smithy_types::Instant::from_epoch_seconds(1398796238),
            ))
            .build();
        let http_request = input.build_http_request();

        assert_eq!(http_request.method(), "POST");
        assert_eq!(http_request.uri().path(), "/");

        let expected_headers = &[
            ("Content-Type", "application/x-amz-json-1.1"),
            ("X-Amz-Target", "JsonProtocol.JsonUnions"),
        ];
        ::protocol_test_helpers::assert_ok(::protocol_test_helpers::validate_headers(
            &http_request,
            expected_headers,
        ));
        ::protocol_test_helpers::assert_ok(::protocol_test_helpers::validate_body(
            &http_request.body(),
            "{
            \"contents\": {
                \"timestampValue\": 1398796238
            }
        }",
            ::protocol_test_helpers::MediaType::from("application/json"),
        ));
    }
    /// Serializes an enum union value
    /// Test ID: AwsJson11SerializeEnumUnionValue
    #[test]
    fn test_aws_json11_serialize_enum_union_value_request() {
        let input = JsonUnionsInput::builder()
            .contents(MyUnion::EnumValue(FooEnum::from("Foo")))
            .build();
        let http_request = input.build_http_request();

        assert_eq!(http_request.method(), "POST");
        assert_eq!(http_request.uri().path(), "/");

        let expected_headers = &[
            ("Content-Type", "application/x-amz-json-1.1"),
            ("X-Amz-Target", "JsonProtocol.JsonUnions"),
        ];
        ::protocol_test_helpers::assert_ok(::protocol_test_helpers::validate_headers(
            &http_request,
            expected_headers,
        ));
        ::protocol_test_helpers::assert_ok(::protocol_test_helpers::validate_body(
            &http_request.body(),
            "{
            \"contents\": {
                \"enumValue\": \"Foo\"
            }
        }",
            ::protocol_test_helpers::MediaType::from("application/json"),
        ));
    }
    /// Serializes a list union value
    /// Test ID: AwsJson11SerializeListUnionValue
    #[test]
    fn test_aws_json11_serialize_list_union_value_request() {
        let input = JsonUnionsInput::builder()
            .contents(MyUnion::ListValue(vec![
                "foo".to_string(),
                "bar".to_string(),
            ]))
            .build();
        let http_request = input.build_http_request();

        assert_eq!(http_request.method(), "POST");
        assert_eq!(http_request.uri().path(), "/");

        let expected_headers = &[
            ("Content-Type", "application/x-amz-json-1.1"),
            ("X-Amz-Target", "JsonProtocol.JsonUnions"),
        ];
        ::protocol_test_helpers::assert_ok(::protocol_test_helpers::validate_headers(
            &http_request,
            expected_headers,
        ));
        ::protocol_test_helpers::assert_ok(::protocol_test_helpers::validate_body(
            &http_request.body(),
            "{
            \"contents\": {
                \"listValue\": [\"foo\", \"bar\"]
            }
        }",
            ::protocol_test_helpers::MediaType::from("application/json"),
        ));
    }
    /// Serializes a map union value
    /// Test ID: AwsJson11SerializeMapUnionValue
    #[test]
    fn test_aws_json11_serialize_map_union_value_request() {
        let input = JsonUnionsInput::builder()
            .contents(MyUnion::MapValue({
                let mut ret = ::std::collections::HashMap::new();
                ret.insert("foo".to_string(), "bar".to_string());
                ret.insert("spam".to_string(), "eggs".to_string());
                ret
            }))
            .build();
        let http_request = input.build_http_request();

        assert_eq!(http_request.method(), "POST");
        assert_eq!(http_request.uri().path(), "/");

        let expected_headers = &[
            ("Content-Type", "application/x-amz-json-1.1"),
            ("X-Amz-Target", "JsonProtocol.JsonUnions"),
        ];
        ::protocol_test_helpers::assert_ok(::protocol_test_helpers::validate_headers(
            &http_request,
            expected_headers,
        ));
        ::protocol_test_helpers::assert_ok(::protocol_test_helpers::validate_body(
            &http_request.body(),
            "{
            \"contents\": {
                \"mapValue\": {
                    \"foo\": \"bar\",
                    \"spam\": \"eggs\"
                }
            }
        }",
            ::protocol_test_helpers::MediaType::from("application/json"),
        ));
    }
    /// Serializes a structure union value
    /// Test ID: AwsJson11SerializeStructureUnionValue
    #[test]
    fn test_aws_json11_serialize_structure_union_value_request() {
        let input = JsonUnionsInput::builder()
            .contents(MyUnion::StructureValue(
                GreetingStruct::builder().hi("hello".to_string()).build(),
            ))
            .build();
        let http_request = input.build_http_request();

        assert_eq!(http_request.method(), "POST");
        assert_eq!(http_request.uri().path(), "/");

        let expected_headers = &[
            ("Content-Type", "application/x-amz-json-1.1"),
            ("X-Amz-Target", "JsonProtocol.JsonUnions"),
        ];
        ::protocol_test_helpers::assert_ok(::protocol_test_helpers::validate_headers(
            &http_request,
            expected_headers,
        ));
        ::protocol_test_helpers::assert_ok(::protocol_test_helpers::validate_body(
            &http_request.body(),
            "{
            \"contents\": {
                \"structureValue\": {
                    \"hi\": \"hello\"
                }
            }
        }",
            ::protocol_test_helpers::MediaType::from("application/json"),
        ));
    }
    /// Deserializes a string union value
    /// Test ID: AwsJson11DeserializeStringUnionValue
    #[test]
    fn test_aws_json11_deserialize_string_union_value_response() {
        /* test case disabled for this protocol (not yet supported) */
    }
    /// Deserializes a boolean union value
    /// Test ID: AwsJson11DeserializeBooleanUnionValue
    #[test]
    fn test_aws_json11_deserialize_boolean_union_value_response() {
        /* test case disabled for this protocol (not yet supported) */
    }
    /// Deserializes a number union value
    /// Test ID: AwsJson11DeserializeNumberUnionValue
    #[test]
    fn test_aws_json11_deserialize_number_union_value_response() {
        /* test case disabled for this protocol (not yet supported) */
    }
    /// Deserializes a blob union value
    /// Test ID: AwsJson11DeserializeBlobUnionValue
    #[test]
    fn test_aws_json11_deserialize_blob_union_value_response() {
        /* test case disabled for this protocol (not yet supported) */
    }
    /// Deserializes a timestamp union value
    /// Test ID: AwsJson11DeserializeTimestampUnionValue
    #[test]
    fn test_aws_json11_deserialize_timestamp_union_value_response() {
        /* test case disabled for this protocol (not yet supported) */
    }
    /// Deserializes an enum union value
    /// Test ID: AwsJson11DeserializeEnumUnionValue
    #[test]
    fn test_aws_json11_deserialize_enum_union_value_response() {
        /* test case disabled for this protocol (not yet supported) */
    }
    /// Deserializes a list union value
    /// Test ID: AwsJson11DeserializeListUnionValue
    #[test]
    fn test_aws_json11_deserialize_list_union_value_response() {
        /* test case disabled for this protocol (not yet supported) */
    }
    /// Deserializes a map union value
    /// Test ID: AwsJson11DeserializeMapUnionValue
    #[test]
    fn test_aws_json11_deserialize_map_union_value_response() {
        /* test case disabled for this protocol (not yet supported) */
    }
    /// Deserializes a structure union value
    /// Test ID: AwsJson11DeserializeStructureUnionValue
    #[test]
    fn test_aws_json11_deserialize_structure_union_value_response() {
        /* test case disabled for this protocol (not yet supported) */
    }
}

pub struct KitchenSinkOperation {
    input: KitchenSinkOperationInput,
}
impl KitchenSinkOperation {
    /// Creates a new builder-style object to manufacture [`KitchenSinkOperationInput`](crate::input::KitchenSinkOperationInput)
    pub fn builder() -> crate::input::kitchen_sink_operation_input::Builder {
        crate::input::kitchen_sink_operation_input::Builder::default()
    }
    pub fn build_http_request(&self) -> ::http::request::Request<Vec<u8>> {
        KitchenSinkOperationInput::assemble(
            self.input.request_builder_base(),
            self.input.build_body(),
        )
    }
    pub fn new(input: KitchenSinkOperationInput) -> Self {
        Self { input }
    }
}
#[cfg(test)]
#[allow(unreachable_code, unused_variables)]
mod kitchen_sink_operation_request_test {

    use crate::input::KitchenSinkOperationInput;
    use crate::model::EmptyStruct;
    use crate::model::KitchenSink;
    use crate::model::SimpleStruct;
    use crate::model::StructWithLocationName;
    /// Serializes string shapes
    /// Test ID: serializes_string_shapes
    #[test]
    fn test_serializes_string_shapes_request() {
        let input = KitchenSinkOperationInput::builder()
            .string("abc xyz".to_string())
            .build();
        let http_request = input.build_http_request();

        assert_eq!(http_request.method(), "POST");
        assert_eq!(http_request.uri().path(), "/");

        let expected_headers = &[("Content-Type", "application/x-amz-json-1.1")];
        ::protocol_test_helpers::assert_ok(::protocol_test_helpers::validate_headers(
            &http_request,
            expected_headers,
        ));
        let required_headers = &["Content-Length"];
        ::protocol_test_helpers::assert_ok(::protocol_test_helpers::require_headers(
            &http_request,
            required_headers,
        ));
        ::protocol_test_helpers::assert_ok(::protocol_test_helpers::validate_body(
            &http_request.body(),
            "{\"String\":\"abc xyz\"}",
            ::protocol_test_helpers::MediaType::from("application/json"),
        ));
    }
    /// Serializes string shapes with jsonvalue trait
    /// Test ID: serializes_string_shapes_with_jsonvalue_trait
    #[test]
    fn test_serializes_string_shapes_with_jsonvalue_trait_request() {
        let input =KitchenSinkOperationInput::builder()
        .json_value(
            "{\"string\":\"value\",\"number\":1234.5,\"boolTrue\":true,\"boolFalse\":false,\"array\":[1,2,3,4],\"object\":{\"key\":\"value\"},\"null\":null}".to_string()
        )
        .build()
        ;
        let http_request = input.build_http_request();

        assert_eq!(http_request.method(), "POST");
        assert_eq!(http_request.uri().path(), "/");

        let expected_headers = &[("Content-Type", "application/x-amz-json-1.1")];
        ::protocol_test_helpers::assert_ok(::protocol_test_helpers::validate_headers(
            &http_request,
            expected_headers,
        ));
        let required_headers = &["Content-Length"];
        ::protocol_test_helpers::assert_ok(::protocol_test_helpers::require_headers(
            &http_request,
            required_headers,
        ));
        ::protocol_test_helpers::assert_ok(
        ::protocol_test_helpers::validate_body(&http_request.body(), "{\"JsonValue\":\"{\\\"string\\\":\\\"value\\\",\\\"number\\\":1234.5,\\\"boolTrue\\\":true,\\\"boolFalse\\\":false,\\\"array\\\":[1,2,3,4],\\\"object\\\":{\\\"key\\\":\\\"value\\\"},\\\"null\\\":null}\"}", ::protocol_test_helpers::MediaType::from("application/json"))
        );
    }
    /// Serializes integer shapes
    /// Test ID: serializes_integer_shapes
    #[test]
    fn test_serializes_integer_shapes_request() {
        let input = KitchenSinkOperationInput::builder().integer(1234).build();
        let http_request = input.build_http_request();

        assert_eq!(http_request.method(), "POST");
        assert_eq!(http_request.uri().path(), "/");

        let expected_headers = &[("Content-Type", "application/x-amz-json-1.1")];
        ::protocol_test_helpers::assert_ok(::protocol_test_helpers::validate_headers(
            &http_request,
            expected_headers,
        ));
        let required_headers = &["Content-Length"];
        ::protocol_test_helpers::assert_ok(::protocol_test_helpers::require_headers(
            &http_request,
            required_headers,
        ));
        ::protocol_test_helpers::assert_ok(::protocol_test_helpers::validate_body(
            &http_request.body(),
            "{\"Integer\":1234}",
            ::protocol_test_helpers::MediaType::from("application/json"),
        ));
    }
    /// Serializes long shapes
    /// Test ID: serializes_long_shapes
    #[test]
    fn test_serializes_long_shapes_request() {
        let input = KitchenSinkOperationInput::builder()
            .long(999999999999)
            .build();
        let http_request = input.build_http_request();

        assert_eq!(http_request.method(), "POST");
        assert_eq!(http_request.uri().path(), "/");

        let expected_headers = &[("Content-Type", "application/x-amz-json-1.1")];
        ::protocol_test_helpers::assert_ok(::protocol_test_helpers::validate_headers(
            &http_request,
            expected_headers,
        ));
        let required_headers = &["Content-Length"];
        ::protocol_test_helpers::assert_ok(::protocol_test_helpers::require_headers(
            &http_request,
            required_headers,
        ));
        ::protocol_test_helpers::assert_ok(::protocol_test_helpers::validate_body(
            &http_request.body(),
            "{\"Long\":999999999999}",
            ::protocol_test_helpers::MediaType::from("application/json"),
        ));
    }
    /// Serializes float shapes
    /// Test ID: serializes_float_shapes
    #[test]
    fn test_serializes_float_shapes_request() {
        let input = KitchenSinkOperationInput::builder().float(1234.5).build();
        let http_request = input.build_http_request();

        assert_eq!(http_request.method(), "POST");
        assert_eq!(http_request.uri().path(), "/");

        let expected_headers = &[("Content-Type", "application/x-amz-json-1.1")];
        ::protocol_test_helpers::assert_ok(::protocol_test_helpers::validate_headers(
            &http_request,
            expected_headers,
        ));
        let required_headers = &["Content-Length"];
        ::protocol_test_helpers::assert_ok(::protocol_test_helpers::require_headers(
            &http_request,
            required_headers,
        ));
        ::protocol_test_helpers::assert_ok(::protocol_test_helpers::validate_body(
            &http_request.body(),
            "{\"Float\":1234.5}",
            ::protocol_test_helpers::MediaType::from("application/json"),
        ));
    }
    /// Serializes double shapes
    /// Test ID: serializes_double_shapes
    #[test]
    fn test_serializes_double_shapes_request() {
        let input = KitchenSinkOperationInput::builder().double(1234.5).build();
        let http_request = input.build_http_request();

        assert_eq!(http_request.method(), "POST");
        assert_eq!(http_request.uri().path(), "/");

        let expected_headers = &[("Content-Type", "application/x-amz-json-1.1")];
        ::protocol_test_helpers::assert_ok(::protocol_test_helpers::validate_headers(
            &http_request,
            expected_headers,
        ));
        let required_headers = &["Content-Length"];
        ::protocol_test_helpers::assert_ok(::protocol_test_helpers::require_headers(
            &http_request,
            required_headers,
        ));
        ::protocol_test_helpers::assert_ok(::protocol_test_helpers::validate_body(
            &http_request.body(),
            "{\"Double\":1234.5}",
            ::protocol_test_helpers::MediaType::from("application/json"),
        ));
    }
    /// Serializes blob shapes
    /// Test ID: serializes_blob_shapes
    #[test]
    fn test_serializes_blob_shapes_request() {
        let input = KitchenSinkOperationInput::builder()
            .blob(::smithy_types::Blob::new("binary-value"))
            .build();
        let http_request = input.build_http_request();

        assert_eq!(http_request.method(), "POST");
        assert_eq!(http_request.uri().path(), "/");

        let expected_headers = &[("Content-Type", "application/x-amz-json-1.1")];
        ::protocol_test_helpers::assert_ok(::protocol_test_helpers::validate_headers(
            &http_request,
            expected_headers,
        ));
        let required_headers = &["Content-Length"];
        ::protocol_test_helpers::assert_ok(::protocol_test_helpers::require_headers(
            &http_request,
            required_headers,
        ));
        ::protocol_test_helpers::assert_ok(::protocol_test_helpers::validate_body(
            &http_request.body(),
            "{\"Blob\":\"YmluYXJ5LXZhbHVl\"}",
            ::protocol_test_helpers::MediaType::from("application/json"),
        ));
    }
    /// Serializes boolean shapes (true)
    /// Test ID: serializes_boolean_shapes_true
    #[test]
    fn test_serializes_boolean_shapes_true_request() {
        let input = KitchenSinkOperationInput::builder().boolean(true).build();
        let http_request = input.build_http_request();

        assert_eq!(http_request.method(), "POST");
        assert_eq!(http_request.uri().path(), "/");

        let expected_headers = &[("Content-Type", "application/x-amz-json-1.1")];
        ::protocol_test_helpers::assert_ok(::protocol_test_helpers::validate_headers(
            &http_request,
            expected_headers,
        ));
        let required_headers = &["Content-Length"];
        ::protocol_test_helpers::assert_ok(::protocol_test_helpers::require_headers(
            &http_request,
            required_headers,
        ));
        ::protocol_test_helpers::assert_ok(::protocol_test_helpers::validate_body(
            &http_request.body(),
            "{\"Boolean\":true}",
            ::protocol_test_helpers::MediaType::from("application/json"),
        ));
    }
    /// Serializes boolean shapes (false)
    /// Test ID: serializes_boolean_shapes_false
    #[test]
    fn test_serializes_boolean_shapes_false_request() {
        let input = KitchenSinkOperationInput::builder().boolean(false).build();
        let http_request = input.build_http_request();

        assert_eq!(http_request.method(), "POST");
        assert_eq!(http_request.uri().path(), "/");

        let expected_headers = &[("Content-Type", "application/x-amz-json-1.1")];
        ::protocol_test_helpers::assert_ok(::protocol_test_helpers::validate_headers(
            &http_request,
            expected_headers,
        ));
        let required_headers = &["Content-Length"];
        ::protocol_test_helpers::assert_ok(::protocol_test_helpers::require_headers(
            &http_request,
            required_headers,
        ));
        ::protocol_test_helpers::assert_ok(::protocol_test_helpers::validate_body(
            &http_request.body(),
            "{\"Boolean\":false}",
            ::protocol_test_helpers::MediaType::from("application/json"),
        ));
    }
    /// Serializes timestamp shapes
    /// Test ID: serializes_timestamp_shapes
    #[test]
    fn test_serializes_timestamp_shapes_request() {
        let input = KitchenSinkOperationInput::builder()
            .timestamp(::smithy_types::Instant::from_epoch_seconds(946845296))
            .build();
        let http_request = input.build_http_request();

        assert_eq!(http_request.method(), "POST");
        assert_eq!(http_request.uri().path(), "/");

        let expected_headers = &[("Content-Type", "application/x-amz-json-1.1")];
        ::protocol_test_helpers::assert_ok(::protocol_test_helpers::validate_headers(
            &http_request,
            expected_headers,
        ));
        let required_headers = &["Content-Length"];
        ::protocol_test_helpers::assert_ok(::protocol_test_helpers::require_headers(
            &http_request,
            required_headers,
        ));
        ::protocol_test_helpers::assert_ok(::protocol_test_helpers::validate_body(
            &http_request.body(),
            "{\"Timestamp\":946845296}",
            ::protocol_test_helpers::MediaType::from("application/json"),
        ));
    }
    /// Serializes timestamp shapes with iso8601 timestampFormat
    /// Test ID: serializes_timestamp_shapes_with_iso8601_timestampformat
    #[test]
    fn test_serializes_timestamp_shapes_with_iso8601_timestampformat_request() {
        let input = KitchenSinkOperationInput::builder()
            .iso8601_timestamp(::smithy_types::Instant::from_epoch_seconds(946845296))
            .build();
        let http_request = input.build_http_request();

        assert_eq!(http_request.method(), "POST");
        assert_eq!(http_request.uri().path(), "/");

        let expected_headers = &[("Content-Type", "application/x-amz-json-1.1")];
        ::protocol_test_helpers::assert_ok(::protocol_test_helpers::validate_headers(
            &http_request,
            expected_headers,
        ));
        let required_headers = &["Content-Length"];
        ::protocol_test_helpers::assert_ok(::protocol_test_helpers::require_headers(
            &http_request,
            required_headers,
        ));
        ::protocol_test_helpers::assert_ok(::protocol_test_helpers::validate_body(
            &http_request.body(),
            "{\"Iso8601Timestamp\":\"2000-01-02T20:34:56Z\"}",
            ::protocol_test_helpers::MediaType::from("application/json"),
        ));
    }
    /// Serializes timestamp shapes with httpdate timestampFormat
    /// Test ID: serializes_timestamp_shapes_with_httpdate_timestampformat
    #[test]
    fn test_serializes_timestamp_shapes_with_httpdate_timestampformat_request() {
        let input = KitchenSinkOperationInput::builder()
            .httpdate_timestamp(::smithy_types::Instant::from_epoch_seconds(946845296))
            .build();
        let http_request = input.build_http_request();

        assert_eq!(http_request.method(), "POST");
        assert_eq!(http_request.uri().path(), "/");

        let expected_headers = &[("Content-Type", "application/x-amz-json-1.1")];
        ::protocol_test_helpers::assert_ok(::protocol_test_helpers::validate_headers(
            &http_request,
            expected_headers,
        ));
        let required_headers = &["Content-Length"];
        ::protocol_test_helpers::assert_ok(::protocol_test_helpers::require_headers(
            &http_request,
            required_headers,
        ));
        ::protocol_test_helpers::assert_ok(::protocol_test_helpers::validate_body(
            &http_request.body(),
            "{\"HttpdateTimestamp\":\"Sun, 02 Jan 2000 20:34:56 GMT\"}",
            ::protocol_test_helpers::MediaType::from("application/json"),
        ));
    }
    /// Serializes timestamp shapes with unixTimestamp timestampFormat
    /// Test ID: serializes_timestamp_shapes_with_unixtimestamp_timestampformat
    #[test]
    fn test_serializes_timestamp_shapes_with_unixtimestamp_timestampformat_request() {
        let input = KitchenSinkOperationInput::builder()
            .unix_timestamp(::smithy_types::Instant::from_epoch_seconds(946845296))
            .build();
        let http_request = input.build_http_request();

        assert_eq!(http_request.method(), "POST");
        assert_eq!(http_request.uri().path(), "/");

        let expected_headers = &[("Content-Type", "application/x-amz-json-1.1")];
        ::protocol_test_helpers::assert_ok(::protocol_test_helpers::validate_headers(
            &http_request,
            expected_headers,
        ));
        let required_headers = &["Content-Length"];
        ::protocol_test_helpers::assert_ok(::protocol_test_helpers::require_headers(
            &http_request,
            required_headers,
        ));
        ::protocol_test_helpers::assert_ok(::protocol_test_helpers::validate_body(
            &http_request.body(),
            "{\"UnixTimestamp\":946845296}",
            ::protocol_test_helpers::MediaType::from("application/json"),
        ));
    }
    /// Serializes list shapes
    /// Test ID: serializes_list_shapes
    #[test]
    fn test_serializes_list_shapes_request() {
        let input = KitchenSinkOperationInput::builder()
            .list_of_strings(vec![
                "abc".to_string(),
                "mno".to_string(),
                "xyz".to_string(),
            ])
            .build();
        let http_request = input.build_http_request();

        assert_eq!(http_request.method(), "POST");
        assert_eq!(http_request.uri().path(), "/");

        let expected_headers = &[("Content-Type", "application/x-amz-json-1.1")];
        ::protocol_test_helpers::assert_ok(::protocol_test_helpers::validate_headers(
            &http_request,
            expected_headers,
        ));
        let required_headers = &["Content-Length"];
        ::protocol_test_helpers::assert_ok(::protocol_test_helpers::require_headers(
            &http_request,
            required_headers,
        ));
        ::protocol_test_helpers::assert_ok(::protocol_test_helpers::validate_body(
            &http_request.body(),
            "{\"ListOfStrings\":[\"abc\",\"mno\",\"xyz\"]}",
            ::protocol_test_helpers::MediaType::from("application/json"),
        ));
    }
    /// Serializes empty list shapes
    /// Test ID: serializes_empty_list_shapes
    #[test]
    fn test_serializes_empty_list_shapes_request() {
        let input = KitchenSinkOperationInput::builder()
            .list_of_strings(vec![])
            .build();
        let http_request = input.build_http_request();

        assert_eq!(http_request.method(), "POST");
        assert_eq!(http_request.uri().path(), "/");

        let expected_headers = &[("Content-Type", "application/x-amz-json-1.1")];
        ::protocol_test_helpers::assert_ok(::protocol_test_helpers::validate_headers(
            &http_request,
            expected_headers,
        ));
        let required_headers = &["Content-Length"];
        ::protocol_test_helpers::assert_ok(::protocol_test_helpers::require_headers(
            &http_request,
            required_headers,
        ));
        ::protocol_test_helpers::assert_ok(::protocol_test_helpers::validate_body(
            &http_request.body(),
            "{\"ListOfStrings\":[]}",
            ::protocol_test_helpers::MediaType::from("application/json"),
        ));
    }
    /// Serializes list of map shapes
    /// Test ID: serializes_list_of_map_shapes
    #[test]
    fn test_serializes_list_of_map_shapes_request() {
        let input = KitchenSinkOperationInput::builder()
            .list_of_maps_of_strings(vec![
                {
                    let mut ret = ::std::collections::HashMap::new();
                    ret.insert("foo".to_string(), "bar".to_string());
                    ret
                },
                {
                    let mut ret = ::std::collections::HashMap::new();
                    ret.insert("abc".to_string(), "xyz".to_string());
                    ret
                },
                {
                    let mut ret = ::std::collections::HashMap::new();
                    ret.insert("red".to_string(), "blue".to_string());
                    ret
                },
            ])
            .build();
        let http_request = input.build_http_request();

        assert_eq!(http_request.method(), "POST");
        assert_eq!(http_request.uri().path(), "/");

        let expected_headers = &[("Content-Type", "application/x-amz-json-1.1")];
        ::protocol_test_helpers::assert_ok(::protocol_test_helpers::validate_headers(
            &http_request,
            expected_headers,
        ));
        let required_headers = &["Content-Length"];
        ::protocol_test_helpers::assert_ok(::protocol_test_helpers::require_headers(
            &http_request,
            required_headers,
        ));
        ::protocol_test_helpers::assert_ok(::protocol_test_helpers::validate_body(
            &http_request.body(),
            "{\"ListOfMapsOfStrings\":[{\"foo\":\"bar\"},{\"abc\":\"xyz\"},{\"red\":\"blue\"}]}",
            ::protocol_test_helpers::MediaType::from("application/json"),
        ));
    }
    /// Serializes list of structure shapes
    /// Test ID: serializes_list_of_structure_shapes
    #[test]
    fn test_serializes_list_of_structure_shapes_request() {
        let input = KitchenSinkOperationInput::builder()
            .list_of_structs(vec![
                SimpleStruct::builder().value("abc".to_string()).build(),
                SimpleStruct::builder().value("mno".to_string()).build(),
                SimpleStruct::builder().value("xyz".to_string()).build(),
            ])
            .build();
        let http_request = input.build_http_request();

        assert_eq!(http_request.method(), "POST");
        assert_eq!(http_request.uri().path(), "/");

        let expected_headers = &[("Content-Type", "application/x-amz-json-1.1")];
        ::protocol_test_helpers::assert_ok(::protocol_test_helpers::validate_headers(
            &http_request,
            expected_headers,
        ));
        let required_headers = &["Content-Length"];
        ::protocol_test_helpers::assert_ok(::protocol_test_helpers::require_headers(
            &http_request,
            required_headers,
        ));
        ::protocol_test_helpers::assert_ok(::protocol_test_helpers::validate_body(
            &http_request.body(),
            "{\"ListOfStructs\":[{\"Value\":\"abc\"},{\"Value\":\"mno\"},{\"Value\":\"xyz\"}]}",
            ::protocol_test_helpers::MediaType::from("application/json"),
        ));
    }
    /// Serializes list of recursive structure shapes
    /// Test ID: serializes_list_of_recursive_structure_shapes
    #[test]
    fn test_serializes_list_of_recursive_structure_shapes_request() {
        let input = KitchenSinkOperationInput::builder()
            .recursive_list(vec![KitchenSink::builder()
                .recursive_list(vec![KitchenSink::builder()
                    .recursive_list(vec![KitchenSink::builder().integer(123).build()])
                    .build()])
                .build()])
            .build();
        let http_request = input.build_http_request();

        assert_eq!(http_request.method(), "POST");
        assert_eq!(http_request.uri().path(), "/");

        let expected_headers = &[("Content-Type", "application/x-amz-json-1.1")];
        ::protocol_test_helpers::assert_ok(::protocol_test_helpers::validate_headers(
            &http_request,
            expected_headers,
        ));
        let required_headers = &["Content-Length"];
        ::protocol_test_helpers::assert_ok(::protocol_test_helpers::require_headers(
            &http_request,
            required_headers,
        ));
        ::protocol_test_helpers::assert_ok(::protocol_test_helpers::validate_body(
            &http_request.body(),
            "{\"RecursiveList\":[{\"RecursiveList\":[{\"RecursiveList\":[{\"Integer\":123}]}]}]}",
            ::protocol_test_helpers::MediaType::from("application/json"),
        ));
    }
    /// Serializes map shapes
    /// Test ID: serializes_map_shapes
    #[test]
    fn test_serializes_map_shapes_request() {
        let input = KitchenSinkOperationInput::builder()
            .map_of_strings({
                let mut ret = ::std::collections::HashMap::new();
                ret.insert("abc".to_string(), "xyz".to_string());
                ret.insert("mno".to_string(), "hjk".to_string());
                ret
            })
            .build();
        let http_request = input.build_http_request();

        assert_eq!(http_request.method(), "POST");
        assert_eq!(http_request.uri().path(), "/");

        let expected_headers = &[("Content-Type", "application/x-amz-json-1.1")];
        ::protocol_test_helpers::assert_ok(::protocol_test_helpers::validate_headers(
            &http_request,
            expected_headers,
        ));
        let required_headers = &["Content-Length"];
        ::protocol_test_helpers::assert_ok(::protocol_test_helpers::require_headers(
            &http_request,
            required_headers,
        ));
        ::protocol_test_helpers::assert_ok(::protocol_test_helpers::validate_body(
            &http_request.body(),
            "{\"MapOfStrings\":{\"abc\":\"xyz\",\"mno\":\"hjk\"}}",
            ::protocol_test_helpers::MediaType::from("application/json"),
        ));
    }
    /// Serializes empty map shapes
    /// Test ID: serializes_empty_map_shapes
    #[test]
    fn test_serializes_empty_map_shapes_request() {
        let input = KitchenSinkOperationInput::builder()
            .map_of_strings(::std::collections::HashMap::new())
            .build();
        let http_request = input.build_http_request();

        assert_eq!(http_request.method(), "POST");
        assert_eq!(http_request.uri().path(), "/");

        let expected_headers = &[("Content-Type", "application/x-amz-json-1.1")];
        ::protocol_test_helpers::assert_ok(::protocol_test_helpers::validate_headers(
            &http_request,
            expected_headers,
        ));
        let required_headers = &["Content-Length"];
        ::protocol_test_helpers::assert_ok(::protocol_test_helpers::require_headers(
            &http_request,
            required_headers,
        ));
        ::protocol_test_helpers::assert_ok(::protocol_test_helpers::validate_body(
            &http_request.body(),
            "{\"MapOfStrings\":{}}",
            ::protocol_test_helpers::MediaType::from("application/json"),
        ));
    }
    /// Serializes map of list shapes
    /// Test ID: serializes_map_of_list_shapes
    #[test]
    fn test_serializes_map_of_list_shapes_request() {
        let input = KitchenSinkOperationInput::builder()
            .map_of_lists_of_strings({
                let mut ret = ::std::collections::HashMap::new();
                ret.insert(
                    "abc".to_string(),
                    vec!["abc".to_string(), "xyz".to_string()],
                );
                ret.insert(
                    "mno".to_string(),
                    vec!["xyz".to_string(), "abc".to_string()],
                );
                ret
            })
            .build();
        let http_request = input.build_http_request();

        assert_eq!(http_request.method(), "POST");
        assert_eq!(http_request.uri().path(), "/");

        let expected_headers = &[("Content-Type", "application/x-amz-json-1.1")];
        ::protocol_test_helpers::assert_ok(::protocol_test_helpers::validate_headers(
            &http_request,
            expected_headers,
        ));
        let required_headers = &["Content-Length"];
        ::protocol_test_helpers::assert_ok(::protocol_test_helpers::require_headers(
            &http_request,
            required_headers,
        ));
        ::protocol_test_helpers::assert_ok(::protocol_test_helpers::validate_body(
            &http_request.body(),
            "{\"MapOfListsOfStrings\":{\"abc\":[\"abc\",\"xyz\"],\"mno\":[\"xyz\",\"abc\"]}}",
            ::protocol_test_helpers::MediaType::from("application/json"),
        ));
    }
    /// Serializes map of structure shapes
    /// Test ID: serializes_map_of_structure_shapes
    #[test]
    fn test_serializes_map_of_structure_shapes_request() {
        let input = KitchenSinkOperationInput::builder()
            .map_of_structs({
                let mut ret = ::std::collections::HashMap::new();
                ret.insert(
                    "key1".to_string(),
                    SimpleStruct::builder().value("value-1".to_string()).build(),
                );
                ret.insert(
                    "key2".to_string(),
                    SimpleStruct::builder().value("value-2".to_string()).build(),
                );
                ret
            })
            .build();
        let http_request = input.build_http_request();

        assert_eq!(http_request.method(), "POST");
        assert_eq!(http_request.uri().path(), "/");

        let expected_headers = &[("Content-Type", "application/x-amz-json-1.1")];
        ::protocol_test_helpers::assert_ok(::protocol_test_helpers::validate_headers(
            &http_request,
            expected_headers,
        ));
        let required_headers = &["Content-Length"];
        ::protocol_test_helpers::assert_ok(::protocol_test_helpers::require_headers(
            &http_request,
            required_headers,
        ));
        ::protocol_test_helpers::assert_ok(
        ::protocol_test_helpers::validate_body(&http_request.body(), "{\"MapOfStructs\":{\"key1\":{\"Value\":\"value-1\"},\"key2\":{\"Value\":\"value-2\"}}}", ::protocol_test_helpers::MediaType::from("application/json"))
        );
    }
    /// Serializes map of recursive structure shapes
    /// Test ID: serializes_map_of_recursive_structure_shapes
    #[test]
    fn test_serializes_map_of_recursive_structure_shapes_request() {
        let input = KitchenSinkOperationInput::builder()
            .recursive_map({
                let mut ret = ::std::collections::HashMap::new();
                ret.insert(
                    "key1".to_string(),
                    KitchenSink::builder()
                        .recursive_map({
                            let mut ret = ::std::collections::HashMap::new();
                            ret.insert(
                                "key2".to_string(),
                                KitchenSink::builder()
                                    .recursive_map({
                                        let mut ret = ::std::collections::HashMap::new();
                                        ret.insert(
                                            "key3".to_string(),
                                            KitchenSink::builder().boolean(false).build(),
                                        );
                                        ret
                                    })
                                    .build(),
                            );
                            ret
                        })
                        .build(),
                );
                ret
            })
            .build();
        let http_request = input.build_http_request();

        assert_eq!(http_request.method(), "POST");
        assert_eq!(http_request.uri().path(), "/");

        let expected_headers = &[("Content-Type", "application/x-amz-json-1.1")];
        ::protocol_test_helpers::assert_ok(::protocol_test_helpers::validate_headers(
            &http_request,
            expected_headers,
        ));
        let required_headers = &["Content-Length"];
        ::protocol_test_helpers::assert_ok(::protocol_test_helpers::require_headers(
            &http_request,
            required_headers,
        ));
        ::protocol_test_helpers::assert_ok(
        ::protocol_test_helpers::validate_body(&http_request.body(), "{\"RecursiveMap\":{\"key1\":{\"RecursiveMap\":{\"key2\":{\"RecursiveMap\":{\"key3\":{\"Boolean\":false}}}}}}}", ::protocol_test_helpers::MediaType::from("application/json"))
        );
    }
    /// Serializes structure shapes
    /// Test ID: serializes_structure_shapes
    #[test]
    fn test_serializes_structure_shapes_request() {
        let input = KitchenSinkOperationInput::builder()
            .simple_struct(SimpleStruct::builder().value("abc".to_string()).build())
            .build();
        let http_request = input.build_http_request();

        assert_eq!(http_request.method(), "POST");
        assert_eq!(http_request.uri().path(), "/");

        let expected_headers = &[("Content-Type", "application/x-amz-json-1.1")];
        ::protocol_test_helpers::assert_ok(::protocol_test_helpers::validate_headers(
            &http_request,
            expected_headers,
        ));
        let required_headers = &["Content-Length"];
        ::protocol_test_helpers::assert_ok(::protocol_test_helpers::require_headers(
            &http_request,
            required_headers,
        ));
        ::protocol_test_helpers::assert_ok(::protocol_test_helpers::validate_body(
            &http_request.body(),
            "{\"SimpleStruct\":{\"Value\":\"abc\"}}",
            ::protocol_test_helpers::MediaType::from("application/json"),
        ));
    }
    /// Serializes structure members with locationName traits
    /// Test ID: serializes_structure_members_with_locationname_traits
    #[test]
    fn test_serializes_structure_members_with_locationname_traits_request() {
        let input = KitchenSinkOperationInput::builder()
            .struct_with_location_name(
                StructWithLocationName::builder()
                    .value("some-value".to_string())
                    .build(),
            )
            .build();
        let http_request = input.build_http_request();

        assert_eq!(http_request.method(), "POST");
        assert_eq!(http_request.uri().path(), "/");

        let expected_headers = &[("Content-Type", "application/x-amz-json-1.1")];
        ::protocol_test_helpers::assert_ok(::protocol_test_helpers::validate_headers(
            &http_request,
            expected_headers,
        ));
        let required_headers = &["Content-Length"];
        ::protocol_test_helpers::assert_ok(::protocol_test_helpers::require_headers(
            &http_request,
            required_headers,
        ));
        ::protocol_test_helpers::assert_ok(::protocol_test_helpers::validate_body(
            &http_request.body(),
            "{\"StructWithLocationName\":{\"RenamedMember\":\"some-value\"}}",
            ::protocol_test_helpers::MediaType::from("application/json"),
        ));
    }
    /// Serializes empty structure shapes
    /// Test ID: serializes_empty_structure_shapes
    #[test]
    fn test_serializes_empty_structure_shapes_request() {
        let input = KitchenSinkOperationInput::builder()
            .simple_struct(SimpleStruct::builder().build())
            .build();
        let http_request = input.build_http_request();

        assert_eq!(http_request.method(), "POST");
        assert_eq!(http_request.uri().path(), "/");

        let expected_headers = &[("Content-Type", "application/x-amz-json-1.1")];
        ::protocol_test_helpers::assert_ok(::protocol_test_helpers::validate_headers(
            &http_request,
            expected_headers,
        ));
        let required_headers = &["Content-Length"];
        ::protocol_test_helpers::assert_ok(::protocol_test_helpers::require_headers(
            &http_request,
            required_headers,
        ));
        ::protocol_test_helpers::assert_ok(::protocol_test_helpers::validate_body(
            &http_request.body(),
            "{\"SimpleStruct\":{}}",
            ::protocol_test_helpers::MediaType::from("application/json"),
        ));
    }
    /// Serializes structure which have no members
    /// Test ID: serializes_structure_which_have_no_members
    #[test]
    fn test_serializes_structure_which_have_no_members_request() {
        let input = KitchenSinkOperationInput::builder()
            .empty_struct(EmptyStruct::builder().build())
            .build();
        let http_request = input.build_http_request();

        assert_eq!(http_request.method(), "POST");
        assert_eq!(http_request.uri().path(), "/");

        let expected_headers = &[("Content-Type", "application/x-amz-json-1.1")];
        ::protocol_test_helpers::assert_ok(::protocol_test_helpers::validate_headers(
            &http_request,
            expected_headers,
        ));
        let required_headers = &["Content-Length"];
        ::protocol_test_helpers::assert_ok(::protocol_test_helpers::require_headers(
            &http_request,
            required_headers,
        ));
        ::protocol_test_helpers::assert_ok(::protocol_test_helpers::validate_body(
            &http_request.body(),
            "{\"EmptyStruct\":{}}",
            ::protocol_test_helpers::MediaType::from("application/json"),
        ));
    }
    /// Serializes recursive structure shapes
    /// Test ID: serializes_recursive_structure_shapes
    #[test]
    fn test_serializes_recursive_structure_shapes_request() {
        let input = KitchenSinkOperationInput::builder()
            .string("top-value".to_string())
            .boolean(false)
            .recursive_struct(
                KitchenSink::builder()
                    .string("nested-value".to_string())
                    .boolean(true)
                    .recursive_list(vec![
                        KitchenSink::builder()
                            .string("string-only".to_string())
                            .build(),
                        KitchenSink::builder()
                            .recursive_struct(
                                KitchenSink::builder()
                                    .map_of_strings({
                                        let mut ret = ::std::collections::HashMap::new();
                                        ret.insert("color".to_string(), "red".to_string());
                                        ret.insert("size".to_string(), "large".to_string());
                                        ret
                                    })
                                    .build(),
                            )
                            .build(),
                    ])
                    .build(),
            )
            .build();
        let http_request = input.build_http_request();

        assert_eq!(http_request.method(), "POST");
        assert_eq!(http_request.uri().path(), "/");

        let expected_headers = &[("Content-Type", "application/x-amz-json-1.1")];
        ::protocol_test_helpers::assert_ok(::protocol_test_helpers::validate_headers(
            &http_request,
            expected_headers,
        ));
        let required_headers = &["Content-Length"];
        ::protocol_test_helpers::assert_ok(::protocol_test_helpers::require_headers(
            &http_request,
            required_headers,
        ));
        ::protocol_test_helpers::assert_ok(
        ::protocol_test_helpers::validate_body(&http_request.body(), "{\"String\":\"top-value\",\"Boolean\":false,\"RecursiveStruct\":{\"String\":\"nested-value\",\"Boolean\":true,\"RecursiveList\":[{\"String\":\"string-only\"},{\"RecursiveStruct\":{\"MapOfStrings\":{\"color\":\"red\",\"size\":\"large\"}}}]}}", ::protocol_test_helpers::MediaType::from("application/json"))
        );
    }
    /// Parses operations with empty JSON bodies
    /// Test ID: parses_operations_with_empty_json_bodies
    #[test]
    fn test_parses_operations_with_empty_json_bodies_response() {
        /* test case disabled for this protocol (not yet supported) */
    }
    /// Parses string shapes
    /// Test ID: parses_string_shapes
    #[test]
    fn test_parses_string_shapes_response() {
        /* test case disabled for this protocol (not yet supported) */
    }
    /// Parses integer shapes
    /// Test ID: parses_integer_shapes
    #[test]
    fn test_parses_integer_shapes_response() {
        /* test case disabled for this protocol (not yet supported) */
    }
    /// Parses long shapes
    /// Test ID: parses_long_shapes
    #[test]
    fn test_parses_long_shapes_response() {
        /* test case disabled for this protocol (not yet supported) */
    }
    /// Parses float shapes
    /// Test ID: parses_float_shapes
    #[test]
    fn test_parses_float_shapes_response() {
        /* test case disabled for this protocol (not yet supported) */
    }
    /// Parses double shapes
    /// Test ID: parses_double_shapes
    #[test]
    fn test_parses_double_shapes_response() {
        /* test case disabled for this protocol (not yet supported) */
    }
    /// Parses boolean shapes (true)
    /// Test ID: parses_boolean_shapes_true
    #[test]
    fn test_parses_boolean_shapes_true_response() {
        /* test case disabled for this protocol (not yet supported) */
    }
    /// Parses boolean (false)
    /// Test ID: parses_boolean_false
    #[test]
    fn test_parses_boolean_false_response() {
        /* test case disabled for this protocol (not yet supported) */
    }
    /// Parses blob shapes
    /// Test ID: parses_blob_shapes
    #[test]
    fn test_parses_blob_shapes_response() {
        /* test case disabled for this protocol (not yet supported) */
    }
    /// Parses timestamp shapes
    /// Test ID: parses_timestamp_shapes
    #[test]
    fn test_parses_timestamp_shapes_response() {
        /* test case disabled for this protocol (not yet supported) */
    }
    /// Parses iso8601 timestamps
    /// Test ID: parses_iso8601_timestamps
    #[test]
    fn test_parses_iso8601_timestamps_response() {
        /* test case disabled for this protocol (not yet supported) */
    }
    /// Parses httpdate timestamps
    /// Test ID: parses_httpdate_timestamps
    #[test]
    fn test_parses_httpdate_timestamps_response() {
        /* test case disabled for this protocol (not yet supported) */
    }
    /// Parses list shapes
    /// Test ID: parses_list_shapes
    #[test]
    fn test_parses_list_shapes_response() {
        /* test case disabled for this protocol (not yet supported) */
    }
    /// Parses list of map shapes
    /// Test ID: parses_list_of_map_shapes
    #[test]
    fn test_parses_list_of_map_shapes_response() {
        /* test case disabled for this protocol (not yet supported) */
    }
    /// Parses list of list shapes
    /// Test ID: parses_list_of_list_shapes
    #[test]
    fn test_parses_list_of_list_shapes_response() {
        /* test case disabled for this protocol (not yet supported) */
    }
    /// Parses list of structure shapes
    /// Test ID: parses_list_of_structure_shapes
    #[test]
    fn test_parses_list_of_structure_shapes_response() {
        /* test case disabled for this protocol (not yet supported) */
    }
    /// Parses list of recursive structure shapes
    /// Test ID: parses_list_of_recursive_structure_shapes
    #[test]
    fn test_parses_list_of_recursive_structure_shapes_response() {
        /* test case disabled for this protocol (not yet supported) */
    }
    /// Parses map shapes
    /// Test ID: parses_map_shapes
    #[test]
    fn test_parses_map_shapes_response() {
        /* test case disabled for this protocol (not yet supported) */
    }
    /// Parses map of list shapes
    /// Test ID: parses_map_of_list_shapes
    #[test]
    fn test_parses_map_of_list_shapes_response() {
        /* test case disabled for this protocol (not yet supported) */
    }
    /// Parses map of map shapes
    /// Test ID: parses_map_of_map_shapes
    #[test]
    fn test_parses_map_of_map_shapes_response() {
        /* test case disabled for this protocol (not yet supported) */
    }
    /// Parses map of structure shapes
    /// Test ID: parses_map_of_structure_shapes
    #[test]
    fn test_parses_map_of_structure_shapes_response() {
        /* test case disabled for this protocol (not yet supported) */
    }
    /// Parses map of recursive structure shapes
    /// Test ID: parses_map_of_recursive_structure_shapes
    #[test]
    fn test_parses_map_of_recursive_structure_shapes_response() {
        /* test case disabled for this protocol (not yet supported) */
    }
    /// Parses the request id from the response
    /// Test ID: parses_the_request_id_from_the_response
    #[test]
    fn test_parses_the_request_id_from_the_response_response() {
        /* test case disabled for this protocol (not yet supported) */
    }
}

pub struct NullOperation {
    input: NullOperationInput,
}
impl NullOperation {
    /// Creates a new builder-style object to manufacture [`NullOperationInput`](crate::input::NullOperationInput)
    pub fn builder() -> crate::input::null_operation_input::Builder {
        crate::input::null_operation_input::Builder::default()
    }
    pub fn build_http_request(&self) -> ::http::request::Request<Vec<u8>> {
        NullOperationInput::assemble(self.input.request_builder_base(), self.input.build_body())
    }
    pub fn new(input: NullOperationInput) -> Self {
        Self { input }
    }
}
#[cfg(test)]
#[allow(unreachable_code, unused_variables)]
mod null_operation_request_test {

    use crate::input::NullOperationInput;
    /// Null structure values are dropped
    /// Test ID: AwsJson11StructuresDontSerializeNullValues
    #[test]
    fn test_aws_json11_structures_dont_serialize_null_values_request() {
        let input = NullOperationInput::builder().build();
        let http_request = input.build_http_request();

        assert_eq!(http_request.method(), "POST");
        assert_eq!(http_request.uri().path(), "/");

        let expected_headers = &[("Content-Type", "application/x-amz-json-1.1")];
        ::protocol_test_helpers::assert_ok(::protocol_test_helpers::validate_headers(
            &http_request,
            expected_headers,
        ));
        ::protocol_test_helpers::assert_ok(::protocol_test_helpers::validate_body(
            &http_request.body(),
            "{}",
            ::protocol_test_helpers::MediaType::from("application/json"),
        ));
    }
    /// Serializes null values in maps
    /// Test ID: AwsJson11MapsSerializeNullValues
    #[test]
    fn test_aws_json11_maps_serialize_null_values_request() {
        let input = NullOperationInput::builder()
            .sparse_string_map({
                let mut ret = ::std::collections::HashMap::new();
                ret.insert("foo".to_string(), None);
                ret
            })
            .build();
        let http_request = input.build_http_request();

        assert_eq!(http_request.method(), "POST");
        assert_eq!(http_request.uri().path(), "/");

        let expected_headers = &[("Content-Type", "application/x-amz-json-1.1")];
        ::protocol_test_helpers::assert_ok(::protocol_test_helpers::validate_headers(
            &http_request,
            expected_headers,
        ));
        ::protocol_test_helpers::assert_ok(::protocol_test_helpers::validate_body(
            &http_request.body(),
            "{
            \"sparseStringMap\": {
                \"foo\": null
            }
        }",
            ::protocol_test_helpers::MediaType::from("application/json"),
        ));
    }
    /// Serializes null values in lists
    /// Test ID: AwsJson11ListsSerializeNull
    #[test]
    fn test_aws_json11_lists_serialize_null_request() {
        let input = NullOperationInput::builder()
            .sparse_string_list(vec![None])
            .build();
        let http_request = input.build_http_request();

        assert_eq!(http_request.method(), "POST");
        assert_eq!(http_request.uri().path(), "/");

        let expected_headers = &[("Content-Type", "application/x-amz-json-1.1")];
        ::protocol_test_helpers::assert_ok(::protocol_test_helpers::validate_headers(
            &http_request,
            expected_headers,
        ));
        ::protocol_test_helpers::assert_ok(::protocol_test_helpers::validate_body(
            &http_request.body(),
            "{
            \"sparseStringList\": [
                null
            ]
        }",
            ::protocol_test_helpers::MediaType::from("application/json"),
        ));
    }
    /// Null structure values are dropped
    /// Test ID: AwsJson11StructuresDontDeserializeNullValues
    #[test]
    fn test_aws_json11_structures_dont_deserialize_null_values_response() {
        /* test case disabled for this protocol (not yet supported) */
    }
    /// Deserializes null values in maps
    /// Test ID: AwsJson11MapsDeserializeNullValues
    #[test]
    fn test_aws_json11_maps_deserialize_null_values_response() {
        /* test case disabled for this protocol (not yet supported) */
    }
    /// Deserializes null values in lists
    /// Test ID: AwsJson11ListsDeserializeNull
    #[test]
    fn test_aws_json11_lists_deserialize_null_response() {
        /* test case disabled for this protocol (not yet supported) */
    }
}

pub struct OperationWithOptionalInputOutput {
    input: OperationWithOptionalInputOutputInput,
}
impl OperationWithOptionalInputOutput {
    /// Creates a new builder-style object to manufacture [`OperationWithOptionalInputOutputInput`](crate::input::OperationWithOptionalInputOutputInput)
    pub fn builder() -> crate::input::operation_with_optional_input_output_input::Builder {
        crate::input::operation_with_optional_input_output_input::Builder::default()
    }
    pub fn build_http_request(&self) -> ::http::request::Request<Vec<u8>> {
        OperationWithOptionalInputOutputInput::assemble(
            self.input.request_builder_base(),
            self.input.build_body(),
        )
    }
    pub fn new(input: OperationWithOptionalInputOutputInput) -> Self {
        Self { input }
    }
}
#[cfg(test)]
#[allow(unreachable_code, unused_variables)]
mod operation_with_optional_input_output_request_test {

    use crate::input::OperationWithOptionalInputOutputInput;
    /// Can call operations with no input or output
    /// Test ID: can_call_operation_with_no_input_or_output
    #[test]
    fn test_can_call_operation_with_no_input_or_output_request() {
        let input = OperationWithOptionalInputOutputInput::builder().build();
        let http_request = input.build_http_request();

        assert_eq!(http_request.method(), "POST");
        assert_eq!(http_request.uri().path(), "/");

        let expected_headers = &[
            ("Content-Type", "application/x-amz-json-1.1"),
            (
                "X-Amz-Target",
                "JsonProtocol.OperationWithOptionalInputOutput",
            ),
        ];
        ::protocol_test_helpers::assert_ok(::protocol_test_helpers::validate_headers(
            &http_request,
            expected_headers,
        ));
        ::protocol_test_helpers::assert_ok(::protocol_test_helpers::validate_body(
            &http_request.body(),
            "{}",
            ::protocol_test_helpers::MediaType::from("application/json"),
        ));
    }
    /// Can invoke operations with optional input
    /// Test ID: can_call_operation_with_optional_input
    #[test]
    fn test_can_call_operation_with_optional_input_request() {
        let input = OperationWithOptionalInputOutputInput::builder()
            .value("Hi".to_string())
            .build();
        let http_request = input.build_http_request();

        assert_eq!(http_request.method(), "POST");
        assert_eq!(http_request.uri().path(), "/");

        let expected_headers = &[
            ("Content-Type", "application/x-amz-json-1.1"),
            (
                "X-Amz-Target",
                "JsonProtocol.OperationWithOptionalInputOutput",
            ),
        ];
        ::protocol_test_helpers::assert_ok(::protocol_test_helpers::validate_headers(
            &http_request,
            expected_headers,
        ));
        ::protocol_test_helpers::assert_ok(::protocol_test_helpers::validate_body(
            &http_request.body(),
            "{\"Value\":\"Hi\"}",
            ::protocol_test_helpers::MediaType::from("application/json"),
        ));
    }
}

/// This example serializes an inline document as part of the payload.
pub struct PutAndGetInlineDocuments {
    input: PutAndGetInlineDocumentsInput,
}
impl PutAndGetInlineDocuments {
    /// Creates a new builder-style object to manufacture [`PutAndGetInlineDocumentsInput`](crate::input::PutAndGetInlineDocumentsInput)
    pub fn builder() -> crate::input::put_and_get_inline_documents_input::Builder {
        crate::input::put_and_get_inline_documents_input::Builder::default()
    }
    pub fn build_http_request(&self) -> ::http::request::Request<Vec<u8>> {
        PutAndGetInlineDocumentsInput::assemble(
            self.input.request_builder_base(),
            self.input.build_body(),
        )
    }
    pub fn new(input: PutAndGetInlineDocumentsInput) -> Self {
        Self { input }
    }
}
#[cfg(test)]
#[allow(unreachable_code, unused_variables)]
mod put_and_get_inline_documents_request_test {

    use crate::input::PutAndGetInlineDocumentsInput;
    /// Serializes inline documents in a JSON request.
    /// Test ID: PutAndGetInlineDocumentsInput
    #[test]
    #[should_panic]
    fn test_put_and_get_inline_documents_input_request() {
        let input =PutAndGetInlineDocumentsInput::builder()
        .inline_document(
            todo!() /* (document: `aws.protocoltests.json#Document`) software.amazon.smithy.model.node.ObjectNode@fecf2c7 */
        )
        .build()
        .unwrap()
        ;
        let http_request = input.build_http_request();

        assert_eq!(http_request.method(), "POST");
        assert_eq!(http_request.uri().path(), "/");

        let expected_headers = &[("Content-Type", "application/x-amz-json-1.1")];
        ::protocol_test_helpers::assert_ok(::protocol_test_helpers::validate_headers(
            &http_request,
            expected_headers,
        ));
        let required_headers = &["Content-Length"];
        ::protocol_test_helpers::assert_ok(::protocol_test_helpers::require_headers(
            &http_request,
            required_headers,
        ));
        ::protocol_test_helpers::assert_ok(::protocol_test_helpers::validate_body(
            &http_request.body(),
            "{
            \"inlineDocument\": {\"foo\": \"bar\"}
        }",
            ::protocol_test_helpers::MediaType::from("application/json"),
        ));
    }
    /// Serializes inline documents in a JSON response.
    /// Test ID: PutAndGetInlineDocumentsInput
    #[test]
    #[should_panic]
    fn test_put_and_get_inline_documents_input_response() {
        /* test case disabled for this protocol (not yet supported) */
        todo!()
    }
}
