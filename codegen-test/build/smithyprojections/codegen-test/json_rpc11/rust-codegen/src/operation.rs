// Code generated by software.amazon.smithy.rust.codegen.smithy-rs. DO NOT EDIT.
use crate::model::EmptyStruct;
use crate::model::FooEnum;
use crate::model::KitchenSink;
use crate::model::MyUnion;
use crate::model::SimpleStruct;
use crate::model::StructWithLocationName;
use crate::serializer::JsonEnumsInputBody;
use crate::serializer::JsonUnionsInputBody;
use crate::serializer::KitchenSinkOperationInputBody;
use crate::serializer::NullOperationInputBody;
use crate::serializer::OperationWithOptionalInputOutputInputBody;
use crate::serializer::PutAndGetInlineDocumentsInputBody;
use smithy_types::Blob;
use smithy_types::Document;
use smithy_types::Instant;
use std::collections::BTreeSet;
use std::collections::HashMap;
impl EmptyOperationInput {
    pub fn request_builder_base(&self) -> ::http::request::Builder {
        let builder = ::http::request::Builder::new();
        builder
            .method("POST")
            .header("Content-Type", "application/x-amz-json-1.1")
            .header("X-Amz-Target", "JsonProtocol.EmptyOperation")
    }
    pub fn build_body(&self) -> Vec<u8> {
        vec![]
    }
    pub fn assemble(
        builder: ::http::request::Builder,
        body: Vec<u8>,
    ) -> ::http::request::Request<Vec<u8>> {
        builder
            .header(::http::header::CONTENT_LENGTH, body.len())
            .body(body)
            .expect("http request should be valid")
    }
}
#[cfg(test)]
#[allow(unreachable_code, unused_variables)]
mod empty_operation_request_test {

    use crate::operation::EmptyOperationInput;
    /// Sends requests to /
    /// Test ID: sends_requests_to_slash
    #[test]
    fn test_sends_requests_to_slash_request() {
        let input = EmptyOperationInput::builder().build();
        let http_request =
            EmptyOperationInput::assemble(input.request_builder_base(), input.build_body());

        assert_eq!(http_request.method(), "POST");
        assert_eq!(http_request.uri().path(), "/");

        // No body
        assert!(input.build_body().is_empty());
    }
    /// Includes X-Amz-Target header and Content-Type
    /// Test ID: includes_x_amz_target_and_content_type
    #[test]
    fn test_includes_x_amz_target_and_content_type_request() {
        let input = EmptyOperationInput::builder().build();
        let http_request =
            EmptyOperationInput::assemble(input.request_builder_base(), input.build_body());

        assert_eq!(http_request.method(), "POST");
        assert_eq!(http_request.uri().path(), "/");

        let expected_headers = &[
            ("Content-Type", "application/x-amz-json-1.1"),
            ("X-Amz-Target", "JsonProtocol.EmptyOperation"),
        ];
        ::protocol_test_helpers::assert_ok(::protocol_test_helpers::validate_headers(
            &http_request,
            expected_headers,
        ));
        // No body
        assert!(input.build_body().is_empty());
    }
    /// Handles empty output shapes
    /// Test ID: handles_empty_output_shape
    #[test]
    fn test_handles_empty_output_shape_response() {
        /* test case disabled for this protocol (not yet supported) */
    }
}

impl GreetingWithErrorsInput {
    pub fn request_builder_base(&self) -> ::http::request::Builder {
        let builder = ::http::request::Builder::new();
        builder
            .method("POST")
            .header("Content-Type", "application/x-amz-json-1.1")
            .header("X-Amz-Target", "JsonProtocol.GreetingWithErrors")
    }
    pub fn build_body(&self) -> Vec<u8> {
        vec![]
    }
    pub fn assemble(
        builder: ::http::request::Builder,
        body: Vec<u8>,
    ) -> ::http::request::Request<Vec<u8>> {
        builder
            .header(::http::header::CONTENT_LENGTH, body.len())
            .body(body)
            .expect("http request should be valid")
    }
}
#[cfg(test)]
#[allow(unreachable_code, unused_variables)]
mod greeting_with_errors_request_test {

    /// Parses simple JSON errors
    /// Test ID: AwsJson11InvalidGreetingError
    #[test]
    fn test_aws_json11_invalid_greeting_error_response() {
        /* test case disabled for this protocol (not yet supported) */
    }
    /// Parses a complex error with no message member
    /// Test ID: AwsJson11ComplexError
    #[test]
    fn test_aws_json11_complex_error_response() {
        /* test case disabled for this protocol (not yet supported) */
    }
    /// Test ID: AwsJson11EmptyComplexError
    #[test]
    fn test_aws_json11_empty_complex_error_response() {
        /* test case disabled for this protocol (not yet supported) */
    }
    /// Serializes the X-Amzn-ErrorType header. For an example service, see Amazon EKS.
    /// Test ID: AwsJson11FooErrorUsingXAmznErrorType
    #[test]
    fn test_aws_json11_foo_error_using_x_amzn_error_type_response() {
        /* test case disabled for this protocol (not yet supported) */
    }
    /// Some X-Amzn-Errortype headers contain URLs. Clients need to split the URL on ':' and take only the first half of the string. For example, 'ValidationException:http://internal.amazon.com/coral/com.amazon.coral.validate/'
    /// is to be interpreted as 'ValidationException'.
    ///
    /// For an example service see Amazon Polly.
    /// Test ID: AwsJson11FooErrorUsingXAmznErrorTypeWithUri
    #[test]
    fn test_aws_json11_foo_error_using_x_amzn_error_type_with_uri_response() {
        /* test case disabled for this protocol (not yet supported) */
    }
    /// X-Amzn-Errortype might contain a URL and a namespace. Client should extract only the shape name. This is a pathalogical case that might not actually happen in any deployed AWS service.
    /// Test ID: AwsJson11FooErrorUsingXAmznErrorTypeWithUriAndNamespace
    #[test]
    fn test_aws_json11_foo_error_using_x_amzn_error_type_with_uri_and_namespace_response() {
        /* test case disabled for this protocol (not yet supported) */
    }
    /// This example uses the 'code' property in the output rather than X-Amzn-Errortype. Some services do this though it's preferable to send the X-Amzn-Errortype. Client implementations must first check for the X-Amzn-Errortype and then check for a top-level 'code' property.
    ///
    /// For example service see Amazon S3 Glacier.
    /// Test ID: AwsJson11FooErrorUsingCode
    #[test]
    fn test_aws_json11_foo_error_using_code_response() {
        /* test case disabled for this protocol (not yet supported) */
    }
    /// Some services serialize errors using code, and it might contain a namespace. Clients should just take the last part of the string after '#'.
    /// Test ID: AwsJson11FooErrorUsingCodeAndNamespace
    #[test]
    fn test_aws_json11_foo_error_using_code_and_namespace_response() {
        /* test case disabled for this protocol (not yet supported) */
    }
    /// Some services serialize errors using code, and it might contain a namespace. It also might contain a URI. Clients should just take the last part of the string after '#' and before ":". This is a pathalogical case that might not occur in any deployed AWS service.
    /// Test ID: AwsJson11FooErrorUsingCodeUriAndNamespace
    #[test]
    fn test_aws_json11_foo_error_using_code_uri_and_namespace_response() {
        /* test case disabled for this protocol (not yet supported) */
    }
    /// Some services serialize errors using __type.
    /// Test ID: AwsJson11FooErrorWithDunderType
    #[test]
    fn test_aws_json11_foo_error_with_dunder_type_response() {
        /* test case disabled for this protocol (not yet supported) */
    }
    /// Some services serialize errors using __type, and it might contain a namespace. Clients should just take the last part of the string after '#'.
    /// Test ID: AwsJson11FooErrorWithDunderTypeAndNamespace
    #[test]
    fn test_aws_json11_foo_error_with_dunder_type_and_namespace_response() {
        /* test case disabled for this protocol (not yet supported) */
    }
    /// Some services serialize errors using __type, and it might contain a namespace. It also might contain a URI. Clients should just take the last part of the string after '#' and before ":". This is a pathalogical case that might not occur in any deployed AWS service.
    /// Test ID: AwsJson11FooErrorWithDunderTypeUriAndNamespace
    #[test]
    fn test_aws_json11_foo_error_with_dunder_type_uri_and_namespace_response() {
        /* test case disabled for this protocol (not yet supported) */
    }
}

impl JsonEnumsInput {
    pub fn request_builder_base(&self) -> ::http::request::Builder {
        let builder = ::http::request::Builder::new();
        builder
            .method("POST")
            .header("Content-Type", "application/x-amz-json-1.1")
            .header("X-Amz-Target", "JsonProtocol.JsonEnums")
    }
    fn body(&self) -> JsonEnumsInputBody {
        JsonEnumsInputBody {
            foo_enum1: &self.foo_enum1,
            foo_enum2: &self.foo_enum2,
            foo_enum3: &self.foo_enum3,
            foo_enum_list: &self.foo_enum_list,
            foo_enum_set: &self.foo_enum_set,
            foo_enum_map: &self.foo_enum_map,
        }
    }
    pub fn build_body(&self) -> Vec<u8> {
        ::serde_json::to_vec(&self.body()).expect("serialization should succeed")
    }
    pub fn assemble(
        builder: ::http::request::Builder,
        body: Vec<u8>,
    ) -> ::http::request::Request<Vec<u8>> {
        builder
            .header(::http::header::CONTENT_LENGTH, body.len())
            .body(body)
            .expect("http request should be valid")
    }
}

impl JsonUnionsInput {
    pub fn request_builder_base(&self) -> ::http::request::Builder {
        let builder = ::http::request::Builder::new();
        builder
            .method("POST")
            .header("Content-Type", "application/x-amz-json-1.1")
            .header("X-Amz-Target", "JsonProtocol.JsonUnions")
    }
    fn body(&self) -> JsonUnionsInputBody {
        JsonUnionsInputBody {
            contents: &self.contents,
        }
    }
    pub fn build_body(&self) -> Vec<u8> {
        ::serde_json::to_vec(&self.body()).expect("serialization should succeed")
    }
    pub fn assemble(
        builder: ::http::request::Builder,
        body: Vec<u8>,
    ) -> ::http::request::Request<Vec<u8>> {
        builder
            .header(::http::header::CONTENT_LENGTH, body.len())
            .body(body)
            .expect("http request should be valid")
    }
}
#[cfg(test)]
#[allow(unreachable_code, unused_variables)]
mod json_unions_request_test {

    use crate::model::FooEnum;
    use crate::model::GreetingStruct;
    use crate::model::MyUnion;
    use crate::operation::JsonUnionsInput;
    /// Serializes a string union value
    /// Test ID: AwsJson11SerializeStringUnionValue
    #[test]
    fn test_aws_json11_serialize_string_union_value_request() {
        let input = JsonUnionsInput::builder()
            .contents(MyUnion::StringValue("foo".to_string()))
            .build();
        let http_request =
            JsonUnionsInput::assemble(input.request_builder_base(), input.build_body());

        assert_eq!(http_request.method(), "POST");
        assert_eq!(http_request.uri().path(), "/");

        let expected_headers = &[
            ("Content-Type", "application/x-amz-json-1.1"),
            ("X-Amz-Target", "JsonProtocol.JsonUnions"),
        ];
        ::protocol_test_helpers::assert_ok(::protocol_test_helpers::validate_headers(
            &http_request,
            expected_headers,
        ));
        ::protocol_test_helpers::assert_ok(::protocol_test_helpers::validate_body(
            input.build_body(),
            "{
            \"contents\": {
                \"stringValue\": \"foo\"
            }
        }",
            ::protocol_test_helpers::MediaType::from("application/json"),
        ));
    }
    /// Serializes a boolean union value
    /// Test ID: AwsJson11SerializeBooleanUnionValue
    #[test]
    fn test_aws_json11_serialize_boolean_union_value_request() {
        let input = JsonUnionsInput::builder()
            .contents(MyUnion::BooleanValue(true))
            .build();
        let http_request =
            JsonUnionsInput::assemble(input.request_builder_base(), input.build_body());

        assert_eq!(http_request.method(), "POST");
        assert_eq!(http_request.uri().path(), "/");

        let expected_headers = &[
            ("Content-Type", "application/x-amz-json-1.1"),
            ("X-Amz-Target", "JsonProtocol.JsonUnions"),
        ];
        ::protocol_test_helpers::assert_ok(::protocol_test_helpers::validate_headers(
            &http_request,
            expected_headers,
        ));
        ::protocol_test_helpers::assert_ok(::protocol_test_helpers::validate_body(
            input.build_body(),
            "{
            \"contents\": {
                \"booleanValue\": true
            }
        }",
            ::protocol_test_helpers::MediaType::from("application/json"),
        ));
    }
    /// Serializes a number union value
    /// Test ID: AwsJson11SerializeNumberUnionValue
    #[test]
    fn test_aws_json11_serialize_number_union_value_request() {
        let input = JsonUnionsInput::builder()
            .contents(MyUnion::NumberValue(1))
            .build();
        let http_request =
            JsonUnionsInput::assemble(input.request_builder_base(), input.build_body());

        assert_eq!(http_request.method(), "POST");
        assert_eq!(http_request.uri().path(), "/");

        let expected_headers = &[
            ("Content-Type", "application/x-amz-json-1.1"),
            ("X-Amz-Target", "JsonProtocol.JsonUnions"),
        ];
        ::protocol_test_helpers::assert_ok(::protocol_test_helpers::validate_headers(
            &http_request,
            expected_headers,
        ));
        ::protocol_test_helpers::assert_ok(::protocol_test_helpers::validate_body(
            input.build_body(),
            "{
            \"contents\": {
                \"numberValue\": 1
            }
        }",
            ::protocol_test_helpers::MediaType::from("application/json"),
        ));
    }
    /// Serializes a blob union value
    /// Test ID: AwsJson11SerializeBlobUnionValue
    #[test]
    fn test_aws_json11_serialize_blob_union_value_request() {
        let input = JsonUnionsInput::builder()
            .contents(MyUnion::BlobValue(::smithy_types::Blob::new("foo")))
            .build();
        let http_request =
            JsonUnionsInput::assemble(input.request_builder_base(), input.build_body());

        assert_eq!(http_request.method(), "POST");
        assert_eq!(http_request.uri().path(), "/");

        let expected_headers = &[
            ("Content-Type", "application/x-amz-json-1.1"),
            ("X-Amz-Target", "JsonProtocol.JsonUnions"),
        ];
        ::protocol_test_helpers::assert_ok(::protocol_test_helpers::validate_headers(
            &http_request,
            expected_headers,
        ));
        ::protocol_test_helpers::assert_ok(::protocol_test_helpers::validate_body(
            input.build_body(),
            "{
            \"contents\": {
                \"blobValue\": \"Zm9v\"
            }
        }",
            ::protocol_test_helpers::MediaType::from("application/json"),
        ));
    }
    /// Serializes a timestamp union value
    /// Test ID: AwsJson11SerializeTimestampUnionValue
    #[test]
    fn test_aws_json11_serialize_timestamp_union_value_request() {
        let input = JsonUnionsInput::builder()
            .contents(MyUnion::TimestampValue(
                ::smithy_types::Instant::from_epoch_seconds(1398796238),
            ))
            .build();
        let http_request =
            JsonUnionsInput::assemble(input.request_builder_base(), input.build_body());

        assert_eq!(http_request.method(), "POST");
        assert_eq!(http_request.uri().path(), "/");

        let expected_headers = &[
            ("Content-Type", "application/x-amz-json-1.1"),
            ("X-Amz-Target", "JsonProtocol.JsonUnions"),
        ];
        ::protocol_test_helpers::assert_ok(::protocol_test_helpers::validate_headers(
            &http_request,
            expected_headers,
        ));
        ::protocol_test_helpers::assert_ok(::protocol_test_helpers::validate_body(
            input.build_body(),
            "{
            \"contents\": {
                \"timestampValue\": 1398796238
            }
        }",
            ::protocol_test_helpers::MediaType::from("application/json"),
        ));
    }
    /// Serializes an enum union value
    /// Test ID: AwsJson11SerializeEnumUnionValue
    #[test]
    fn test_aws_json11_serialize_enum_union_value_request() {
        let input = JsonUnionsInput::builder()
            .contents(MyUnion::EnumValue(FooEnum::from("Foo")))
            .build();
        let http_request =
            JsonUnionsInput::assemble(input.request_builder_base(), input.build_body());

        assert_eq!(http_request.method(), "POST");
        assert_eq!(http_request.uri().path(), "/");

        let expected_headers = &[
            ("Content-Type", "application/x-amz-json-1.1"),
            ("X-Amz-Target", "JsonProtocol.JsonUnions"),
        ];
        ::protocol_test_helpers::assert_ok(::protocol_test_helpers::validate_headers(
            &http_request,
            expected_headers,
        ));
        ::protocol_test_helpers::assert_ok(::protocol_test_helpers::validate_body(
            input.build_body(),
            "{
            \"contents\": {
                \"enumValue\": \"Foo\"
            }
        }",
            ::protocol_test_helpers::MediaType::from("application/json"),
        ));
    }
    /// Serializes a list union value
    /// Test ID: AwsJson11SerializeListUnionValue
    #[test]
    fn test_aws_json11_serialize_list_union_value_request() {
        let input = JsonUnionsInput::builder()
            .contents(MyUnion::ListValue(vec![
                "foo".to_string(),
                "bar".to_string(),
            ]))
            .build();
        let http_request =
            JsonUnionsInput::assemble(input.request_builder_base(), input.build_body());

        assert_eq!(http_request.method(), "POST");
        assert_eq!(http_request.uri().path(), "/");

        let expected_headers = &[
            ("Content-Type", "application/x-amz-json-1.1"),
            ("X-Amz-Target", "JsonProtocol.JsonUnions"),
        ];
        ::protocol_test_helpers::assert_ok(::protocol_test_helpers::validate_headers(
            &http_request,
            expected_headers,
        ));
        ::protocol_test_helpers::assert_ok(::protocol_test_helpers::validate_body(
            input.build_body(),
            "{
            \"contents\": {
                \"listValue\": [\"foo\", \"bar\"]
            }
        }",
            ::protocol_test_helpers::MediaType::from("application/json"),
        ));
    }
    /// Serializes a map union value
    /// Test ID: AwsJson11SerializeMapUnionValue
    #[test]
    fn test_aws_json11_serialize_map_union_value_request() {
        let input = JsonUnionsInput::builder()
            .contents(MyUnion::MapValue({
                let mut ret = ::std::collections::HashMap::new();
                ret.insert("foo".to_string(), "bar".to_string());
                ret.insert("spam".to_string(), "eggs".to_string());
                ret
            }))
            .build();
        let http_request =
            JsonUnionsInput::assemble(input.request_builder_base(), input.build_body());

        assert_eq!(http_request.method(), "POST");
        assert_eq!(http_request.uri().path(), "/");

        let expected_headers = &[
            ("Content-Type", "application/x-amz-json-1.1"),
            ("X-Amz-Target", "JsonProtocol.JsonUnions"),
        ];
        ::protocol_test_helpers::assert_ok(::protocol_test_helpers::validate_headers(
            &http_request,
            expected_headers,
        ));
        ::protocol_test_helpers::assert_ok(::protocol_test_helpers::validate_body(
            input.build_body(),
            "{
            \"contents\": {
                \"mapValue\": {
                    \"foo\": \"bar\",
                    \"spam\": \"eggs\"
                }
            }
        }",
            ::protocol_test_helpers::MediaType::from("application/json"),
        ));
    }
    /// Serializes a structure union value
    /// Test ID: AwsJson11SerializeStructureUnionValue
    #[test]
    fn test_aws_json11_serialize_structure_union_value_request() {
        let input = JsonUnionsInput::builder()
            .contents(MyUnion::StructureValue(
                GreetingStruct::builder().hi("hello".to_string()).build(),
            ))
            .build();
        let http_request =
            JsonUnionsInput::assemble(input.request_builder_base(), input.build_body());

        assert_eq!(http_request.method(), "POST");
        assert_eq!(http_request.uri().path(), "/");

        let expected_headers = &[
            ("Content-Type", "application/x-amz-json-1.1"),
            ("X-Amz-Target", "JsonProtocol.JsonUnions"),
        ];
        ::protocol_test_helpers::assert_ok(::protocol_test_helpers::validate_headers(
            &http_request,
            expected_headers,
        ));
        ::protocol_test_helpers::assert_ok(::protocol_test_helpers::validate_body(
            input.build_body(),
            "{
            \"contents\": {
                \"structureValue\": {
                    \"hi\": \"hello\"
                }
            }
        }",
            ::protocol_test_helpers::MediaType::from("application/json"),
        ));
    }
    /// Deserializes a string union value
    /// Test ID: AwsJson11DeserializeStringUnionValue
    #[test]
    fn test_aws_json11_deserialize_string_union_value_response() {
        /* test case disabled for this protocol (not yet supported) */
    }
    /// Deserializes a boolean union value
    /// Test ID: AwsJson11DeserializeBooleanUnionValue
    #[test]
    fn test_aws_json11_deserialize_boolean_union_value_response() {
        /* test case disabled for this protocol (not yet supported) */
    }
    /// Deserializes a number union value
    /// Test ID: AwsJson11DeserializeNumberUnionValue
    #[test]
    fn test_aws_json11_deserialize_number_union_value_response() {
        /* test case disabled for this protocol (not yet supported) */
    }
    /// Deserializes a blob union value
    /// Test ID: AwsJson11DeserializeBlobUnionValue
    #[test]
    fn test_aws_json11_deserialize_blob_union_value_response() {
        /* test case disabled for this protocol (not yet supported) */
    }
    /// Deserializes a timestamp union value
    /// Test ID: AwsJson11DeserializeTimestampUnionValue
    #[test]
    fn test_aws_json11_deserialize_timestamp_union_value_response() {
        /* test case disabled for this protocol (not yet supported) */
    }
    /// Deserializes an enum union value
    /// Test ID: AwsJson11DeserializeEnumUnionValue
    #[test]
    fn test_aws_json11_deserialize_enum_union_value_response() {
        /* test case disabled for this protocol (not yet supported) */
    }
    /// Deserializes a list union value
    /// Test ID: AwsJson11DeserializeListUnionValue
    #[test]
    fn test_aws_json11_deserialize_list_union_value_response() {
        /* test case disabled for this protocol (not yet supported) */
    }
    /// Deserializes a map union value
    /// Test ID: AwsJson11DeserializeMapUnionValue
    #[test]
    fn test_aws_json11_deserialize_map_union_value_response() {
        /* test case disabled for this protocol (not yet supported) */
    }
    /// Deserializes a structure union value
    /// Test ID: AwsJson11DeserializeStructureUnionValue
    #[test]
    fn test_aws_json11_deserialize_structure_union_value_response() {
        /* test case disabled for this protocol (not yet supported) */
    }
}

impl KitchenSinkOperationInput {
    pub fn request_builder_base(&self) -> ::http::request::Builder {
        let builder = ::http::request::Builder::new();
        builder
            .method("POST")
            .header("Content-Type", "application/x-amz-json-1.1")
            .header("X-Amz-Target", "JsonProtocol.KitchenSinkOperation")
    }
    fn body(&self) -> KitchenSinkOperationInputBody {
        KitchenSinkOperationInputBody {
            blob: &self.blob,
            boolean: &self.boolean,
            double: &self.double,
            empty_struct: &self.empty_struct,
            float: &self.float,
            httpdate_timestamp: &self.httpdate_timestamp,
            integer: &self.integer,
            iso8601_timestamp: &self.iso8601_timestamp,
            json_value: &self.json_value,
            list_of_lists: &self.list_of_lists,
            list_of_maps_of_strings: &self.list_of_maps_of_strings,
            list_of_strings: &self.list_of_strings,
            list_of_structs: &self.list_of_structs,
            long: &self.long,
            map_of_lists_of_strings: &self.map_of_lists_of_strings,
            map_of_maps: &self.map_of_maps,
            map_of_strings: &self.map_of_strings,
            map_of_structs: &self.map_of_structs,
            recursive_list: &self.recursive_list,
            recursive_map: &self.recursive_map,
            recursive_struct: &self.recursive_struct,
            simple_struct: &self.simple_struct,
            string: &self.string,
            struct_with_location_name: &self.struct_with_location_name,
            timestamp: &self.timestamp,
            unix_timestamp: &self.unix_timestamp,
        }
    }
    pub fn build_body(&self) -> Vec<u8> {
        ::serde_json::to_vec(&self.body()).expect("serialization should succeed")
    }
    pub fn assemble(
        builder: ::http::request::Builder,
        body: Vec<u8>,
    ) -> ::http::request::Request<Vec<u8>> {
        builder
            .header(::http::header::CONTENT_LENGTH, body.len())
            .body(body)
            .expect("http request should be valid")
    }
}
#[cfg(test)]
#[allow(unreachable_code, unused_variables)]
mod kitchen_sink_operation_request_test {

    use crate::model::EmptyStruct;
    use crate::model::KitchenSink;
    use crate::model::SimpleStruct;
    use crate::model::StructWithLocationName;
    use crate::operation::KitchenSinkOperationInput;
    /// Serializes string shapes
    /// Test ID: serializes_string_shapes
    #[test]
    fn test_serializes_string_shapes_request() {
        let input = KitchenSinkOperationInput::builder()
            .string("abc xyz".to_string())
            .build();
        let http_request =
            KitchenSinkOperationInput::assemble(input.request_builder_base(), input.build_body());

        assert_eq!(http_request.method(), "POST");
        assert_eq!(http_request.uri().path(), "/");

        let expected_headers = &[("Content-Type", "application/x-amz-json-1.1")];
        ::protocol_test_helpers::assert_ok(::protocol_test_helpers::validate_headers(
            &http_request,
            expected_headers,
        ));
        let required_headers = &["Content-Length"];
        ::protocol_test_helpers::assert_ok(::protocol_test_helpers::require_headers(
            &http_request,
            required_headers,
        ));
        ::protocol_test_helpers::assert_ok(::protocol_test_helpers::validate_body(
            input.build_body(),
            "{\"String\":\"abc xyz\"}",
            ::protocol_test_helpers::MediaType::from("application/json"),
        ));
    }
    /// Serializes string shapes with jsonvalue trait
    /// Test ID: serializes_string_shapes_with_jsonvalue_trait
    #[test]
    fn test_serializes_string_shapes_with_jsonvalue_trait_request() {
        let input =KitchenSinkOperationInput::builder()
        .json_value(
            "{\"string\":\"value\",\"number\":1234.5,\"boolTrue\":true,\"boolFalse\":false,\"array\":[1,2,3,4],\"object\":{\"key\":\"value\"},\"null\":null}".to_string()
        )
        .build()
        ;
        let http_request =
            KitchenSinkOperationInput::assemble(input.request_builder_base(), input.build_body());

        assert_eq!(http_request.method(), "POST");
        assert_eq!(http_request.uri().path(), "/");

        let expected_headers = &[("Content-Type", "application/x-amz-json-1.1")];
        ::protocol_test_helpers::assert_ok(::protocol_test_helpers::validate_headers(
            &http_request,
            expected_headers,
        ));
        let required_headers = &["Content-Length"];
        ::protocol_test_helpers::assert_ok(::protocol_test_helpers::require_headers(
            &http_request,
            required_headers,
        ));
        ::protocol_test_helpers::assert_ok(
        ::protocol_test_helpers::validate_body(input.build_body(), "{\"JsonValue\":\"{\\\"string\\\":\\\"value\\\",\\\"number\\\":1234.5,\\\"boolTrue\\\":true,\\\"boolFalse\\\":false,\\\"array\\\":[1,2,3,4],\\\"object\\\":{\\\"key\\\":\\\"value\\\"},\\\"null\\\":null}\"}", ::protocol_test_helpers::MediaType::from("application/json"))
        );
    }
    /// Serializes integer shapes
    /// Test ID: serializes_integer_shapes
    #[test]
    fn test_serializes_integer_shapes_request() {
        let input = KitchenSinkOperationInput::builder().integer(1234).build();
        let http_request =
            KitchenSinkOperationInput::assemble(input.request_builder_base(), input.build_body());

        assert_eq!(http_request.method(), "POST");
        assert_eq!(http_request.uri().path(), "/");

        let expected_headers = &[("Content-Type", "application/x-amz-json-1.1")];
        ::protocol_test_helpers::assert_ok(::protocol_test_helpers::validate_headers(
            &http_request,
            expected_headers,
        ));
        let required_headers = &["Content-Length"];
        ::protocol_test_helpers::assert_ok(::protocol_test_helpers::require_headers(
            &http_request,
            required_headers,
        ));
        ::protocol_test_helpers::assert_ok(::protocol_test_helpers::validate_body(
            input.build_body(),
            "{\"Integer\":1234}",
            ::protocol_test_helpers::MediaType::from("application/json"),
        ));
    }
    /// Serializes long shapes
    /// Test ID: serializes_long_shapes
    #[test]
    fn test_serializes_long_shapes_request() {
        let input = KitchenSinkOperationInput::builder()
            .long(999999999999)
            .build();
        let http_request =
            KitchenSinkOperationInput::assemble(input.request_builder_base(), input.build_body());

        assert_eq!(http_request.method(), "POST");
        assert_eq!(http_request.uri().path(), "/");

        let expected_headers = &[("Content-Type", "application/x-amz-json-1.1")];
        ::protocol_test_helpers::assert_ok(::protocol_test_helpers::validate_headers(
            &http_request,
            expected_headers,
        ));
        let required_headers = &["Content-Length"];
        ::protocol_test_helpers::assert_ok(::protocol_test_helpers::require_headers(
            &http_request,
            required_headers,
        ));
        ::protocol_test_helpers::assert_ok(::protocol_test_helpers::validate_body(
            input.build_body(),
            "{\"Long\":999999999999}",
            ::protocol_test_helpers::MediaType::from("application/json"),
        ));
    }
    /// Serializes float shapes
    /// Test ID: serializes_float_shapes
    #[test]
    fn test_serializes_float_shapes_request() {
        let input = KitchenSinkOperationInput::builder().float(1234.5).build();
        let http_request =
            KitchenSinkOperationInput::assemble(input.request_builder_base(), input.build_body());

        assert_eq!(http_request.method(), "POST");
        assert_eq!(http_request.uri().path(), "/");

        let expected_headers = &[("Content-Type", "application/x-amz-json-1.1")];
        ::protocol_test_helpers::assert_ok(::protocol_test_helpers::validate_headers(
            &http_request,
            expected_headers,
        ));
        let required_headers = &["Content-Length"];
        ::protocol_test_helpers::assert_ok(::protocol_test_helpers::require_headers(
            &http_request,
            required_headers,
        ));
        ::protocol_test_helpers::assert_ok(::protocol_test_helpers::validate_body(
            input.build_body(),
            "{\"Float\":1234.5}",
            ::protocol_test_helpers::MediaType::from("application/json"),
        ));
    }
    /// Serializes double shapes
    /// Test ID: serializes_double_shapes
    #[test]
    fn test_serializes_double_shapes_request() {
        let input = KitchenSinkOperationInput::builder().double(1234.5).build();
        let http_request =
            KitchenSinkOperationInput::assemble(input.request_builder_base(), input.build_body());

        assert_eq!(http_request.method(), "POST");
        assert_eq!(http_request.uri().path(), "/");

        let expected_headers = &[("Content-Type", "application/x-amz-json-1.1")];
        ::protocol_test_helpers::assert_ok(::protocol_test_helpers::validate_headers(
            &http_request,
            expected_headers,
        ));
        let required_headers = &["Content-Length"];
        ::protocol_test_helpers::assert_ok(::protocol_test_helpers::require_headers(
            &http_request,
            required_headers,
        ));
        ::protocol_test_helpers::assert_ok(::protocol_test_helpers::validate_body(
            input.build_body(),
            "{\"Double\":1234.5}",
            ::protocol_test_helpers::MediaType::from("application/json"),
        ));
    }
    /// Serializes blob shapes
    /// Test ID: serializes_blob_shapes
    #[test]
    fn test_serializes_blob_shapes_request() {
        let input = KitchenSinkOperationInput::builder()
            .blob(::smithy_types::Blob::new("binary-value"))
            .build();
        let http_request =
            KitchenSinkOperationInput::assemble(input.request_builder_base(), input.build_body());

        assert_eq!(http_request.method(), "POST");
        assert_eq!(http_request.uri().path(), "/");

        let expected_headers = &[("Content-Type", "application/x-amz-json-1.1")];
        ::protocol_test_helpers::assert_ok(::protocol_test_helpers::validate_headers(
            &http_request,
            expected_headers,
        ));
        let required_headers = &["Content-Length"];
        ::protocol_test_helpers::assert_ok(::protocol_test_helpers::require_headers(
            &http_request,
            required_headers,
        ));
        ::protocol_test_helpers::assert_ok(::protocol_test_helpers::validate_body(
            input.build_body(),
            "{\"Blob\":\"YmluYXJ5LXZhbHVl\"}",
            ::protocol_test_helpers::MediaType::from("application/json"),
        ));
    }
    /// Serializes boolean shapes (true)
    /// Test ID: serializes_boolean_shapes_true
    #[test]
    fn test_serializes_boolean_shapes_true_request() {
        let input = KitchenSinkOperationInput::builder().boolean(true).build();
        let http_request =
            KitchenSinkOperationInput::assemble(input.request_builder_base(), input.build_body());

        assert_eq!(http_request.method(), "POST");
        assert_eq!(http_request.uri().path(), "/");

        let expected_headers = &[("Content-Type", "application/x-amz-json-1.1")];
        ::protocol_test_helpers::assert_ok(::protocol_test_helpers::validate_headers(
            &http_request,
            expected_headers,
        ));
        let required_headers = &["Content-Length"];
        ::protocol_test_helpers::assert_ok(::protocol_test_helpers::require_headers(
            &http_request,
            required_headers,
        ));
        ::protocol_test_helpers::assert_ok(::protocol_test_helpers::validate_body(
            input.build_body(),
            "{\"Boolean\":true}",
            ::protocol_test_helpers::MediaType::from("application/json"),
        ));
    }
    /// Serializes boolean shapes (false)
    /// Test ID: serializes_boolean_shapes_false
    #[test]
    fn test_serializes_boolean_shapes_false_request() {
        let input = KitchenSinkOperationInput::builder().boolean(false).build();
        let http_request =
            KitchenSinkOperationInput::assemble(input.request_builder_base(), input.build_body());

        assert_eq!(http_request.method(), "POST");
        assert_eq!(http_request.uri().path(), "/");

        let expected_headers = &[("Content-Type", "application/x-amz-json-1.1")];
        ::protocol_test_helpers::assert_ok(::protocol_test_helpers::validate_headers(
            &http_request,
            expected_headers,
        ));
        let required_headers = &["Content-Length"];
        ::protocol_test_helpers::assert_ok(::protocol_test_helpers::require_headers(
            &http_request,
            required_headers,
        ));
        ::protocol_test_helpers::assert_ok(::protocol_test_helpers::validate_body(
            input.build_body(),
            "{\"Boolean\":false}",
            ::protocol_test_helpers::MediaType::from("application/json"),
        ));
    }
    /// Serializes timestamp shapes
    /// Test ID: serializes_timestamp_shapes
    #[test]
    fn test_serializes_timestamp_shapes_request() {
        let input = KitchenSinkOperationInput::builder()
            .timestamp(::smithy_types::Instant::from_epoch_seconds(946845296))
            .build();
        let http_request =
            KitchenSinkOperationInput::assemble(input.request_builder_base(), input.build_body());

        assert_eq!(http_request.method(), "POST");
        assert_eq!(http_request.uri().path(), "/");

        let expected_headers = &[("Content-Type", "application/x-amz-json-1.1")];
        ::protocol_test_helpers::assert_ok(::protocol_test_helpers::validate_headers(
            &http_request,
            expected_headers,
        ));
        let required_headers = &["Content-Length"];
        ::protocol_test_helpers::assert_ok(::protocol_test_helpers::require_headers(
            &http_request,
            required_headers,
        ));
        ::protocol_test_helpers::assert_ok(::protocol_test_helpers::validate_body(
            input.build_body(),
            "{\"Timestamp\":946845296}",
            ::protocol_test_helpers::MediaType::from("application/json"),
        ));
    }
    /// Serializes timestamp shapes with iso8601 timestampFormat
    /// Test ID: serializes_timestamp_shapes_with_iso8601_timestampformat
    #[test]
    fn test_serializes_timestamp_shapes_with_iso8601_timestampformat_request() {
        let input = KitchenSinkOperationInput::builder()
            .iso8601_timestamp(::smithy_types::Instant::from_epoch_seconds(946845296))
            .build();
        let http_request =
            KitchenSinkOperationInput::assemble(input.request_builder_base(), input.build_body());

        assert_eq!(http_request.method(), "POST");
        assert_eq!(http_request.uri().path(), "/");

        let expected_headers = &[("Content-Type", "application/x-amz-json-1.1")];
        ::protocol_test_helpers::assert_ok(::protocol_test_helpers::validate_headers(
            &http_request,
            expected_headers,
        ));
        let required_headers = &["Content-Length"];
        ::protocol_test_helpers::assert_ok(::protocol_test_helpers::require_headers(
            &http_request,
            required_headers,
        ));
        ::protocol_test_helpers::assert_ok(::protocol_test_helpers::validate_body(
            input.build_body(),
            "{\"Iso8601Timestamp\":\"2000-01-02T20:34:56Z\"}",
            ::protocol_test_helpers::MediaType::from("application/json"),
        ));
    }
    /// Serializes timestamp shapes with httpdate timestampFormat
    /// Test ID: serializes_timestamp_shapes_with_httpdate_timestampformat
    #[test]
    fn test_serializes_timestamp_shapes_with_httpdate_timestampformat_request() {
        let input = KitchenSinkOperationInput::builder()
            .httpdate_timestamp(::smithy_types::Instant::from_epoch_seconds(946845296))
            .build();
        let http_request =
            KitchenSinkOperationInput::assemble(input.request_builder_base(), input.build_body());

        assert_eq!(http_request.method(), "POST");
        assert_eq!(http_request.uri().path(), "/");

        let expected_headers = &[("Content-Type", "application/x-amz-json-1.1")];
        ::protocol_test_helpers::assert_ok(::protocol_test_helpers::validate_headers(
            &http_request,
            expected_headers,
        ));
        let required_headers = &["Content-Length"];
        ::protocol_test_helpers::assert_ok(::protocol_test_helpers::require_headers(
            &http_request,
            required_headers,
        ));
        ::protocol_test_helpers::assert_ok(::protocol_test_helpers::validate_body(
            input.build_body(),
            "{\"HttpdateTimestamp\":\"Sun, 02 Jan 2000 20:34:56 GMT\"}",
            ::protocol_test_helpers::MediaType::from("application/json"),
        ));
    }
    /// Serializes timestamp shapes with unixTimestamp timestampFormat
    /// Test ID: serializes_timestamp_shapes_with_unixtimestamp_timestampformat
    #[test]
    fn test_serializes_timestamp_shapes_with_unixtimestamp_timestampformat_request() {
        let input = KitchenSinkOperationInput::builder()
            .unix_timestamp(::smithy_types::Instant::from_epoch_seconds(946845296))
            .build();
        let http_request =
            KitchenSinkOperationInput::assemble(input.request_builder_base(), input.build_body());

        assert_eq!(http_request.method(), "POST");
        assert_eq!(http_request.uri().path(), "/");

        let expected_headers = &[("Content-Type", "application/x-amz-json-1.1")];
        ::protocol_test_helpers::assert_ok(::protocol_test_helpers::validate_headers(
            &http_request,
            expected_headers,
        ));
        let required_headers = &["Content-Length"];
        ::protocol_test_helpers::assert_ok(::protocol_test_helpers::require_headers(
            &http_request,
            required_headers,
        ));
        ::protocol_test_helpers::assert_ok(::protocol_test_helpers::validate_body(
            input.build_body(),
            "{\"UnixTimestamp\":946845296}",
            ::protocol_test_helpers::MediaType::from("application/json"),
        ));
    }
    /// Serializes list shapes
    /// Test ID: serializes_list_shapes
    #[test]
    fn test_serializes_list_shapes_request() {
        let input = KitchenSinkOperationInput::builder()
            .list_of_strings(vec![
                "abc".to_string(),
                "mno".to_string(),
                "xyz".to_string(),
            ])
            .build();
        let http_request =
            KitchenSinkOperationInput::assemble(input.request_builder_base(), input.build_body());

        assert_eq!(http_request.method(), "POST");
        assert_eq!(http_request.uri().path(), "/");

        let expected_headers = &[("Content-Type", "application/x-amz-json-1.1")];
        ::protocol_test_helpers::assert_ok(::protocol_test_helpers::validate_headers(
            &http_request,
            expected_headers,
        ));
        let required_headers = &["Content-Length"];
        ::protocol_test_helpers::assert_ok(::protocol_test_helpers::require_headers(
            &http_request,
            required_headers,
        ));
        ::protocol_test_helpers::assert_ok(::protocol_test_helpers::validate_body(
            input.build_body(),
            "{\"ListOfStrings\":[\"abc\",\"mno\",\"xyz\"]}",
            ::protocol_test_helpers::MediaType::from("application/json"),
        ));
    }
    /// Serializes empty list shapes
    /// Test ID: serializes_empty_list_shapes
    #[test]
    fn test_serializes_empty_list_shapes_request() {
        let input = KitchenSinkOperationInput::builder()
            .list_of_strings(vec![])
            .build();
        let http_request =
            KitchenSinkOperationInput::assemble(input.request_builder_base(), input.build_body());

        assert_eq!(http_request.method(), "POST");
        assert_eq!(http_request.uri().path(), "/");

        let expected_headers = &[("Content-Type", "application/x-amz-json-1.1")];
        ::protocol_test_helpers::assert_ok(::protocol_test_helpers::validate_headers(
            &http_request,
            expected_headers,
        ));
        let required_headers = &["Content-Length"];
        ::protocol_test_helpers::assert_ok(::protocol_test_helpers::require_headers(
            &http_request,
            required_headers,
        ));
        ::protocol_test_helpers::assert_ok(::protocol_test_helpers::validate_body(
            input.build_body(),
            "{\"ListOfStrings\":[]}",
            ::protocol_test_helpers::MediaType::from("application/json"),
        ));
    }
    /// Serializes list of map shapes
    /// Test ID: serializes_list_of_map_shapes
    #[test]
    fn test_serializes_list_of_map_shapes_request() {
        let input = KitchenSinkOperationInput::builder()
            .list_of_maps_of_strings(vec![
                {
                    let mut ret = ::std::collections::HashMap::new();
                    ret.insert("foo".to_string(), "bar".to_string());
                    ret
                },
                {
                    let mut ret = ::std::collections::HashMap::new();
                    ret.insert("abc".to_string(), "xyz".to_string());
                    ret
                },
                {
                    let mut ret = ::std::collections::HashMap::new();
                    ret.insert("red".to_string(), "blue".to_string());
                    ret
                },
            ])
            .build();
        let http_request =
            KitchenSinkOperationInput::assemble(input.request_builder_base(), input.build_body());

        assert_eq!(http_request.method(), "POST");
        assert_eq!(http_request.uri().path(), "/");

        let expected_headers = &[("Content-Type", "application/x-amz-json-1.1")];
        ::protocol_test_helpers::assert_ok(::protocol_test_helpers::validate_headers(
            &http_request,
            expected_headers,
        ));
        let required_headers = &["Content-Length"];
        ::protocol_test_helpers::assert_ok(::protocol_test_helpers::require_headers(
            &http_request,
            required_headers,
        ));
        ::protocol_test_helpers::assert_ok(::protocol_test_helpers::validate_body(
            input.build_body(),
            "{\"ListOfMapsOfStrings\":[{\"foo\":\"bar\"},{\"abc\":\"xyz\"},{\"red\":\"blue\"}]}",
            ::protocol_test_helpers::MediaType::from("application/json"),
        ));
    }
    /// Serializes list of structure shapes
    /// Test ID: serializes_list_of_structure_shapes
    #[test]
    fn test_serializes_list_of_structure_shapes_request() {
        let input = KitchenSinkOperationInput::builder()
            .list_of_structs(vec![
                SimpleStruct::builder().value("abc".to_string()).build(),
                SimpleStruct::builder().value("mno".to_string()).build(),
                SimpleStruct::builder().value("xyz".to_string()).build(),
            ])
            .build();
        let http_request =
            KitchenSinkOperationInput::assemble(input.request_builder_base(), input.build_body());

        assert_eq!(http_request.method(), "POST");
        assert_eq!(http_request.uri().path(), "/");

        let expected_headers = &[("Content-Type", "application/x-amz-json-1.1")];
        ::protocol_test_helpers::assert_ok(::protocol_test_helpers::validate_headers(
            &http_request,
            expected_headers,
        ));
        let required_headers = &["Content-Length"];
        ::protocol_test_helpers::assert_ok(::protocol_test_helpers::require_headers(
            &http_request,
            required_headers,
        ));
        ::protocol_test_helpers::assert_ok(::protocol_test_helpers::validate_body(
            input.build_body(),
            "{\"ListOfStructs\":[{\"Value\":\"abc\"},{\"Value\":\"mno\"},{\"Value\":\"xyz\"}]}",
            ::protocol_test_helpers::MediaType::from("application/json"),
        ));
    }
    /// Serializes list of recursive structure shapes
    /// Test ID: serializes_list_of_recursive_structure_shapes
    #[test]
    fn test_serializes_list_of_recursive_structure_shapes_request() {
        let input = KitchenSinkOperationInput::builder()
            .recursive_list(vec![KitchenSink::builder()
                .recursive_list(vec![KitchenSink::builder()
                    .recursive_list(vec![KitchenSink::builder().integer(123).build()])
                    .build()])
                .build()])
            .build();
        let http_request =
            KitchenSinkOperationInput::assemble(input.request_builder_base(), input.build_body());

        assert_eq!(http_request.method(), "POST");
        assert_eq!(http_request.uri().path(), "/");

        let expected_headers = &[("Content-Type", "application/x-amz-json-1.1")];
        ::protocol_test_helpers::assert_ok(::protocol_test_helpers::validate_headers(
            &http_request,
            expected_headers,
        ));
        let required_headers = &["Content-Length"];
        ::protocol_test_helpers::assert_ok(::protocol_test_helpers::require_headers(
            &http_request,
            required_headers,
        ));
        ::protocol_test_helpers::assert_ok(::protocol_test_helpers::validate_body(
            input.build_body(),
            "{\"RecursiveList\":[{\"RecursiveList\":[{\"RecursiveList\":[{\"Integer\":123}]}]}]}",
            ::protocol_test_helpers::MediaType::from("application/json"),
        ));
    }
    /// Serializes map shapes
    /// Test ID: serializes_map_shapes
    #[test]
    fn test_serializes_map_shapes_request() {
        let input = KitchenSinkOperationInput::builder()
            .map_of_strings({
                let mut ret = ::std::collections::HashMap::new();
                ret.insert("abc".to_string(), "xyz".to_string());
                ret.insert("mno".to_string(), "hjk".to_string());
                ret
            })
            .build();
        let http_request =
            KitchenSinkOperationInput::assemble(input.request_builder_base(), input.build_body());

        assert_eq!(http_request.method(), "POST");
        assert_eq!(http_request.uri().path(), "/");

        let expected_headers = &[("Content-Type", "application/x-amz-json-1.1")];
        ::protocol_test_helpers::assert_ok(::protocol_test_helpers::validate_headers(
            &http_request,
            expected_headers,
        ));
        let required_headers = &["Content-Length"];
        ::protocol_test_helpers::assert_ok(::protocol_test_helpers::require_headers(
            &http_request,
            required_headers,
        ));
        ::protocol_test_helpers::assert_ok(::protocol_test_helpers::validate_body(
            input.build_body(),
            "{\"MapOfStrings\":{\"abc\":\"xyz\",\"mno\":\"hjk\"}}",
            ::protocol_test_helpers::MediaType::from("application/json"),
        ));
    }
    /// Serializes empty map shapes
    /// Test ID: serializes_empty_map_shapes
    #[test]
    fn test_serializes_empty_map_shapes_request() {
        let input = KitchenSinkOperationInput::builder()
            .map_of_strings(::std::collections::HashMap::new())
            .build();
        let http_request =
            KitchenSinkOperationInput::assemble(input.request_builder_base(), input.build_body());

        assert_eq!(http_request.method(), "POST");
        assert_eq!(http_request.uri().path(), "/");

        let expected_headers = &[("Content-Type", "application/x-amz-json-1.1")];
        ::protocol_test_helpers::assert_ok(::protocol_test_helpers::validate_headers(
            &http_request,
            expected_headers,
        ));
        let required_headers = &["Content-Length"];
        ::protocol_test_helpers::assert_ok(::protocol_test_helpers::require_headers(
            &http_request,
            required_headers,
        ));
        ::protocol_test_helpers::assert_ok(::protocol_test_helpers::validate_body(
            input.build_body(),
            "{\"MapOfStrings\":{}}",
            ::protocol_test_helpers::MediaType::from("application/json"),
        ));
    }
    /// Serializes map of list shapes
    /// Test ID: serializes_map_of_list_shapes
    #[test]
    fn test_serializes_map_of_list_shapes_request() {
        let input = KitchenSinkOperationInput::builder()
            .map_of_lists_of_strings({
                let mut ret = ::std::collections::HashMap::new();
                ret.insert(
                    "abc".to_string(),
                    vec!["abc".to_string(), "xyz".to_string()],
                );
                ret.insert(
                    "mno".to_string(),
                    vec!["xyz".to_string(), "abc".to_string()],
                );
                ret
            })
            .build();
        let http_request =
            KitchenSinkOperationInput::assemble(input.request_builder_base(), input.build_body());

        assert_eq!(http_request.method(), "POST");
        assert_eq!(http_request.uri().path(), "/");

        let expected_headers = &[("Content-Type", "application/x-amz-json-1.1")];
        ::protocol_test_helpers::assert_ok(::protocol_test_helpers::validate_headers(
            &http_request,
            expected_headers,
        ));
        let required_headers = &["Content-Length"];
        ::protocol_test_helpers::assert_ok(::protocol_test_helpers::require_headers(
            &http_request,
            required_headers,
        ));
        ::protocol_test_helpers::assert_ok(::protocol_test_helpers::validate_body(
            input.build_body(),
            "{\"MapOfListsOfStrings\":{\"abc\":[\"abc\",\"xyz\"],\"mno\":[\"xyz\",\"abc\"]}}",
            ::protocol_test_helpers::MediaType::from("application/json"),
        ));
    }
    /// Serializes map of structure shapes
    /// Test ID: serializes_map_of_structure_shapes
    #[test]
    fn test_serializes_map_of_structure_shapes_request() {
        let input = KitchenSinkOperationInput::builder()
            .map_of_structs({
                let mut ret = ::std::collections::HashMap::new();
                ret.insert(
                    "key1".to_string(),
                    SimpleStruct::builder().value("value-1".to_string()).build(),
                );
                ret.insert(
                    "key2".to_string(),
                    SimpleStruct::builder().value("value-2".to_string()).build(),
                );
                ret
            })
            .build();
        let http_request =
            KitchenSinkOperationInput::assemble(input.request_builder_base(), input.build_body());

        assert_eq!(http_request.method(), "POST");
        assert_eq!(http_request.uri().path(), "/");

        let expected_headers = &[("Content-Type", "application/x-amz-json-1.1")];
        ::protocol_test_helpers::assert_ok(::protocol_test_helpers::validate_headers(
            &http_request,
            expected_headers,
        ));
        let required_headers = &["Content-Length"];
        ::protocol_test_helpers::assert_ok(::protocol_test_helpers::require_headers(
            &http_request,
            required_headers,
        ));
        ::protocol_test_helpers::assert_ok(
        ::protocol_test_helpers::validate_body(input.build_body(), "{\"MapOfStructs\":{\"key1\":{\"Value\":\"value-1\"},\"key2\":{\"Value\":\"value-2\"}}}", ::protocol_test_helpers::MediaType::from("application/json"))
        );
    }
    /// Serializes map of recursive structure shapes
    /// Test ID: serializes_map_of_recursive_structure_shapes
    #[test]
    fn test_serializes_map_of_recursive_structure_shapes_request() {
        let input = KitchenSinkOperationInput::builder()
            .recursive_map({
                let mut ret = ::std::collections::HashMap::new();
                ret.insert(
                    "key1".to_string(),
                    KitchenSink::builder()
                        .recursive_map({
                            let mut ret = ::std::collections::HashMap::new();
                            ret.insert(
                                "key2".to_string(),
                                KitchenSink::builder()
                                    .recursive_map({
                                        let mut ret = ::std::collections::HashMap::new();
                                        ret.insert(
                                            "key3".to_string(),
                                            KitchenSink::builder().boolean(false).build(),
                                        );
                                        ret
                                    })
                                    .build(),
                            );
                            ret
                        })
                        .build(),
                );
                ret
            })
            .build();
        let http_request =
            KitchenSinkOperationInput::assemble(input.request_builder_base(), input.build_body());

        assert_eq!(http_request.method(), "POST");
        assert_eq!(http_request.uri().path(), "/");

        let expected_headers = &[("Content-Type", "application/x-amz-json-1.1")];
        ::protocol_test_helpers::assert_ok(::protocol_test_helpers::validate_headers(
            &http_request,
            expected_headers,
        ));
        let required_headers = &["Content-Length"];
        ::protocol_test_helpers::assert_ok(::protocol_test_helpers::require_headers(
            &http_request,
            required_headers,
        ));
        ::protocol_test_helpers::assert_ok(
        ::protocol_test_helpers::validate_body(input.build_body(), "{\"RecursiveMap\":{\"key1\":{\"RecursiveMap\":{\"key2\":{\"RecursiveMap\":{\"key3\":{\"Boolean\":false}}}}}}}", ::protocol_test_helpers::MediaType::from("application/json"))
        );
    }
    /// Serializes structure shapes
    /// Test ID: serializes_structure_shapes
    #[test]
    fn test_serializes_structure_shapes_request() {
        let input = KitchenSinkOperationInput::builder()
            .simple_struct(SimpleStruct::builder().value("abc".to_string()).build())
            .build();
        let http_request =
            KitchenSinkOperationInput::assemble(input.request_builder_base(), input.build_body());

        assert_eq!(http_request.method(), "POST");
        assert_eq!(http_request.uri().path(), "/");

        let expected_headers = &[("Content-Type", "application/x-amz-json-1.1")];
        ::protocol_test_helpers::assert_ok(::protocol_test_helpers::validate_headers(
            &http_request,
            expected_headers,
        ));
        let required_headers = &["Content-Length"];
        ::protocol_test_helpers::assert_ok(::protocol_test_helpers::require_headers(
            &http_request,
            required_headers,
        ));
        ::protocol_test_helpers::assert_ok(::protocol_test_helpers::validate_body(
            input.build_body(),
            "{\"SimpleStruct\":{\"Value\":\"abc\"}}",
            ::protocol_test_helpers::MediaType::from("application/json"),
        ));
    }
    /// Serializes structure members with locationName traits
    /// Test ID: serializes_structure_members_with_locationname_traits
    #[test]
    fn test_serializes_structure_members_with_locationname_traits_request() {
        let input = KitchenSinkOperationInput::builder()
            .struct_with_location_name(
                StructWithLocationName::builder()
                    .value("some-value".to_string())
                    .build(),
            )
            .build();
        let http_request =
            KitchenSinkOperationInput::assemble(input.request_builder_base(), input.build_body());

        assert_eq!(http_request.method(), "POST");
        assert_eq!(http_request.uri().path(), "/");

        let expected_headers = &[("Content-Type", "application/x-amz-json-1.1")];
        ::protocol_test_helpers::assert_ok(::protocol_test_helpers::validate_headers(
            &http_request,
            expected_headers,
        ));
        let required_headers = &["Content-Length"];
        ::protocol_test_helpers::assert_ok(::protocol_test_helpers::require_headers(
            &http_request,
            required_headers,
        ));
        ::protocol_test_helpers::assert_ok(::protocol_test_helpers::validate_body(
            input.build_body(),
            "{\"StructWithLocationName\":{\"RenamedMember\":\"some-value\"}}",
            ::protocol_test_helpers::MediaType::from("application/json"),
        ));
    }
    /// Serializes empty structure shapes
    /// Test ID: serializes_empty_structure_shapes
    #[test]
    fn test_serializes_empty_structure_shapes_request() {
        let input = KitchenSinkOperationInput::builder()
            .simple_struct(SimpleStruct::builder().build())
            .build();
        let http_request =
            KitchenSinkOperationInput::assemble(input.request_builder_base(), input.build_body());

        assert_eq!(http_request.method(), "POST");
        assert_eq!(http_request.uri().path(), "/");

        let expected_headers = &[("Content-Type", "application/x-amz-json-1.1")];
        ::protocol_test_helpers::assert_ok(::protocol_test_helpers::validate_headers(
            &http_request,
            expected_headers,
        ));
        let required_headers = &["Content-Length"];
        ::protocol_test_helpers::assert_ok(::protocol_test_helpers::require_headers(
            &http_request,
            required_headers,
        ));
        ::protocol_test_helpers::assert_ok(::protocol_test_helpers::validate_body(
            input.build_body(),
            "{\"SimpleStruct\":{}}",
            ::protocol_test_helpers::MediaType::from("application/json"),
        ));
    }
    /// Serializes structure which have no members
    /// Test ID: serializes_structure_which_have_no_members
    #[test]
    fn test_serializes_structure_which_have_no_members_request() {
        let input = KitchenSinkOperationInput::builder()
            .empty_struct(EmptyStruct::builder().build())
            .build();
        let http_request =
            KitchenSinkOperationInput::assemble(input.request_builder_base(), input.build_body());

        assert_eq!(http_request.method(), "POST");
        assert_eq!(http_request.uri().path(), "/");

        let expected_headers = &[("Content-Type", "application/x-amz-json-1.1")];
        ::protocol_test_helpers::assert_ok(::protocol_test_helpers::validate_headers(
            &http_request,
            expected_headers,
        ));
        let required_headers = &["Content-Length"];
        ::protocol_test_helpers::assert_ok(::protocol_test_helpers::require_headers(
            &http_request,
            required_headers,
        ));
        ::protocol_test_helpers::assert_ok(::protocol_test_helpers::validate_body(
            input.build_body(),
            "{\"EmptyStruct\":{}}",
            ::protocol_test_helpers::MediaType::from("application/json"),
        ));
    }
    /// Serializes recursive structure shapes
    /// Test ID: serializes_recursive_structure_shapes
    #[test]
    fn test_serializes_recursive_structure_shapes_request() {
        let input = KitchenSinkOperationInput::builder()
            .string("top-value".to_string())
            .boolean(false)
            .recursive_struct(
                KitchenSink::builder()
                    .string("nested-value".to_string())
                    .boolean(true)
                    .recursive_list(vec![
                        KitchenSink::builder()
                            .string("string-only".to_string())
                            .build(),
                        KitchenSink::builder()
                            .recursive_struct(
                                KitchenSink::builder()
                                    .map_of_strings({
                                        let mut ret = ::std::collections::HashMap::new();
                                        ret.insert("color".to_string(), "red".to_string());
                                        ret.insert("size".to_string(), "large".to_string());
                                        ret
                                    })
                                    .build(),
                            )
                            .build(),
                    ])
                    .build(),
            )
            .build();
        let http_request =
            KitchenSinkOperationInput::assemble(input.request_builder_base(), input.build_body());

        assert_eq!(http_request.method(), "POST");
        assert_eq!(http_request.uri().path(), "/");

        let expected_headers = &[("Content-Type", "application/x-amz-json-1.1")];
        ::protocol_test_helpers::assert_ok(::protocol_test_helpers::validate_headers(
            &http_request,
            expected_headers,
        ));
        let required_headers = &["Content-Length"];
        ::protocol_test_helpers::assert_ok(::protocol_test_helpers::require_headers(
            &http_request,
            required_headers,
        ));
        ::protocol_test_helpers::assert_ok(
        ::protocol_test_helpers::validate_body(input.build_body(), "{\"String\":\"top-value\",\"Boolean\":false,\"RecursiveStruct\":{\"String\":\"nested-value\",\"Boolean\":true,\"RecursiveList\":[{\"String\":\"string-only\"},{\"RecursiveStruct\":{\"MapOfStrings\":{\"color\":\"red\",\"size\":\"large\"}}}]}}", ::protocol_test_helpers::MediaType::from("application/json"))
        );
    }
    /// Parses operations with empty JSON bodies
    /// Test ID: parses_operations_with_empty_json_bodies
    #[test]
    fn test_parses_operations_with_empty_json_bodies_response() {
        /* test case disabled for this protocol (not yet supported) */
    }
    /// Parses string shapes
    /// Test ID: parses_string_shapes
    #[test]
    fn test_parses_string_shapes_response() {
        /* test case disabled for this protocol (not yet supported) */
    }
    /// Parses integer shapes
    /// Test ID: parses_integer_shapes
    #[test]
    fn test_parses_integer_shapes_response() {
        /* test case disabled for this protocol (not yet supported) */
    }
    /// Parses long shapes
    /// Test ID: parses_long_shapes
    #[test]
    fn test_parses_long_shapes_response() {
        /* test case disabled for this protocol (not yet supported) */
    }
    /// Parses float shapes
    /// Test ID: parses_float_shapes
    #[test]
    fn test_parses_float_shapes_response() {
        /* test case disabled for this protocol (not yet supported) */
    }
    /// Parses double shapes
    /// Test ID: parses_double_shapes
    #[test]
    fn test_parses_double_shapes_response() {
        /* test case disabled for this protocol (not yet supported) */
    }
    /// Parses boolean shapes (true)
    /// Test ID: parses_boolean_shapes_true
    #[test]
    fn test_parses_boolean_shapes_true_response() {
        /* test case disabled for this protocol (not yet supported) */
    }
    /// Parses boolean (false)
    /// Test ID: parses_boolean_false
    #[test]
    fn test_parses_boolean_false_response() {
        /* test case disabled for this protocol (not yet supported) */
    }
    /// Parses blob shapes
    /// Test ID: parses_blob_shapes
    #[test]
    fn test_parses_blob_shapes_response() {
        /* test case disabled for this protocol (not yet supported) */
    }
    /// Parses timestamp shapes
    /// Test ID: parses_timestamp_shapes
    #[test]
    fn test_parses_timestamp_shapes_response() {
        /* test case disabled for this protocol (not yet supported) */
    }
    /// Parses iso8601 timestamps
    /// Test ID: parses_iso8601_timestamps
    #[test]
    fn test_parses_iso8601_timestamps_response() {
        /* test case disabled for this protocol (not yet supported) */
    }
    /// Parses httpdate timestamps
    /// Test ID: parses_httpdate_timestamps
    #[test]
    fn test_parses_httpdate_timestamps_response() {
        /* test case disabled for this protocol (not yet supported) */
    }
    /// Parses list shapes
    /// Test ID: parses_list_shapes
    #[test]
    fn test_parses_list_shapes_response() {
        /* test case disabled for this protocol (not yet supported) */
    }
    /// Parses list of map shapes
    /// Test ID: parses_list_of_map_shapes
    #[test]
    fn test_parses_list_of_map_shapes_response() {
        /* test case disabled for this protocol (not yet supported) */
    }
    /// Parses list of list shapes
    /// Test ID: parses_list_of_list_shapes
    #[test]
    fn test_parses_list_of_list_shapes_response() {
        /* test case disabled for this protocol (not yet supported) */
    }
    /// Parses list of structure shapes
    /// Test ID: parses_list_of_structure_shapes
    #[test]
    fn test_parses_list_of_structure_shapes_response() {
        /* test case disabled for this protocol (not yet supported) */
    }
    /// Parses list of recursive structure shapes
    /// Test ID: parses_list_of_recursive_structure_shapes
    #[test]
    fn test_parses_list_of_recursive_structure_shapes_response() {
        /* test case disabled for this protocol (not yet supported) */
    }
    /// Parses map shapes
    /// Test ID: parses_map_shapes
    #[test]
    fn test_parses_map_shapes_response() {
        /* test case disabled for this protocol (not yet supported) */
    }
    /// Parses map of list shapes
    /// Test ID: parses_map_of_list_shapes
    #[test]
    fn test_parses_map_of_list_shapes_response() {
        /* test case disabled for this protocol (not yet supported) */
    }
    /// Parses map of map shapes
    /// Test ID: parses_map_of_map_shapes
    #[test]
    fn test_parses_map_of_map_shapes_response() {
        /* test case disabled for this protocol (not yet supported) */
    }
    /// Parses map of structure shapes
    /// Test ID: parses_map_of_structure_shapes
    #[test]
    fn test_parses_map_of_structure_shapes_response() {
        /* test case disabled for this protocol (not yet supported) */
    }
    /// Parses map of recursive structure shapes
    /// Test ID: parses_map_of_recursive_structure_shapes
    #[test]
    fn test_parses_map_of_recursive_structure_shapes_response() {
        /* test case disabled for this protocol (not yet supported) */
    }
    /// Parses the request id from the response
    /// Test ID: parses_the_request_id_from_the_response
    #[test]
    fn test_parses_the_request_id_from_the_response_response() {
        /* test case disabled for this protocol (not yet supported) */
    }
}

impl NullOperationInput {
    pub fn request_builder_base(&self) -> ::http::request::Builder {
        let builder = ::http::request::Builder::new();
        builder
            .method("POST")
            .header("Content-Type", "application/x-amz-json-1.1")
            .header("X-Amz-Target", "JsonProtocol.NullOperation")
    }
    fn body(&self) -> NullOperationInputBody {
        NullOperationInputBody {
            string: &self.string,
            sparse_string_list: &self.sparse_string_list,
            sparse_string_map: &self.sparse_string_map,
        }
    }
    pub fn build_body(&self) -> Vec<u8> {
        ::serde_json::to_vec(&self.body()).expect("serialization should succeed")
    }
    pub fn assemble(
        builder: ::http::request::Builder,
        body: Vec<u8>,
    ) -> ::http::request::Request<Vec<u8>> {
        builder
            .header(::http::header::CONTENT_LENGTH, body.len())
            .body(body)
            .expect("http request should be valid")
    }
}
#[cfg(test)]
#[allow(unreachable_code, unused_variables)]
mod null_operation_request_test {

    use crate::operation::NullOperationInput;
    /// Null structure values are dropped
    /// Test ID: AwsJson11StructuresDontSerializeNullValues
    #[test]
    fn test_aws_json11_structures_dont_serialize_null_values_request() {
        let input = NullOperationInput::builder().build();
        let http_request =
            NullOperationInput::assemble(input.request_builder_base(), input.build_body());

        assert_eq!(http_request.method(), "POST");
        assert_eq!(http_request.uri().path(), "/");

        let expected_headers = &[("Content-Type", "application/x-amz-json-1.1")];
        ::protocol_test_helpers::assert_ok(::protocol_test_helpers::validate_headers(
            &http_request,
            expected_headers,
        ));
        ::protocol_test_helpers::assert_ok(::protocol_test_helpers::validate_body(
            input.build_body(),
            "{}",
            ::protocol_test_helpers::MediaType::from("application/json"),
        ));
    }
    /// Serializes null values in maps
    /// Test ID: AwsJson11MapsSerializeNullValues
    #[test]
    fn test_aws_json11_maps_serialize_null_values_request() {
        let input = NullOperationInput::builder()
            .sparse_string_map({
                let mut ret = ::std::collections::HashMap::new();
                ret.insert("foo".to_string(), None);
                ret
            })
            .build();
        let http_request =
            NullOperationInput::assemble(input.request_builder_base(), input.build_body());

        assert_eq!(http_request.method(), "POST");
        assert_eq!(http_request.uri().path(), "/");

        let expected_headers = &[("Content-Type", "application/x-amz-json-1.1")];
        ::protocol_test_helpers::assert_ok(::protocol_test_helpers::validate_headers(
            &http_request,
            expected_headers,
        ));
        ::protocol_test_helpers::assert_ok(::protocol_test_helpers::validate_body(
            input.build_body(),
            "{
            \"sparseStringMap\": {
                \"foo\": null
            }
        }",
            ::protocol_test_helpers::MediaType::from("application/json"),
        ));
    }
    /// Serializes null values in lists
    /// Test ID: AwsJson11ListsSerializeNull
    #[test]
    fn test_aws_json11_lists_serialize_null_request() {
        let input = NullOperationInput::builder()
            .sparse_string_list(vec![None])
            .build();
        let http_request =
            NullOperationInput::assemble(input.request_builder_base(), input.build_body());

        assert_eq!(http_request.method(), "POST");
        assert_eq!(http_request.uri().path(), "/");

        let expected_headers = &[("Content-Type", "application/x-amz-json-1.1")];
        ::protocol_test_helpers::assert_ok(::protocol_test_helpers::validate_headers(
            &http_request,
            expected_headers,
        ));
        ::protocol_test_helpers::assert_ok(::protocol_test_helpers::validate_body(
            input.build_body(),
            "{
            \"sparseStringList\": [
                null
            ]
        }",
            ::protocol_test_helpers::MediaType::from("application/json"),
        ));
    }
    /// Null structure values are dropped
    /// Test ID: AwsJson11StructuresDontDeserializeNullValues
    #[test]
    fn test_aws_json11_structures_dont_deserialize_null_values_response() {
        /* test case disabled for this protocol (not yet supported) */
    }
    /// Deserializes null values in maps
    /// Test ID: AwsJson11MapsDeserializeNullValues
    #[test]
    fn test_aws_json11_maps_deserialize_null_values_response() {
        /* test case disabled for this protocol (not yet supported) */
    }
    /// Deserializes null values in lists
    /// Test ID: AwsJson11ListsDeserializeNull
    #[test]
    fn test_aws_json11_lists_deserialize_null_response() {
        /* test case disabled for this protocol (not yet supported) */
    }
}

impl OperationWithOptionalInputOutputInput {
    pub fn request_builder_base(&self) -> ::http::request::Builder {
        let builder = ::http::request::Builder::new();
        builder
            .method("POST")
            .header("Content-Type", "application/x-amz-json-1.1")
            .header(
                "X-Amz-Target",
                "JsonProtocol.OperationWithOptionalInputOutput",
            )
    }
    fn body(&self) -> OperationWithOptionalInputOutputInputBody {
        OperationWithOptionalInputOutputInputBody { value: &self.value }
    }
    pub fn build_body(&self) -> Vec<u8> {
        ::serde_json::to_vec(&self.body()).expect("serialization should succeed")
    }
    pub fn assemble(
        builder: ::http::request::Builder,
        body: Vec<u8>,
    ) -> ::http::request::Request<Vec<u8>> {
        builder
            .header(::http::header::CONTENT_LENGTH, body.len())
            .body(body)
            .expect("http request should be valid")
    }
}
#[cfg(test)]
#[allow(unreachable_code, unused_variables)]
mod operation_with_optional_input_output_request_test {

    use crate::operation::OperationWithOptionalInputOutputInput;
    /// Can call operations with no input or output
    /// Test ID: can_call_operation_with_no_input_or_output
    #[test]
    fn test_can_call_operation_with_no_input_or_output_request() {
        let input = OperationWithOptionalInputOutputInput::builder().build();
        let http_request = OperationWithOptionalInputOutputInput::assemble(
            input.request_builder_base(),
            input.build_body(),
        );

        assert_eq!(http_request.method(), "POST");
        assert_eq!(http_request.uri().path(), "/");

        let expected_headers = &[
            ("Content-Type", "application/x-amz-json-1.1"),
            (
                "X-Amz-Target",
                "JsonProtocol.OperationWithOptionalInputOutput",
            ),
        ];
        ::protocol_test_helpers::assert_ok(::protocol_test_helpers::validate_headers(
            &http_request,
            expected_headers,
        ));
        ::protocol_test_helpers::assert_ok(::protocol_test_helpers::validate_body(
            input.build_body(),
            "{}",
            ::protocol_test_helpers::MediaType::from("application/json"),
        ));
    }
    /// Can invoke operations with optional input
    /// Test ID: can_call_operation_with_optional_input
    #[test]
    fn test_can_call_operation_with_optional_input_request() {
        let input = OperationWithOptionalInputOutputInput::builder()
            .value("Hi".to_string())
            .build();
        let http_request = OperationWithOptionalInputOutputInput::assemble(
            input.request_builder_base(),
            input.build_body(),
        );

        assert_eq!(http_request.method(), "POST");
        assert_eq!(http_request.uri().path(), "/");

        let expected_headers = &[
            ("Content-Type", "application/x-amz-json-1.1"),
            (
                "X-Amz-Target",
                "JsonProtocol.OperationWithOptionalInputOutput",
            ),
        ];
        ::protocol_test_helpers::assert_ok(::protocol_test_helpers::validate_headers(
            &http_request,
            expected_headers,
        ));
        ::protocol_test_helpers::assert_ok(::protocol_test_helpers::validate_body(
            input.build_body(),
            "{\"Value\":\"Hi\"}",
            ::protocol_test_helpers::MediaType::from("application/json"),
        ));
    }
}

impl PutAndGetInlineDocumentsInput {
    pub fn request_builder_base(&self) -> ::http::request::Builder {
        let builder = ::http::request::Builder::new();
        builder
            .method("POST")
            .header("Content-Type", "application/x-amz-json-1.1")
            .header("X-Amz-Target", "JsonProtocol.PutAndGetInlineDocuments")
    }
    fn body(&self) -> PutAndGetInlineDocumentsInputBody {
        PutAndGetInlineDocumentsInputBody {
            inline_document: &self.inline_document,
        }
    }
    pub fn build_body(&self) -> Vec<u8> {
        ::serde_json::to_vec(&self.body()).expect("serialization should succeed")
    }
    pub fn assemble(
        builder: ::http::request::Builder,
        body: Vec<u8>,
    ) -> ::http::request::Request<Vec<u8>> {
        builder
            .header(::http::header::CONTENT_LENGTH, body.len())
            .body(body)
            .expect("http request should be valid")
    }
}
#[cfg(test)]
#[allow(unreachable_code, unused_variables)]
mod put_and_get_inline_documents_request_test {

    use crate::operation::PutAndGetInlineDocumentsInput;
    /// Serializes inline documents in a JSON request.
    /// Test ID: PutAndGetInlineDocumentsInput
    #[test]
    #[should_panic]
    fn test_put_and_get_inline_documents_input_request() {
        let input =PutAndGetInlineDocumentsInput::builder()
        .inline_document(
            todo!() /* (document: `aws.protocoltests.json#Document`) software.amazon.smithy.model.node.ObjectNode@2cd3bb4e */
        )
        .build()
        .unwrap()
        ;
        let http_request = PutAndGetInlineDocumentsInput::assemble(
            input.request_builder_base(),
            input.build_body(),
        );

        assert_eq!(http_request.method(), "POST");
        assert_eq!(http_request.uri().path(), "/");

        let expected_headers = &[("Content-Type", "application/x-amz-json-1.1")];
        ::protocol_test_helpers::assert_ok(::protocol_test_helpers::validate_headers(
            &http_request,
            expected_headers,
        ));
        let required_headers = &["Content-Length"];
        ::protocol_test_helpers::assert_ok(::protocol_test_helpers::require_headers(
            &http_request,
            required_headers,
        ));
        ::protocol_test_helpers::assert_ok(::protocol_test_helpers::validate_body(
            input.build_body(),
            "{
            \"inlineDocument\": {\"foo\": \"bar\"}
        }",
            ::protocol_test_helpers::MediaType::from("application/json"),
        ));
    }
    /// Serializes inline documents in a JSON response.
    /// Test ID: PutAndGetInlineDocumentsInput
    #[test]
    #[should_panic]
    fn test_put_and_get_inline_documents_input_response() {
        /* test case disabled for this protocol (not yet supported) */
        todo!()
    }
}

/// A shared structure that contains a single union member.
#[non_exhaustive]
#[derive(::std::clone::Clone, ::std::cmp::PartialEq, ::std::fmt::Debug)]
pub struct JsonUnionsOutput {
    /// A union with a representative set of types for members.
    pub contents: Option<MyUnion>,
}
impl JsonUnionsOutput {
    /// Creates a new builder-style object to manufacture [`JsonUnionsOutput`](crate::operation::JsonUnionsOutput)
    pub fn builder() -> crate::operation::json_unions_output::Builder {
        crate::operation::json_unions_output::Builder::default()
    }
}
/// See [`JsonUnionsOutput`](crate::operation::JsonUnionsOutput)
pub mod json_unions_output {

    use crate::model::MyUnion;
    use crate::operation::JsonUnionsOutput;
    /// A builder for [`JsonUnionsOutput`](crate::operation::JsonUnionsOutput)
    #[non_exhaustive]
    #[derive(Debug, Clone, Default)]
    pub struct Builder {
        contents: Option<MyUnion>,
    }
    impl Builder {
        /// A union with a representative set of types for members.
        pub fn contents(mut self, inp: MyUnion) -> Self {
            self.contents = Some(inp);
            self
        }
        /// Consumes the builder and constructs a [`JsonUnionsOutput`](crate::operation::JsonUnionsOutput)
        pub fn build(self) -> JsonUnionsOutput {
            JsonUnionsOutput {
                contents: self.contents,
            }
        }
    }
}

/// A shared structure that contains a single union member.
#[non_exhaustive]
#[derive(::std::clone::Clone, ::std::cmp::PartialEq, ::std::fmt::Debug)]
pub struct JsonUnionsInput {
    /// A union with a representative set of types for members.
    pub contents: Option<MyUnion>,
}
impl JsonUnionsInput {
    /// Creates a new builder-style object to manufacture [`JsonUnionsInput`](crate::operation::JsonUnionsInput)
    pub fn builder() -> crate::operation::json_unions_input::Builder {
        crate::operation::json_unions_input::Builder::default()
    }
}
/// See [`JsonUnionsInput`](crate::operation::JsonUnionsInput)
pub mod json_unions_input {

    use crate::model::MyUnion;
    use crate::operation::JsonUnionsInput;
    /// A builder for [`JsonUnionsInput`](crate::operation::JsonUnionsInput)
    #[non_exhaustive]
    #[derive(Debug, Clone, Default)]
    pub struct Builder {
        contents: Option<MyUnion>,
    }
    impl Builder {
        /// A union with a representative set of types for members.
        pub fn contents(mut self, inp: MyUnion) -> Self {
            self.contents = Some(inp);
            self
        }
        /// Consumes the builder and constructs a [`JsonUnionsInput`](crate::operation::JsonUnionsInput)
        pub fn build(self) -> JsonUnionsInput {
            JsonUnionsInput {
                contents: self.contents,
            }
        }
    }
}

#[non_exhaustive]
#[derive(::std::clone::Clone, ::std::cmp::PartialEq, ::std::fmt::Debug)]
pub struct GreetingWithErrorsOutput {
    pub greeting: Option<String>,
}
impl GreetingWithErrorsOutput {
    /// Creates a new builder-style object to manufacture [`GreetingWithErrorsOutput`](crate::operation::GreetingWithErrorsOutput)
    pub fn builder() -> crate::operation::greeting_with_errors_output::Builder {
        crate::operation::greeting_with_errors_output::Builder::default()
    }
}
/// See [`GreetingWithErrorsOutput`](crate::operation::GreetingWithErrorsOutput)
pub mod greeting_with_errors_output {

    use crate::operation::GreetingWithErrorsOutput;
    /// A builder for [`GreetingWithErrorsOutput`](crate::operation::GreetingWithErrorsOutput)
    #[non_exhaustive]
    #[derive(Debug, Clone, Default)]
    pub struct Builder {
        greeting: Option<String>,
    }
    impl Builder {
        pub fn greeting(mut self, inp: impl Into<String>) -> Self {
            self.greeting = Some(inp.into());
            self
        }
        /// Consumes the builder and constructs a [`GreetingWithErrorsOutput`](crate::operation::GreetingWithErrorsOutput)
        pub fn build(self) -> GreetingWithErrorsOutput {
            GreetingWithErrorsOutput {
                greeting: self.greeting,
            }
        }
    }
}

#[non_exhaustive]
#[derive(::std::clone::Clone, ::std::cmp::PartialEq, ::std::fmt::Debug)]
pub struct GreetingWithErrorsInput {}
impl GreetingWithErrorsInput {
    /// Creates a new builder-style object to manufacture [`GreetingWithErrorsInput`](crate::operation::GreetingWithErrorsInput)
    pub fn builder() -> crate::operation::greeting_with_errors_input::Builder {
        crate::operation::greeting_with_errors_input::Builder::default()
    }
}
/// See [`GreetingWithErrorsInput`](crate::operation::GreetingWithErrorsInput)
pub mod greeting_with_errors_input {

    use crate::operation::GreetingWithErrorsInput;
    /// A builder for [`GreetingWithErrorsInput`](crate::operation::GreetingWithErrorsInput)
    #[non_exhaustive]
    #[derive(Debug, Clone, Default)]
    pub struct Builder {}
    impl Builder {
        /// Consumes the builder and constructs a [`GreetingWithErrorsInput`](crate::operation::GreetingWithErrorsInput)
        pub fn build(self) -> GreetingWithErrorsInput {
            GreetingWithErrorsInput {}
        }
    }
}

#[non_exhaustive]
#[derive(::std::clone::Clone, ::std::cmp::PartialEq, ::std::fmt::Debug)]
pub struct NullOperationOutput {
    pub string: Option<String>,
    pub sparse_string_list: Option<Vec<Option<String>>>,
    pub sparse_string_map: Option<HashMap<String, Option<String>>>,
}
impl NullOperationOutput {
    /// Creates a new builder-style object to manufacture [`NullOperationOutput`](crate::operation::NullOperationOutput)
    pub fn builder() -> crate::operation::null_operation_output::Builder {
        crate::operation::null_operation_output::Builder::default()
    }
}
/// See [`NullOperationOutput`](crate::operation::NullOperationOutput)
pub mod null_operation_output {

    use crate::operation::NullOperationOutput;
    use std::collections::HashMap;
    /// A builder for [`NullOperationOutput`](crate::operation::NullOperationOutput)
    #[non_exhaustive]
    #[derive(Debug, Clone, Default)]
    pub struct Builder {
        string: Option<String>,
        sparse_string_list: Option<Vec<Option<String>>>,
        sparse_string_map: Option<HashMap<String, Option<String>>>,
    }
    impl Builder {
        pub fn string(mut self, inp: impl Into<String>) -> Self {
            self.string = Some(inp.into());
            self
        }
        pub fn sparse_string_list(mut self, inp: Vec<Option<String>>) -> Self {
            self.sparse_string_list = Some(inp);
            self
        }
        pub fn sparse_string_map(mut self, inp: HashMap<String, Option<String>>) -> Self {
            self.sparse_string_map = Some(inp);
            self
        }
        /// Consumes the builder and constructs a [`NullOperationOutput`](crate::operation::NullOperationOutput)
        pub fn build(self) -> NullOperationOutput {
            NullOperationOutput {
                string: self.string,
                sparse_string_list: self.sparse_string_list,
                sparse_string_map: self.sparse_string_map,
            }
        }
    }
}

#[non_exhaustive]
#[derive(::std::clone::Clone, ::std::cmp::PartialEq, ::std::fmt::Debug)]
pub struct NullOperationInput {
    pub string: Option<String>,
    pub sparse_string_list: Option<Vec<Option<String>>>,
    pub sparse_string_map: Option<HashMap<String, Option<String>>>,
}
impl NullOperationInput {
    /// Creates a new builder-style object to manufacture [`NullOperationInput`](crate::operation::NullOperationInput)
    pub fn builder() -> crate::operation::null_operation_input::Builder {
        crate::operation::null_operation_input::Builder::default()
    }
}
/// See [`NullOperationInput`](crate::operation::NullOperationInput)
pub mod null_operation_input {

    use crate::operation::NullOperationInput;
    use std::collections::HashMap;
    /// A builder for [`NullOperationInput`](crate::operation::NullOperationInput)
    #[non_exhaustive]
    #[derive(Debug, Clone, Default)]
    pub struct Builder {
        string: Option<String>,
        sparse_string_list: Option<Vec<Option<String>>>,
        sparse_string_map: Option<HashMap<String, Option<String>>>,
    }
    impl Builder {
        pub fn string(mut self, inp: impl Into<String>) -> Self {
            self.string = Some(inp.into());
            self
        }
        pub fn sparse_string_list(mut self, inp: Vec<Option<String>>) -> Self {
            self.sparse_string_list = Some(inp);
            self
        }
        pub fn sparse_string_map(mut self, inp: HashMap<String, Option<String>>) -> Self {
            self.sparse_string_map = Some(inp);
            self
        }
        /// Consumes the builder and constructs a [`NullOperationInput`](crate::operation::NullOperationInput)
        pub fn build(self) -> NullOperationInput {
            NullOperationInput {
                string: self.string,
                sparse_string_list: self.sparse_string_list,
                sparse_string_map: self.sparse_string_map,
            }
        }
    }
}

#[non_exhaustive]
#[derive(::std::clone::Clone, ::std::cmp::PartialEq, ::std::fmt::Debug)]
pub struct JsonEnumsOutput {
    pub foo_enum1: Option<FooEnum>,
    pub foo_enum2: Option<FooEnum>,
    pub foo_enum3: Option<FooEnum>,
    pub foo_enum_list: Option<Vec<FooEnum>>,
    pub foo_enum_set: Option<BTreeSet<FooEnum>>,
    pub foo_enum_map: Option<HashMap<String, FooEnum>>,
}
impl JsonEnumsOutput {
    /// Creates a new builder-style object to manufacture [`JsonEnumsOutput`](crate::operation::JsonEnumsOutput)
    pub fn builder() -> crate::operation::json_enums_output::Builder {
        crate::operation::json_enums_output::Builder::default()
    }
}
/// See [`JsonEnumsOutput`](crate::operation::JsonEnumsOutput)
pub mod json_enums_output {

    use crate::model::FooEnum;
    use crate::operation::JsonEnumsOutput;
    use std::collections::BTreeSet;
    use std::collections::HashMap;
    /// A builder for [`JsonEnumsOutput`](crate::operation::JsonEnumsOutput)
    #[non_exhaustive]
    #[derive(Debug, Clone, Default)]
    pub struct Builder {
        foo_enum1: Option<FooEnum>,
        foo_enum2: Option<FooEnum>,
        foo_enum3: Option<FooEnum>,
        foo_enum_list: Option<Vec<FooEnum>>,
        foo_enum_set: Option<BTreeSet<FooEnum>>,
        foo_enum_map: Option<HashMap<String, FooEnum>>,
    }
    impl Builder {
        pub fn foo_enum1(mut self, inp: FooEnum) -> Self {
            self.foo_enum1 = Some(inp);
            self
        }
        pub fn foo_enum2(mut self, inp: FooEnum) -> Self {
            self.foo_enum2 = Some(inp);
            self
        }
        pub fn foo_enum3(mut self, inp: FooEnum) -> Self {
            self.foo_enum3 = Some(inp);
            self
        }
        pub fn foo_enum_list(mut self, inp: Vec<FooEnum>) -> Self {
            self.foo_enum_list = Some(inp);
            self
        }
        pub fn foo_enum_set(mut self, inp: BTreeSet<FooEnum>) -> Self {
            self.foo_enum_set = Some(inp);
            self
        }
        pub fn foo_enum_map(mut self, inp: HashMap<String, FooEnum>) -> Self {
            self.foo_enum_map = Some(inp);
            self
        }
        /// Consumes the builder and constructs a [`JsonEnumsOutput`](crate::operation::JsonEnumsOutput)
        pub fn build(self) -> JsonEnumsOutput {
            JsonEnumsOutput {
                foo_enum1: self.foo_enum1,
                foo_enum2: self.foo_enum2,
                foo_enum3: self.foo_enum3,
                foo_enum_list: self.foo_enum_list,
                foo_enum_set: self.foo_enum_set,
                foo_enum_map: self.foo_enum_map,
            }
        }
    }
}

#[non_exhaustive]
#[derive(::std::clone::Clone, ::std::cmp::PartialEq, ::std::fmt::Debug)]
pub struct JsonEnumsInput {
    pub foo_enum1: Option<FooEnum>,
    pub foo_enum2: Option<FooEnum>,
    pub foo_enum3: Option<FooEnum>,
    pub foo_enum_list: Option<Vec<FooEnum>>,
    pub foo_enum_set: Option<BTreeSet<FooEnum>>,
    pub foo_enum_map: Option<HashMap<String, FooEnum>>,
}
impl JsonEnumsInput {
    /// Creates a new builder-style object to manufacture [`JsonEnumsInput`](crate::operation::JsonEnumsInput)
    pub fn builder() -> crate::operation::json_enums_input::Builder {
        crate::operation::json_enums_input::Builder::default()
    }
}
/// See [`JsonEnumsInput`](crate::operation::JsonEnumsInput)
pub mod json_enums_input {

    use crate::model::FooEnum;
    use crate::operation::JsonEnumsInput;
    use std::collections::BTreeSet;
    use std::collections::HashMap;
    /// A builder for [`JsonEnumsInput`](crate::operation::JsonEnumsInput)
    #[non_exhaustive]
    #[derive(Debug, Clone, Default)]
    pub struct Builder {
        foo_enum1: Option<FooEnum>,
        foo_enum2: Option<FooEnum>,
        foo_enum3: Option<FooEnum>,
        foo_enum_list: Option<Vec<FooEnum>>,
        foo_enum_set: Option<BTreeSet<FooEnum>>,
        foo_enum_map: Option<HashMap<String, FooEnum>>,
    }
    impl Builder {
        pub fn foo_enum1(mut self, inp: FooEnum) -> Self {
            self.foo_enum1 = Some(inp);
            self
        }
        pub fn foo_enum2(mut self, inp: FooEnum) -> Self {
            self.foo_enum2 = Some(inp);
            self
        }
        pub fn foo_enum3(mut self, inp: FooEnum) -> Self {
            self.foo_enum3 = Some(inp);
            self
        }
        pub fn foo_enum_list(mut self, inp: Vec<FooEnum>) -> Self {
            self.foo_enum_list = Some(inp);
            self
        }
        pub fn foo_enum_set(mut self, inp: BTreeSet<FooEnum>) -> Self {
            self.foo_enum_set = Some(inp);
            self
        }
        pub fn foo_enum_map(mut self, inp: HashMap<String, FooEnum>) -> Self {
            self.foo_enum_map = Some(inp);
            self
        }
        /// Consumes the builder and constructs a [`JsonEnumsInput`](crate::operation::JsonEnumsInput)
        pub fn build(self) -> JsonEnumsInput {
            JsonEnumsInput {
                foo_enum1: self.foo_enum1,
                foo_enum2: self.foo_enum2,
                foo_enum3: self.foo_enum3,
                foo_enum_list: self.foo_enum_list,
                foo_enum_set: self.foo_enum_set,
                foo_enum_map: self.foo_enum_map,
            }
        }
    }
}

#[non_exhaustive]
#[derive(::std::clone::Clone, ::std::cmp::PartialEq, ::std::fmt::Debug)]
pub struct PutAndGetInlineDocumentsOutput {
    pub inline_document: Document,
}
impl PutAndGetInlineDocumentsOutput {
    /// Creates a new builder-style object to manufacture [`PutAndGetInlineDocumentsOutput`](crate::operation::PutAndGetInlineDocumentsOutput)
    pub fn builder() -> crate::operation::put_and_get_inline_documents_output::Builder {
        crate::operation::put_and_get_inline_documents_output::Builder::default()
    }
}
/// See [`PutAndGetInlineDocumentsOutput`](crate::operation::PutAndGetInlineDocumentsOutput)
pub mod put_and_get_inline_documents_output {

    use crate::operation::PutAndGetInlineDocumentsOutput;
    use smithy_types::Document;
    /// A builder for [`PutAndGetInlineDocumentsOutput`](crate::operation::PutAndGetInlineDocumentsOutput)
    #[non_exhaustive]
    #[derive(Debug, Clone, Default)]
    pub struct Builder {
        inline_document: Option<Document>,
    }
    impl Builder {
        pub fn inline_document(mut self, inp: Document) -> Self {
            self.inline_document = Some(inp);
            self
        }
        /// Consumes the builder and constructs a [`PutAndGetInlineDocumentsOutput`](crate::operation::PutAndGetInlineDocumentsOutput)
        pub fn build(self) -> Result<PutAndGetInlineDocumentsOutput, String> {
            Ok(PutAndGetInlineDocumentsOutput {
                inline_document: self.inline_document.ok_or(
                    "inline_document is required when building PutAndGetInlineDocumentsOutput",
                )?,
            })
        }
    }
}

#[non_exhaustive]
#[derive(::std::clone::Clone, ::std::cmp::PartialEq, ::std::fmt::Debug)]
pub struct PutAndGetInlineDocumentsInput {
    pub inline_document: Document,
}
impl PutAndGetInlineDocumentsInput {
    /// Creates a new builder-style object to manufacture [`PutAndGetInlineDocumentsInput`](crate::operation::PutAndGetInlineDocumentsInput)
    pub fn builder() -> crate::operation::put_and_get_inline_documents_input::Builder {
        crate::operation::put_and_get_inline_documents_input::Builder::default()
    }
}
/// See [`PutAndGetInlineDocumentsInput`](crate::operation::PutAndGetInlineDocumentsInput)
pub mod put_and_get_inline_documents_input {

    use crate::operation::PutAndGetInlineDocumentsInput;
    use smithy_types::Document;
    /// A builder for [`PutAndGetInlineDocumentsInput`](crate::operation::PutAndGetInlineDocumentsInput)
    #[non_exhaustive]
    #[derive(Debug, Clone, Default)]
    pub struct Builder {
        inline_document: Option<Document>,
    }
    impl Builder {
        pub fn inline_document(mut self, inp: Document) -> Self {
            self.inline_document = Some(inp);
            self
        }
        /// Consumes the builder and constructs a [`PutAndGetInlineDocumentsInput`](crate::operation::PutAndGetInlineDocumentsInput)
        pub fn build(self) -> Result<PutAndGetInlineDocumentsInput, String> {
            Ok(PutAndGetInlineDocumentsInput {
                inline_document: self.inline_document.ok_or(
                    "inline_document is required when building PutAndGetInlineDocumentsInput",
                )?,
            })
        }
    }
}

#[non_exhaustive]
#[derive(::std::clone::Clone, ::std::cmp::PartialEq, ::std::fmt::Debug)]
pub struct OperationWithOptionalInputOutputOutput {
    pub value: Option<String>,
}
impl OperationWithOptionalInputOutputOutput {
    /// Creates a new builder-style object to manufacture [`OperationWithOptionalInputOutputOutput`](crate::operation::OperationWithOptionalInputOutputOutput)
    pub fn builder() -> crate::operation::operation_with_optional_input_output_output::Builder {
        crate::operation::operation_with_optional_input_output_output::Builder::default()
    }
}
/// See [`OperationWithOptionalInputOutputOutput`](crate::operation::OperationWithOptionalInputOutputOutput)
pub mod operation_with_optional_input_output_output {

    use crate::operation::OperationWithOptionalInputOutputOutput;
    /// A builder for [`OperationWithOptionalInputOutputOutput`](crate::operation::OperationWithOptionalInputOutputOutput)
    #[non_exhaustive]
    #[derive(Debug, Clone, Default)]
    pub struct Builder {
        value: Option<String>,
    }
    impl Builder {
        pub fn value(mut self, inp: impl Into<String>) -> Self {
            self.value = Some(inp.into());
            self
        }
        /// Consumes the builder and constructs a [`OperationWithOptionalInputOutputOutput`](crate::operation::OperationWithOptionalInputOutputOutput)
        pub fn build(self) -> OperationWithOptionalInputOutputOutput {
            OperationWithOptionalInputOutputOutput { value: self.value }
        }
    }
}

#[non_exhaustive]
#[derive(::std::clone::Clone, ::std::cmp::PartialEq, ::std::fmt::Debug)]
pub struct OperationWithOptionalInputOutputInput {
    pub value: Option<String>,
}
impl OperationWithOptionalInputOutputInput {
    /// Creates a new builder-style object to manufacture [`OperationWithOptionalInputOutputInput`](crate::operation::OperationWithOptionalInputOutputInput)
    pub fn builder() -> crate::operation::operation_with_optional_input_output_input::Builder {
        crate::operation::operation_with_optional_input_output_input::Builder::default()
    }
}
/// See [`OperationWithOptionalInputOutputInput`](crate::operation::OperationWithOptionalInputOutputInput)
pub mod operation_with_optional_input_output_input {

    use crate::operation::OperationWithOptionalInputOutputInput;
    /// A builder for [`OperationWithOptionalInputOutputInput`](crate::operation::OperationWithOptionalInputOutputInput)
    #[non_exhaustive]
    #[derive(Debug, Clone, Default)]
    pub struct Builder {
        value: Option<String>,
    }
    impl Builder {
        pub fn value(mut self, inp: impl Into<String>) -> Self {
            self.value = Some(inp.into());
            self
        }
        /// Consumes the builder and constructs a [`OperationWithOptionalInputOutputInput`](crate::operation::OperationWithOptionalInputOutputInput)
        pub fn build(self) -> OperationWithOptionalInputOutputInput {
            OperationWithOptionalInputOutputInput { value: self.value }
        }
    }
}

#[non_exhaustive]
#[derive(::std::clone::Clone, ::std::cmp::PartialEq, ::std::fmt::Debug)]
pub struct KitchenSinkOperationOutput {
    pub blob: Option<Blob>,
    pub boolean: Option<bool>,
    pub double: Option<f64>,
    pub empty_struct: Option<EmptyStruct>,
    pub float: Option<f32>,
    pub httpdate_timestamp: Option<Instant>,
    pub integer: Option<i32>,
    pub iso8601_timestamp: Option<Instant>,
    pub json_value: Option<String>,
    pub list_of_lists: Option<Vec<Vec<String>>>,
    pub list_of_maps_of_strings: Option<Vec<HashMap<String, String>>>,
    pub list_of_strings: Option<Vec<String>>,
    pub list_of_structs: Option<Vec<SimpleStruct>>,
    pub long: Option<i64>,
    pub map_of_lists_of_strings: Option<HashMap<String, Vec<String>>>,
    pub map_of_maps: Option<HashMap<String, HashMap<String, String>>>,
    pub map_of_strings: Option<HashMap<String, String>>,
    pub map_of_structs: Option<HashMap<String, SimpleStruct>>,
    pub recursive_list: Option<Vec<KitchenSink>>,
    pub recursive_map: Option<HashMap<String, KitchenSink>>,
    pub recursive_struct: Option<Box<KitchenSink>>,
    pub simple_struct: Option<SimpleStruct>,
    pub string: Option<String>,
    pub struct_with_location_name: Option<StructWithLocationName>,
    pub timestamp: Option<Instant>,
    pub unix_timestamp: Option<Instant>,
}
impl KitchenSinkOperationOutput {
    /// Creates a new builder-style object to manufacture [`KitchenSinkOperationOutput`](crate::operation::KitchenSinkOperationOutput)
    pub fn builder() -> crate::operation::kitchen_sink_operation_output::Builder {
        crate::operation::kitchen_sink_operation_output::Builder::default()
    }
}
/// See [`KitchenSinkOperationOutput`](crate::operation::KitchenSinkOperationOutput)
pub mod kitchen_sink_operation_output {

    use crate::model::EmptyStruct;
    use crate::model::KitchenSink;
    use crate::model::SimpleStruct;
    use crate::model::StructWithLocationName;
    use crate::operation::KitchenSinkOperationOutput;
    use smithy_types::Blob;
    use smithy_types::Instant;
    use std::collections::HashMap;
    /// A builder for [`KitchenSinkOperationOutput`](crate::operation::KitchenSinkOperationOutput)
    #[non_exhaustive]
    #[derive(Debug, Clone, Default)]
    pub struct Builder {
        blob: Option<Blob>,
        boolean: Option<bool>,
        double: Option<f64>,
        empty_struct: Option<EmptyStruct>,
        float: Option<f32>,
        httpdate_timestamp: Option<Instant>,
        integer: Option<i32>,
        iso8601_timestamp: Option<Instant>,
        json_value: Option<String>,
        list_of_lists: Option<Vec<Vec<String>>>,
        list_of_maps_of_strings: Option<Vec<HashMap<String, String>>>,
        list_of_strings: Option<Vec<String>>,
        list_of_structs: Option<Vec<SimpleStruct>>,
        long: Option<i64>,
        map_of_lists_of_strings: Option<HashMap<String, Vec<String>>>,
        map_of_maps: Option<HashMap<String, HashMap<String, String>>>,
        map_of_strings: Option<HashMap<String, String>>,
        map_of_structs: Option<HashMap<String, SimpleStruct>>,
        recursive_list: Option<Vec<KitchenSink>>,
        recursive_map: Option<HashMap<String, KitchenSink>>,
        recursive_struct: Option<Box<KitchenSink>>,
        simple_struct: Option<SimpleStruct>,
        string: Option<String>,
        struct_with_location_name: Option<StructWithLocationName>,
        timestamp: Option<Instant>,
        unix_timestamp: Option<Instant>,
    }
    impl Builder {
        pub fn blob(mut self, inp: Blob) -> Self {
            self.blob = Some(inp);
            self
        }
        pub fn boolean(mut self, inp: bool) -> Self {
            self.boolean = Some(inp);
            self
        }
        pub fn double(mut self, inp: f64) -> Self {
            self.double = Some(inp);
            self
        }
        pub fn empty_struct(mut self, inp: EmptyStruct) -> Self {
            self.empty_struct = Some(inp);
            self
        }
        pub fn float(mut self, inp: f32) -> Self {
            self.float = Some(inp);
            self
        }
        pub fn httpdate_timestamp(mut self, inp: Instant) -> Self {
            self.httpdate_timestamp = Some(inp);
            self
        }
        pub fn integer(mut self, inp: i32) -> Self {
            self.integer = Some(inp);
            self
        }
        pub fn iso8601_timestamp(mut self, inp: Instant) -> Self {
            self.iso8601_timestamp = Some(inp);
            self
        }
        pub fn json_value(mut self, inp: impl Into<String>) -> Self {
            self.json_value = Some(inp.into());
            self
        }
        pub fn list_of_lists(mut self, inp: Vec<Vec<String>>) -> Self {
            self.list_of_lists = Some(inp);
            self
        }
        pub fn list_of_maps_of_strings(mut self, inp: Vec<HashMap<String, String>>) -> Self {
            self.list_of_maps_of_strings = Some(inp);
            self
        }
        pub fn list_of_strings(mut self, inp: Vec<String>) -> Self {
            self.list_of_strings = Some(inp);
            self
        }
        pub fn list_of_structs(mut self, inp: Vec<SimpleStruct>) -> Self {
            self.list_of_structs = Some(inp);
            self
        }
        pub fn long(mut self, inp: i64) -> Self {
            self.long = Some(inp);
            self
        }
        pub fn map_of_lists_of_strings(mut self, inp: HashMap<String, Vec<String>>) -> Self {
            self.map_of_lists_of_strings = Some(inp);
            self
        }
        pub fn map_of_maps(mut self, inp: HashMap<String, HashMap<String, String>>) -> Self {
            self.map_of_maps = Some(inp);
            self
        }
        pub fn map_of_strings(mut self, inp: HashMap<String, String>) -> Self {
            self.map_of_strings = Some(inp);
            self
        }
        pub fn map_of_structs(mut self, inp: HashMap<String, SimpleStruct>) -> Self {
            self.map_of_structs = Some(inp);
            self
        }
        pub fn recursive_list(mut self, inp: Vec<KitchenSink>) -> Self {
            self.recursive_list = Some(inp);
            self
        }
        pub fn recursive_map(mut self, inp: HashMap<String, KitchenSink>) -> Self {
            self.recursive_map = Some(inp);
            self
        }
        pub fn recursive_struct(mut self, inp: impl Into<Box<KitchenSink>>) -> Self {
            self.recursive_struct = Some(inp.into());
            self
        }
        pub fn simple_struct(mut self, inp: SimpleStruct) -> Self {
            self.simple_struct = Some(inp);
            self
        }
        pub fn string(mut self, inp: impl Into<String>) -> Self {
            self.string = Some(inp.into());
            self
        }
        pub fn struct_with_location_name(mut self, inp: StructWithLocationName) -> Self {
            self.struct_with_location_name = Some(inp);
            self
        }
        pub fn timestamp(mut self, inp: Instant) -> Self {
            self.timestamp = Some(inp);
            self
        }
        pub fn unix_timestamp(mut self, inp: Instant) -> Self {
            self.unix_timestamp = Some(inp);
            self
        }
        /// Consumes the builder and constructs a [`KitchenSinkOperationOutput`](crate::operation::KitchenSinkOperationOutput)
        pub fn build(self) -> KitchenSinkOperationOutput {
            KitchenSinkOperationOutput {
                blob: self.blob,
                boolean: self.boolean,
                double: self.double,
                empty_struct: self.empty_struct,
                float: self.float,
                httpdate_timestamp: self.httpdate_timestamp,
                integer: self.integer,
                iso8601_timestamp: self.iso8601_timestamp,
                json_value: self.json_value,
                list_of_lists: self.list_of_lists,
                list_of_maps_of_strings: self.list_of_maps_of_strings,
                list_of_strings: self.list_of_strings,
                list_of_structs: self.list_of_structs,
                long: self.long,
                map_of_lists_of_strings: self.map_of_lists_of_strings,
                map_of_maps: self.map_of_maps,
                map_of_strings: self.map_of_strings,
                map_of_structs: self.map_of_structs,
                recursive_list: self.recursive_list,
                recursive_map: self.recursive_map,
                recursive_struct: self.recursive_struct,
                simple_struct: self.simple_struct,
                string: self.string,
                struct_with_location_name: self.struct_with_location_name,
                timestamp: self.timestamp,
                unix_timestamp: self.unix_timestamp,
            }
        }
    }
}

#[non_exhaustive]
#[derive(::std::clone::Clone, ::std::cmp::PartialEq, ::std::fmt::Debug)]
pub struct KitchenSinkOperationInput {
    pub blob: Option<Blob>,
    pub boolean: Option<bool>,
    pub double: Option<f64>,
    pub empty_struct: Option<EmptyStruct>,
    pub float: Option<f32>,
    pub httpdate_timestamp: Option<Instant>,
    pub integer: Option<i32>,
    pub iso8601_timestamp: Option<Instant>,
    pub json_value: Option<String>,
    pub list_of_lists: Option<Vec<Vec<String>>>,
    pub list_of_maps_of_strings: Option<Vec<HashMap<String, String>>>,
    pub list_of_strings: Option<Vec<String>>,
    pub list_of_structs: Option<Vec<SimpleStruct>>,
    pub long: Option<i64>,
    pub map_of_lists_of_strings: Option<HashMap<String, Vec<String>>>,
    pub map_of_maps: Option<HashMap<String, HashMap<String, String>>>,
    pub map_of_strings: Option<HashMap<String, String>>,
    pub map_of_structs: Option<HashMap<String, SimpleStruct>>,
    pub recursive_list: Option<Vec<KitchenSink>>,
    pub recursive_map: Option<HashMap<String, KitchenSink>>,
    pub recursive_struct: Option<Box<KitchenSink>>,
    pub simple_struct: Option<SimpleStruct>,
    pub string: Option<String>,
    pub struct_with_location_name: Option<StructWithLocationName>,
    pub timestamp: Option<Instant>,
    pub unix_timestamp: Option<Instant>,
}
impl KitchenSinkOperationInput {
    /// Creates a new builder-style object to manufacture [`KitchenSinkOperationInput`](crate::operation::KitchenSinkOperationInput)
    pub fn builder() -> crate::operation::kitchen_sink_operation_input::Builder {
        crate::operation::kitchen_sink_operation_input::Builder::default()
    }
}
/// See [`KitchenSinkOperationInput`](crate::operation::KitchenSinkOperationInput)
pub mod kitchen_sink_operation_input {

    use crate::model::EmptyStruct;
    use crate::model::KitchenSink;
    use crate::model::SimpleStruct;
    use crate::model::StructWithLocationName;
    use crate::operation::KitchenSinkOperationInput;
    use smithy_types::Blob;
    use smithy_types::Instant;
    use std::collections::HashMap;
    /// A builder for [`KitchenSinkOperationInput`](crate::operation::KitchenSinkOperationInput)
    #[non_exhaustive]
    #[derive(Debug, Clone, Default)]
    pub struct Builder {
        blob: Option<Blob>,
        boolean: Option<bool>,
        double: Option<f64>,
        empty_struct: Option<EmptyStruct>,
        float: Option<f32>,
        httpdate_timestamp: Option<Instant>,
        integer: Option<i32>,
        iso8601_timestamp: Option<Instant>,
        json_value: Option<String>,
        list_of_lists: Option<Vec<Vec<String>>>,
        list_of_maps_of_strings: Option<Vec<HashMap<String, String>>>,
        list_of_strings: Option<Vec<String>>,
        list_of_structs: Option<Vec<SimpleStruct>>,
        long: Option<i64>,
        map_of_lists_of_strings: Option<HashMap<String, Vec<String>>>,
        map_of_maps: Option<HashMap<String, HashMap<String, String>>>,
        map_of_strings: Option<HashMap<String, String>>,
        map_of_structs: Option<HashMap<String, SimpleStruct>>,
        recursive_list: Option<Vec<KitchenSink>>,
        recursive_map: Option<HashMap<String, KitchenSink>>,
        recursive_struct: Option<Box<KitchenSink>>,
        simple_struct: Option<SimpleStruct>,
        string: Option<String>,
        struct_with_location_name: Option<StructWithLocationName>,
        timestamp: Option<Instant>,
        unix_timestamp: Option<Instant>,
    }
    impl Builder {
        pub fn blob(mut self, inp: Blob) -> Self {
            self.blob = Some(inp);
            self
        }
        pub fn boolean(mut self, inp: bool) -> Self {
            self.boolean = Some(inp);
            self
        }
        pub fn double(mut self, inp: f64) -> Self {
            self.double = Some(inp);
            self
        }
        pub fn empty_struct(mut self, inp: EmptyStruct) -> Self {
            self.empty_struct = Some(inp);
            self
        }
        pub fn float(mut self, inp: f32) -> Self {
            self.float = Some(inp);
            self
        }
        pub fn httpdate_timestamp(mut self, inp: Instant) -> Self {
            self.httpdate_timestamp = Some(inp);
            self
        }
        pub fn integer(mut self, inp: i32) -> Self {
            self.integer = Some(inp);
            self
        }
        pub fn iso8601_timestamp(mut self, inp: Instant) -> Self {
            self.iso8601_timestamp = Some(inp);
            self
        }
        pub fn json_value(mut self, inp: impl Into<String>) -> Self {
            self.json_value = Some(inp.into());
            self
        }
        pub fn list_of_lists(mut self, inp: Vec<Vec<String>>) -> Self {
            self.list_of_lists = Some(inp);
            self
        }
        pub fn list_of_maps_of_strings(mut self, inp: Vec<HashMap<String, String>>) -> Self {
            self.list_of_maps_of_strings = Some(inp);
            self
        }
        pub fn list_of_strings(mut self, inp: Vec<String>) -> Self {
            self.list_of_strings = Some(inp);
            self
        }
        pub fn list_of_structs(mut self, inp: Vec<SimpleStruct>) -> Self {
            self.list_of_structs = Some(inp);
            self
        }
        pub fn long(mut self, inp: i64) -> Self {
            self.long = Some(inp);
            self
        }
        pub fn map_of_lists_of_strings(mut self, inp: HashMap<String, Vec<String>>) -> Self {
            self.map_of_lists_of_strings = Some(inp);
            self
        }
        pub fn map_of_maps(mut self, inp: HashMap<String, HashMap<String, String>>) -> Self {
            self.map_of_maps = Some(inp);
            self
        }
        pub fn map_of_strings(mut self, inp: HashMap<String, String>) -> Self {
            self.map_of_strings = Some(inp);
            self
        }
        pub fn map_of_structs(mut self, inp: HashMap<String, SimpleStruct>) -> Self {
            self.map_of_structs = Some(inp);
            self
        }
        pub fn recursive_list(mut self, inp: Vec<KitchenSink>) -> Self {
            self.recursive_list = Some(inp);
            self
        }
        pub fn recursive_map(mut self, inp: HashMap<String, KitchenSink>) -> Self {
            self.recursive_map = Some(inp);
            self
        }
        pub fn recursive_struct(mut self, inp: impl Into<Box<KitchenSink>>) -> Self {
            self.recursive_struct = Some(inp.into());
            self
        }
        pub fn simple_struct(mut self, inp: SimpleStruct) -> Self {
            self.simple_struct = Some(inp);
            self
        }
        pub fn string(mut self, inp: impl Into<String>) -> Self {
            self.string = Some(inp.into());
            self
        }
        pub fn struct_with_location_name(mut self, inp: StructWithLocationName) -> Self {
            self.struct_with_location_name = Some(inp);
            self
        }
        pub fn timestamp(mut self, inp: Instant) -> Self {
            self.timestamp = Some(inp);
            self
        }
        pub fn unix_timestamp(mut self, inp: Instant) -> Self {
            self.unix_timestamp = Some(inp);
            self
        }
        /// Consumes the builder and constructs a [`KitchenSinkOperationInput`](crate::operation::KitchenSinkOperationInput)
        pub fn build(self) -> KitchenSinkOperationInput {
            KitchenSinkOperationInput {
                blob: self.blob,
                boolean: self.boolean,
                double: self.double,
                empty_struct: self.empty_struct,
                float: self.float,
                httpdate_timestamp: self.httpdate_timestamp,
                integer: self.integer,
                iso8601_timestamp: self.iso8601_timestamp,
                json_value: self.json_value,
                list_of_lists: self.list_of_lists,
                list_of_maps_of_strings: self.list_of_maps_of_strings,
                list_of_strings: self.list_of_strings,
                list_of_structs: self.list_of_structs,
                long: self.long,
                map_of_lists_of_strings: self.map_of_lists_of_strings,
                map_of_maps: self.map_of_maps,
                map_of_strings: self.map_of_strings,
                map_of_structs: self.map_of_structs,
                recursive_list: self.recursive_list,
                recursive_map: self.recursive_map,
                recursive_struct: self.recursive_struct,
                simple_struct: self.simple_struct,
                string: self.string,
                struct_with_location_name: self.struct_with_location_name,
                timestamp: self.timestamp,
                unix_timestamp: self.unix_timestamp,
            }
        }
    }
}

#[non_exhaustive]
#[derive(::std::clone::Clone, ::std::cmp::PartialEq, ::std::fmt::Debug)]
pub struct EmptyOperationOutput {}
impl EmptyOperationOutput {
    /// Creates a new builder-style object to manufacture [`EmptyOperationOutput`](crate::operation::EmptyOperationOutput)
    pub fn builder() -> crate::operation::empty_operation_output::Builder {
        crate::operation::empty_operation_output::Builder::default()
    }
}
/// See [`EmptyOperationOutput`](crate::operation::EmptyOperationOutput)
pub mod empty_operation_output {

    use crate::operation::EmptyOperationOutput;
    /// A builder for [`EmptyOperationOutput`](crate::operation::EmptyOperationOutput)
    #[non_exhaustive]
    #[derive(Debug, Clone, Default)]
    pub struct Builder {}
    impl Builder {
        /// Consumes the builder and constructs a [`EmptyOperationOutput`](crate::operation::EmptyOperationOutput)
        pub fn build(self) -> EmptyOperationOutput {
            EmptyOperationOutput {}
        }
    }
}

#[non_exhaustive]
#[derive(::std::clone::Clone, ::std::cmp::PartialEq, ::std::fmt::Debug)]
pub struct EmptyOperationInput {}
impl EmptyOperationInput {
    /// Creates a new builder-style object to manufacture [`EmptyOperationInput`](crate::operation::EmptyOperationInput)
    pub fn builder() -> crate::operation::empty_operation_input::Builder {
        crate::operation::empty_operation_input::Builder::default()
    }
}
/// See [`EmptyOperationInput`](crate::operation::EmptyOperationInput)
pub mod empty_operation_input {

    use crate::operation::EmptyOperationInput;
    /// A builder for [`EmptyOperationInput`](crate::operation::EmptyOperationInput)
    #[non_exhaustive]
    #[derive(Debug, Clone, Default)]
    pub struct Builder {}
    impl Builder {
        /// Consumes the builder and constructs a [`EmptyOperationInput`](crate::operation::EmptyOperationInput)
        pub fn build(self) -> EmptyOperationInput {
            EmptyOperationInput {}
        }
    }
}
