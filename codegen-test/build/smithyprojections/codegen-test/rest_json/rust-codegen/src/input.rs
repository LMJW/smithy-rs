// Code generated by software.amazon.smithy.rust.codegen.smithy-rs. DO NOT EDIT.
use crate::model::FooEnum;
use crate::model::GreetingStruct;
use crate::model::MyUnion;
use crate::model::NestedPayload;
use crate::model::RecursiveShapesInputOutputNested1;
use crate::model::StructureListMember;
use smithy_types::Blob;
use smithy_types::Document;
use smithy_types::Instant;
use std::fmt::Write;
/// See [`AllQueryStringTypesInput`](crate::input::AllQueryStringTypesInput)
pub mod all_query_string_types_input {

    use crate::input::AllQueryStringTypesInput;
    use crate::model::FooEnum;
    use crate::operation::AllQueryStringTypes;
    use smithy_types::Instant;
    /// A builder for [`AllQueryStringTypesInput`](crate::input::AllQueryStringTypesInput)
    #[non_exhaustive]
    #[derive(Debug, Clone, Default)]
    pub struct Builder {
        query_string: ::std::option::Option<::std::string::String>,
        query_string_list: ::std::option::Option<::std::vec::Vec<::std::string::String>>,
        query_string_set:
            ::std::option::Option<::std::collections::BTreeSet<::std::string::String>>,
        query_byte: ::std::option::Option<i8>,
        query_short: ::std::option::Option<i16>,
        query_integer: ::std::option::Option<i32>,
        query_integer_list: ::std::option::Option<::std::vec::Vec<i32>>,
        query_integer_set: ::std::option::Option<::std::vec::Vec<i32>>,
        query_long: ::std::option::Option<i64>,
        query_float: ::std::option::Option<f32>,
        query_double: ::std::option::Option<f64>,
        query_double_list: ::std::option::Option<::std::vec::Vec<f64>>,
        query_boolean: ::std::option::Option<bool>,
        query_boolean_list: ::std::option::Option<::std::vec::Vec<bool>>,
        query_timestamp: ::std::option::Option<Instant>,
        query_timestamp_list: ::std::option::Option<::std::vec::Vec<Instant>>,
        query_enum: ::std::option::Option<FooEnum>,
        query_enum_list: ::std::option::Option<::std::vec::Vec<FooEnum>>,
    }
    impl Builder {
        pub fn query_string(mut self, inp: impl Into<::std::string::String>) -> Self {
            self.query_string = Some(inp.into());
            self
        }
        pub fn query_string_list(mut self, inp: ::std::vec::Vec<::std::string::String>) -> Self {
            self.query_string_list = Some(inp);
            self
        }
        pub fn query_string_set(
            mut self,
            inp: ::std::collections::BTreeSet<::std::string::String>,
        ) -> Self {
            self.query_string_set = Some(inp);
            self
        }
        pub fn query_byte(mut self, inp: i8) -> Self {
            self.query_byte = Some(inp);
            self
        }
        pub fn query_short(mut self, inp: i16) -> Self {
            self.query_short = Some(inp);
            self
        }
        pub fn query_integer(mut self, inp: i32) -> Self {
            self.query_integer = Some(inp);
            self
        }
        pub fn query_integer_list(mut self, inp: ::std::vec::Vec<i32>) -> Self {
            self.query_integer_list = Some(inp);
            self
        }
        pub fn query_integer_set(mut self, inp: ::std::vec::Vec<i32>) -> Self {
            self.query_integer_set = Some(inp);
            self
        }
        pub fn query_long(mut self, inp: i64) -> Self {
            self.query_long = Some(inp);
            self
        }
        pub fn query_float(mut self, inp: f32) -> Self {
            self.query_float = Some(inp);
            self
        }
        pub fn query_double(mut self, inp: f64) -> Self {
            self.query_double = Some(inp);
            self
        }
        pub fn query_double_list(mut self, inp: ::std::vec::Vec<f64>) -> Self {
            self.query_double_list = Some(inp);
            self
        }
        pub fn query_boolean(mut self, inp: bool) -> Self {
            self.query_boolean = Some(inp);
            self
        }
        pub fn query_boolean_list(mut self, inp: ::std::vec::Vec<bool>) -> Self {
            self.query_boolean_list = Some(inp);
            self
        }
        pub fn query_timestamp(mut self, inp: Instant) -> Self {
            self.query_timestamp = Some(inp);
            self
        }
        pub fn query_timestamp_list(mut self, inp: ::std::vec::Vec<Instant>) -> Self {
            self.query_timestamp_list = Some(inp);
            self
        }
        pub fn query_enum(mut self, inp: FooEnum) -> Self {
            self.query_enum = Some(inp);
            self
        }
        pub fn query_enum_list(mut self, inp: ::std::vec::Vec<FooEnum>) -> Self {
            self.query_enum_list = Some(inp);
            self
        }
        /// Consumes the builder and constructs a [`AllQueryStringTypes`](crate::operation::AllQueryStringTypes)
        pub fn build(self) -> AllQueryStringTypes {
            AllQueryStringTypes::new(AllQueryStringTypesInput {
                query_string: self.query_string,
                query_string_list: self.query_string_list,
                query_string_set: self.query_string_set,
                query_byte: self.query_byte,
                query_short: self.query_short,
                query_integer: self.query_integer,
                query_integer_list: self.query_integer_list,
                query_integer_set: self.query_integer_set,
                query_long: self.query_long,
                query_float: self.query_float,
                query_double: self.query_double,
                query_double_list: self.query_double_list,
                query_boolean: self.query_boolean,
                query_boolean_list: self.query_boolean_list,
                query_timestamp: self.query_timestamp,
                query_timestamp_list: self.query_timestamp_list,
                query_enum: self.query_enum,
                query_enum_list: self.query_enum_list,
            })
        }
    }
}
impl AllQueryStringTypesInput {
    fn uri_base(&self, output: &mut String) {
        write!(output, "/AllQueryStringTypesInput").expect("formatting should succeed")
    }
    fn uri_query(&self, output: &mut String) {
        let mut params = Vec::new();
        if let Some(inner_1) = &self.query_string {
            params.push(("String", ::smithy_http::query::fmt_string(&inner_1)))
        }
        if let Some(inner_2) = &self.query_string_list {
            for inner_3 in inner_2 {
                params.push(("StringList", ::smithy_http::query::fmt_string(&inner_3)))
            }
        }
        if let Some(inner_4) = &self.query_string_set {
            for inner_5 in inner_4 {
                params.push(("StringSet", ::smithy_http::query::fmt_string(&inner_5)))
            }
        }
        if let Some(inner_6) = &self.query_byte {
            params.push(("Byte", ::smithy_http::query::fmt_default(&inner_6)))
        }
        if let Some(inner_7) = &self.query_short {
            params.push(("Short", ::smithy_http::query::fmt_default(&inner_7)))
        }
        if let Some(inner_8) = &self.query_integer {
            params.push(("Integer", ::smithy_http::query::fmt_default(&inner_8)))
        }
        if let Some(inner_9) = &self.query_integer_list {
            for inner_10 in inner_9 {
                params.push(("IntegerList", ::smithy_http::query::fmt_default(&inner_10)))
            }
        }
        if let Some(inner_11) = &self.query_integer_set {
            for inner_12 in inner_11 {
                params.push(("IntegerSet", ::smithy_http::query::fmt_default(&inner_12)))
            }
        }
        if let Some(inner_13) = &self.query_long {
            params.push(("Long", ::smithy_http::query::fmt_default(&inner_13)))
        }
        if let Some(inner_14) = &self.query_float {
            params.push(("Float", ::smithy_http::query::fmt_default(&inner_14)))
        }
        if let Some(inner_15) = &self.query_double {
            params.push(("Double", ::smithy_http::query::fmt_default(&inner_15)))
        }
        if let Some(inner_16) = &self.query_double_list {
            for inner_17 in inner_16 {
                params.push(("DoubleList", ::smithy_http::query::fmt_default(&inner_17)))
            }
        }
        if let Some(inner_18) = &self.query_boolean {
            params.push(("Boolean", ::smithy_http::query::fmt_default(&inner_18)))
        }
        if let Some(inner_19) = &self.query_boolean_list {
            for inner_20 in inner_19 {
                params.push(("BooleanList", ::smithy_http::query::fmt_default(&inner_20)))
            }
        }
        if let Some(inner_21) = &self.query_timestamp {
            params.push((
                "Timestamp",
                ::smithy_http::query::fmt_timestamp(
                    inner_21,
                    ::smithy_types::instant::Format::DateTime,
                ),
            ))
        }
        if let Some(inner_22) = &self.query_timestamp_list {
            for inner_23 in inner_22 {
                params.push((
                    "TimestampList",
                    ::smithy_http::query::fmt_timestamp(
                        inner_23,
                        ::smithy_types::instant::Format::DateTime,
                    ),
                ))
            }
        }
        if let Some(inner_24) = &self.query_enum {
            params.push(("Enum", ::smithy_http::query::fmt_string(&inner_24.as_str())))
        }
        if let Some(inner_25) = &self.query_enum_list {
            for inner_26 in inner_25 {
                params.push((
                    "EnumList",
                    ::smithy_http::query::fmt_string(&inner_26.as_str()),
                ))
            }
        }
        ::smithy_http::query::write(params, output)
    }
    fn update_http_builder(&self, builder: ::http::request::Builder) -> ::http::request::Builder {
        let mut uri = String::new();
        self.uri_base(&mut uri);
        self.uri_query(&mut uri);
        builder.method("GET").uri(uri)
    }
    pub fn request_builder_base(&self) -> ::http::request::Builder {
        let builder = ::http::request::Builder::new();
        let builder = builder.header("Content-Type", "application/json");
        self.update_http_builder(builder)
    }
    pub fn build_body(&self) -> ::std::vec::Vec<u8> {
        todo!()
    }
    pub fn assemble(
        builder: ::http::request::Builder,
        body: ::std::vec::Vec<u8>,
    ) -> ::http::request::Request<::std::vec::Vec<u8>> {
        builder
            .header(::http::header::CONTENT_LENGTH, body.len())
            .body(body)
            .expect("http request should be valid")
    }
    /// Creates a new builder-style object to manufacture [`AllQueryStringTypesInput`](crate::input::AllQueryStringTypesInput)
    pub fn builder() -> crate::input::all_query_string_types_input::Builder {
        crate::input::all_query_string_types_input::Builder::default()
    }
}

/// See [`ConstantAndVariableQueryStringInput`](crate::input::ConstantAndVariableQueryStringInput)
pub mod constant_and_variable_query_string_input {

    use crate::input::ConstantAndVariableQueryStringInput;
    use crate::operation::ConstantAndVariableQueryString;
    /// A builder for [`ConstantAndVariableQueryStringInput`](crate::input::ConstantAndVariableQueryStringInput)
    #[non_exhaustive]
    #[derive(Debug, Clone, Default)]
    pub struct Builder {
        baz: ::std::option::Option<::std::string::String>,
        maybe_set: ::std::option::Option<::std::string::String>,
    }
    impl Builder {
        pub fn baz(mut self, inp: impl Into<::std::string::String>) -> Self {
            self.baz = Some(inp.into());
            self
        }
        pub fn maybe_set(mut self, inp: impl Into<::std::string::String>) -> Self {
            self.maybe_set = Some(inp.into());
            self
        }
        /// Consumes the builder and constructs a [`ConstantAndVariableQueryString`](crate::operation::ConstantAndVariableQueryString)
        pub fn build(self) -> ConstantAndVariableQueryString {
            ConstantAndVariableQueryString::new(ConstantAndVariableQueryStringInput {
                baz: self.baz,
                maybe_set: self.maybe_set,
            })
        }
    }
}
impl ConstantAndVariableQueryStringInput {
    fn uri_base(&self, output: &mut String) {
        write!(output, "/ConstantAndVariableQueryString").expect("formatting should succeed")
    }
    fn uri_query(&self, output: &mut String) {
        let mut params = Vec::new();
        if let Some(inner_27) = &self.baz {
            params.push(("baz", ::smithy_http::query::fmt_string(&inner_27)))
        }
        if let Some(inner_28) = &self.maybe_set {
            params.push(("maybeSet", ::smithy_http::query::fmt_string(&inner_28)))
        }
        ::smithy_http::query::write(params, output)
    }
    fn update_http_builder(&self, builder: ::http::request::Builder) -> ::http::request::Builder {
        let mut uri = String::new();
        self.uri_base(&mut uri);
        self.uri_query(&mut uri);
        builder.method("GET").uri(uri)
    }
    pub fn request_builder_base(&self) -> ::http::request::Builder {
        let builder = ::http::request::Builder::new();
        let builder = builder.header("Content-Type", "application/json");
        self.update_http_builder(builder)
    }
    pub fn build_body(&self) -> ::std::vec::Vec<u8> {
        todo!()
    }
    pub fn assemble(
        builder: ::http::request::Builder,
        body: ::std::vec::Vec<u8>,
    ) -> ::http::request::Request<::std::vec::Vec<u8>> {
        builder
            .header(::http::header::CONTENT_LENGTH, body.len())
            .body(body)
            .expect("http request should be valid")
    }
    /// Creates a new builder-style object to manufacture [`ConstantAndVariableQueryStringInput`](crate::input::ConstantAndVariableQueryStringInput)
    pub fn builder() -> crate::input::constant_and_variable_query_string_input::Builder {
        crate::input::constant_and_variable_query_string_input::Builder::default()
    }
}

/// See [`ConstantQueryStringInput`](crate::input::ConstantQueryStringInput)
pub mod constant_query_string_input {

    use crate::input::ConstantQueryStringInput;
    use crate::operation::ConstantQueryString;
    /// A builder for [`ConstantQueryStringInput`](crate::input::ConstantQueryStringInput)
    #[non_exhaustive]
    #[derive(Debug, Clone, Default)]
    pub struct Builder {
        hello: ::std::option::Option<::std::string::String>,
    }
    impl Builder {
        pub fn hello(mut self, inp: impl Into<::std::string::String>) -> Self {
            self.hello = Some(inp.into());
            self
        }
        /// Consumes the builder and constructs a [`ConstantQueryString`](crate::operation::ConstantQueryString)
        pub fn build(self) -> ConstantQueryString {
            ConstantQueryString::new(ConstantQueryStringInput {
                hello: self.hello.unwrap_or_default(),
            })
        }
    }
}
impl ConstantQueryStringInput {
    fn uri_base(&self, output: &mut String) {
        write!(
            output,
            "/ConstantQueryString/{hello}",
            hello = ::smithy_http::label::fmt_string(&self.hello, false)
        )
        .expect("formatting should succeed")
    }
    fn update_http_builder(&self, builder: ::http::request::Builder) -> ::http::request::Builder {
        let mut uri = String::new();
        self.uri_base(&mut uri);
        builder.method("GET").uri(uri)
    }
    pub fn request_builder_base(&self) -> ::http::request::Builder {
        let builder = ::http::request::Builder::new();
        let builder = builder.header("Content-Type", "application/json");
        self.update_http_builder(builder)
    }
    pub fn build_body(&self) -> ::std::vec::Vec<u8> {
        todo!()
    }
    pub fn assemble(
        builder: ::http::request::Builder,
        body: ::std::vec::Vec<u8>,
    ) -> ::http::request::Request<::std::vec::Vec<u8>> {
        builder
            .header(::http::header::CONTENT_LENGTH, body.len())
            .body(body)
            .expect("http request should be valid")
    }
    /// Creates a new builder-style object to manufacture [`ConstantQueryStringInput`](crate::input::ConstantQueryStringInput)
    pub fn builder() -> crate::input::constant_query_string_input::Builder {
        crate::input::constant_query_string_input::Builder::default()
    }
}

/// See [`EmptyInputAndEmptyOutputInput`](crate::input::EmptyInputAndEmptyOutputInput)
pub mod empty_input_and_empty_output_input {

    use crate::input::EmptyInputAndEmptyOutputInput;
    use crate::operation::EmptyInputAndEmptyOutput;
    /// A builder for [`EmptyInputAndEmptyOutputInput`](crate::input::EmptyInputAndEmptyOutputInput)
    #[non_exhaustive]
    #[derive(Debug, Clone, Default)]
    pub struct Builder {}
    impl Builder {
        /// Consumes the builder and constructs a [`EmptyInputAndEmptyOutput`](crate::operation::EmptyInputAndEmptyOutput)
        pub fn build(self) -> EmptyInputAndEmptyOutput {
            EmptyInputAndEmptyOutput::new(EmptyInputAndEmptyOutputInput {})
        }
    }
}
impl EmptyInputAndEmptyOutputInput {
    fn uri_base(&self, output: &mut String) {
        write!(output, "/EmptyInputAndEmptyOutput").expect("formatting should succeed")
    }
    fn update_http_builder(&self, builder: ::http::request::Builder) -> ::http::request::Builder {
        let mut uri = String::new();
        self.uri_base(&mut uri);
        builder.method("POST").uri(uri)
    }
    pub fn request_builder_base(&self) -> ::http::request::Builder {
        let builder = ::http::request::Builder::new();
        let builder = builder.header("Content-Type", "application/json");
        self.update_http_builder(builder)
    }
    pub fn build_body(&self) -> ::std::vec::Vec<u8> {
        todo!()
    }
    pub fn assemble(
        builder: ::http::request::Builder,
        body: ::std::vec::Vec<u8>,
    ) -> ::http::request::Request<::std::vec::Vec<u8>> {
        builder
            .header(::http::header::CONTENT_LENGTH, body.len())
            .body(body)
            .expect("http request should be valid")
    }
    /// Creates a new builder-style object to manufacture [`EmptyInputAndEmptyOutputInput`](crate::input::EmptyInputAndEmptyOutputInput)
    pub fn builder() -> crate::input::empty_input_and_empty_output_input::Builder {
        crate::input::empty_input_and_empty_output_input::Builder::default()
    }
}

/// See [`GreetingWithErrorsInput`](crate::input::GreetingWithErrorsInput)
pub mod greeting_with_errors_input {

    use crate::input::GreetingWithErrorsInput;
    use crate::operation::GreetingWithErrors;
    /// A builder for [`GreetingWithErrorsInput`](crate::input::GreetingWithErrorsInput)
    #[non_exhaustive]
    #[derive(Debug, Clone, Default)]
    pub struct Builder {}
    impl Builder {
        /// Consumes the builder and constructs a [`GreetingWithErrors`](crate::operation::GreetingWithErrors)
        pub fn build(self) -> GreetingWithErrors {
            GreetingWithErrors::new(GreetingWithErrorsInput {})
        }
    }
}
impl GreetingWithErrorsInput {
    fn uri_base(&self, output: &mut String) {
        write!(output, "/GreetingWithErrors").expect("formatting should succeed")
    }
    fn update_http_builder(&self, builder: ::http::request::Builder) -> ::http::request::Builder {
        let mut uri = String::new();
        self.uri_base(&mut uri);
        builder.method("PUT").uri(uri)
    }
    pub fn request_builder_base(&self) -> ::http::request::Builder {
        let builder = ::http::request::Builder::new();
        let builder = builder.header("Content-Type", "application/json");
        self.update_http_builder(builder)
    }
    pub fn build_body(&self) -> ::std::vec::Vec<u8> {
        todo!()
    }
    pub fn assemble(
        builder: ::http::request::Builder,
        body: ::std::vec::Vec<u8>,
    ) -> ::http::request::Request<::std::vec::Vec<u8>> {
        builder
            .header(::http::header::CONTENT_LENGTH, body.len())
            .body(body)
            .expect("http request should be valid")
    }
    /// Creates a new builder-style object to manufacture [`GreetingWithErrorsInput`](crate::input::GreetingWithErrorsInput)
    pub fn builder() -> crate::input::greeting_with_errors_input::Builder {
        crate::input::greeting_with_errors_input::Builder::default()
    }
}

/// See [`HttpPayloadTraitsInput`](crate::input::HttpPayloadTraitsInput)
pub mod http_payload_traits_input {

    use crate::input::HttpPayloadTraitsInput;
    use crate::operation::HttpPayloadTraits;
    use smithy_types::Blob;
    /// A builder for [`HttpPayloadTraitsInput`](crate::input::HttpPayloadTraitsInput)
    #[non_exhaustive]
    #[derive(Debug, Clone, Default)]
    pub struct Builder {
        foo: ::std::option::Option<::std::string::String>,
        blob: ::std::option::Option<Blob>,
    }
    impl Builder {
        pub fn foo(mut self, inp: impl Into<::std::string::String>) -> Self {
            self.foo = Some(inp.into());
            self
        }
        pub fn blob(mut self, inp: Blob) -> Self {
            self.blob = Some(inp);
            self
        }
        /// Consumes the builder and constructs a [`HttpPayloadTraits`](crate::operation::HttpPayloadTraits)
        pub fn build(self) -> HttpPayloadTraits {
            HttpPayloadTraits::new(HttpPayloadTraitsInput {
                foo: self.foo,
                blob: self.blob,
            })
        }
    }
}
impl HttpPayloadTraitsInput {
    fn uri_base(&self, output: &mut String) {
        write!(output, "/HttpPayloadTraits").expect("formatting should succeed")
    }
    fn add_headers(&self, mut builder: ::http::request::Builder) -> ::http::request::Builder {
        if let Some(inner_29) = &self.foo {
            let formatted_30 = ::smithy_http::query::fmt_string(&inner_29);
            if !formatted_30.is_empty() {
                builder = builder.header("X-Foo", ::smithy_http::query::fmt_string(&inner_29));
            }
        }
        builder
    }
    fn update_http_builder(&self, builder: ::http::request::Builder) -> ::http::request::Builder {
        let mut uri = String::new();
        self.uri_base(&mut uri);
        let builder = self.add_headers(builder);
        builder.method("POST").uri(uri)
    }
    pub fn request_builder_base(&self) -> ::http::request::Builder {
        let builder = ::http::request::Builder::new();
        let builder = builder.header("Content-Type", "application/octet-stream");
        self.update_http_builder(builder)
    }
    pub fn build_body(&self) -> ::std::vec::Vec<u8> {
        todo!()
    }
    pub fn assemble(
        builder: ::http::request::Builder,
        body: ::std::vec::Vec<u8>,
    ) -> ::http::request::Request<::std::vec::Vec<u8>> {
        builder
            .header(::http::header::CONTENT_LENGTH, body.len())
            .body(body)
            .expect("http request should be valid")
    }
    /// Creates a new builder-style object to manufacture [`HttpPayloadTraitsInput`](crate::input::HttpPayloadTraitsInput)
    pub fn builder() -> crate::input::http_payload_traits_input::Builder {
        crate::input::http_payload_traits_input::Builder::default()
    }
}

/// See [`HttpPayloadTraitsWithMediaTypeInput`](crate::input::HttpPayloadTraitsWithMediaTypeInput)
pub mod http_payload_traits_with_media_type_input {

    use crate::input::HttpPayloadTraitsWithMediaTypeInput;
    use crate::operation::HttpPayloadTraitsWithMediaType;
    use smithy_types::Blob;
    /// A builder for [`HttpPayloadTraitsWithMediaTypeInput`](crate::input::HttpPayloadTraitsWithMediaTypeInput)
    #[non_exhaustive]
    #[derive(Debug, Clone, Default)]
    pub struct Builder {
        foo: ::std::option::Option<::std::string::String>,
        blob: ::std::option::Option<Blob>,
    }
    impl Builder {
        pub fn foo(mut self, inp: impl Into<::std::string::String>) -> Self {
            self.foo = Some(inp.into());
            self
        }
        pub fn blob(mut self, inp: Blob) -> Self {
            self.blob = Some(inp);
            self
        }
        /// Consumes the builder and constructs a [`HttpPayloadTraitsWithMediaType`](crate::operation::HttpPayloadTraitsWithMediaType)
        pub fn build(self) -> HttpPayloadTraitsWithMediaType {
            HttpPayloadTraitsWithMediaType::new(HttpPayloadTraitsWithMediaTypeInput {
                foo: self.foo,
                blob: self.blob,
            })
        }
    }
}
impl HttpPayloadTraitsWithMediaTypeInput {
    fn uri_base(&self, output: &mut String) {
        write!(output, "/HttpPayloadTraitsWithMediaType").expect("formatting should succeed")
    }
    fn add_headers(&self, mut builder: ::http::request::Builder) -> ::http::request::Builder {
        if let Some(inner_31) = &self.foo {
            let formatted_32 = ::smithy_http::query::fmt_string(&inner_31);
            if !formatted_32.is_empty() {
                builder = builder.header("X-Foo", ::smithy_http::query::fmt_string(&inner_31));
            }
        }
        builder
    }
    fn update_http_builder(&self, builder: ::http::request::Builder) -> ::http::request::Builder {
        let mut uri = String::new();
        self.uri_base(&mut uri);
        let builder = self.add_headers(builder);
        builder.method("POST").uri(uri)
    }
    pub fn request_builder_base(&self) -> ::http::request::Builder {
        let builder = ::http::request::Builder::new();
        let builder = builder.header("Content-Type", "text/plain");
        self.update_http_builder(builder)
    }
    pub fn build_body(&self) -> ::std::vec::Vec<u8> {
        todo!()
    }
    pub fn assemble(
        builder: ::http::request::Builder,
        body: ::std::vec::Vec<u8>,
    ) -> ::http::request::Request<::std::vec::Vec<u8>> {
        builder
            .header(::http::header::CONTENT_LENGTH, body.len())
            .body(body)
            .expect("http request should be valid")
    }
    /// Creates a new builder-style object to manufacture [`HttpPayloadTraitsWithMediaTypeInput`](crate::input::HttpPayloadTraitsWithMediaTypeInput)
    pub fn builder() -> crate::input::http_payload_traits_with_media_type_input::Builder {
        crate::input::http_payload_traits_with_media_type_input::Builder::default()
    }
}

/// See [`HttpPayloadWithStructureInput`](crate::input::HttpPayloadWithStructureInput)
pub mod http_payload_with_structure_input {

    use crate::input::HttpPayloadWithStructureInput;
    use crate::model::NestedPayload;
    use crate::operation::HttpPayloadWithStructure;
    /// A builder for [`HttpPayloadWithStructureInput`](crate::input::HttpPayloadWithStructureInput)
    #[non_exhaustive]
    #[derive(Debug, Clone, Default)]
    pub struct Builder {
        nested: ::std::option::Option<NestedPayload>,
    }
    impl Builder {
        pub fn nested(mut self, inp: NestedPayload) -> Self {
            self.nested = Some(inp);
            self
        }
        /// Consumes the builder and constructs a [`HttpPayloadWithStructure`](crate::operation::HttpPayloadWithStructure)
        pub fn build(self) -> HttpPayloadWithStructure {
            HttpPayloadWithStructure::new(HttpPayloadWithStructureInput {
                nested: self.nested,
            })
        }
    }
}
impl HttpPayloadWithStructureInput {
    fn uri_base(&self, output: &mut String) {
        write!(output, "/HttpPayloadWithStructure").expect("formatting should succeed")
    }
    fn update_http_builder(&self, builder: ::http::request::Builder) -> ::http::request::Builder {
        let mut uri = String::new();
        self.uri_base(&mut uri);
        builder.method("PUT").uri(uri)
    }
    pub fn request_builder_base(&self) -> ::http::request::Builder {
        let builder = ::http::request::Builder::new();
        let builder = builder.header("Content-Type", "application/json");
        self.update_http_builder(builder)
    }
    pub fn build_body(&self) -> ::std::vec::Vec<u8> {
        todo!()
    }
    pub fn assemble(
        builder: ::http::request::Builder,
        body: ::std::vec::Vec<u8>,
    ) -> ::http::request::Request<::std::vec::Vec<u8>> {
        builder
            .header(::http::header::CONTENT_LENGTH, body.len())
            .body(body)
            .expect("http request should be valid")
    }
    /// Creates a new builder-style object to manufacture [`HttpPayloadWithStructureInput`](crate::input::HttpPayloadWithStructureInput)
    pub fn builder() -> crate::input::http_payload_with_structure_input::Builder {
        crate::input::http_payload_with_structure_input::Builder::default()
    }
}

/// See [`HttpPrefixHeadersInput`](crate::input::HttpPrefixHeadersInput)
pub mod http_prefix_headers_input {

    use crate::input::HttpPrefixHeadersInput;
    use crate::operation::HttpPrefixHeaders;
    /// A builder for [`HttpPrefixHeadersInput`](crate::input::HttpPrefixHeadersInput)
    #[non_exhaustive]
    #[derive(Debug, Clone, Default)]
    pub struct Builder {
        foo: ::std::option::Option<::std::string::String>,
        foo_map: ::std::option::Option<
            ::std::collections::HashMap<::std::string::String, ::std::string::String>,
        >,
    }
    impl Builder {
        pub fn foo(mut self, inp: impl Into<::std::string::String>) -> Self {
            self.foo = Some(inp.into());
            self
        }
        pub fn foo_map(
            mut self,
            inp: ::std::collections::HashMap<::std::string::String, ::std::string::String>,
        ) -> Self {
            self.foo_map = Some(inp);
            self
        }
        /// Consumes the builder and constructs a [`HttpPrefixHeaders`](crate::operation::HttpPrefixHeaders)
        pub fn build(self) -> HttpPrefixHeaders {
            HttpPrefixHeaders::new(HttpPrefixHeadersInput {
                foo: self.foo,
                foo_map: self.foo_map,
            })
        }
    }
}
impl HttpPrefixHeadersInput {
    fn uri_base(&self, output: &mut String) {
        write!(output, "/HttpPrefixHeaders").expect("formatting should succeed")
    }
    fn add_headers(&self, mut builder: ::http::request::Builder) -> ::http::request::Builder {
        if let Some(inner_33) = &self.foo {
            let formatted_34 = ::smithy_http::query::fmt_string(&inner_33);
            if !formatted_34.is_empty() {
                builder = builder.header("X-Foo", ::smithy_http::query::fmt_string(&inner_33));
            }
        }
        builder
    }
    fn update_http_builder(&self, builder: ::http::request::Builder) -> ::http::request::Builder {
        let mut uri = String::new();
        self.uri_base(&mut uri);
        let builder = self.add_headers(builder);
        builder.method("GET").uri(uri)
    }
    pub fn request_builder_base(&self) -> ::http::request::Builder {
        let builder = ::http::request::Builder::new();
        let builder = builder.header("Content-Type", "application/json");
        self.update_http_builder(builder)
    }
    pub fn build_body(&self) -> ::std::vec::Vec<u8> {
        todo!()
    }
    pub fn assemble(
        builder: ::http::request::Builder,
        body: ::std::vec::Vec<u8>,
    ) -> ::http::request::Request<::std::vec::Vec<u8>> {
        builder
            .header(::http::header::CONTENT_LENGTH, body.len())
            .body(body)
            .expect("http request should be valid")
    }
    /// Creates a new builder-style object to manufacture [`HttpPrefixHeadersInput`](crate::input::HttpPrefixHeadersInput)
    pub fn builder() -> crate::input::http_prefix_headers_input::Builder {
        crate::input::http_prefix_headers_input::Builder::default()
    }
}

/// See [`HttpPrefixHeadersResponseInput`](crate::input::HttpPrefixHeadersResponseInput)
pub mod http_prefix_headers_response_input {

    use crate::input::HttpPrefixHeadersResponseInput;
    use crate::operation::HttpPrefixHeadersResponse;
    /// A builder for [`HttpPrefixHeadersResponseInput`](crate::input::HttpPrefixHeadersResponseInput)
    #[non_exhaustive]
    #[derive(Debug, Clone, Default)]
    pub struct Builder {}
    impl Builder {
        /// Consumes the builder and constructs a [`HttpPrefixHeadersResponse`](crate::operation::HttpPrefixHeadersResponse)
        pub fn build(self) -> HttpPrefixHeadersResponse {
            HttpPrefixHeadersResponse::new(HttpPrefixHeadersResponseInput {})
        }
    }
}
impl HttpPrefixHeadersResponseInput {
    fn uri_base(&self, output: &mut String) {
        write!(output, "/HttpPrefixHeadersResponse").expect("formatting should succeed")
    }
    fn update_http_builder(&self, builder: ::http::request::Builder) -> ::http::request::Builder {
        let mut uri = String::new();
        self.uri_base(&mut uri);
        builder.method("GET").uri(uri)
    }
    pub fn request_builder_base(&self) -> ::http::request::Builder {
        let builder = ::http::request::Builder::new();
        let builder = builder.header("Content-Type", "application/json");
        self.update_http_builder(builder)
    }
    pub fn build_body(&self) -> ::std::vec::Vec<u8> {
        todo!()
    }
    pub fn assemble(
        builder: ::http::request::Builder,
        body: ::std::vec::Vec<u8>,
    ) -> ::http::request::Request<::std::vec::Vec<u8>> {
        builder
            .header(::http::header::CONTENT_LENGTH, body.len())
            .body(body)
            .expect("http request should be valid")
    }
    /// Creates a new builder-style object to manufacture [`HttpPrefixHeadersResponseInput`](crate::input::HttpPrefixHeadersResponseInput)
    pub fn builder() -> crate::input::http_prefix_headers_response_input::Builder {
        crate::input::http_prefix_headers_response_input::Builder::default()
    }
}

/// See [`HttpRequestWithGreedyLabelInPathInput`](crate::input::HttpRequestWithGreedyLabelInPathInput)
pub mod http_request_with_greedy_label_in_path_input {

    use crate::input::HttpRequestWithGreedyLabelInPathInput;
    use crate::operation::HttpRequestWithGreedyLabelInPath;
    /// A builder for [`HttpRequestWithGreedyLabelInPathInput`](crate::input::HttpRequestWithGreedyLabelInPathInput)
    #[non_exhaustive]
    #[derive(Debug, Clone, Default)]
    pub struct Builder {
        foo: ::std::option::Option<::std::string::String>,
        baz: ::std::option::Option<::std::string::String>,
    }
    impl Builder {
        pub fn foo(mut self, inp: impl Into<::std::string::String>) -> Self {
            self.foo = Some(inp.into());
            self
        }
        pub fn baz(mut self, inp: impl Into<::std::string::String>) -> Self {
            self.baz = Some(inp.into());
            self
        }
        /// Consumes the builder and constructs a [`HttpRequestWithGreedyLabelInPath`](crate::operation::HttpRequestWithGreedyLabelInPath)
        pub fn build(self) -> HttpRequestWithGreedyLabelInPath {
            HttpRequestWithGreedyLabelInPath::new(HttpRequestWithGreedyLabelInPathInput {
                foo: self.foo.unwrap_or_default(),
                baz: self.baz.unwrap_or_default(),
            })
        }
    }
}
impl HttpRequestWithGreedyLabelInPathInput {
    fn uri_base(&self, output: &mut String) {
        write!(
            output,
            "/HttpRequestWithGreedyLabelInPath/foo/{foo}/baz/{baz}",
            foo = ::smithy_http::label::fmt_string(&self.foo, false),
            baz = ::smithy_http::label::fmt_string(&self.baz, true)
        )
        .expect("formatting should succeed")
    }
    fn update_http_builder(&self, builder: ::http::request::Builder) -> ::http::request::Builder {
        let mut uri = String::new();
        self.uri_base(&mut uri);
        builder.method("GET").uri(uri)
    }
    pub fn request_builder_base(&self) -> ::http::request::Builder {
        let builder = ::http::request::Builder::new();
        let builder = builder.header("Content-Type", "application/json");
        self.update_http_builder(builder)
    }
    pub fn build_body(&self) -> ::std::vec::Vec<u8> {
        todo!()
    }
    pub fn assemble(
        builder: ::http::request::Builder,
        body: ::std::vec::Vec<u8>,
    ) -> ::http::request::Request<::std::vec::Vec<u8>> {
        builder
            .header(::http::header::CONTENT_LENGTH, body.len())
            .body(body)
            .expect("http request should be valid")
    }
    /// Creates a new builder-style object to manufacture [`HttpRequestWithGreedyLabelInPathInput`](crate::input::HttpRequestWithGreedyLabelInPathInput)
    pub fn builder() -> crate::input::http_request_with_greedy_label_in_path_input::Builder {
        crate::input::http_request_with_greedy_label_in_path_input::Builder::default()
    }
}

/// See [`HttpRequestWithLabelsInput`](crate::input::HttpRequestWithLabelsInput)
pub mod http_request_with_labels_input {

    use crate::input::HttpRequestWithLabelsInput;
    use crate::operation::HttpRequestWithLabels;
    use smithy_types::Instant;
    /// A builder for [`HttpRequestWithLabelsInput`](crate::input::HttpRequestWithLabelsInput)
    #[non_exhaustive]
    #[derive(Debug, Clone, Default)]
    pub struct Builder {
        string: ::std::option::Option<::std::string::String>,
        short: ::std::option::Option<i16>,
        integer: ::std::option::Option<i32>,
        long: ::std::option::Option<i64>,
        float: ::std::option::Option<f32>,
        double: ::std::option::Option<f64>,
        boolean: ::std::option::Option<bool>,
        timestamp: ::std::option::Option<Instant>,
    }
    impl Builder {
        pub fn string(mut self, inp: impl Into<::std::string::String>) -> Self {
            self.string = Some(inp.into());
            self
        }
        pub fn short(mut self, inp: i16) -> Self {
            self.short = Some(inp);
            self
        }
        pub fn integer(mut self, inp: i32) -> Self {
            self.integer = Some(inp);
            self
        }
        pub fn long(mut self, inp: i64) -> Self {
            self.long = Some(inp);
            self
        }
        pub fn float(mut self, inp: f32) -> Self {
            self.float = Some(inp);
            self
        }
        pub fn double(mut self, inp: f64) -> Self {
            self.double = Some(inp);
            self
        }
        /// Serialized in the path as true or false.
        pub fn boolean(mut self, inp: bool) -> Self {
            self.boolean = Some(inp);
            self
        }
        /// Note that this member has no format, so it's serialized as an RFC 3399 date-time.
        pub fn timestamp(mut self, inp: Instant) -> Self {
            self.timestamp = Some(inp);
            self
        }
        /// Consumes the builder and constructs a [`HttpRequestWithLabels`](crate::operation::HttpRequestWithLabels)
        pub fn build(self) -> Result<HttpRequestWithLabels, String> {
            Ok(HttpRequestWithLabels::new(HttpRequestWithLabelsInput {
                string: self.string.unwrap_or_default(),
                short: self.short.unwrap_or_default(),
                integer: self.integer.unwrap_or_default(),
                long: self.long.unwrap_or_default(),
                float: self.float.unwrap_or_default(),
                double: self.double.unwrap_or_default(),
                boolean: self.boolean.unwrap_or_default(),
                timestamp: self
                    .timestamp
                    .ok_or("timestamp is required when building HttpRequestWithLabelsInput")?,
            }))
        }
    }
}
impl HttpRequestWithLabelsInput {
    fn uri_base(&self, output: &mut String) {
        write!(output, "/HttpRequestWithLabels/{string}/{short}/{integer}/{long}/{float}/{double}/{boolean}/{timestamp}", string = ::smithy_http::label::fmt_string(&self.string, false), short = ::smithy_http::label::fmt_default(&self.short), integer = ::smithy_http::label::fmt_default(&self.integer), long = ::smithy_http::label::fmt_default(&self.long), float = ::smithy_http::label::fmt_default(&self.float), double = ::smithy_http::label::fmt_default(&self.double), boolean = ::smithy_http::label::fmt_default(&self.boolean), timestamp = ::smithy_http::label::fmt_timestamp(&self.timestamp, ::smithy_types::instant::Format::DateTime)).expect("formatting should succeed")
    }
    fn update_http_builder(&self, builder: ::http::request::Builder) -> ::http::request::Builder {
        let mut uri = String::new();
        self.uri_base(&mut uri);
        builder.method("GET").uri(uri)
    }
    pub fn request_builder_base(&self) -> ::http::request::Builder {
        let builder = ::http::request::Builder::new();
        let builder = builder.header("Content-Type", "application/json");
        self.update_http_builder(builder)
    }
    pub fn build_body(&self) -> ::std::vec::Vec<u8> {
        todo!()
    }
    pub fn assemble(
        builder: ::http::request::Builder,
        body: ::std::vec::Vec<u8>,
    ) -> ::http::request::Request<::std::vec::Vec<u8>> {
        builder
            .header(::http::header::CONTENT_LENGTH, body.len())
            .body(body)
            .expect("http request should be valid")
    }
    /// Creates a new builder-style object to manufacture [`HttpRequestWithLabelsInput`](crate::input::HttpRequestWithLabelsInput)
    pub fn builder() -> crate::input::http_request_with_labels_input::Builder {
        crate::input::http_request_with_labels_input::Builder::default()
    }
}

/// See [`HttpRequestWithLabelsAndTimestampFormatInput`](crate::input::HttpRequestWithLabelsAndTimestampFormatInput)
pub mod http_request_with_labels_and_timestamp_format_input {

    use crate::input::HttpRequestWithLabelsAndTimestampFormatInput;
    use crate::operation::HttpRequestWithLabelsAndTimestampFormat;
    use smithy_types::Instant;
    /// A builder for [`HttpRequestWithLabelsAndTimestampFormatInput`](crate::input::HttpRequestWithLabelsAndTimestampFormatInput)
    #[non_exhaustive]
    #[derive(Debug, Clone, Default)]
    pub struct Builder {
        member_epoch_seconds: ::std::option::Option<Instant>,
        member_http_date: ::std::option::Option<Instant>,
        member_date_time: ::std::option::Option<Instant>,
        default_format: ::std::option::Option<Instant>,
        target_epoch_seconds: ::std::option::Option<Instant>,
        target_http_date: ::std::option::Option<Instant>,
        target_date_time: ::std::option::Option<Instant>,
    }
    impl Builder {
        pub fn member_epoch_seconds(mut self, inp: Instant) -> Self {
            self.member_epoch_seconds = Some(inp);
            self
        }
        pub fn member_http_date(mut self, inp: Instant) -> Self {
            self.member_http_date = Some(inp);
            self
        }
        pub fn member_date_time(mut self, inp: Instant) -> Self {
            self.member_date_time = Some(inp);
            self
        }
        pub fn default_format(mut self, inp: Instant) -> Self {
            self.default_format = Some(inp);
            self
        }
        pub fn target_epoch_seconds(mut self, inp: Instant) -> Self {
            self.target_epoch_seconds = Some(inp);
            self
        }
        pub fn target_http_date(mut self, inp: Instant) -> Self {
            self.target_http_date = Some(inp);
            self
        }
        pub fn target_date_time(mut self, inp: Instant) -> Self {
            self.target_date_time = Some(inp);
            self
        }
        /// Consumes the builder and constructs a [`HttpRequestWithLabelsAndTimestampFormat`](crate::operation::HttpRequestWithLabelsAndTimestampFormat)
        pub fn build(self) -> Result<HttpRequestWithLabelsAndTimestampFormat, String> {
            Ok(
                HttpRequestWithLabelsAndTimestampFormat::new(
                    HttpRequestWithLabelsAndTimestampFormatInput {
                        member_epoch_seconds: self.member_epoch_seconds.ok_or("member_epoch_seconds is required when building HttpRequestWithLabelsAndTimestampFormatInput")?,
                        member_http_date: self.member_http_date.ok_or("member_http_date is required when building HttpRequestWithLabelsAndTimestampFormatInput")?,
                        member_date_time: self.member_date_time.ok_or("member_date_time is required when building HttpRequestWithLabelsAndTimestampFormatInput")?,
                        default_format: self.default_format.ok_or("default_format is required when building HttpRequestWithLabelsAndTimestampFormatInput")?,
                        target_epoch_seconds: self.target_epoch_seconds.ok_or("target_epoch_seconds is required when building HttpRequestWithLabelsAndTimestampFormatInput")?,
                        target_http_date: self.target_http_date.ok_or("target_http_date is required when building HttpRequestWithLabelsAndTimestampFormatInput")?,
                        target_date_time: self.target_date_time.ok_or("target_date_time is required when building HttpRequestWithLabelsAndTimestampFormatInput")?,
                    }
                )
            )
        }
    }
}
impl HttpRequestWithLabelsAndTimestampFormatInput {
    fn uri_base(&self, output: &mut String) {
        write!(output, "/HttpRequestWithLabelsAndTimestampFormat/{memberEpochSeconds}/{memberHttpDate}/{memberDateTime}/{defaultFormat}/{targetEpochSeconds}/{targetHttpDate}/{targetDateTime}", memberEpochSeconds = ::smithy_http::label::fmt_timestamp(&self.member_epoch_seconds, ::smithy_types::instant::Format::EpochSeconds), memberHttpDate = ::smithy_http::label::fmt_timestamp(&self.member_http_date, ::smithy_types::instant::Format::HttpDate), memberDateTime = ::smithy_http::label::fmt_timestamp(&self.member_date_time, ::smithy_types::instant::Format::DateTime), defaultFormat = ::smithy_http::label::fmt_timestamp(&self.default_format, ::smithy_types::instant::Format::DateTime), targetEpochSeconds = ::smithy_http::label::fmt_timestamp(&self.target_epoch_seconds, ::smithy_types::instant::Format::EpochSeconds), targetHttpDate = ::smithy_http::label::fmt_timestamp(&self.target_http_date, ::smithy_types::instant::Format::HttpDate), targetDateTime = ::smithy_http::label::fmt_timestamp(&self.target_date_time, ::smithy_types::instant::Format::DateTime)).expect("formatting should succeed")
    }
    fn update_http_builder(&self, builder: ::http::request::Builder) -> ::http::request::Builder {
        let mut uri = String::new();
        self.uri_base(&mut uri);
        builder.method("GET").uri(uri)
    }
    pub fn request_builder_base(&self) -> ::http::request::Builder {
        let builder = ::http::request::Builder::new();
        let builder = builder.header("Content-Type", "application/json");
        self.update_http_builder(builder)
    }
    pub fn build_body(&self) -> ::std::vec::Vec<u8> {
        todo!()
    }
    pub fn assemble(
        builder: ::http::request::Builder,
        body: ::std::vec::Vec<u8>,
    ) -> ::http::request::Request<::std::vec::Vec<u8>> {
        builder
            .header(::http::header::CONTENT_LENGTH, body.len())
            .body(body)
            .expect("http request should be valid")
    }
    /// Creates a new builder-style object to manufacture [`HttpRequestWithLabelsAndTimestampFormatInput`](crate::input::HttpRequestWithLabelsAndTimestampFormatInput)
    pub fn builder() -> crate::input::http_request_with_labels_and_timestamp_format_input::Builder {
        crate::input::http_request_with_labels_and_timestamp_format_input::Builder::default()
    }
}

/// See [`HttpResponseCodeInput`](crate::input::HttpResponseCodeInput)
pub mod http_response_code_input {

    use crate::input::HttpResponseCodeInput;
    use crate::operation::HttpResponseCode;
    /// A builder for [`HttpResponseCodeInput`](crate::input::HttpResponseCodeInput)
    #[non_exhaustive]
    #[derive(Debug, Clone, Default)]
    pub struct Builder {}
    impl Builder {
        /// Consumes the builder and constructs a [`HttpResponseCode`](crate::operation::HttpResponseCode)
        pub fn build(self) -> HttpResponseCode {
            HttpResponseCode::new(HttpResponseCodeInput {})
        }
    }
}
impl HttpResponseCodeInput {
    fn uri_base(&self, output: &mut String) {
        write!(output, "/HttpResponseCode").expect("formatting should succeed")
    }
    fn update_http_builder(&self, builder: ::http::request::Builder) -> ::http::request::Builder {
        let mut uri = String::new();
        self.uri_base(&mut uri);
        builder.method("PUT").uri(uri)
    }
    pub fn request_builder_base(&self) -> ::http::request::Builder {
        let builder = ::http::request::Builder::new();
        let builder = builder.header("Content-Type", "application/json");
        self.update_http_builder(builder)
    }
    pub fn build_body(&self) -> ::std::vec::Vec<u8> {
        todo!()
    }
    pub fn assemble(
        builder: ::http::request::Builder,
        body: ::std::vec::Vec<u8>,
    ) -> ::http::request::Request<::std::vec::Vec<u8>> {
        builder
            .header(::http::header::CONTENT_LENGTH, body.len())
            .body(body)
            .expect("http request should be valid")
    }
    /// Creates a new builder-style object to manufacture [`HttpResponseCodeInput`](crate::input::HttpResponseCodeInput)
    pub fn builder() -> crate::input::http_response_code_input::Builder {
        crate::input::http_response_code_input::Builder::default()
    }
}

/// See [`IgnoreQueryParamsInResponseInput`](crate::input::IgnoreQueryParamsInResponseInput)
pub mod ignore_query_params_in_response_input {

    use crate::input::IgnoreQueryParamsInResponseInput;
    use crate::operation::IgnoreQueryParamsInResponse;
    /// A builder for [`IgnoreQueryParamsInResponseInput`](crate::input::IgnoreQueryParamsInResponseInput)
    #[non_exhaustive]
    #[derive(Debug, Clone, Default)]
    pub struct Builder {}
    impl Builder {
        /// Consumes the builder and constructs a [`IgnoreQueryParamsInResponse`](crate::operation::IgnoreQueryParamsInResponse)
        pub fn build(self) -> IgnoreQueryParamsInResponse {
            IgnoreQueryParamsInResponse::new(IgnoreQueryParamsInResponseInput {})
        }
    }
}
impl IgnoreQueryParamsInResponseInput {
    fn uri_base(&self, output: &mut String) {
        write!(output, "/IgnoreQueryParamsInResponse").expect("formatting should succeed")
    }
    fn update_http_builder(&self, builder: ::http::request::Builder) -> ::http::request::Builder {
        let mut uri = String::new();
        self.uri_base(&mut uri);
        builder.method("GET").uri(uri)
    }
    pub fn request_builder_base(&self) -> ::http::request::Builder {
        let builder = ::http::request::Builder::new();
        let builder = builder.header("Content-Type", "application/json");
        self.update_http_builder(builder)
    }
    pub fn build_body(&self) -> ::std::vec::Vec<u8> {
        todo!()
    }
    pub fn assemble(
        builder: ::http::request::Builder,
        body: ::std::vec::Vec<u8>,
    ) -> ::http::request::Request<::std::vec::Vec<u8>> {
        builder
            .header(::http::header::CONTENT_LENGTH, body.len())
            .body(body)
            .expect("http request should be valid")
    }
    /// Creates a new builder-style object to manufacture [`IgnoreQueryParamsInResponseInput`](crate::input::IgnoreQueryParamsInResponseInput)
    pub fn builder() -> crate::input::ignore_query_params_in_response_input::Builder {
        crate::input::ignore_query_params_in_response_input::Builder::default()
    }
}

/// See [`InlineDocumentInput`](crate::input::InlineDocumentInput)
pub mod inline_document_input {

    use crate::input::InlineDocumentInput;
    use crate::operation::InlineDocument;
    use smithy_types::Document;
    /// A builder for [`InlineDocumentInput`](crate::input::InlineDocumentInput)
    #[non_exhaustive]
    #[derive(Debug, Clone, Default)]
    pub struct Builder {
        string_value: ::std::option::Option<::std::string::String>,
        document_value: ::std::option::Option<Document>,
    }
    impl Builder {
        pub fn string_value(mut self, inp: impl Into<::std::string::String>) -> Self {
            self.string_value = Some(inp.into());
            self
        }
        pub fn document_value(mut self, inp: Document) -> Self {
            self.document_value = Some(inp);
            self
        }
        /// Consumes the builder and constructs a [`InlineDocument`](crate::operation::InlineDocument)
        pub fn build(self) -> Result<InlineDocument, String> {
            Ok(InlineDocument::new(InlineDocumentInput {
                string_value: self.string_value,
                document_value: self
                    .document_value
                    .ok_or("document_value is required when building InlineDocumentInput")?,
            }))
        }
    }
}
impl InlineDocumentInput {
    fn uri_base(&self, output: &mut String) {
        write!(output, "/InlineDocument").expect("formatting should succeed")
    }
    fn update_http_builder(&self, builder: ::http::request::Builder) -> ::http::request::Builder {
        let mut uri = String::new();
        self.uri_base(&mut uri);
        builder.method("PUT").uri(uri)
    }
    pub fn request_builder_base(&self) -> ::http::request::Builder {
        let builder = ::http::request::Builder::new();
        let builder = builder.header("Content-Type", "application/json");
        self.update_http_builder(builder)
    }
    pub fn build_body(&self) -> ::std::vec::Vec<u8> {
        todo!()
    }
    pub fn assemble(
        builder: ::http::request::Builder,
        body: ::std::vec::Vec<u8>,
    ) -> ::http::request::Request<::std::vec::Vec<u8>> {
        builder
            .header(::http::header::CONTENT_LENGTH, body.len())
            .body(body)
            .expect("http request should be valid")
    }
    /// Creates a new builder-style object to manufacture [`InlineDocumentInput`](crate::input::InlineDocumentInput)
    pub fn builder() -> crate::input::inline_document_input::Builder {
        crate::input::inline_document_input::Builder::default()
    }
}

/// See [`InlineDocumentAsPayloadInput`](crate::input::InlineDocumentAsPayloadInput)
pub mod inline_document_as_payload_input {

    use crate::input::InlineDocumentAsPayloadInput;
    use crate::operation::InlineDocumentAsPayload;
    use smithy_types::Document;
    /// A builder for [`InlineDocumentAsPayloadInput`](crate::input::InlineDocumentAsPayloadInput)
    #[non_exhaustive]
    #[derive(Debug, Clone, Default)]
    pub struct Builder {
        document_value: ::std::option::Option<Document>,
    }
    impl Builder {
        pub fn document_value(mut self, inp: Document) -> Self {
            self.document_value = Some(inp);
            self
        }
        /// Consumes the builder and constructs a [`InlineDocumentAsPayload`](crate::operation::InlineDocumentAsPayload)
        pub fn build(self) -> Result<InlineDocumentAsPayload, String> {
            Ok(InlineDocumentAsPayload::new(InlineDocumentAsPayloadInput {
                document_value: self.document_value.ok_or(
                    "document_value is required when building InlineDocumentAsPayloadInput",
                )?,
            }))
        }
    }
}
impl InlineDocumentAsPayloadInput {
    fn uri_base(&self, output: &mut String) {
        write!(output, "/InlineDocumentAsPayload").expect("formatting should succeed")
    }
    fn update_http_builder(&self, builder: ::http::request::Builder) -> ::http::request::Builder {
        let mut uri = String::new();
        self.uri_base(&mut uri);
        builder.method("PUT").uri(uri)
    }
    pub fn request_builder_base(&self) -> ::http::request::Builder {
        let builder = ::http::request::Builder::new();
        let builder = builder.header("Content-Type", "application/json");
        self.update_http_builder(builder)
    }
    pub fn build_body(&self) -> ::std::vec::Vec<u8> {
        todo!()
    }
    pub fn assemble(
        builder: ::http::request::Builder,
        body: ::std::vec::Vec<u8>,
    ) -> ::http::request::Request<::std::vec::Vec<u8>> {
        builder
            .header(::http::header::CONTENT_LENGTH, body.len())
            .body(body)
            .expect("http request should be valid")
    }
    /// Creates a new builder-style object to manufacture [`InlineDocumentAsPayloadInput`](crate::input::InlineDocumentAsPayloadInput)
    pub fn builder() -> crate::input::inline_document_as_payload_input::Builder {
        crate::input::inline_document_as_payload_input::Builder::default()
    }
}

/// See [`InputAndOutputWithHeadersInput`](crate::input::InputAndOutputWithHeadersInput)
pub mod input_and_output_with_headers_input {

    use crate::input::InputAndOutputWithHeadersInput;
    use crate::model::FooEnum;
    use crate::operation::InputAndOutputWithHeaders;
    use smithy_types::Instant;
    /// A builder for [`InputAndOutputWithHeadersInput`](crate::input::InputAndOutputWithHeadersInput)
    #[non_exhaustive]
    #[derive(Debug, Clone, Default)]
    pub struct Builder {
        header_string: ::std::option::Option<::std::string::String>,
        header_byte: ::std::option::Option<i8>,
        header_short: ::std::option::Option<i16>,
        header_integer: ::std::option::Option<i32>,
        header_long: ::std::option::Option<i64>,
        header_float: ::std::option::Option<f32>,
        header_double: ::std::option::Option<f64>,
        header_true_bool: ::std::option::Option<bool>,
        header_false_bool: ::std::option::Option<bool>,
        header_string_list: ::std::option::Option<::std::vec::Vec<::std::string::String>>,
        header_string_set:
            ::std::option::Option<::std::collections::BTreeSet<::std::string::String>>,
        header_integer_list: ::std::option::Option<::std::vec::Vec<i32>>,
        header_boolean_list: ::std::option::Option<::std::vec::Vec<bool>>,
        header_timestamp_list: ::std::option::Option<::std::vec::Vec<Instant>>,
        header_enum: ::std::option::Option<FooEnum>,
        header_enum_list: ::std::option::Option<::std::vec::Vec<FooEnum>>,
    }
    impl Builder {
        pub fn header_string(mut self, inp: impl Into<::std::string::String>) -> Self {
            self.header_string = Some(inp.into());
            self
        }
        pub fn header_byte(mut self, inp: i8) -> Self {
            self.header_byte = Some(inp);
            self
        }
        pub fn header_short(mut self, inp: i16) -> Self {
            self.header_short = Some(inp);
            self
        }
        pub fn header_integer(mut self, inp: i32) -> Self {
            self.header_integer = Some(inp);
            self
        }
        pub fn header_long(mut self, inp: i64) -> Self {
            self.header_long = Some(inp);
            self
        }
        pub fn header_float(mut self, inp: f32) -> Self {
            self.header_float = Some(inp);
            self
        }
        pub fn header_double(mut self, inp: f64) -> Self {
            self.header_double = Some(inp);
            self
        }
        pub fn header_true_bool(mut self, inp: bool) -> Self {
            self.header_true_bool = Some(inp);
            self
        }
        pub fn header_false_bool(mut self, inp: bool) -> Self {
            self.header_false_bool = Some(inp);
            self
        }
        pub fn header_string_list(mut self, inp: ::std::vec::Vec<::std::string::String>) -> Self {
            self.header_string_list = Some(inp);
            self
        }
        pub fn header_string_set(
            mut self,
            inp: ::std::collections::BTreeSet<::std::string::String>,
        ) -> Self {
            self.header_string_set = Some(inp);
            self
        }
        pub fn header_integer_list(mut self, inp: ::std::vec::Vec<i32>) -> Self {
            self.header_integer_list = Some(inp);
            self
        }
        pub fn header_boolean_list(mut self, inp: ::std::vec::Vec<bool>) -> Self {
            self.header_boolean_list = Some(inp);
            self
        }
        pub fn header_timestamp_list(mut self, inp: ::std::vec::Vec<Instant>) -> Self {
            self.header_timestamp_list = Some(inp);
            self
        }
        pub fn header_enum(mut self, inp: FooEnum) -> Self {
            self.header_enum = Some(inp);
            self
        }
        pub fn header_enum_list(mut self, inp: ::std::vec::Vec<FooEnum>) -> Self {
            self.header_enum_list = Some(inp);
            self
        }
        /// Consumes the builder and constructs a [`InputAndOutputWithHeaders`](crate::operation::InputAndOutputWithHeaders)
        pub fn build(self) -> InputAndOutputWithHeaders {
            InputAndOutputWithHeaders::new(InputAndOutputWithHeadersInput {
                header_string: self.header_string,
                header_byte: self.header_byte,
                header_short: self.header_short,
                header_integer: self.header_integer,
                header_long: self.header_long,
                header_float: self.header_float,
                header_double: self.header_double,
                header_true_bool: self.header_true_bool,
                header_false_bool: self.header_false_bool,
                header_string_list: self.header_string_list,
                header_string_set: self.header_string_set,
                header_integer_list: self.header_integer_list,
                header_boolean_list: self.header_boolean_list,
                header_timestamp_list: self.header_timestamp_list,
                header_enum: self.header_enum,
                header_enum_list: self.header_enum_list,
            })
        }
    }
}
impl InputAndOutputWithHeadersInput {
    fn uri_base(&self, output: &mut String) {
        write!(output, "/InputAndOutputWithHeaders").expect("formatting should succeed")
    }
    fn add_headers(&self, mut builder: ::http::request::Builder) -> ::http::request::Builder {
        if let Some(inner_35) = &self.header_string {
            let formatted_36 = ::smithy_http::query::fmt_string(&inner_35);
            if !formatted_36.is_empty() {
                builder = builder.header("X-String", ::smithy_http::query::fmt_string(&inner_35));
            }
        }
        if let Some(inner_37) = &self.header_byte {
            let formatted_38 = ::smithy_http::query::fmt_default(&inner_37);
            if !formatted_38.is_empty() {
                builder = builder.header("X-Byte", ::smithy_http::query::fmt_default(&inner_37));
            }
        }
        if let Some(inner_39) = &self.header_short {
            let formatted_40 = ::smithy_http::query::fmt_default(&inner_39);
            if !formatted_40.is_empty() {
                builder = builder.header("X-Short", ::smithy_http::query::fmt_default(&inner_39));
            }
        }
        if let Some(inner_41) = &self.header_integer {
            let formatted_42 = ::smithy_http::query::fmt_default(&inner_41);
            if !formatted_42.is_empty() {
                builder = builder.header("X-Integer", ::smithy_http::query::fmt_default(&inner_41));
            }
        }
        if let Some(inner_43) = &self.header_long {
            let formatted_44 = ::smithy_http::query::fmt_default(&inner_43);
            if !formatted_44.is_empty() {
                builder = builder.header("X-Long", ::smithy_http::query::fmt_default(&inner_43));
            }
        }
        if let Some(inner_45) = &self.header_float {
            let formatted_46 = ::smithy_http::query::fmt_default(&inner_45);
            if !formatted_46.is_empty() {
                builder = builder.header("X-Float", ::smithy_http::query::fmt_default(&inner_45));
            }
        }
        if let Some(inner_47) = &self.header_double {
            let formatted_48 = ::smithy_http::query::fmt_default(&inner_47);
            if !formatted_48.is_empty() {
                builder = builder.header("X-Double", ::smithy_http::query::fmt_default(&inner_47));
            }
        }
        if let Some(inner_49) = &self.header_true_bool {
            let formatted_50 = ::smithy_http::query::fmt_default(&inner_49);
            if !formatted_50.is_empty() {
                builder =
                    builder.header("X-Boolean1", ::smithy_http::query::fmt_default(&inner_49));
            }
        }
        if let Some(inner_51) = &self.header_false_bool {
            let formatted_52 = ::smithy_http::query::fmt_default(&inner_51);
            if !formatted_52.is_empty() {
                builder =
                    builder.header("X-Boolean2", ::smithy_http::query::fmt_default(&inner_51));
            }
        }
        if let Some(inner_53) = &self.header_string_list {
            for inner_54 in inner_53 {
                let formatted_55 = ::smithy_http::query::fmt_string(&inner_54);
                if !formatted_55.is_empty() {
                    builder =
                        builder.header("X-StringList", ::smithy_http::query::fmt_string(&inner_54));
                }
            }
        }
        if let Some(inner_56) = &self.header_string_set {
            for inner_57 in inner_56 {
                let formatted_58 = ::smithy_http::query::fmt_string(&inner_57);
                if !formatted_58.is_empty() {
                    builder =
                        builder.header("X-StringSet", ::smithy_http::query::fmt_string(&inner_57));
                }
            }
        }
        if let Some(inner_59) = &self.header_integer_list {
            for inner_60 in inner_59 {
                let formatted_61 = ::smithy_http::query::fmt_default(&inner_60);
                if !formatted_61.is_empty() {
                    builder = builder.header(
                        "X-IntegerList",
                        ::smithy_http::query::fmt_default(&inner_60),
                    );
                }
            }
        }
        if let Some(inner_62) = &self.header_boolean_list {
            for inner_63 in inner_62 {
                let formatted_64 = ::smithy_http::query::fmt_default(&inner_63);
                if !formatted_64.is_empty() {
                    builder = builder.header(
                        "X-BooleanList",
                        ::smithy_http::query::fmt_default(&inner_63),
                    );
                }
            }
        }
        if let Some(inner_65) = &self.header_timestamp_list {
            for inner_66 in inner_65 {
                let formatted_67 = inner_66.fmt(::smithy_types::instant::Format::HttpDate);
                if !formatted_67.is_empty() {
                    builder = builder.header(
                        "X-TimestampList",
                        inner_66.fmt(::smithy_types::instant::Format::HttpDate),
                    );
                }
            }
        }
        if let Some(inner_68) = &self.header_enum {
            let formatted_69 = ::smithy_http::query::fmt_string(&inner_68.as_str());
            if !formatted_69.is_empty() {
                builder = builder.header(
                    "X-Enum",
                    ::smithy_http::query::fmt_string(&inner_68.as_str()),
                );
            }
        }
        if let Some(inner_70) = &self.header_enum_list {
            for inner_71 in inner_70 {
                let formatted_72 = ::smithy_http::query::fmt_string(&inner_71.as_str());
                if !formatted_72.is_empty() {
                    builder = builder.header(
                        "X-EnumList",
                        ::smithy_http::query::fmt_string(&inner_71.as_str()),
                    );
                }
            }
        }
        builder
    }
    fn update_http_builder(&self, builder: ::http::request::Builder) -> ::http::request::Builder {
        let mut uri = String::new();
        self.uri_base(&mut uri);
        let builder = self.add_headers(builder);
        builder.method("POST").uri(uri)
    }
    pub fn request_builder_base(&self) -> ::http::request::Builder {
        let builder = ::http::request::Builder::new();
        let builder = builder.header("Content-Type", "application/json");
        self.update_http_builder(builder)
    }
    pub fn build_body(&self) -> ::std::vec::Vec<u8> {
        todo!()
    }
    pub fn assemble(
        builder: ::http::request::Builder,
        body: ::std::vec::Vec<u8>,
    ) -> ::http::request::Request<::std::vec::Vec<u8>> {
        builder
            .header(::http::header::CONTENT_LENGTH, body.len())
            .body(body)
            .expect("http request should be valid")
    }
    /// Creates a new builder-style object to manufacture [`InputAndOutputWithHeadersInput`](crate::input::InputAndOutputWithHeadersInput)
    pub fn builder() -> crate::input::input_and_output_with_headers_input::Builder {
        crate::input::input_and_output_with_headers_input::Builder::default()
    }
}

/// See [`JsonBlobsInput`](crate::input::JsonBlobsInput)
pub mod json_blobs_input {

    use crate::input::JsonBlobsInput;
    use crate::operation::JsonBlobs;
    use smithy_types::Blob;
    /// A builder for [`JsonBlobsInput`](crate::input::JsonBlobsInput)
    #[non_exhaustive]
    #[derive(Debug, Clone, Default)]
    pub struct Builder {
        data: ::std::option::Option<Blob>,
    }
    impl Builder {
        pub fn data(mut self, inp: Blob) -> Self {
            self.data = Some(inp);
            self
        }
        /// Consumes the builder and constructs a [`JsonBlobs`](crate::operation::JsonBlobs)
        pub fn build(self) -> JsonBlobs {
            JsonBlobs::new(JsonBlobsInput { data: self.data })
        }
    }
}
impl JsonBlobsInput {
    fn uri_base(&self, output: &mut String) {
        write!(output, "/JsonBlobs").expect("formatting should succeed")
    }
    fn update_http_builder(&self, builder: ::http::request::Builder) -> ::http::request::Builder {
        let mut uri = String::new();
        self.uri_base(&mut uri);
        builder.method("POST").uri(uri)
    }
    pub fn request_builder_base(&self) -> ::http::request::Builder {
        let builder = ::http::request::Builder::new();
        let builder = builder.header("Content-Type", "application/json");
        self.update_http_builder(builder)
    }
    pub fn build_body(&self) -> ::std::vec::Vec<u8> {
        todo!()
    }
    pub fn assemble(
        builder: ::http::request::Builder,
        body: ::std::vec::Vec<u8>,
    ) -> ::http::request::Request<::std::vec::Vec<u8>> {
        builder
            .header(::http::header::CONTENT_LENGTH, body.len())
            .body(body)
            .expect("http request should be valid")
    }
    /// Creates a new builder-style object to manufacture [`JsonBlobsInput`](crate::input::JsonBlobsInput)
    pub fn builder() -> crate::input::json_blobs_input::Builder {
        crate::input::json_blobs_input::Builder::default()
    }
}

/// See [`JsonEnumsInput`](crate::input::JsonEnumsInput)
pub mod json_enums_input {

    use crate::input::JsonEnumsInput;
    use crate::model::FooEnum;
    use crate::operation::JsonEnums;
    /// A builder for [`JsonEnumsInput`](crate::input::JsonEnumsInput)
    #[non_exhaustive]
    #[derive(Debug, Clone, Default)]
    pub struct Builder {
        foo_enum1: ::std::option::Option<FooEnum>,
        foo_enum2: ::std::option::Option<FooEnum>,
        foo_enum3: ::std::option::Option<FooEnum>,
        foo_enum_list: ::std::option::Option<::std::vec::Vec<FooEnum>>,
        foo_enum_set: ::std::option::Option<::std::collections::BTreeSet<FooEnum>>,
        foo_enum_map:
            ::std::option::Option<::std::collections::HashMap<::std::string::String, FooEnum>>,
    }
    impl Builder {
        pub fn foo_enum1(mut self, inp: FooEnum) -> Self {
            self.foo_enum1 = Some(inp);
            self
        }
        pub fn foo_enum2(mut self, inp: FooEnum) -> Self {
            self.foo_enum2 = Some(inp);
            self
        }
        pub fn foo_enum3(mut self, inp: FooEnum) -> Self {
            self.foo_enum3 = Some(inp);
            self
        }
        pub fn foo_enum_list(mut self, inp: ::std::vec::Vec<FooEnum>) -> Self {
            self.foo_enum_list = Some(inp);
            self
        }
        pub fn foo_enum_set(mut self, inp: ::std::collections::BTreeSet<FooEnum>) -> Self {
            self.foo_enum_set = Some(inp);
            self
        }
        pub fn foo_enum_map(
            mut self,
            inp: ::std::collections::HashMap<::std::string::String, FooEnum>,
        ) -> Self {
            self.foo_enum_map = Some(inp);
            self
        }
        /// Consumes the builder and constructs a [`JsonEnums`](crate::operation::JsonEnums)
        pub fn build(self) -> JsonEnums {
            JsonEnums::new(JsonEnumsInput {
                foo_enum1: self.foo_enum1,
                foo_enum2: self.foo_enum2,
                foo_enum3: self.foo_enum3,
                foo_enum_list: self.foo_enum_list,
                foo_enum_set: self.foo_enum_set,
                foo_enum_map: self.foo_enum_map,
            })
        }
    }
}
impl JsonEnumsInput {
    fn uri_base(&self, output: &mut String) {
        write!(output, "/JsonEnums").expect("formatting should succeed")
    }
    fn update_http_builder(&self, builder: ::http::request::Builder) -> ::http::request::Builder {
        let mut uri = String::new();
        self.uri_base(&mut uri);
        builder.method("PUT").uri(uri)
    }
    pub fn request_builder_base(&self) -> ::http::request::Builder {
        let builder = ::http::request::Builder::new();
        let builder = builder.header("Content-Type", "application/json");
        self.update_http_builder(builder)
    }
    pub fn build_body(&self) -> ::std::vec::Vec<u8> {
        todo!()
    }
    pub fn assemble(
        builder: ::http::request::Builder,
        body: ::std::vec::Vec<u8>,
    ) -> ::http::request::Request<::std::vec::Vec<u8>> {
        builder
            .header(::http::header::CONTENT_LENGTH, body.len())
            .body(body)
            .expect("http request should be valid")
    }
    /// Creates a new builder-style object to manufacture [`JsonEnumsInput`](crate::input::JsonEnumsInput)
    pub fn builder() -> crate::input::json_enums_input::Builder {
        crate::input::json_enums_input::Builder::default()
    }
}

/// See [`JsonListsInput`](crate::input::JsonListsInput)
pub mod json_lists_input {

    use crate::input::JsonListsInput;
    use crate::model::FooEnum;
    use crate::model::StructureListMember;
    use crate::operation::JsonLists;
    use smithy_types::Instant;
    /// A builder for [`JsonListsInput`](crate::input::JsonListsInput)
    #[non_exhaustive]
    #[derive(Debug, Clone, Default)]
    pub struct Builder {
        string_list: ::std::option::Option<::std::vec::Vec<::std::string::String>>,
        sparse_string_list:
            ::std::option::Option<::std::vec::Vec<::std::option::Option<::std::string::String>>>,
        string_set: ::std::option::Option<::std::collections::BTreeSet<::std::string::String>>,
        integer_list: ::std::option::Option<::std::vec::Vec<i32>>,
        boolean_list: ::std::option::Option<::std::vec::Vec<bool>>,
        timestamp_list: ::std::option::Option<::std::vec::Vec<Instant>>,
        enum_list: ::std::option::Option<::std::vec::Vec<FooEnum>>,
        nested_string_list:
            ::std::option::Option<::std::vec::Vec<::std::vec::Vec<::std::string::String>>>,
        structure_list: ::std::option::Option<::std::vec::Vec<StructureListMember>>,
    }
    impl Builder {
        pub fn string_list(mut self, inp: ::std::vec::Vec<::std::string::String>) -> Self {
            self.string_list = Some(inp);
            self
        }
        pub fn sparse_string_list(
            mut self,
            inp: ::std::vec::Vec<::std::option::Option<::std::string::String>>,
        ) -> Self {
            self.sparse_string_list = Some(inp);
            self
        }
        pub fn string_set(
            mut self,
            inp: ::std::collections::BTreeSet<::std::string::String>,
        ) -> Self {
            self.string_set = Some(inp);
            self
        }
        pub fn integer_list(mut self, inp: ::std::vec::Vec<i32>) -> Self {
            self.integer_list = Some(inp);
            self
        }
        pub fn boolean_list(mut self, inp: ::std::vec::Vec<bool>) -> Self {
            self.boolean_list = Some(inp);
            self
        }
        pub fn timestamp_list(mut self, inp: ::std::vec::Vec<Instant>) -> Self {
            self.timestamp_list = Some(inp);
            self
        }
        pub fn enum_list(mut self, inp: ::std::vec::Vec<FooEnum>) -> Self {
            self.enum_list = Some(inp);
            self
        }
        /// A list of lists of strings.
        pub fn nested_string_list(
            mut self,
            inp: ::std::vec::Vec<::std::vec::Vec<::std::string::String>>,
        ) -> Self {
            self.nested_string_list = Some(inp);
            self
        }
        pub fn structure_list(mut self, inp: ::std::vec::Vec<StructureListMember>) -> Self {
            self.structure_list = Some(inp);
            self
        }
        /// Consumes the builder and constructs a [`JsonLists`](crate::operation::JsonLists)
        pub fn build(self) -> JsonLists {
            JsonLists::new(JsonListsInput {
                string_list: self.string_list,
                sparse_string_list: self.sparse_string_list,
                string_set: self.string_set,
                integer_list: self.integer_list,
                boolean_list: self.boolean_list,
                timestamp_list: self.timestamp_list,
                enum_list: self.enum_list,
                nested_string_list: self.nested_string_list,
                structure_list: self.structure_list,
            })
        }
    }
}
impl JsonListsInput {
    fn uri_base(&self, output: &mut String) {
        write!(output, "/JsonLists").expect("formatting should succeed")
    }
    fn update_http_builder(&self, builder: ::http::request::Builder) -> ::http::request::Builder {
        let mut uri = String::new();
        self.uri_base(&mut uri);
        builder.method("PUT").uri(uri)
    }
    pub fn request_builder_base(&self) -> ::http::request::Builder {
        let builder = ::http::request::Builder::new();
        let builder = builder.header("Content-Type", "application/json");
        self.update_http_builder(builder)
    }
    pub fn build_body(&self) -> ::std::vec::Vec<u8> {
        todo!()
    }
    pub fn assemble(
        builder: ::http::request::Builder,
        body: ::std::vec::Vec<u8>,
    ) -> ::http::request::Request<::std::vec::Vec<u8>> {
        builder
            .header(::http::header::CONTENT_LENGTH, body.len())
            .body(body)
            .expect("http request should be valid")
    }
    /// Creates a new builder-style object to manufacture [`JsonListsInput`](crate::input::JsonListsInput)
    pub fn builder() -> crate::input::json_lists_input::Builder {
        crate::input::json_lists_input::Builder::default()
    }
}

/// See [`JsonMapsInput`](crate::input::JsonMapsInput)
pub mod json_maps_input {

    use crate::input::JsonMapsInput;
    use crate::model::GreetingStruct;
    use crate::operation::JsonMaps;
    /// A builder for [`JsonMapsInput`](crate::input::JsonMapsInput)
    #[non_exhaustive]
    #[derive(Debug, Clone, Default)]
    pub struct Builder {
        dense_struct_map: ::std::option::Option<
            ::std::collections::HashMap<::std::string::String, GreetingStruct>,
        >,
        sparse_struct_map: ::std::option::Option<
            ::std::collections::HashMap<
                ::std::string::String,
                ::std::option::Option<GreetingStruct>,
            >,
        >,
        dense_number_map:
            ::std::option::Option<::std::collections::HashMap<::std::string::String, i32>>,
        dense_boolean_map:
            ::std::option::Option<::std::collections::HashMap<::std::string::String, bool>>,
        dense_string_map: ::std::option::Option<
            ::std::collections::HashMap<::std::string::String, ::std::string::String>,
        >,
        sparse_number_map: ::std::option::Option<
            ::std::collections::HashMap<::std::string::String, ::std::option::Option<i32>>,
        >,
        sparse_boolean_map: ::std::option::Option<
            ::std::collections::HashMap<::std::string::String, ::std::option::Option<bool>>,
        >,
        sparse_string_map: ::std::option::Option<
            ::std::collections::HashMap<
                ::std::string::String,
                ::std::option::Option<::std::string::String>,
            >,
        >,
    }
    impl Builder {
        pub fn dense_struct_map(
            mut self,
            inp: ::std::collections::HashMap<::std::string::String, GreetingStruct>,
        ) -> Self {
            self.dense_struct_map = Some(inp);
            self
        }
        pub fn sparse_struct_map(
            mut self,
            inp: ::std::collections::HashMap<
                ::std::string::String,
                ::std::option::Option<GreetingStruct>,
            >,
        ) -> Self {
            self.sparse_struct_map = Some(inp);
            self
        }
        pub fn dense_number_map(
            mut self,
            inp: ::std::collections::HashMap<::std::string::String, i32>,
        ) -> Self {
            self.dense_number_map = Some(inp);
            self
        }
        pub fn dense_boolean_map(
            mut self,
            inp: ::std::collections::HashMap<::std::string::String, bool>,
        ) -> Self {
            self.dense_boolean_map = Some(inp);
            self
        }
        pub fn dense_string_map(
            mut self,
            inp: ::std::collections::HashMap<::std::string::String, ::std::string::String>,
        ) -> Self {
            self.dense_string_map = Some(inp);
            self
        }
        pub fn sparse_number_map(
            mut self,
            inp: ::std::collections::HashMap<::std::string::String, ::std::option::Option<i32>>,
        ) -> Self {
            self.sparse_number_map = Some(inp);
            self
        }
        pub fn sparse_boolean_map(
            mut self,
            inp: ::std::collections::HashMap<::std::string::String, ::std::option::Option<bool>>,
        ) -> Self {
            self.sparse_boolean_map = Some(inp);
            self
        }
        pub fn sparse_string_map(
            mut self,
            inp: ::std::collections::HashMap<
                ::std::string::String,
                ::std::option::Option<::std::string::String>,
            >,
        ) -> Self {
            self.sparse_string_map = Some(inp);
            self
        }
        /// Consumes the builder and constructs a [`JsonMaps`](crate::operation::JsonMaps)
        pub fn build(self) -> JsonMaps {
            JsonMaps::new(JsonMapsInput {
                dense_struct_map: self.dense_struct_map,
                sparse_struct_map: self.sparse_struct_map,
                dense_number_map: self.dense_number_map,
                dense_boolean_map: self.dense_boolean_map,
                dense_string_map: self.dense_string_map,
                sparse_number_map: self.sparse_number_map,
                sparse_boolean_map: self.sparse_boolean_map,
                sparse_string_map: self.sparse_string_map,
            })
        }
    }
}
impl JsonMapsInput {
    fn uri_base(&self, output: &mut String) {
        write!(output, "/JsonMaps").expect("formatting should succeed")
    }
    fn update_http_builder(&self, builder: ::http::request::Builder) -> ::http::request::Builder {
        let mut uri = String::new();
        self.uri_base(&mut uri);
        builder.method("POST").uri(uri)
    }
    pub fn request_builder_base(&self) -> ::http::request::Builder {
        let builder = ::http::request::Builder::new();
        let builder = builder.header("Content-Type", "application/json");
        self.update_http_builder(builder)
    }
    pub fn build_body(&self) -> ::std::vec::Vec<u8> {
        todo!()
    }
    pub fn assemble(
        builder: ::http::request::Builder,
        body: ::std::vec::Vec<u8>,
    ) -> ::http::request::Request<::std::vec::Vec<u8>> {
        builder
            .header(::http::header::CONTENT_LENGTH, body.len())
            .body(body)
            .expect("http request should be valid")
    }
    /// Creates a new builder-style object to manufacture [`JsonMapsInput`](crate::input::JsonMapsInput)
    pub fn builder() -> crate::input::json_maps_input::Builder {
        crate::input::json_maps_input::Builder::default()
    }
}

/// See [`JsonTimestampsInput`](crate::input::JsonTimestampsInput)
pub mod json_timestamps_input {

    use crate::input::JsonTimestampsInput;
    use crate::operation::JsonTimestamps;
    use smithy_types::Instant;
    /// A builder for [`JsonTimestampsInput`](crate::input::JsonTimestampsInput)
    #[non_exhaustive]
    #[derive(Debug, Clone, Default)]
    pub struct Builder {
        normal: ::std::option::Option<Instant>,
        date_time: ::std::option::Option<Instant>,
        epoch_seconds: ::std::option::Option<Instant>,
        http_date: ::std::option::Option<Instant>,
    }
    impl Builder {
        pub fn normal(mut self, inp: Instant) -> Self {
            self.normal = Some(inp);
            self
        }
        pub fn date_time(mut self, inp: Instant) -> Self {
            self.date_time = Some(inp);
            self
        }
        pub fn epoch_seconds(mut self, inp: Instant) -> Self {
            self.epoch_seconds = Some(inp);
            self
        }
        pub fn http_date(mut self, inp: Instant) -> Self {
            self.http_date = Some(inp);
            self
        }
        /// Consumes the builder and constructs a [`JsonTimestamps`](crate::operation::JsonTimestamps)
        pub fn build(self) -> JsonTimestamps {
            JsonTimestamps::new(JsonTimestampsInput {
                normal: self.normal,
                date_time: self.date_time,
                epoch_seconds: self.epoch_seconds,
                http_date: self.http_date,
            })
        }
    }
}
impl JsonTimestampsInput {
    fn uri_base(&self, output: &mut String) {
        write!(output, "/JsonTimestamps").expect("formatting should succeed")
    }
    fn update_http_builder(&self, builder: ::http::request::Builder) -> ::http::request::Builder {
        let mut uri = String::new();
        self.uri_base(&mut uri);
        builder.method("POST").uri(uri)
    }
    pub fn request_builder_base(&self) -> ::http::request::Builder {
        let builder = ::http::request::Builder::new();
        let builder = builder.header("Content-Type", "application/json");
        self.update_http_builder(builder)
    }
    pub fn build_body(&self) -> ::std::vec::Vec<u8> {
        todo!()
    }
    pub fn assemble(
        builder: ::http::request::Builder,
        body: ::std::vec::Vec<u8>,
    ) -> ::http::request::Request<::std::vec::Vec<u8>> {
        builder
            .header(::http::header::CONTENT_LENGTH, body.len())
            .body(body)
            .expect("http request should be valid")
    }
    /// Creates a new builder-style object to manufacture [`JsonTimestampsInput`](crate::input::JsonTimestampsInput)
    pub fn builder() -> crate::input::json_timestamps_input::Builder {
        crate::input::json_timestamps_input::Builder::default()
    }
}

/// See [`JsonUnionsInput`](crate::input::JsonUnionsInput)
pub mod json_unions_input {

    use crate::input::JsonUnionsInput;
    use crate::model::MyUnion;
    use crate::operation::JsonUnions;
    /// A builder for [`JsonUnionsInput`](crate::input::JsonUnionsInput)
    #[non_exhaustive]
    #[derive(Debug, Clone, Default)]
    pub struct Builder {
        contents: ::std::option::Option<MyUnion>,
    }
    impl Builder {
        /// A union with a representative set of types for members.
        pub fn contents(mut self, inp: MyUnion) -> Self {
            self.contents = Some(inp);
            self
        }
        /// Consumes the builder and constructs a [`JsonUnions`](crate::operation::JsonUnions)
        pub fn build(self) -> JsonUnions {
            JsonUnions::new(JsonUnionsInput {
                contents: self.contents,
            })
        }
    }
}
impl JsonUnionsInput {
    fn uri_base(&self, output: &mut String) {
        write!(output, "/JsonUnions").expect("formatting should succeed")
    }
    fn update_http_builder(&self, builder: ::http::request::Builder) -> ::http::request::Builder {
        let mut uri = String::new();
        self.uri_base(&mut uri);
        builder.method("PUT").uri(uri)
    }
    pub fn request_builder_base(&self) -> ::http::request::Builder {
        let builder = ::http::request::Builder::new();
        let builder = builder.header("Content-Type", "application/json");
        self.update_http_builder(builder)
    }
    pub fn build_body(&self) -> ::std::vec::Vec<u8> {
        todo!()
    }
    pub fn assemble(
        builder: ::http::request::Builder,
        body: ::std::vec::Vec<u8>,
    ) -> ::http::request::Request<::std::vec::Vec<u8>> {
        builder
            .header(::http::header::CONTENT_LENGTH, body.len())
            .body(body)
            .expect("http request should be valid")
    }
    /// Creates a new builder-style object to manufacture [`JsonUnionsInput`](crate::input::JsonUnionsInput)
    pub fn builder() -> crate::input::json_unions_input::Builder {
        crate::input::json_unions_input::Builder::default()
    }
}

/// See [`MediaTypeHeaderInput`](crate::input::MediaTypeHeaderInput)
pub mod media_type_header_input {

    use crate::input::MediaTypeHeaderInput;
    use crate::operation::MediaTypeHeader;
    /// A builder for [`MediaTypeHeaderInput`](crate::input::MediaTypeHeaderInput)
    #[non_exhaustive]
    #[derive(Debug, Clone, Default)]
    pub struct Builder {
        json: ::std::option::Option<::std::string::String>,
    }
    impl Builder {
        pub fn json(mut self, inp: impl Into<::std::string::String>) -> Self {
            self.json = Some(inp.into());
            self
        }
        /// Consumes the builder and constructs a [`MediaTypeHeader`](crate::operation::MediaTypeHeader)
        pub fn build(self) -> MediaTypeHeader {
            MediaTypeHeader::new(MediaTypeHeaderInput { json: self.json })
        }
    }
}
impl MediaTypeHeaderInput {
    fn uri_base(&self, output: &mut String) {
        write!(output, "/MediaTypeHeader").expect("formatting should succeed")
    }
    fn add_headers(&self, mut builder: ::http::request::Builder) -> ::http::request::Builder {
        if let Some(inner_73) = &self.json {
            let formatted_74 = ::smithy_http::base64::encode(&inner_73);
            if !formatted_74.is_empty() {
                builder = builder.header("X-Json", ::smithy_http::base64::encode(&inner_73));
            }
        }
        builder
    }
    fn update_http_builder(&self, builder: ::http::request::Builder) -> ::http::request::Builder {
        let mut uri = String::new();
        self.uri_base(&mut uri);
        let builder = self.add_headers(builder);
        builder.method("GET").uri(uri)
    }
    pub fn request_builder_base(&self) -> ::http::request::Builder {
        let builder = ::http::request::Builder::new();
        let builder = builder.header("Content-Type", "application/json");
        self.update_http_builder(builder)
    }
    pub fn build_body(&self) -> ::std::vec::Vec<u8> {
        todo!()
    }
    pub fn assemble(
        builder: ::http::request::Builder,
        body: ::std::vec::Vec<u8>,
    ) -> ::http::request::Request<::std::vec::Vec<u8>> {
        builder
            .header(::http::header::CONTENT_LENGTH, body.len())
            .body(body)
            .expect("http request should be valid")
    }
    /// Creates a new builder-style object to manufacture [`MediaTypeHeaderInput`](crate::input::MediaTypeHeaderInput)
    pub fn builder() -> crate::input::media_type_header_input::Builder {
        crate::input::media_type_header_input::Builder::default()
    }
}

/// See [`NoInputAndNoOutputInput`](crate::input::NoInputAndNoOutputInput)
pub mod no_input_and_no_output_input {

    use crate::input::NoInputAndNoOutputInput;
    use crate::operation::NoInputAndNoOutput;
    /// A builder for [`NoInputAndNoOutputInput`](crate::input::NoInputAndNoOutputInput)
    #[non_exhaustive]
    #[derive(Debug, Clone, Default)]
    pub struct Builder {}
    impl Builder {
        /// Consumes the builder and constructs a [`NoInputAndNoOutput`](crate::operation::NoInputAndNoOutput)
        pub fn build(self) -> NoInputAndNoOutput {
            NoInputAndNoOutput::new(NoInputAndNoOutputInput {})
        }
    }
}
impl NoInputAndNoOutputInput {
    fn uri_base(&self, output: &mut String) {
        write!(output, "/NoInputAndNoOutput").expect("formatting should succeed")
    }
    fn update_http_builder(&self, builder: ::http::request::Builder) -> ::http::request::Builder {
        let mut uri = String::new();
        self.uri_base(&mut uri);
        builder.method("POST").uri(uri)
    }
    pub fn request_builder_base(&self) -> ::http::request::Builder {
        let builder = ::http::request::Builder::new();
        let builder = builder.header("Content-Type", "application/json");
        self.update_http_builder(builder)
    }
    pub fn build_body(&self) -> ::std::vec::Vec<u8> {
        todo!()
    }
    pub fn assemble(
        builder: ::http::request::Builder,
        body: ::std::vec::Vec<u8>,
    ) -> ::http::request::Request<::std::vec::Vec<u8>> {
        builder
            .header(::http::header::CONTENT_LENGTH, body.len())
            .body(body)
            .expect("http request should be valid")
    }
    /// Creates a new builder-style object to manufacture [`NoInputAndNoOutputInput`](crate::input::NoInputAndNoOutputInput)
    pub fn builder() -> crate::input::no_input_and_no_output_input::Builder {
        crate::input::no_input_and_no_output_input::Builder::default()
    }
}

/// See [`NoInputAndOutputInput`](crate::input::NoInputAndOutputInput)
pub mod no_input_and_output_input {

    use crate::input::NoInputAndOutputInput;
    use crate::operation::NoInputAndOutput;
    /// A builder for [`NoInputAndOutputInput`](crate::input::NoInputAndOutputInput)
    #[non_exhaustive]
    #[derive(Debug, Clone, Default)]
    pub struct Builder {}
    impl Builder {
        /// Consumes the builder and constructs a [`NoInputAndOutput`](crate::operation::NoInputAndOutput)
        pub fn build(self) -> NoInputAndOutput {
            NoInputAndOutput::new(NoInputAndOutputInput {})
        }
    }
}
impl NoInputAndOutputInput {
    fn uri_base(&self, output: &mut String) {
        write!(output, "/NoInputAndOutputOutput").expect("formatting should succeed")
    }
    fn update_http_builder(&self, builder: ::http::request::Builder) -> ::http::request::Builder {
        let mut uri = String::new();
        self.uri_base(&mut uri);
        builder.method("POST").uri(uri)
    }
    pub fn request_builder_base(&self) -> ::http::request::Builder {
        let builder = ::http::request::Builder::new();
        let builder = builder.header("Content-Type", "application/json");
        self.update_http_builder(builder)
    }
    pub fn build_body(&self) -> ::std::vec::Vec<u8> {
        todo!()
    }
    pub fn assemble(
        builder: ::http::request::Builder,
        body: ::std::vec::Vec<u8>,
    ) -> ::http::request::Request<::std::vec::Vec<u8>> {
        builder
            .header(::http::header::CONTENT_LENGTH, body.len())
            .body(body)
            .expect("http request should be valid")
    }
    /// Creates a new builder-style object to manufacture [`NoInputAndOutputInput`](crate::input::NoInputAndOutputInput)
    pub fn builder() -> crate::input::no_input_and_output_input::Builder {
        crate::input::no_input_and_output_input::Builder::default()
    }
}

/// See [`NullAndEmptyHeadersClientInput`](crate::input::NullAndEmptyHeadersClientInput)
pub mod null_and_empty_headers_client_input {

    use crate::input::NullAndEmptyHeadersClientInput;
    use crate::operation::NullAndEmptyHeadersClient;
    /// A builder for [`NullAndEmptyHeadersClientInput`](crate::input::NullAndEmptyHeadersClientInput)
    #[non_exhaustive]
    #[derive(Debug, Clone, Default)]
    pub struct Builder {
        a: ::std::option::Option<::std::string::String>,
        b: ::std::option::Option<::std::string::String>,
        c: ::std::option::Option<::std::vec::Vec<::std::string::String>>,
    }
    impl Builder {
        pub fn a(mut self, inp: impl Into<::std::string::String>) -> Self {
            self.a = Some(inp.into());
            self
        }
        pub fn b(mut self, inp: impl Into<::std::string::String>) -> Self {
            self.b = Some(inp.into());
            self
        }
        pub fn c(mut self, inp: ::std::vec::Vec<::std::string::String>) -> Self {
            self.c = Some(inp);
            self
        }
        /// Consumes the builder and constructs a [`NullAndEmptyHeadersClient`](crate::operation::NullAndEmptyHeadersClient)
        pub fn build(self) -> NullAndEmptyHeadersClient {
            NullAndEmptyHeadersClient::new(NullAndEmptyHeadersClientInput {
                a: self.a,
                b: self.b,
                c: self.c,
            })
        }
    }
}
impl NullAndEmptyHeadersClientInput {
    fn uri_base(&self, output: &mut String) {
        write!(output, "/NullAndEmptyHeadersClient").expect("formatting should succeed")
    }
    fn add_headers(&self, mut builder: ::http::request::Builder) -> ::http::request::Builder {
        if let Some(inner_75) = &self.a {
            let formatted_76 = ::smithy_http::query::fmt_string(&inner_75);
            if !formatted_76.is_empty() {
                builder = builder.header("X-A", ::smithy_http::query::fmt_string(&inner_75));
            }
        }
        if let Some(inner_77) = &self.b {
            let formatted_78 = ::smithy_http::query::fmt_string(&inner_77);
            if !formatted_78.is_empty() {
                builder = builder.header("X-B", ::smithy_http::query::fmt_string(&inner_77));
            }
        }
        if let Some(inner_79) = &self.c {
            for inner_80 in inner_79 {
                let formatted_81 = ::smithy_http::query::fmt_string(&inner_80);
                if !formatted_81.is_empty() {
                    builder = builder.header("X-C", ::smithy_http::query::fmt_string(&inner_80));
                }
            }
        }
        builder
    }
    fn update_http_builder(&self, builder: ::http::request::Builder) -> ::http::request::Builder {
        let mut uri = String::new();
        self.uri_base(&mut uri);
        let builder = self.add_headers(builder);
        builder.method("GET").uri(uri)
    }
    pub fn request_builder_base(&self) -> ::http::request::Builder {
        let builder = ::http::request::Builder::new();
        let builder = builder.header("Content-Type", "application/json");
        self.update_http_builder(builder)
    }
    pub fn build_body(&self) -> ::std::vec::Vec<u8> {
        todo!()
    }
    pub fn assemble(
        builder: ::http::request::Builder,
        body: ::std::vec::Vec<u8>,
    ) -> ::http::request::Request<::std::vec::Vec<u8>> {
        builder
            .header(::http::header::CONTENT_LENGTH, body.len())
            .body(body)
            .expect("http request should be valid")
    }
    /// Creates a new builder-style object to manufacture [`NullAndEmptyHeadersClientInput`](crate::input::NullAndEmptyHeadersClientInput)
    pub fn builder() -> crate::input::null_and_empty_headers_client_input::Builder {
        crate::input::null_and_empty_headers_client_input::Builder::default()
    }
}

/// See [`NullAndEmptyHeadersServerInput`](crate::input::NullAndEmptyHeadersServerInput)
pub mod null_and_empty_headers_server_input {

    use crate::input::NullAndEmptyHeadersServerInput;
    use crate::operation::NullAndEmptyHeadersServer;
    /// A builder for [`NullAndEmptyHeadersServerInput`](crate::input::NullAndEmptyHeadersServerInput)
    #[non_exhaustive]
    #[derive(Debug, Clone, Default)]
    pub struct Builder {
        a: ::std::option::Option<::std::string::String>,
        b: ::std::option::Option<::std::string::String>,
        c: ::std::option::Option<::std::vec::Vec<::std::string::String>>,
    }
    impl Builder {
        pub fn a(mut self, inp: impl Into<::std::string::String>) -> Self {
            self.a = Some(inp.into());
            self
        }
        pub fn b(mut self, inp: impl Into<::std::string::String>) -> Self {
            self.b = Some(inp.into());
            self
        }
        pub fn c(mut self, inp: ::std::vec::Vec<::std::string::String>) -> Self {
            self.c = Some(inp);
            self
        }
        /// Consumes the builder and constructs a [`NullAndEmptyHeadersServer`](crate::operation::NullAndEmptyHeadersServer)
        pub fn build(self) -> NullAndEmptyHeadersServer {
            NullAndEmptyHeadersServer::new(NullAndEmptyHeadersServerInput {
                a: self.a,
                b: self.b,
                c: self.c,
            })
        }
    }
}
impl NullAndEmptyHeadersServerInput {
    fn uri_base(&self, output: &mut String) {
        write!(output, "/NullAndEmptyHeadersServer").expect("formatting should succeed")
    }
    fn add_headers(&self, mut builder: ::http::request::Builder) -> ::http::request::Builder {
        if let Some(inner_82) = &self.a {
            let formatted_83 = ::smithy_http::query::fmt_string(&inner_82);
            if !formatted_83.is_empty() {
                builder = builder.header("X-A", ::smithy_http::query::fmt_string(&inner_82));
            }
        }
        if let Some(inner_84) = &self.b {
            let formatted_85 = ::smithy_http::query::fmt_string(&inner_84);
            if !formatted_85.is_empty() {
                builder = builder.header("X-B", ::smithy_http::query::fmt_string(&inner_84));
            }
        }
        if let Some(inner_86) = &self.c {
            for inner_87 in inner_86 {
                let formatted_88 = ::smithy_http::query::fmt_string(&inner_87);
                if !formatted_88.is_empty() {
                    builder = builder.header("X-C", ::smithy_http::query::fmt_string(&inner_87));
                }
            }
        }
        builder
    }
    fn update_http_builder(&self, builder: ::http::request::Builder) -> ::http::request::Builder {
        let mut uri = String::new();
        self.uri_base(&mut uri);
        let builder = self.add_headers(builder);
        builder.method("GET").uri(uri)
    }
    pub fn request_builder_base(&self) -> ::http::request::Builder {
        let builder = ::http::request::Builder::new();
        let builder = builder.header("Content-Type", "application/json");
        self.update_http_builder(builder)
    }
    pub fn build_body(&self) -> ::std::vec::Vec<u8> {
        todo!()
    }
    pub fn assemble(
        builder: ::http::request::Builder,
        body: ::std::vec::Vec<u8>,
    ) -> ::http::request::Request<::std::vec::Vec<u8>> {
        builder
            .header(::http::header::CONTENT_LENGTH, body.len())
            .body(body)
            .expect("http request should be valid")
    }
    /// Creates a new builder-style object to manufacture [`NullAndEmptyHeadersServerInput`](crate::input::NullAndEmptyHeadersServerInput)
    pub fn builder() -> crate::input::null_and_empty_headers_server_input::Builder {
        crate::input::null_and_empty_headers_server_input::Builder::default()
    }
}

/// See [`OmitsNullSerializesEmptyStringInput`](crate::input::OmitsNullSerializesEmptyStringInput)
pub mod omits_null_serializes_empty_string_input {

    use crate::input::OmitsNullSerializesEmptyStringInput;
    use crate::operation::OmitsNullSerializesEmptyString;
    /// A builder for [`OmitsNullSerializesEmptyStringInput`](crate::input::OmitsNullSerializesEmptyStringInput)
    #[non_exhaustive]
    #[derive(Debug, Clone, Default)]
    pub struct Builder {
        null_value: ::std::option::Option<::std::string::String>,
        empty_string: ::std::option::Option<::std::string::String>,
    }
    impl Builder {
        pub fn null_value(mut self, inp: impl Into<::std::string::String>) -> Self {
            self.null_value = Some(inp.into());
            self
        }
        pub fn empty_string(mut self, inp: impl Into<::std::string::String>) -> Self {
            self.empty_string = Some(inp.into());
            self
        }
        /// Consumes the builder and constructs a [`OmitsNullSerializesEmptyString`](crate::operation::OmitsNullSerializesEmptyString)
        pub fn build(self) -> OmitsNullSerializesEmptyString {
            OmitsNullSerializesEmptyString::new(OmitsNullSerializesEmptyStringInput {
                null_value: self.null_value,
                empty_string: self.empty_string,
            })
        }
    }
}
impl OmitsNullSerializesEmptyStringInput {
    fn uri_base(&self, output: &mut String) {
        write!(output, "/OmitsNullSerializesEmptyString").expect("formatting should succeed")
    }
    fn uri_query(&self, output: &mut String) {
        let mut params = Vec::new();
        if let Some(inner_89) = &self.null_value {
            params.push(("Null", ::smithy_http::query::fmt_string(&inner_89)))
        }
        if let Some(inner_90) = &self.empty_string {
            params.push(("Empty", ::smithy_http::query::fmt_string(&inner_90)))
        }
        ::smithy_http::query::write(params, output)
    }
    fn update_http_builder(&self, builder: ::http::request::Builder) -> ::http::request::Builder {
        let mut uri = String::new();
        self.uri_base(&mut uri);
        self.uri_query(&mut uri);
        builder.method("GET").uri(uri)
    }
    pub fn request_builder_base(&self) -> ::http::request::Builder {
        let builder = ::http::request::Builder::new();
        let builder = builder.header("Content-Type", "application/json");
        self.update_http_builder(builder)
    }
    pub fn build_body(&self) -> ::std::vec::Vec<u8> {
        todo!()
    }
    pub fn assemble(
        builder: ::http::request::Builder,
        body: ::std::vec::Vec<u8>,
    ) -> ::http::request::Request<::std::vec::Vec<u8>> {
        builder
            .header(::http::header::CONTENT_LENGTH, body.len())
            .body(body)
            .expect("http request should be valid")
    }
    /// Creates a new builder-style object to manufacture [`OmitsNullSerializesEmptyStringInput`](crate::input::OmitsNullSerializesEmptyStringInput)
    pub fn builder() -> crate::input::omits_null_serializes_empty_string_input::Builder {
        crate::input::omits_null_serializes_empty_string_input::Builder::default()
    }
}

/// See [`QueryIdempotencyTokenAutoFillInput`](crate::input::QueryIdempotencyTokenAutoFillInput)
pub mod query_idempotency_token_auto_fill_input {

    use crate::input::QueryIdempotencyTokenAutoFillInput;
    use crate::operation::QueryIdempotencyTokenAutoFill;
    /// A builder for [`QueryIdempotencyTokenAutoFillInput`](crate::input::QueryIdempotencyTokenAutoFillInput)
    #[non_exhaustive]
    #[derive(Debug, Clone, Default)]
    pub struct Builder {
        token: ::std::option::Option<::std::string::String>,
    }
    impl Builder {
        pub fn token(mut self, inp: impl Into<::std::string::String>) -> Self {
            self.token = Some(inp.into());
            self
        }
        /// Consumes the builder and constructs a [`QueryIdempotencyTokenAutoFill`](crate::operation::QueryIdempotencyTokenAutoFill)
        pub fn build(self) -> QueryIdempotencyTokenAutoFill {
            QueryIdempotencyTokenAutoFill::new(QueryIdempotencyTokenAutoFillInput {
                token: self.token,
            })
        }
    }
}
impl QueryIdempotencyTokenAutoFillInput {
    fn uri_base(&self, output: &mut String) {
        write!(output, "/QueryIdempotencyTokenAutoFill").expect("formatting should succeed")
    }
    fn uri_query(&self, output: &mut String) {
        let mut params = Vec::new();
        if let Some(inner_91) = &self.token {
            params.push(("token", ::smithy_http::query::fmt_string(&inner_91)))
        }
        ::smithy_http::query::write(params, output)
    }
    fn update_http_builder(&self, builder: ::http::request::Builder) -> ::http::request::Builder {
        let mut uri = String::new();
        self.uri_base(&mut uri);
        self.uri_query(&mut uri);
        builder.method("POST").uri(uri)
    }
    pub fn request_builder_base(&self) -> ::http::request::Builder {
        let builder = ::http::request::Builder::new();
        let builder = builder.header("Content-Type", "application/json");
        self.update_http_builder(builder)
    }
    pub fn build_body(&self) -> ::std::vec::Vec<u8> {
        todo!()
    }
    pub fn assemble(
        builder: ::http::request::Builder,
        body: ::std::vec::Vec<u8>,
    ) -> ::http::request::Request<::std::vec::Vec<u8>> {
        builder
            .header(::http::header::CONTENT_LENGTH, body.len())
            .body(body)
            .expect("http request should be valid")
    }
    /// Creates a new builder-style object to manufacture [`QueryIdempotencyTokenAutoFillInput`](crate::input::QueryIdempotencyTokenAutoFillInput)
    pub fn builder() -> crate::input::query_idempotency_token_auto_fill_input::Builder {
        crate::input::query_idempotency_token_auto_fill_input::Builder::default()
    }
}

/// See [`RecursiveShapesInput`](crate::input::RecursiveShapesInput)
pub mod recursive_shapes_input {

    use crate::input::RecursiveShapesInput;
    use crate::model::RecursiveShapesInputOutputNested1;
    use crate::operation::RecursiveShapes;
    /// A builder for [`RecursiveShapesInput`](crate::input::RecursiveShapesInput)
    #[non_exhaustive]
    #[derive(Debug, Clone, Default)]
    pub struct Builder {
        nested: ::std::option::Option<RecursiveShapesInputOutputNested1>,
    }
    impl Builder {
        pub fn nested(mut self, inp: RecursiveShapesInputOutputNested1) -> Self {
            self.nested = Some(inp);
            self
        }
        /// Consumes the builder and constructs a [`RecursiveShapes`](crate::operation::RecursiveShapes)
        pub fn build(self) -> RecursiveShapes {
            RecursiveShapes::new(RecursiveShapesInput {
                nested: self.nested,
            })
        }
    }
}
impl RecursiveShapesInput {
    fn uri_base(&self, output: &mut String) {
        write!(output, "/RecursiveShapes").expect("formatting should succeed")
    }
    fn update_http_builder(&self, builder: ::http::request::Builder) -> ::http::request::Builder {
        let mut uri = String::new();
        self.uri_base(&mut uri);
        builder.method("PUT").uri(uri)
    }
    pub fn request_builder_base(&self) -> ::http::request::Builder {
        let builder = ::http::request::Builder::new();
        let builder = builder.header("Content-Type", "application/json");
        self.update_http_builder(builder)
    }
    pub fn build_body(&self) -> ::std::vec::Vec<u8> {
        todo!()
    }
    pub fn assemble(
        builder: ::http::request::Builder,
        body: ::std::vec::Vec<u8>,
    ) -> ::http::request::Request<::std::vec::Vec<u8>> {
        builder
            .header(::http::header::CONTENT_LENGTH, body.len())
            .body(body)
            .expect("http request should be valid")
    }
    /// Creates a new builder-style object to manufacture [`RecursiveShapesInput`](crate::input::RecursiveShapesInput)
    pub fn builder() -> crate::input::recursive_shapes_input::Builder {
        crate::input::recursive_shapes_input::Builder::default()
    }
}

/// See [`SimpleScalarPropertiesInput`](crate::input::SimpleScalarPropertiesInput)
pub mod simple_scalar_properties_input {

    use crate::input::SimpleScalarPropertiesInput;
    use crate::operation::SimpleScalarProperties;
    /// A builder for [`SimpleScalarPropertiesInput`](crate::input::SimpleScalarPropertiesInput)
    #[non_exhaustive]
    #[derive(Debug, Clone, Default)]
    pub struct Builder {
        foo: ::std::option::Option<::std::string::String>,
        string_value: ::std::option::Option<::std::string::String>,
        true_boolean_value: ::std::option::Option<bool>,
        false_boolean_value: ::std::option::Option<bool>,
        byte_value: ::std::option::Option<i8>,
        short_value: ::std::option::Option<i16>,
        integer_value: ::std::option::Option<i32>,
        long_value: ::std::option::Option<i64>,
        float_value: ::std::option::Option<f32>,
        double_value: ::std::option::Option<f64>,
    }
    impl Builder {
        pub fn foo(mut self, inp: impl Into<::std::string::String>) -> Self {
            self.foo = Some(inp.into());
            self
        }
        pub fn string_value(mut self, inp: impl Into<::std::string::String>) -> Self {
            self.string_value = Some(inp.into());
            self
        }
        pub fn true_boolean_value(mut self, inp: bool) -> Self {
            self.true_boolean_value = Some(inp);
            self
        }
        pub fn false_boolean_value(mut self, inp: bool) -> Self {
            self.false_boolean_value = Some(inp);
            self
        }
        pub fn byte_value(mut self, inp: i8) -> Self {
            self.byte_value = Some(inp);
            self
        }
        pub fn short_value(mut self, inp: i16) -> Self {
            self.short_value = Some(inp);
            self
        }
        pub fn integer_value(mut self, inp: i32) -> Self {
            self.integer_value = Some(inp);
            self
        }
        pub fn long_value(mut self, inp: i64) -> Self {
            self.long_value = Some(inp);
            self
        }
        pub fn float_value(mut self, inp: f32) -> Self {
            self.float_value = Some(inp);
            self
        }
        pub fn double_value(mut self, inp: f64) -> Self {
            self.double_value = Some(inp);
            self
        }
        /// Consumes the builder and constructs a [`SimpleScalarProperties`](crate::operation::SimpleScalarProperties)
        pub fn build(self) -> SimpleScalarProperties {
            SimpleScalarProperties::new(SimpleScalarPropertiesInput {
                foo: self.foo,
                string_value: self.string_value,
                true_boolean_value: self.true_boolean_value,
                false_boolean_value: self.false_boolean_value,
                byte_value: self.byte_value,
                short_value: self.short_value,
                integer_value: self.integer_value,
                long_value: self.long_value,
                float_value: self.float_value,
                double_value: self.double_value,
            })
        }
    }
}
impl SimpleScalarPropertiesInput {
    fn uri_base(&self, output: &mut String) {
        write!(output, "/SimpleScalarProperties").expect("formatting should succeed")
    }
    fn add_headers(&self, mut builder: ::http::request::Builder) -> ::http::request::Builder {
        if let Some(inner_92) = &self.foo {
            let formatted_93 = ::smithy_http::query::fmt_string(&inner_92);
            if !formatted_93.is_empty() {
                builder = builder.header("X-Foo", ::smithy_http::query::fmt_string(&inner_92));
            }
        }
        builder
    }
    fn update_http_builder(&self, builder: ::http::request::Builder) -> ::http::request::Builder {
        let mut uri = String::new();
        self.uri_base(&mut uri);
        let builder = self.add_headers(builder);
        builder.method("PUT").uri(uri)
    }
    pub fn request_builder_base(&self) -> ::http::request::Builder {
        let builder = ::http::request::Builder::new();
        let builder = builder.header("Content-Type", "application/json");
        self.update_http_builder(builder)
    }
    pub fn build_body(&self) -> ::std::vec::Vec<u8> {
        todo!()
    }
    pub fn assemble(
        builder: ::http::request::Builder,
        body: ::std::vec::Vec<u8>,
    ) -> ::http::request::Request<::std::vec::Vec<u8>> {
        builder
            .header(::http::header::CONTENT_LENGTH, body.len())
            .body(body)
            .expect("http request should be valid")
    }
    /// Creates a new builder-style object to manufacture [`SimpleScalarPropertiesInput`](crate::input::SimpleScalarPropertiesInput)
    pub fn builder() -> crate::input::simple_scalar_properties_input::Builder {
        crate::input::simple_scalar_properties_input::Builder::default()
    }
}

/// See [`StreamingTraitsInput`](crate::input::StreamingTraitsInput)
pub mod streaming_traits_input {

    use crate::input::StreamingTraitsInput;
    use crate::operation::StreamingTraits;
    use smithy_types::Blob;
    /// A builder for [`StreamingTraitsInput`](crate::input::StreamingTraitsInput)
    #[non_exhaustive]
    #[derive(Debug, Clone, Default)]
    pub struct Builder {
        foo: ::std::option::Option<::std::string::String>,
        blob: ::std::option::Option<Blob>,
    }
    impl Builder {
        pub fn foo(mut self, inp: impl Into<::std::string::String>) -> Self {
            self.foo = Some(inp.into());
            self
        }
        pub fn blob(mut self, inp: Blob) -> Self {
            self.blob = Some(inp);
            self
        }
        /// Consumes the builder and constructs a [`StreamingTraits`](crate::operation::StreamingTraits)
        pub fn build(self) -> StreamingTraits {
            StreamingTraits::new(StreamingTraitsInput {
                foo: self.foo,
                blob: self.blob,
            })
        }
    }
}
impl StreamingTraitsInput {
    fn uri_base(&self, output: &mut String) {
        write!(output, "/StreamingTraits").expect("formatting should succeed")
    }
    fn add_headers(&self, mut builder: ::http::request::Builder) -> ::http::request::Builder {
        if let Some(inner_94) = &self.foo {
            let formatted_95 = ::smithy_http::query::fmt_string(&inner_94);
            if !formatted_95.is_empty() {
                builder = builder.header("X-Foo", ::smithy_http::query::fmt_string(&inner_94));
            }
        }
        builder
    }
    fn update_http_builder(&self, builder: ::http::request::Builder) -> ::http::request::Builder {
        let mut uri = String::new();
        self.uri_base(&mut uri);
        let builder = self.add_headers(builder);
        builder.method("POST").uri(uri)
    }
    pub fn request_builder_base(&self) -> ::http::request::Builder {
        let builder = ::http::request::Builder::new();
        let builder = builder.header("Content-Type", "application/octet-stream");
        self.update_http_builder(builder)
    }
    pub fn build_body(&self) -> ::std::vec::Vec<u8> {
        todo!()
    }
    pub fn assemble(
        builder: ::http::request::Builder,
        body: ::std::vec::Vec<u8>,
    ) -> ::http::request::Request<::std::vec::Vec<u8>> {
        builder
            .header(::http::header::CONTENT_LENGTH, body.len())
            .body(body)
            .expect("http request should be valid")
    }
    /// Creates a new builder-style object to manufacture [`StreamingTraitsInput`](crate::input::StreamingTraitsInput)
    pub fn builder() -> crate::input::streaming_traits_input::Builder {
        crate::input::streaming_traits_input::Builder::default()
    }
}

/// See [`StreamingTraitsRequireLengthInput`](crate::input::StreamingTraitsRequireLengthInput)
pub mod streaming_traits_require_length_input {

    use crate::input::StreamingTraitsRequireLengthInput;
    use crate::operation::StreamingTraitsRequireLength;
    use smithy_types::Blob;
    /// A builder for [`StreamingTraitsRequireLengthInput`](crate::input::StreamingTraitsRequireLengthInput)
    #[non_exhaustive]
    #[derive(Debug, Clone, Default)]
    pub struct Builder {
        foo: ::std::option::Option<::std::string::String>,
        blob: ::std::option::Option<Blob>,
    }
    impl Builder {
        pub fn foo(mut self, inp: impl Into<::std::string::String>) -> Self {
            self.foo = Some(inp.into());
            self
        }
        pub fn blob(mut self, inp: Blob) -> Self {
            self.blob = Some(inp);
            self
        }
        /// Consumes the builder and constructs a [`StreamingTraitsRequireLength`](crate::operation::StreamingTraitsRequireLength)
        pub fn build(self) -> StreamingTraitsRequireLength {
            StreamingTraitsRequireLength::new(StreamingTraitsRequireLengthInput {
                foo: self.foo,
                blob: self.blob,
            })
        }
    }
}
impl StreamingTraitsRequireLengthInput {
    fn uri_base(&self, output: &mut String) {
        write!(output, "/StreamingTraitsRequireLength").expect("formatting should succeed")
    }
    fn add_headers(&self, mut builder: ::http::request::Builder) -> ::http::request::Builder {
        if let Some(inner_96) = &self.foo {
            let formatted_97 = ::smithy_http::query::fmt_string(&inner_96);
            if !formatted_97.is_empty() {
                builder = builder.header("X-Foo", ::smithy_http::query::fmt_string(&inner_96));
            }
        }
        builder
    }
    fn update_http_builder(&self, builder: ::http::request::Builder) -> ::http::request::Builder {
        let mut uri = String::new();
        self.uri_base(&mut uri);
        let builder = self.add_headers(builder);
        builder.method("POST").uri(uri)
    }
    pub fn request_builder_base(&self) -> ::http::request::Builder {
        let builder = ::http::request::Builder::new();
        let builder = builder.header("Content-Type", "application/octet-stream");
        self.update_http_builder(builder)
    }
    pub fn build_body(&self) -> ::std::vec::Vec<u8> {
        todo!()
    }
    pub fn assemble(
        builder: ::http::request::Builder,
        body: ::std::vec::Vec<u8>,
    ) -> ::http::request::Request<::std::vec::Vec<u8>> {
        builder
            .header(::http::header::CONTENT_LENGTH, body.len())
            .body(body)
            .expect("http request should be valid")
    }
    /// Creates a new builder-style object to manufacture [`StreamingTraitsRequireLengthInput`](crate::input::StreamingTraitsRequireLengthInput)
    pub fn builder() -> crate::input::streaming_traits_require_length_input::Builder {
        crate::input::streaming_traits_require_length_input::Builder::default()
    }
}

/// See [`StreamingTraitsWithMediaTypeInput`](crate::input::StreamingTraitsWithMediaTypeInput)
pub mod streaming_traits_with_media_type_input {

    use crate::input::StreamingTraitsWithMediaTypeInput;
    use crate::operation::StreamingTraitsWithMediaType;
    use smithy_types::Blob;
    /// A builder for [`StreamingTraitsWithMediaTypeInput`](crate::input::StreamingTraitsWithMediaTypeInput)
    #[non_exhaustive]
    #[derive(Debug, Clone, Default)]
    pub struct Builder {
        foo: ::std::option::Option<::std::string::String>,
        blob: ::std::option::Option<Blob>,
    }
    impl Builder {
        pub fn foo(mut self, inp: impl Into<::std::string::String>) -> Self {
            self.foo = Some(inp.into());
            self
        }
        pub fn blob(mut self, inp: Blob) -> Self {
            self.blob = Some(inp);
            self
        }
        /// Consumes the builder and constructs a [`StreamingTraitsWithMediaType`](crate::operation::StreamingTraitsWithMediaType)
        pub fn build(self) -> StreamingTraitsWithMediaType {
            StreamingTraitsWithMediaType::new(StreamingTraitsWithMediaTypeInput {
                foo: self.foo,
                blob: self.blob,
            })
        }
    }
}
impl StreamingTraitsWithMediaTypeInput {
    fn uri_base(&self, output: &mut String) {
        write!(output, "/StreamingTraitsWithMediaType").expect("formatting should succeed")
    }
    fn add_headers(&self, mut builder: ::http::request::Builder) -> ::http::request::Builder {
        if let Some(inner_98) = &self.foo {
            let formatted_99 = ::smithy_http::query::fmt_string(&inner_98);
            if !formatted_99.is_empty() {
                builder = builder.header("X-Foo", ::smithy_http::query::fmt_string(&inner_98));
            }
        }
        builder
    }
    fn update_http_builder(&self, builder: ::http::request::Builder) -> ::http::request::Builder {
        let mut uri = String::new();
        self.uri_base(&mut uri);
        let builder = self.add_headers(builder);
        builder.method("POST").uri(uri)
    }
    pub fn request_builder_base(&self) -> ::http::request::Builder {
        let builder = ::http::request::Builder::new();
        let builder = builder.header("Content-Type", "text/plain");
        self.update_http_builder(builder)
    }
    pub fn build_body(&self) -> ::std::vec::Vec<u8> {
        todo!()
    }
    pub fn assemble(
        builder: ::http::request::Builder,
        body: ::std::vec::Vec<u8>,
    ) -> ::http::request::Request<::std::vec::Vec<u8>> {
        builder
            .header(::http::header::CONTENT_LENGTH, body.len())
            .body(body)
            .expect("http request should be valid")
    }
    /// Creates a new builder-style object to manufacture [`StreamingTraitsWithMediaTypeInput`](crate::input::StreamingTraitsWithMediaTypeInput)
    pub fn builder() -> crate::input::streaming_traits_with_media_type_input::Builder {
        crate::input::streaming_traits_with_media_type_input::Builder::default()
    }
}

/// See [`TimestampFormatHeadersInput`](crate::input::TimestampFormatHeadersInput)
pub mod timestamp_format_headers_input {

    use crate::input::TimestampFormatHeadersInput;
    use crate::operation::TimestampFormatHeaders;
    use smithy_types::Instant;
    /// A builder for [`TimestampFormatHeadersInput`](crate::input::TimestampFormatHeadersInput)
    #[non_exhaustive]
    #[derive(Debug, Clone, Default)]
    pub struct Builder {
        member_epoch_seconds: ::std::option::Option<Instant>,
        member_http_date: ::std::option::Option<Instant>,
        member_date_time: ::std::option::Option<Instant>,
        default_format: ::std::option::Option<Instant>,
        target_epoch_seconds: ::std::option::Option<Instant>,
        target_http_date: ::std::option::Option<Instant>,
        target_date_time: ::std::option::Option<Instant>,
    }
    impl Builder {
        pub fn member_epoch_seconds(mut self, inp: Instant) -> Self {
            self.member_epoch_seconds = Some(inp);
            self
        }
        pub fn member_http_date(mut self, inp: Instant) -> Self {
            self.member_http_date = Some(inp);
            self
        }
        pub fn member_date_time(mut self, inp: Instant) -> Self {
            self.member_date_time = Some(inp);
            self
        }
        pub fn default_format(mut self, inp: Instant) -> Self {
            self.default_format = Some(inp);
            self
        }
        pub fn target_epoch_seconds(mut self, inp: Instant) -> Self {
            self.target_epoch_seconds = Some(inp);
            self
        }
        pub fn target_http_date(mut self, inp: Instant) -> Self {
            self.target_http_date = Some(inp);
            self
        }
        pub fn target_date_time(mut self, inp: Instant) -> Self {
            self.target_date_time = Some(inp);
            self
        }
        /// Consumes the builder and constructs a [`TimestampFormatHeaders`](crate::operation::TimestampFormatHeaders)
        pub fn build(self) -> TimestampFormatHeaders {
            TimestampFormatHeaders::new(TimestampFormatHeadersInput {
                member_epoch_seconds: self.member_epoch_seconds,
                member_http_date: self.member_http_date,
                member_date_time: self.member_date_time,
                default_format: self.default_format,
                target_epoch_seconds: self.target_epoch_seconds,
                target_http_date: self.target_http_date,
                target_date_time: self.target_date_time,
            })
        }
    }
}
impl TimestampFormatHeadersInput {
    fn uri_base(&self, output: &mut String) {
        write!(output, "/TimestampFormatHeaders").expect("formatting should succeed")
    }
    fn add_headers(&self, mut builder: ::http::request::Builder) -> ::http::request::Builder {
        if let Some(inner_100) = &self.member_epoch_seconds {
            let formatted_101 = inner_100.fmt(::smithy_types::instant::Format::EpochSeconds);
            if !formatted_101.is_empty() {
                builder = builder.header(
                    "X-memberEpochSeconds",
                    inner_100.fmt(::smithy_types::instant::Format::EpochSeconds),
                );
            }
        }
        if let Some(inner_102) = &self.member_http_date {
            let formatted_103 = inner_102.fmt(::smithy_types::instant::Format::HttpDate);
            if !formatted_103.is_empty() {
                builder = builder.header(
                    "X-memberHttpDate",
                    inner_102.fmt(::smithy_types::instant::Format::HttpDate),
                );
            }
        }
        if let Some(inner_104) = &self.member_date_time {
            let formatted_105 = inner_104.fmt(::smithy_types::instant::Format::DateTime);
            if !formatted_105.is_empty() {
                builder = builder.header(
                    "X-memberDateTime",
                    inner_104.fmt(::smithy_types::instant::Format::DateTime),
                );
            }
        }
        if let Some(inner_106) = &self.default_format {
            let formatted_107 = inner_106.fmt(::smithy_types::instant::Format::HttpDate);
            if !formatted_107.is_empty() {
                builder = builder.header(
                    "X-defaultFormat",
                    inner_106.fmt(::smithy_types::instant::Format::HttpDate),
                );
            }
        }
        if let Some(inner_108) = &self.target_epoch_seconds {
            let formatted_109 = inner_108.fmt(::smithy_types::instant::Format::EpochSeconds);
            if !formatted_109.is_empty() {
                builder = builder.header(
                    "X-targetEpochSeconds",
                    inner_108.fmt(::smithy_types::instant::Format::EpochSeconds),
                );
            }
        }
        if let Some(inner_110) = &self.target_http_date {
            let formatted_111 = inner_110.fmt(::smithy_types::instant::Format::HttpDate);
            if !formatted_111.is_empty() {
                builder = builder.header(
                    "X-targetHttpDate",
                    inner_110.fmt(::smithy_types::instant::Format::HttpDate),
                );
            }
        }
        if let Some(inner_112) = &self.target_date_time {
            let formatted_113 = inner_112.fmt(::smithy_types::instant::Format::DateTime);
            if !formatted_113.is_empty() {
                builder = builder.header(
                    "X-targetDateTime",
                    inner_112.fmt(::smithy_types::instant::Format::DateTime),
                );
            }
        }
        builder
    }
    fn update_http_builder(&self, builder: ::http::request::Builder) -> ::http::request::Builder {
        let mut uri = String::new();
        self.uri_base(&mut uri);
        let builder = self.add_headers(builder);
        builder.method("POST").uri(uri)
    }
    pub fn request_builder_base(&self) -> ::http::request::Builder {
        let builder = ::http::request::Builder::new();
        let builder = builder.header("Content-Type", "application/json");
        self.update_http_builder(builder)
    }
    pub fn build_body(&self) -> ::std::vec::Vec<u8> {
        todo!()
    }
    pub fn assemble(
        builder: ::http::request::Builder,
        body: ::std::vec::Vec<u8>,
    ) -> ::http::request::Request<::std::vec::Vec<u8>> {
        builder
            .header(::http::header::CONTENT_LENGTH, body.len())
            .body(body)
            .expect("http request should be valid")
    }
    /// Creates a new builder-style object to manufacture [`TimestampFormatHeadersInput`](crate::input::TimestampFormatHeadersInput)
    pub fn builder() -> crate::input::timestamp_format_headers_input::Builder {
        crate::input::timestamp_format_headers_input::Builder::default()
    }
}

/// A shared structure that contains a single union member.
#[non_exhaustive]
#[derive(::std::clone::Clone, ::std::cmp::PartialEq, ::std::fmt::Debug)]
pub struct JsonUnionsInput {
    /// A union with a representative set of types for members.
    pub contents: ::std::option::Option<MyUnion>,
}

#[non_exhaustive]
#[derive(::std::clone::Clone, ::std::cmp::PartialEq, ::std::fmt::Debug)]
pub struct InlineDocumentAsPayloadInput {
    pub document_value: Document,
}

#[non_exhaustive]
#[derive(::std::clone::Clone, ::std::cmp::PartialEq, ::std::fmt::Debug)]
pub struct InlineDocumentInput {
    pub string_value: ::std::option::Option<::std::string::String>,
    pub document_value: Document,
}

#[non_exhaustive]
#[derive(::std::clone::Clone, ::std::cmp::PartialEq, ::std::fmt::Debug)]
pub struct JsonBlobsInput {
    pub data: ::std::option::Option<Blob>,
}

#[non_exhaustive]
#[derive(::std::clone::Clone, ::std::cmp::PartialEq, ::std::fmt::Debug)]
pub struct JsonMapsInput {
    pub dense_struct_map:
        ::std::option::Option<::std::collections::HashMap<::std::string::String, GreetingStruct>>,
    pub sparse_struct_map: ::std::option::Option<
        ::std::collections::HashMap<::std::string::String, ::std::option::Option<GreetingStruct>>,
    >,
    pub dense_number_map:
        ::std::option::Option<::std::collections::HashMap<::std::string::String, i32>>,
    pub dense_boolean_map:
        ::std::option::Option<::std::collections::HashMap<::std::string::String, bool>>,
    pub dense_string_map: ::std::option::Option<
        ::std::collections::HashMap<::std::string::String, ::std::string::String>,
    >,
    pub sparse_number_map: ::std::option::Option<
        ::std::collections::HashMap<::std::string::String, ::std::option::Option<i32>>,
    >,
    pub sparse_boolean_map: ::std::option::Option<
        ::std::collections::HashMap<::std::string::String, ::std::option::Option<bool>>,
    >,
    pub sparse_string_map: ::std::option::Option<
        ::std::collections::HashMap<
            ::std::string::String,
            ::std::option::Option<::std::string::String>,
        >,
    >,
}

#[non_exhaustive]
#[derive(::std::clone::Clone, ::std::cmp::PartialEq, ::std::fmt::Debug)]
pub struct JsonListsInput {
    pub string_list: ::std::option::Option<::std::vec::Vec<::std::string::String>>,
    pub sparse_string_list:
        ::std::option::Option<::std::vec::Vec<::std::option::Option<::std::string::String>>>,
    pub string_set: ::std::option::Option<::std::collections::BTreeSet<::std::string::String>>,
    pub integer_list: ::std::option::Option<::std::vec::Vec<i32>>,
    pub boolean_list: ::std::option::Option<::std::vec::Vec<bool>>,
    pub timestamp_list: ::std::option::Option<::std::vec::Vec<Instant>>,
    pub enum_list: ::std::option::Option<::std::vec::Vec<FooEnum>>,
    /// A list of lists of strings.
    pub nested_string_list:
        ::std::option::Option<::std::vec::Vec<::std::vec::Vec<::std::string::String>>>,
    pub structure_list: ::std::option::Option<::std::vec::Vec<StructureListMember>>,
}

#[non_exhaustive]
#[derive(::std::clone::Clone, ::std::cmp::PartialEq, ::std::fmt::Debug)]
pub struct RecursiveShapesInput {
    pub nested: ::std::option::Option<RecursiveShapesInputOutputNested1>,
}

#[non_exhaustive]
#[derive(::std::clone::Clone, ::std::cmp::PartialEq, ::std::fmt::Debug)]
pub struct JsonEnumsInput {
    pub foo_enum1: ::std::option::Option<FooEnum>,
    pub foo_enum2: ::std::option::Option<FooEnum>,
    pub foo_enum3: ::std::option::Option<FooEnum>,
    pub foo_enum_list: ::std::option::Option<::std::vec::Vec<FooEnum>>,
    pub foo_enum_set: ::std::option::Option<::std::collections::BTreeSet<FooEnum>>,
    pub foo_enum_map:
        ::std::option::Option<::std::collections::HashMap<::std::string::String, FooEnum>>,
}

#[non_exhaustive]
#[derive(::std::clone::Clone, ::std::cmp::PartialEq, ::std::fmt::Debug)]
pub struct JsonTimestampsInput {
    pub normal: ::std::option::Option<Instant>,
    pub date_time: ::std::option::Option<Instant>,
    pub epoch_seconds: ::std::option::Option<Instant>,
    pub http_date: ::std::option::Option<Instant>,
}

#[non_exhaustive]
#[derive(::std::clone::Clone, ::std::cmp::PartialEq, ::std::fmt::Debug)]
pub struct SimpleScalarPropertiesInput {
    pub foo: ::std::option::Option<::std::string::String>,
    pub string_value: ::std::option::Option<::std::string::String>,
    pub true_boolean_value: ::std::option::Option<bool>,
    pub false_boolean_value: ::std::option::Option<bool>,
    pub byte_value: ::std::option::Option<i8>,
    pub short_value: ::std::option::Option<i16>,
    pub integer_value: ::std::option::Option<i32>,
    pub long_value: ::std::option::Option<i64>,
    pub float_value: ::std::option::Option<f32>,
    pub double_value: ::std::option::Option<f64>,
}

#[non_exhaustive]
#[derive(::std::clone::Clone, ::std::cmp::PartialEq, ::std::fmt::Debug)]
pub struct GreetingWithErrorsInput {}

#[non_exhaustive]
#[derive(::std::clone::Clone, ::std::cmp::PartialEq, ::std::fmt::Debug)]
pub struct StreamingTraitsWithMediaTypeInput {
    pub foo: ::std::option::Option<::std::string::String>,
    pub blob: ::std::option::Option<Blob>,
}

#[non_exhaustive]
#[derive(::std::clone::Clone, ::std::cmp::PartialEq, ::std::fmt::Debug)]
pub struct StreamingTraitsRequireLengthInput {
    pub foo: ::std::option::Option<::std::string::String>,
    pub blob: ::std::option::Option<Blob>,
}

#[non_exhaustive]
#[derive(::std::clone::Clone, ::std::cmp::PartialEq, ::std::fmt::Debug)]
pub struct StreamingTraitsInput {
    pub foo: ::std::option::Option<::std::string::String>,
    pub blob: ::std::option::Option<Blob>,
}

#[non_exhaustive]
#[derive(::std::clone::Clone, ::std::cmp::PartialEq, ::std::fmt::Debug)]
pub struct HttpResponseCodeInput {}

#[non_exhaustive]
#[derive(::std::clone::Clone, ::std::cmp::PartialEq, ::std::fmt::Debug)]
pub struct HttpPayloadWithStructureInput {
    pub nested: ::std::option::Option<NestedPayload>,
}

#[non_exhaustive]
#[derive(::std::clone::Clone, ::std::cmp::PartialEq, ::std::fmt::Debug)]
pub struct HttpPayloadTraitsWithMediaTypeInput {
    pub foo: ::std::option::Option<::std::string::String>,
    pub blob: ::std::option::Option<Blob>,
}

#[non_exhaustive]
#[derive(::std::clone::Clone, ::std::cmp::PartialEq, ::std::fmt::Debug)]
pub struct HttpPayloadTraitsInput {
    pub foo: ::std::option::Option<::std::string::String>,
    pub blob: ::std::option::Option<Blob>,
}

#[non_exhaustive]
#[derive(::std::clone::Clone, ::std::cmp::PartialEq, ::std::fmt::Debug)]
pub struct HttpPrefixHeadersResponseInput {}

#[non_exhaustive]
#[derive(::std::clone::Clone, ::std::cmp::PartialEq, ::std::fmt::Debug)]
pub struct HttpPrefixHeadersInput {
    pub foo: ::std::option::Option<::std::string::String>,
    pub foo_map: ::std::option::Option<
        ::std::collections::HashMap<::std::string::String, ::std::string::String>,
    >,
}

#[non_exhaustive]
#[derive(::std::clone::Clone, ::std::cmp::PartialEq, ::std::fmt::Debug)]
pub struct QueryIdempotencyTokenAutoFillInput {
    pub token: ::std::option::Option<::std::string::String>,
}

#[non_exhaustive]
#[derive(::std::clone::Clone, ::std::cmp::PartialEq, ::std::fmt::Debug)]
pub struct OmitsNullSerializesEmptyStringInput {
    pub null_value: ::std::option::Option<::std::string::String>,
    pub empty_string: ::std::option::Option<::std::string::String>,
}

#[non_exhaustive]
#[derive(::std::clone::Clone, ::std::cmp::PartialEq, ::std::fmt::Debug)]
pub struct IgnoreQueryParamsInResponseInput {}

#[non_exhaustive]
#[derive(::std::clone::Clone, ::std::cmp::PartialEq, ::std::fmt::Debug)]
pub struct ConstantAndVariableQueryStringInput {
    pub baz: ::std::option::Option<::std::string::String>,
    pub maybe_set: ::std::option::Option<::std::string::String>,
}

#[non_exhaustive]
#[derive(::std::clone::Clone, ::std::cmp::PartialEq, ::std::fmt::Debug)]
pub struct ConstantQueryStringInput {
    pub hello: ::std::string::String,
}

#[non_exhaustive]
#[derive(::std::clone::Clone, ::std::cmp::PartialEq, ::std::fmt::Debug)]
pub struct AllQueryStringTypesInput {
    pub query_string: ::std::option::Option<::std::string::String>,
    pub query_string_list: ::std::option::Option<::std::vec::Vec<::std::string::String>>,
    pub query_string_set:
        ::std::option::Option<::std::collections::BTreeSet<::std::string::String>>,
    pub query_byte: ::std::option::Option<i8>,
    pub query_short: ::std::option::Option<i16>,
    pub query_integer: ::std::option::Option<i32>,
    pub query_integer_list: ::std::option::Option<::std::vec::Vec<i32>>,
    pub query_integer_set: ::std::option::Option<::std::vec::Vec<i32>>,
    pub query_long: ::std::option::Option<i64>,
    pub query_float: ::std::option::Option<f32>,
    pub query_double: ::std::option::Option<f64>,
    pub query_double_list: ::std::option::Option<::std::vec::Vec<f64>>,
    pub query_boolean: ::std::option::Option<bool>,
    pub query_boolean_list: ::std::option::Option<::std::vec::Vec<bool>>,
    pub query_timestamp: ::std::option::Option<Instant>,
    pub query_timestamp_list: ::std::option::Option<::std::vec::Vec<Instant>>,
    pub query_enum: ::std::option::Option<FooEnum>,
    pub query_enum_list: ::std::option::Option<::std::vec::Vec<FooEnum>>,
}

#[non_exhaustive]
#[derive(::std::clone::Clone, ::std::cmp::PartialEq, ::std::fmt::Debug)]
pub struct HttpRequestWithGreedyLabelInPathInput {
    pub foo: ::std::string::String,
    pub baz: ::std::string::String,
}

#[non_exhaustive]
#[derive(::std::clone::Clone, ::std::cmp::PartialEq, ::std::fmt::Debug)]
pub struct HttpRequestWithLabelsAndTimestampFormatInput {
    pub member_epoch_seconds: Instant,
    pub member_http_date: Instant,
    pub member_date_time: Instant,
    pub default_format: Instant,
    pub target_epoch_seconds: Instant,
    pub target_http_date: Instant,
    pub target_date_time: Instant,
}

#[non_exhaustive]
#[derive(::std::clone::Clone, ::std::cmp::PartialEq, ::std::fmt::Debug)]
pub struct HttpRequestWithLabelsInput {
    pub string: ::std::string::String,
    pub short: i16,
    pub integer: i32,
    pub long: i64,
    pub float: f32,
    pub double: f64,
    /// Serialized in the path as true or false.
    pub boolean: bool,
    /// Note that this member has no format, so it's serialized as an RFC 3399 date-time.
    pub timestamp: Instant,
}

#[non_exhaustive]
#[derive(::std::clone::Clone, ::std::cmp::PartialEq, ::std::fmt::Debug)]
pub struct MediaTypeHeaderInput {
    pub json: ::std::option::Option<::std::string::String>,
}

#[non_exhaustive]
#[derive(::std::clone::Clone, ::std::cmp::PartialEq, ::std::fmt::Debug)]
pub struct TimestampFormatHeadersInput {
    pub member_epoch_seconds: ::std::option::Option<Instant>,
    pub member_http_date: ::std::option::Option<Instant>,
    pub member_date_time: ::std::option::Option<Instant>,
    pub default_format: ::std::option::Option<Instant>,
    pub target_epoch_seconds: ::std::option::Option<Instant>,
    pub target_http_date: ::std::option::Option<Instant>,
    pub target_date_time: ::std::option::Option<Instant>,
}

#[non_exhaustive]
#[derive(::std::clone::Clone, ::std::cmp::PartialEq, ::std::fmt::Debug)]
pub struct NullAndEmptyHeadersServerInput {
    pub a: ::std::option::Option<::std::string::String>,
    pub b: ::std::option::Option<::std::string::String>,
    pub c: ::std::option::Option<::std::vec::Vec<::std::string::String>>,
}

#[non_exhaustive]
#[derive(::std::clone::Clone, ::std::cmp::PartialEq, ::std::fmt::Debug)]
pub struct NullAndEmptyHeadersClientInput {
    pub a: ::std::option::Option<::std::string::String>,
    pub b: ::std::option::Option<::std::string::String>,
    pub c: ::std::option::Option<::std::vec::Vec<::std::string::String>>,
}

#[non_exhaustive]
#[derive(::std::clone::Clone, ::std::cmp::PartialEq, ::std::fmt::Debug)]
pub struct InputAndOutputWithHeadersInput {
    pub header_string: ::std::option::Option<::std::string::String>,
    pub header_byte: ::std::option::Option<i8>,
    pub header_short: ::std::option::Option<i16>,
    pub header_integer: ::std::option::Option<i32>,
    pub header_long: ::std::option::Option<i64>,
    pub header_float: ::std::option::Option<f32>,
    pub header_double: ::std::option::Option<f64>,
    pub header_true_bool: ::std::option::Option<bool>,
    pub header_false_bool: ::std::option::Option<bool>,
    pub header_string_list: ::std::option::Option<::std::vec::Vec<::std::string::String>>,
    pub header_string_set:
        ::std::option::Option<::std::collections::BTreeSet<::std::string::String>>,
    pub header_integer_list: ::std::option::Option<::std::vec::Vec<i32>>,
    pub header_boolean_list: ::std::option::Option<::std::vec::Vec<bool>>,
    pub header_timestamp_list: ::std::option::Option<::std::vec::Vec<Instant>>,
    pub header_enum: ::std::option::Option<FooEnum>,
    pub header_enum_list: ::std::option::Option<::std::vec::Vec<FooEnum>>,
}

#[non_exhaustive]
#[derive(::std::clone::Clone, ::std::cmp::PartialEq, ::std::fmt::Debug)]
pub struct EmptyInputAndEmptyOutputInput {}

#[non_exhaustive]
#[derive(::std::clone::Clone, ::std::cmp::PartialEq, ::std::fmt::Debug)]
pub struct NoInputAndOutputInput {}

#[non_exhaustive]
#[derive(::std::clone::Clone, ::std::cmp::PartialEq, ::std::fmt::Debug)]
pub struct NoInputAndNoOutputInput {}
