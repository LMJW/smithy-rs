// Code generated by software.amazon.smithy.rust.codegen.smithy-rs. DO NOT EDIT.
use crate::input::AllQueryStringTypesInput;
use crate::input::ConstantAndVariableQueryStringInput;
use crate::input::ConstantQueryStringInput;
use crate::input::EmptyInputAndEmptyOutputInput;
use crate::input::GreetingWithErrorsInput;
use crate::input::HttpPayloadTraitsInput;
use crate::input::HttpPayloadTraitsWithMediaTypeInput;
use crate::input::HttpPayloadWithStructureInput;
use crate::input::HttpPrefixHeadersInput;
use crate::input::HttpPrefixHeadersResponseInput;
use crate::input::HttpRequestWithGreedyLabelInPathInput;
use crate::input::HttpRequestWithLabelsAndTimestampFormatInput;
use crate::input::HttpRequestWithLabelsInput;
use crate::input::HttpResponseCodeInput;
use crate::input::IgnoreQueryParamsInResponseInput;
use crate::input::InlineDocumentAsPayloadInput;
use crate::input::InlineDocumentInput;
use crate::input::InputAndOutputWithHeadersInput;
use crate::input::JsonBlobsInput;
use crate::input::JsonEnumsInput;
use crate::input::JsonListsInput;
use crate::input::JsonMapsInput;
use crate::input::JsonTimestampsInput;
use crate::input::JsonUnionsInput;
use crate::input::MediaTypeHeaderInput;
use crate::input::NoInputAndNoOutputInput;
use crate::input::NoInputAndOutputInput;
use crate::input::NullAndEmptyHeadersClientInput;
use crate::input::NullAndEmptyHeadersServerInput;
use crate::input::OmitsNullSerializesEmptyStringInput;
use crate::input::QueryIdempotencyTokenAutoFillInput;
use crate::input::RecursiveShapesInput;
use crate::input::SimpleScalarPropertiesInput;
use crate::input::StreamingTraitsInput;
use crate::input::StreamingTraitsRequireLengthInput;
use crate::input::StreamingTraitsWithMediaTypeInput;
use crate::input::TimestampFormatHeadersInput;
/// This example uses all query string types.
pub struct AllQueryStringTypes {
    input: AllQueryStringTypesInput,
}
impl AllQueryStringTypes {
    /// Creates a new builder-style object to manufacture [`AllQueryStringTypesInput`](crate::input::AllQueryStringTypesInput)
    pub fn builder() -> crate::input::all_query_string_types_input::Builder {
        crate::input::all_query_string_types_input::Builder::default()
    }
    pub fn build_http_request(&self) -> ::http::request::Request<Vec<u8>> {
        AllQueryStringTypesInput::assemble(
            self.input.request_builder_base(),
            self.input.build_body(),
        )
    }
    pub fn new(input: AllQueryStringTypesInput) -> Self {
        Self { input }
    }
}
#[cfg(test)]
#[allow(unreachable_code, unused_variables)]
mod all_query_string_types_request_test {

    use crate::input::AllQueryStringTypesInput;
    use crate::model::FooEnum;
    /// Serializes query string parameters with all supported types
    /// Test ID: RestJsonAllQueryStringTypes
    #[test]
    fn test_rest_json_all_query_string_types_request() {
        let input = AllQueryStringTypesInput::builder()
            .query_string("Hello there".to_string())
            .query_string_list(vec!["a".to_string(), "b".to_string(), "c".to_string()])
            .query_string_set({
                let mut ret = ::std::collections::BTreeSet::new();
                ret.insert("a".to_string());
                ret.insert("b".to_string());
                ret.insert("c".to_string());
                ret
            })
            .query_byte(1)
            .query_short(2)
            .query_integer(3)
            .query_integer_list(vec![1, 2, 3])
            .query_integer_set(vec![1, 2, 3])
            .query_long(4)
            .query_float(1.1)
            .query_double(1.1)
            .query_double_list(vec![1.1, 2.1, 3.1])
            .query_boolean(true)
            .query_boolean_list(vec![true, false, true])
            .query_timestamp(::smithy_types::Instant::from_epoch_seconds(1))
            .query_timestamp_list(vec![
                ::smithy_types::Instant::from_epoch_seconds(1),
                ::smithy_types::Instant::from_epoch_seconds(2),
                ::smithy_types::Instant::from_epoch_seconds(3),
            ])
            .query_enum(FooEnum::from("Foo"))
            .query_enum_list(vec![
                FooEnum::from("Foo"),
                FooEnum::from("Baz"),
                FooEnum::from("Bar"),
            ])
            .build();
        let http_request =
            AllQueryStringTypesInput::assemble(input.input.request_builder_base(), vec![]);

        assert_eq!(http_request.method(), "GET");
        assert_eq!(http_request.uri().path(), "/AllQueryStringTypesInput");

        let expected_query_params = &[
            "String=Hello%20there",
            "StringList=a",
            "StringList=b",
            "StringList=c",
            "StringSet=a",
            "StringSet=b",
            "StringSet=c",
            "Byte=1",
            "Short=2",
            "Integer=3",
            "IntegerList=1",
            "IntegerList=2",
            "IntegerList=3",
            "IntegerSet=1",
            "IntegerSet=2",
            "IntegerSet=3",
            "Long=4",
            "Float=1.1",
            "Double=1.1",
            "DoubleList=1.1",
            "DoubleList=2.1",
            "DoubleList=3.1",
            "Boolean=true",
            "BooleanList=true",
            "BooleanList=false",
            "BooleanList=true",
            "Timestamp=1970-01-01T00%3A00%3A01Z",
            "TimestampList=1970-01-01T00%3A00%3A01Z",
            "TimestampList=1970-01-01T00%3A00%3A02Z",
            "TimestampList=1970-01-01T00%3A00%3A03Z",
            "Enum=Foo",
            "EnumList=Foo",
            "EnumList=Baz",
            "EnumList=Bar",
        ];
        ::protocol_test_helpers::assert_ok(::protocol_test_helpers::validate_query_string(
            &http_request,
            expected_query_params,
        ));
    }
}

/// This example uses fixed query string params and variable query string params.
/// The fixed query string parameters and variable parameters must both be
/// serialized (implementations may need to merge them together).
pub struct ConstantAndVariableQueryString {
    input: ConstantAndVariableQueryStringInput,
}
impl ConstantAndVariableQueryString {
    /// Creates a new builder-style object to manufacture [`ConstantAndVariableQueryStringInput`](crate::input::ConstantAndVariableQueryStringInput)
    pub fn builder() -> crate::input::constant_and_variable_query_string_input::Builder {
        crate::input::constant_and_variable_query_string_input::Builder::default()
    }
    pub fn build_http_request(&self) -> ::http::request::Request<Vec<u8>> {
        ConstantAndVariableQueryStringInput::assemble(
            self.input.request_builder_base(),
            self.input.build_body(),
        )
    }
    pub fn new(input: ConstantAndVariableQueryStringInput) -> Self {
        Self { input }
    }
}
#[cfg(test)]
#[allow(unreachable_code, unused_variables)]
mod constant_and_variable_query_string_request_test {

    use crate::input::ConstantAndVariableQueryStringInput;
    /// Mixes constant and variable query string parameters
    /// Test ID: RestJsonConstantAndVariableQueryStringMissingOneValue
    #[test]
    #[should_panic]
    fn test_rest_json_constant_and_variable_query_string_missing_one_value_request() {
        let input = ConstantAndVariableQueryStringInput::builder()
            .baz("bam".to_string())
            .build();
        let http_request = ConstantAndVariableQueryStringInput::assemble(
            input.input.request_builder_base(),
            vec![],
        );

        assert_eq!(http_request.method(), "GET");
        assert_eq!(http_request.uri().path(), "/ConstantAndVariableQueryString");

        let expected_query_params = &["foo=bar", "baz=bam"];
        ::protocol_test_helpers::assert_ok(::protocol_test_helpers::validate_query_string(
            &http_request,
            expected_query_params,
        ));
        let forbid_params = &["maybeSet"];
        ::protocol_test_helpers::assert_ok(::protocol_test_helpers::forbid_query_params(
            &http_request,
            forbid_params,
        ));
    }
    /// Mixes constant and variable query string parameters
    /// Test ID: RestJsonConstantAndVariableQueryStringAllValues
    #[test]
    #[should_panic]
    fn test_rest_json_constant_and_variable_query_string_all_values_request() {
        let input = ConstantAndVariableQueryStringInput::builder()
            .baz("bam".to_string())
            .maybe_set("yes".to_string())
            .build();
        let http_request = ConstantAndVariableQueryStringInput::assemble(
            input.input.request_builder_base(),
            vec![],
        );

        assert_eq!(http_request.method(), "GET");
        assert_eq!(http_request.uri().path(), "/ConstantAndVariableQueryString");

        let expected_query_params = &["foo=bar", "baz=bam", "maybeSet=yes"];
        ::protocol_test_helpers::assert_ok(::protocol_test_helpers::validate_query_string(
            &http_request,
            expected_query_params,
        ));
    }
}

/// This example uses a constant query string parameters and a label.
/// This simply tests that labels and query string parameters are
/// compatible. The fixed query string parameter named "hello" should
/// in no way conflict with the label, `{hello}`.
pub struct ConstantQueryString {
    input: ConstantQueryStringInput,
}
impl ConstantQueryString {
    /// Creates a new builder-style object to manufacture [`ConstantQueryStringInput`](crate::input::ConstantQueryStringInput)
    pub fn builder() -> crate::input::constant_query_string_input::Builder {
        crate::input::constant_query_string_input::Builder::default()
    }
    pub fn build_http_request(&self) -> ::http::request::Request<Vec<u8>> {
        ConstantQueryStringInput::assemble(
            self.input.request_builder_base(),
            self.input.build_body(),
        )
    }
    pub fn new(input: ConstantQueryStringInput) -> Self {
        Self { input }
    }
}
#[cfg(test)]
#[allow(unreachable_code, unused_variables)]
mod constant_query_string_request_test {

    use crate::input::ConstantQueryStringInput;
    /// Includes constant query string parameters
    /// Test ID: RestJsonConstantQueryString
    #[test]
    #[should_panic]
    fn test_rest_json_constant_query_string_request() {
        let input = ConstantQueryStringInput::builder()
            .hello("hi".to_string())
            .build();
        let http_request =
            ConstantQueryStringInput::assemble(input.input.request_builder_base(), vec![]);

        assert_eq!(http_request.method(), "GET");
        assert_eq!(http_request.uri().path(), "/ConstantQueryString/hi");

        let expected_query_params = &["foo=bar", "hello"];
        ::protocol_test_helpers::assert_ok(::protocol_test_helpers::validate_query_string(
            &http_request,
            expected_query_params,
        ));
    }
}

/// The example tests how requests and responses are serialized when there's
/// no request or response payload because the operation has an empty input
/// and empty output structure that reuses the same shape. While this should
/// be rare, code generators must support this.
pub struct EmptyInputAndEmptyOutput {
    input: EmptyInputAndEmptyOutputInput,
}
impl EmptyInputAndEmptyOutput {
    /// Creates a new builder-style object to manufacture [`EmptyInputAndEmptyOutputInput`](crate::input::EmptyInputAndEmptyOutputInput)
    pub fn builder() -> crate::input::empty_input_and_empty_output_input::Builder {
        crate::input::empty_input_and_empty_output_input::Builder::default()
    }
    pub fn build_http_request(&self) -> ::http::request::Request<Vec<u8>> {
        EmptyInputAndEmptyOutputInput::assemble(
            self.input.request_builder_base(),
            self.input.build_body(),
        )
    }
    pub fn new(input: EmptyInputAndEmptyOutputInput) -> Self {
        Self { input }
    }
}
#[cfg(test)]
#[allow(unreachable_code, unused_variables)]
mod empty_input_and_empty_output_request_test {

    use crate::input::EmptyInputAndEmptyOutputInput;
    /// Empty input serializes no payload
    /// Test ID: RestJsonEmptyInputAndEmptyOutput
    #[test]
    fn test_rest_json_empty_input_and_empty_output_request() {
        let input = EmptyInputAndEmptyOutputInput::builder().build();
        let http_request =
            EmptyInputAndEmptyOutputInput::assemble(input.input.request_builder_base(), vec![]);

        assert_eq!(http_request.method(), "POST");
        assert_eq!(http_request.uri().path(), "/EmptyInputAndEmptyOutput");
    }
    /// Empty output serializes no payload
    /// Test ID: RestJsonEmptyInputAndEmptyOutput
    #[test]
    fn test_rest_json_empty_input_and_empty_output_response() {
        /* test case disabled for this protocol (not yet supported) */
    }
    /// Empty output serializes no payload
    /// Test ID: RestJsonEmptyInputAndEmptyJsonObjectOutput
    #[test]
    fn test_rest_json_empty_input_and_empty_json_object_output_response() {
        /* test case disabled for this protocol (not yet supported) */
    }
}

/// This operation has four possible return values:
/// 1. A successful response in the form of GreetingWithErrorsOutput
/// 2. An InvalidGreeting error.
/// 3. A BadRequest error.
/// 4. A FooError.
/// Implementations must be able to successfully take a response and
/// properly (de)serialize successful and error responses based on the
/// the presence of the
pub struct GreetingWithErrors {
    input: GreetingWithErrorsInput,
}
impl GreetingWithErrors {
    /// Creates a new builder-style object to manufacture [`GreetingWithErrorsInput`](crate::input::GreetingWithErrorsInput)
    pub fn builder() -> crate::input::greeting_with_errors_input::Builder {
        crate::input::greeting_with_errors_input::Builder::default()
    }
    pub fn build_http_request(&self) -> ::http::request::Request<Vec<u8>> {
        GreetingWithErrorsInput::assemble(
            self.input.request_builder_base(),
            self.input.build_body(),
        )
    }
    pub fn new(input: GreetingWithErrorsInput) -> Self {
        Self { input }
    }
}
#[cfg(test)]
#[allow(unreachable_code, unused_variables)]
mod greeting_with_errors_request_test {

    /// Ensures that operations with errors successfully know how to deserialize the successful response
    /// Test ID: RestJsonGreetingWithErrors
    #[test]
    fn test_rest_json_greeting_with_errors_response() {
        /* test case disabled for this protocol (not yet supported) */
    }
    /// Parses simple JSON errors
    /// Test ID: RestJsonInvalidGreetingError
    #[test]
    fn test_rest_json_invalid_greeting_error_response() {
        /* test case disabled for this protocol (not yet supported) */
    }
    /// Serializes a complex error with no message member
    /// Test ID: RestJsonComplexErrorWithNoMessage
    #[test]
    fn test_rest_json_complex_error_with_no_message_response() {
        /* test case disabled for this protocol (not yet supported) */
    }
    /// Test ID: RestJsonEmptyComplexErrorWithNoMessage
    #[test]
    fn test_rest_json_empty_complex_error_with_no_message_response() {
        /* test case disabled for this protocol (not yet supported) */
    }
    /// Serializes the X-Amzn-ErrorType header. For an example service, see Amazon EKS.
    /// Test ID: RestJsonFooErrorUsingXAmznErrorType
    #[test]
    fn test_rest_json_foo_error_using_x_amzn_error_type_response() {
        /* test case disabled for this protocol (not yet supported) */
    }
    /// Some X-Amzn-Errortype headers contain URLs. Clients need to split the URL on ':' and take only the first half of the string. For example, 'ValidationException:http://internal.amazon.com/coral/com.amazon.coral.validate/'
    /// is to be interpreted as 'ValidationException'.
    ///
    /// For an example service see Amazon Polly.
    /// Test ID: RestJsonFooErrorUsingXAmznErrorTypeWithUri
    #[test]
    fn test_rest_json_foo_error_using_x_amzn_error_type_with_uri_response() {
        /* test case disabled for this protocol (not yet supported) */
    }
    /// X-Amzn-Errortype might contain a URL and a namespace. Client should extract only the shape name. This is a pathalogical case that might not actually happen in any deployed AWS service.
    /// Test ID: RestJsonFooErrorUsingXAmznErrorTypeWithUriAndNamespace
    #[test]
    fn test_rest_json_foo_error_using_x_amzn_error_type_with_uri_and_namespace_response() {
        /* test case disabled for this protocol (not yet supported) */
    }
    /// This example uses the 'code' property in the output rather than X-Amzn-Errortype. Some services do this though it's preferable to send the X-Amzn-Errortype. Client implementations must first check for the X-Amzn-Errortype and then check for a top-level 'code' property.
    ///
    /// For example service see Amazon S3 Glacier.
    /// Test ID: RestJsonFooErrorUsingCode
    #[test]
    fn test_rest_json_foo_error_using_code_response() {
        /* test case disabled for this protocol (not yet supported) */
    }
    /// Some services serialize errors using code, and it might contain a namespace. Clients should just take the last part of the string after '#'.
    /// Test ID: RestJsonFooErrorUsingCodeAndNamespace
    #[test]
    fn test_rest_json_foo_error_using_code_and_namespace_response() {
        /* test case disabled for this protocol (not yet supported) */
    }
    /// Some services serialize errors using code, and it might contain a namespace. It also might contain a URI. Clients should just take the last part of the string after '#' and before ":". This is a pathalogical case that might not occur in any deployed AWS service.
    /// Test ID: RestJsonFooErrorUsingCodeUriAndNamespace
    #[test]
    fn test_rest_json_foo_error_using_code_uri_and_namespace_response() {
        /* test case disabled for this protocol (not yet supported) */
    }
    /// Some services serialize errors using __type.
    /// Test ID: RestJsonFooErrorWithDunderType
    #[test]
    fn test_rest_json_foo_error_with_dunder_type_response() {
        /* test case disabled for this protocol (not yet supported) */
    }
    /// Some services serialize errors using __type, and it might contain a namespace. Clients should just take the last part of the string after '#'.
    /// Test ID: RestJsonFooErrorWithDunderTypeAndNamespace
    #[test]
    fn test_rest_json_foo_error_with_dunder_type_and_namespace_response() {
        /* test case disabled for this protocol (not yet supported) */
    }
    /// Some services serialize errors using __type, and it might contain a namespace. It also might contain a URI. Clients should just take the last part of the string after '#' and before ":". This is a pathalogical case that might not occur in any deployed AWS service.
    /// Test ID: RestJsonFooErrorWithDunderTypeUriAndNamespace
    #[test]
    fn test_rest_json_foo_error_with_dunder_type_uri_and_namespace_response() {
        /* test case disabled for this protocol (not yet supported) */
    }
}

/// This examples serializes a blob shape in the payload.
/// In this example, no JSON document is synthesized because the payload is
/// not a structure or a union type.
pub struct HttpPayloadTraits {
    input: HttpPayloadTraitsInput,
}
impl HttpPayloadTraits {
    /// Creates a new builder-style object to manufacture [`HttpPayloadTraitsInput`](crate::input::HttpPayloadTraitsInput)
    pub fn builder() -> crate::input::http_payload_traits_input::Builder {
        crate::input::http_payload_traits_input::Builder::default()
    }
    pub fn build_http_request(&self) -> ::http::request::Request<Vec<u8>> {
        HttpPayloadTraitsInput::assemble(self.input.request_builder_base(), self.input.build_body())
    }
    pub fn new(input: HttpPayloadTraitsInput) -> Self {
        Self { input }
    }
}
#[cfg(test)]
#[allow(unreachable_code, unused_variables)]
mod http_payload_traits_request_test {

    use crate::input::HttpPayloadTraitsInput;
    /// Serializes a blob in the HTTP payload
    /// Test ID: RestJsonHttpPayloadTraitsWithBlob
    #[test]
    fn test_rest_json_http_payload_traits_with_blob_request() {
        let input = HttpPayloadTraitsInput::builder()
            .foo("Foo".to_string())
            .blob(::smithy_types::Blob::new("blobby blob blob"))
            .build();
        let http_request =
            HttpPayloadTraitsInput::assemble(input.input.request_builder_base(), vec![]);

        assert_eq!(http_request.method(), "POST");
        assert_eq!(http_request.uri().path(), "/HttpPayloadTraits");

        let expected_headers = &[("X-Foo", "Foo")];
        ::protocol_test_helpers::assert_ok(::protocol_test_helpers::validate_headers(
            &http_request,
            expected_headers,
        ));
        let required_headers = &["Content-Length"];
        ::protocol_test_helpers::assert_ok(::protocol_test_helpers::require_headers(
            &http_request,
            required_headers,
        ));
    }
    /// Serializes an empty blob in the HTTP payload
    /// Test ID: RestJsonHttpPayloadTraitsWithNoBlobBody
    #[test]
    fn test_rest_json_http_payload_traits_with_no_blob_body_request() {
        let input = HttpPayloadTraitsInput::builder()
            .foo("Foo".to_string())
            .build();
        let http_request =
            HttpPayloadTraitsInput::assemble(input.input.request_builder_base(), vec![]);

        assert_eq!(http_request.method(), "POST");
        assert_eq!(http_request.uri().path(), "/HttpPayloadTraits");

        let expected_headers = &[("X-Foo", "Foo")];
        ::protocol_test_helpers::assert_ok(::protocol_test_helpers::validate_headers(
            &http_request,
            expected_headers,
        ));
    }
    /// Serializes a blob in the HTTP payload
    /// Test ID: RestJsonHttpPayloadTraitsWithBlob
    #[test]
    fn test_rest_json_http_payload_traits_with_blob_response() {
        /* test case disabled for this protocol (not yet supported) */
    }
    /// Serializes an empty blob in the HTTP payload
    /// Test ID: RestJsonHttpPayloadTraitsWithNoBlobBody
    #[test]
    fn test_rest_json_http_payload_traits_with_no_blob_body_response() {
        /* test case disabled for this protocol (not yet supported) */
    }
}

/// This examples uses a `@mediaType` trait on the payload to force a custom
/// content-type to be serialized.
pub struct HttpPayloadTraitsWithMediaType {
    input: HttpPayloadTraitsWithMediaTypeInput,
}
impl HttpPayloadTraitsWithMediaType {
    /// Creates a new builder-style object to manufacture [`HttpPayloadTraitsWithMediaTypeInput`](crate::input::HttpPayloadTraitsWithMediaTypeInput)
    pub fn builder() -> crate::input::http_payload_traits_with_media_type_input::Builder {
        crate::input::http_payload_traits_with_media_type_input::Builder::default()
    }
    pub fn build_http_request(&self) -> ::http::request::Request<Vec<u8>> {
        HttpPayloadTraitsWithMediaTypeInput::assemble(
            self.input.request_builder_base(),
            self.input.build_body(),
        )
    }
    pub fn new(input: HttpPayloadTraitsWithMediaTypeInput) -> Self {
        Self { input }
    }
}
#[cfg(test)]
#[allow(unreachable_code, unused_variables)]
mod http_payload_traits_with_media_type_request_test {

    use crate::input::HttpPayloadTraitsWithMediaTypeInput;
    /// Serializes a blob in the HTTP payload with a content-type
    /// Test ID: RestJsonHttpPayloadTraitsWithMediaTypeWithBlob
    #[test]
    fn test_rest_json_http_payload_traits_with_media_type_with_blob_request() {
        let input = HttpPayloadTraitsWithMediaTypeInput::builder()
            .foo("Foo".to_string())
            .blob(::smithy_types::Blob::new("blobby blob blob"))
            .build();
        let http_request = HttpPayloadTraitsWithMediaTypeInput::assemble(
            input.input.request_builder_base(),
            vec![],
        );

        assert_eq!(http_request.method(), "POST");
        assert_eq!(http_request.uri().path(), "/HttpPayloadTraitsWithMediaType");

        let expected_headers = &[("Content-Type", "text/plain"), ("X-Foo", "Foo")];
        ::protocol_test_helpers::assert_ok(::protocol_test_helpers::validate_headers(
            &http_request,
            expected_headers,
        ));
        let required_headers = &["Content-Length"];
        ::protocol_test_helpers::assert_ok(::protocol_test_helpers::require_headers(
            &http_request,
            required_headers,
        ));
    }
    /// Serializes a blob in the HTTP payload with a content-type
    /// Test ID: RestJsonHttpPayloadTraitsWithMediaTypeWithBlob
    #[test]
    fn test_rest_json_http_payload_traits_with_media_type_with_blob_response() {
        /* test case disabled for this protocol (not yet supported) */
    }
}

/// This examples serializes a structure in the payload.
/// Note that serializing a structure changes the wrapper element name
/// to match the targeted structure.
pub struct HttpPayloadWithStructure {
    input: HttpPayloadWithStructureInput,
}
impl HttpPayloadWithStructure {
    /// Creates a new builder-style object to manufacture [`HttpPayloadWithStructureInput`](crate::input::HttpPayloadWithStructureInput)
    pub fn builder() -> crate::input::http_payload_with_structure_input::Builder {
        crate::input::http_payload_with_structure_input::Builder::default()
    }
    pub fn build_http_request(&self) -> ::http::request::Request<Vec<u8>> {
        HttpPayloadWithStructureInput::assemble(
            self.input.request_builder_base(),
            self.input.build_body(),
        )
    }
    pub fn new(input: HttpPayloadWithStructureInput) -> Self {
        Self { input }
    }
}
#[cfg(test)]
#[allow(unreachable_code, unused_variables)]
mod http_payload_with_structure_request_test {

    use crate::input::HttpPayloadWithStructureInput;
    use crate::model::NestedPayload;
    /// Serializes a structure in the payload
    /// Test ID: RestJsonHttpPayloadWithStructure
    #[test]
    fn test_rest_json_http_payload_with_structure_request() {
        let input = HttpPayloadWithStructureInput::builder()
            .nested(
                NestedPayload::builder()
                    .greeting("hello".to_string())
                    .name("Phreddy".to_string())
                    .build(),
            )
            .build();
        let http_request =
            HttpPayloadWithStructureInput::assemble(input.input.request_builder_base(), vec![]);

        assert_eq!(http_request.method(), "PUT");
        assert_eq!(http_request.uri().path(), "/HttpPayloadWithStructure");

        let expected_headers = &[("Content-Type", "application/json")];
        ::protocol_test_helpers::assert_ok(::protocol_test_helpers::validate_headers(
            &http_request,
            expected_headers,
        ));
        let required_headers = &["Content-Length"];
        ::protocol_test_helpers::assert_ok(::protocol_test_helpers::require_headers(
            &http_request,
            required_headers,
        ));
    }
    /// Serializes a structure in the payload
    /// Test ID: RestJsonHttpPayloadWithStructure
    #[test]
    fn test_rest_json_http_payload_with_structure_response() {
        /* test case disabled for this protocol (not yet supported) */
    }
}

/// This examples adds headers to the input of a request and response by prefix.
pub struct HttpPrefixHeaders {
    input: HttpPrefixHeadersInput,
}
impl HttpPrefixHeaders {
    /// Creates a new builder-style object to manufacture [`HttpPrefixHeadersInput`](crate::input::HttpPrefixHeadersInput)
    pub fn builder() -> crate::input::http_prefix_headers_input::Builder {
        crate::input::http_prefix_headers_input::Builder::default()
    }
    pub fn build_http_request(&self) -> ::http::request::Request<Vec<u8>> {
        HttpPrefixHeadersInput::assemble(self.input.request_builder_base(), self.input.build_body())
    }
    pub fn new(input: HttpPrefixHeadersInput) -> Self {
        Self { input }
    }
}
#[cfg(test)]
#[allow(unreachable_code, unused_variables)]
mod http_prefix_headers_request_test {

    use crate::input::HttpPrefixHeadersInput;
    /// Adds headers by prefix
    /// Test ID: RestJsonHttpPrefixHeadersArePresent
    #[test]
    #[should_panic]
    fn test_rest_json_http_prefix_headers_are_present_request() {
        let input = HttpPrefixHeadersInput::builder()
            .foo("Foo".to_string())
            .foo_map({
                let mut ret = ::std::collections::HashMap::new();
                ret.insert("Abc".to_string(), "Abc value".to_string());
                ret.insert("Def".to_string(), "Def value".to_string());
                ret
            })
            .build();
        let http_request =
            HttpPrefixHeadersInput::assemble(input.input.request_builder_base(), vec![]);

        assert_eq!(http_request.method(), "GET");
        assert_eq!(http_request.uri().path(), "/HttpPrefixHeaders");

        let expected_headers = &[
            ("X-Foo", "Foo"),
            ("X-Foo-Abc", "Abc value"),
            ("X-Foo-Def", "Def value"),
        ];
        ::protocol_test_helpers::assert_ok(::protocol_test_helpers::validate_headers(
            &http_request,
            expected_headers,
        ));
    }
    /// No prefix headers are serialized because the value is empty
    /// Test ID: RestJsonHttpPrefixHeadersAreNotPresent
    #[test]
    fn test_rest_json_http_prefix_headers_are_not_present_request() {
        let input = HttpPrefixHeadersInput::builder()
            .foo("Foo".to_string())
            .foo_map(::std::collections::HashMap::new())
            .build();
        let http_request =
            HttpPrefixHeadersInput::assemble(input.input.request_builder_base(), vec![]);

        assert_eq!(http_request.method(), "GET");
        assert_eq!(http_request.uri().path(), "/HttpPrefixHeaders");

        let expected_headers = &[("X-Foo", "Foo")];
        ::protocol_test_helpers::assert_ok(::protocol_test_helpers::validate_headers(
            &http_request,
            expected_headers,
        ));
    }
    /// Adds headers by prefix
    /// Test ID: RestJsonHttpPrefixHeadersArePresent
    #[test]
    #[should_panic]
    fn test_rest_json_http_prefix_headers_are_present_response() {
        /* test case disabled for this protocol (not yet supported) */
        todo!()
    }
}

/// Clients that perform this test extract all headers from the response.
pub struct HttpPrefixHeadersResponse {
    input: HttpPrefixHeadersResponseInput,
}
impl HttpPrefixHeadersResponse {
    /// Creates a new builder-style object to manufacture [`HttpPrefixHeadersResponseInput`](crate::input::HttpPrefixHeadersResponseInput)
    pub fn builder() -> crate::input::http_prefix_headers_response_input::Builder {
        crate::input::http_prefix_headers_response_input::Builder::default()
    }
    pub fn build_http_request(&self) -> ::http::request::Request<Vec<u8>> {
        HttpPrefixHeadersResponseInput::assemble(
            self.input.request_builder_base(),
            self.input.build_body(),
        )
    }
    pub fn new(input: HttpPrefixHeadersResponseInput) -> Self {
        Self { input }
    }
}
#[cfg(test)]
#[allow(unreachable_code, unused_variables)]
mod http_prefix_headers_response_request_test {

    /// (de)serializes all response headers
    /// Test ID: HttpPrefixHeadersResponse
    #[test]
    fn test_http_prefix_headers_response_response() {
        /* test case disabled for this protocol (not yet supported) */
    }
}

pub struct HttpRequestWithGreedyLabelInPath {
    input: HttpRequestWithGreedyLabelInPathInput,
}
impl HttpRequestWithGreedyLabelInPath {
    /// Creates a new builder-style object to manufacture [`HttpRequestWithGreedyLabelInPathInput`](crate::input::HttpRequestWithGreedyLabelInPathInput)
    pub fn builder() -> crate::input::http_request_with_greedy_label_in_path_input::Builder {
        crate::input::http_request_with_greedy_label_in_path_input::Builder::default()
    }
    pub fn build_http_request(&self) -> ::http::request::Request<Vec<u8>> {
        HttpRequestWithGreedyLabelInPathInput::assemble(
            self.input.request_builder_base(),
            self.input.build_body(),
        )
    }
    pub fn new(input: HttpRequestWithGreedyLabelInPathInput) -> Self {
        Self { input }
    }
}
#[cfg(test)]
#[allow(unreachable_code, unused_variables)]
mod http_request_with_greedy_label_in_path_request_test {

    use crate::input::HttpRequestWithGreedyLabelInPathInput;
    /// Serializes greedy labels and normal labels
    /// Test ID: RestJsonHttpRequestWithGreedyLabelInPath
    #[test]
    fn test_rest_json_http_request_with_greedy_label_in_path_request() {
        let input = HttpRequestWithGreedyLabelInPathInput::builder()
            .foo("hello".to_string())
            .baz("there/guy".to_string())
            .build();
        let http_request = HttpRequestWithGreedyLabelInPathInput::assemble(
            input.input.request_builder_base(),
            vec![],
        );

        assert_eq!(http_request.method(), "GET");
        assert_eq!(
            http_request.uri().path(),
            "/HttpRequestWithGreedyLabelInPath/foo/hello/baz/there/guy"
        );
    }
}

/// The example tests how requests are serialized when there's no input
/// payload but there are HTTP labels.
pub struct HttpRequestWithLabels {
    input: HttpRequestWithLabelsInput,
}
impl HttpRequestWithLabels {
    /// Creates a new builder-style object to manufacture [`HttpRequestWithLabelsInput`](crate::input::HttpRequestWithLabelsInput)
    pub fn builder() -> crate::input::http_request_with_labels_input::Builder {
        crate::input::http_request_with_labels_input::Builder::default()
    }
    pub fn build_http_request(&self) -> ::http::request::Request<Vec<u8>> {
        HttpRequestWithLabelsInput::assemble(
            self.input.request_builder_base(),
            self.input.build_body(),
        )
    }
    pub fn new(input: HttpRequestWithLabelsInput) -> Self {
        Self { input }
    }
}
#[cfg(test)]
#[allow(unreachable_code, unused_variables)]
mod http_request_with_labels_request_test {

    use crate::input::HttpRequestWithLabelsInput;
    /// Sends a GET request that uses URI label bindings
    /// Test ID: RestJsonInputWithHeadersAndAllParams
    #[test]
    fn test_rest_json_input_with_headers_and_all_params_request() {
        let input = HttpRequestWithLabelsInput::builder()
            .string("string".to_string())
            .short(1)
            .integer(2)
            .long(3)
            .float(4.1)
            .double(5.1)
            .boolean(true)
            .timestamp(::smithy_types::Instant::from_epoch_seconds(1576540098))
            .build()
            .unwrap();
        let http_request =
            HttpRequestWithLabelsInput::assemble(input.input.request_builder_base(), vec![]);

        assert_eq!(http_request.method(), "GET");
        assert_eq!(
            http_request.uri().path(),
            "/HttpRequestWithLabels/string/1/2/3/4.1/5.1/true/2019-12-16T23%3A48%3A18Z"
        );
    }
}

/// The example tests how requests serialize different timestamp formats in the
/// URI path.
pub struct HttpRequestWithLabelsAndTimestampFormat {
    input: HttpRequestWithLabelsAndTimestampFormatInput,
}
impl HttpRequestWithLabelsAndTimestampFormat {
    /// Creates a new builder-style object to manufacture [`HttpRequestWithLabelsAndTimestampFormatInput`](crate::input::HttpRequestWithLabelsAndTimestampFormatInput)
    pub fn builder() -> crate::input::http_request_with_labels_and_timestamp_format_input::Builder {
        crate::input::http_request_with_labels_and_timestamp_format_input::Builder::default()
    }
    pub fn build_http_request(&self) -> ::http::request::Request<Vec<u8>> {
        HttpRequestWithLabelsAndTimestampFormatInput::assemble(
            self.input.request_builder_base(),
            self.input.build_body(),
        )
    }
    pub fn new(input: HttpRequestWithLabelsAndTimestampFormatInput) -> Self {
        Self { input }
    }
}
#[cfg(test)]
#[allow(unreachable_code, unused_variables)]
mod http_request_with_labels_and_timestamp_format_request_test {

    use crate::input::HttpRequestWithLabelsAndTimestampFormatInput;
    /// Serializes different timestamp formats in URI labels
    /// Test ID: RestJsonHttpRequestWithLabelsAndTimestampFormat
    #[test]
    fn test_rest_json_http_request_with_labels_and_timestamp_format_request() {
        let input = HttpRequestWithLabelsAndTimestampFormatInput::builder()
            .member_epoch_seconds(::smithy_types::Instant::from_epoch_seconds(1576540098))
            .member_http_date(::smithy_types::Instant::from_epoch_seconds(1576540098))
            .member_date_time(::smithy_types::Instant::from_epoch_seconds(1576540098))
            .default_format(::smithy_types::Instant::from_epoch_seconds(1576540098))
            .target_epoch_seconds(::smithy_types::Instant::from_epoch_seconds(1576540098))
            .target_http_date(::smithy_types::Instant::from_epoch_seconds(1576540098))
            .target_date_time(::smithy_types::Instant::from_epoch_seconds(1576540098))
            .build()
            .unwrap();
        let http_request = HttpRequestWithLabelsAndTimestampFormatInput::assemble(
            input.input.request_builder_base(),
            vec![],
        );

        assert_eq!(http_request.method(), "GET");
        assert_eq!(http_request.uri().path(), "/HttpRequestWithLabelsAndTimestampFormat/1576540098/Mon%2C%2016%20Dec%202019%2023%3A48%3A18%20GMT/2019-12-16T23%3A48%3A18Z/2019-12-16T23%3A48%3A18Z/1576540098/Mon%2C%2016%20Dec%202019%2023%3A48%3A18%20GMT/2019-12-16T23%3A48%3A18Z");
    }
}

pub struct HttpResponseCode {
    input: HttpResponseCodeInput,
}
impl HttpResponseCode {
    /// Creates a new builder-style object to manufacture [`HttpResponseCodeInput`](crate::input::HttpResponseCodeInput)
    pub fn builder() -> crate::input::http_response_code_input::Builder {
        crate::input::http_response_code_input::Builder::default()
    }
    pub fn build_http_request(&self) -> ::http::request::Request<Vec<u8>> {
        HttpResponseCodeInput::assemble(self.input.request_builder_base(), self.input.build_body())
    }
    pub fn new(input: HttpResponseCodeInput) -> Self {
        Self { input }
    }
}
#[cfg(test)]
#[allow(unreachable_code, unused_variables)]
mod http_response_code_request_test {

    /// Binds the http response code to an output structure.
    /// Test ID: RestJsonHttpResponseCode
    #[test]
    fn test_rest_json_http_response_code_response() {
        /* test case disabled for this protocol (not yet supported) */
    }
}

/// This example ensures that query string bound request parameters are
/// serialized in the body of responses if the structure is used in both
/// the request and response.
pub struct IgnoreQueryParamsInResponse {
    input: IgnoreQueryParamsInResponseInput,
}
impl IgnoreQueryParamsInResponse {
    /// Creates a new builder-style object to manufacture [`IgnoreQueryParamsInResponseInput`](crate::input::IgnoreQueryParamsInResponseInput)
    pub fn builder() -> crate::input::ignore_query_params_in_response_input::Builder {
        crate::input::ignore_query_params_in_response_input::Builder::default()
    }
    pub fn build_http_request(&self) -> ::http::request::Request<Vec<u8>> {
        IgnoreQueryParamsInResponseInput::assemble(
            self.input.request_builder_base(),
            self.input.build_body(),
        )
    }
    pub fn new(input: IgnoreQueryParamsInResponseInput) -> Self {
        Self { input }
    }
}
#[cfg(test)]
#[allow(unreachable_code, unused_variables)]
mod ignore_query_params_in_response_request_test {

    /// Query parameters must be ignored when serializing the output of an operation
    /// Test ID: RestJsonIgnoreQueryParamsInResponse
    #[test]
    fn test_rest_json_ignore_query_params_in_response_response() {
        /* test case disabled for this protocol (not yet supported) */
    }
}

/// This example serializes an inline document as part of the payload.
pub struct InlineDocument {
    input: InlineDocumentInput,
}
impl InlineDocument {
    /// Creates a new builder-style object to manufacture [`InlineDocumentInput`](crate::input::InlineDocumentInput)
    pub fn builder() -> crate::input::inline_document_input::Builder {
        crate::input::inline_document_input::Builder::default()
    }
    pub fn build_http_request(&self) -> ::http::request::Request<Vec<u8>> {
        InlineDocumentInput::assemble(self.input.request_builder_base(), self.input.build_body())
    }
    pub fn new(input: InlineDocumentInput) -> Self {
        Self { input }
    }
}
#[cfg(test)]
#[allow(unreachable_code, unused_variables)]
mod inline_document_request_test {

    use crate::input::InlineDocumentInput;
    /// Serializes inline documents as part of the JSON request payload with no escaping.
    /// Test ID: InlineDocumentInput
    #[test]
    #[should_panic]
    fn test_inline_document_input_request() {
        let input =InlineDocumentInput::builder()
        .string_value(
            "string".to_string()
        )
        .document_value(
            todo!() /* (document: `aws.protocoltests.restjson#Document`) software.amazon.smithy.model.node.ObjectNode@fecf2c7 */
        )
        .build()
        .unwrap()
        ;
        let http_request =
            InlineDocumentInput::assemble(input.input.request_builder_base(), vec![]);

        assert_eq!(http_request.method(), "PUT");
        assert_eq!(http_request.uri().path(), "/InlineDocument");

        let expected_headers = &[("Content-Type", "application/json")];
        ::protocol_test_helpers::assert_ok(::protocol_test_helpers::validate_headers(
            &http_request,
            expected_headers,
        ));
    }
    /// Serializes inline documents as part of the JSON response payload with no escaping.
    /// Test ID: InlineDocumentOutput
    #[test]
    fn test_inline_document_output_response() {
        /* test case disabled for this protocol (not yet supported) */
    }
}

/// This example serializes an inline document as the entire HTTP payload.
pub struct InlineDocumentAsPayload {
    input: InlineDocumentAsPayloadInput,
}
impl InlineDocumentAsPayload {
    /// Creates a new builder-style object to manufacture [`InlineDocumentAsPayloadInput`](crate::input::InlineDocumentAsPayloadInput)
    pub fn builder() -> crate::input::inline_document_as_payload_input::Builder {
        crate::input::inline_document_as_payload_input::Builder::default()
    }
    pub fn build_http_request(&self) -> ::http::request::Request<Vec<u8>> {
        InlineDocumentAsPayloadInput::assemble(
            self.input.request_builder_base(),
            self.input.build_body(),
        )
    }
    pub fn new(input: InlineDocumentAsPayloadInput) -> Self {
        Self { input }
    }
}
#[cfg(test)]
#[allow(unreachable_code, unused_variables)]
mod inline_document_as_payload_request_test {

    use crate::input::InlineDocumentAsPayloadInput;
    /// Serializes an inline document as the target of the httpPayload trait.
    /// Test ID: InlineDocumentAsPayloadInput
    #[test]
    #[should_panic]
    fn test_inline_document_as_payload_input_request() {
        let input =InlineDocumentAsPayloadInput::builder()
        .document_value(
            todo!() /* (document: `aws.protocoltests.restjson#Document`) software.amazon.smithy.model.node.ObjectNode@fecf2c7 */
        )
        .build()
        .unwrap()
        ;
        let http_request =
            InlineDocumentAsPayloadInput::assemble(input.input.request_builder_base(), vec![]);

        assert_eq!(http_request.method(), "PUT");
        assert_eq!(http_request.uri().path(), "/InlineDocumentAsPayload");

        let expected_headers = &[("Content-Type", "application/json")];
        ::protocol_test_helpers::assert_ok(::protocol_test_helpers::validate_headers(
            &http_request,
            expected_headers,
        ));
    }
    /// Serializes an inline document as the target of the httpPayload trait.
    /// Test ID: InlineDocumentAsPayloadInputOutput
    #[test]
    fn test_inline_document_as_payload_input_output_response() {
        /* test case disabled for this protocol (not yet supported) */
    }
}

/// The example tests how requests and responses are serialized when there is
/// no input or output payload but there are HTTP header bindings.
pub struct InputAndOutputWithHeaders {
    input: InputAndOutputWithHeadersInput,
}
impl InputAndOutputWithHeaders {
    /// Creates a new builder-style object to manufacture [`InputAndOutputWithHeadersInput`](crate::input::InputAndOutputWithHeadersInput)
    pub fn builder() -> crate::input::input_and_output_with_headers_input::Builder {
        crate::input::input_and_output_with_headers_input::Builder::default()
    }
    pub fn build_http_request(&self) -> ::http::request::Request<Vec<u8>> {
        InputAndOutputWithHeadersInput::assemble(
            self.input.request_builder_base(),
            self.input.build_body(),
        )
    }
    pub fn new(input: InputAndOutputWithHeadersInput) -> Self {
        Self { input }
    }
}
#[cfg(test)]
#[allow(unreachable_code, unused_variables)]
mod input_and_output_with_headers_request_test {

    use crate::input::InputAndOutputWithHeadersInput;
    use crate::model::FooEnum;
    /// Tests requests with string header bindings
    /// Test ID: RestJsonInputAndOutputWithStringHeaders
    #[test]
    fn test_rest_json_input_and_output_with_string_headers_request() {
        let input = InputAndOutputWithHeadersInput::builder()
            .header_string("Hello".to_string())
            .header_string_list(vec!["a".to_string(), "b".to_string(), "c".to_string()])
            .header_string_set({
                let mut ret = ::std::collections::BTreeSet::new();
                ret.insert("a".to_string());
                ret.insert("b".to_string());
                ret.insert("c".to_string());
                ret
            })
            .build();
        let http_request =
            InputAndOutputWithHeadersInput::assemble(input.input.request_builder_base(), vec![]);

        assert_eq!(http_request.method(), "POST");
        assert_eq!(http_request.uri().path(), "/InputAndOutputWithHeaders");

        let expected_headers = &[
            ("X-String", "Hello"),
            ("X-StringList", "a, b, c"),
            ("X-StringSet", "a, b, c"),
        ];
        ::protocol_test_helpers::assert_ok(::protocol_test_helpers::validate_headers(
            &http_request,
            expected_headers,
        ));
    }
    /// Tests requests with numeric header bindings
    /// Test ID: RestJsonInputAndOutputWithNumericHeaders
    #[test]
    fn test_rest_json_input_and_output_with_numeric_headers_request() {
        let input = InputAndOutputWithHeadersInput::builder()
            .header_byte(1)
            .header_short(123)
            .header_integer(123)
            .header_long(123)
            .header_float(1.1)
            .header_double(1.1)
            .header_integer_list(vec![1, 2, 3])
            .build();
        let http_request =
            InputAndOutputWithHeadersInput::assemble(input.input.request_builder_base(), vec![]);

        assert_eq!(http_request.method(), "POST");
        assert_eq!(http_request.uri().path(), "/InputAndOutputWithHeaders");

        let expected_headers = &[
            ("X-Byte", "1"),
            ("X-Double", "1.1"),
            ("X-Float", "1.1"),
            ("X-Integer", "123"),
            ("X-IntegerList", "1, 2, 3"),
            ("X-Long", "123"),
            ("X-Short", "123"),
        ];
        ::protocol_test_helpers::assert_ok(::protocol_test_helpers::validate_headers(
            &http_request,
            expected_headers,
        ));
    }
    /// Tests requests with boolean header bindings
    /// Test ID: RestJsonInputAndOutputWithBooleanHeaders
    #[test]
    fn test_rest_json_input_and_output_with_boolean_headers_request() {
        let input = InputAndOutputWithHeadersInput::builder()
            .header_true_bool(true)
            .header_false_bool(false)
            .header_boolean_list(vec![true, false, true])
            .build();
        let http_request =
            InputAndOutputWithHeadersInput::assemble(input.input.request_builder_base(), vec![]);

        assert_eq!(http_request.method(), "POST");
        assert_eq!(http_request.uri().path(), "/InputAndOutputWithHeaders");

        let expected_headers = &[
            ("X-Boolean1", "true"),
            ("X-Boolean2", "false"),
            ("X-BooleanList", "true, false, true"),
        ];
        ::protocol_test_helpers::assert_ok(::protocol_test_helpers::validate_headers(
            &http_request,
            expected_headers,
        ));
    }
    /// Tests requests with timestamp header bindings
    /// Test ID: RestJsonInputAndOutputWithTimestampHeaders
    #[test]
    fn test_rest_json_input_and_output_with_timestamp_headers_request() {
        let input = InputAndOutputWithHeadersInput::builder()
            .header_timestamp_list(vec![
                ::smithy_types::Instant::from_epoch_seconds(1576540098),
                ::smithy_types::Instant::from_epoch_seconds(1576540098),
            ])
            .build();
        let http_request =
            InputAndOutputWithHeadersInput::assemble(input.input.request_builder_base(), vec![]);

        assert_eq!(http_request.method(), "POST");
        assert_eq!(http_request.uri().path(), "/InputAndOutputWithHeaders");

        let expected_headers = &[(
            "X-TimestampList",
            "Mon, 16 Dec 2019 23:48:18 GMT, Mon, 16 Dec 2019 23:48:18 GMT",
        )];
        ::protocol_test_helpers::assert_ok(::protocol_test_helpers::validate_headers(
            &http_request,
            expected_headers,
        ));
    }
    /// Tests requests with enum header bindings
    /// Test ID: RestJsonInputAndOutputWithEnumHeaders
    #[test]
    fn test_rest_json_input_and_output_with_enum_headers_request() {
        let input = InputAndOutputWithHeadersInput::builder()
            .header_enum(FooEnum::from("Foo"))
            .header_enum_list(vec![
                FooEnum::from("Foo"),
                FooEnum::from("Bar"),
                FooEnum::from("Baz"),
            ])
            .build();
        let http_request =
            InputAndOutputWithHeadersInput::assemble(input.input.request_builder_base(), vec![]);

        assert_eq!(http_request.method(), "POST");
        assert_eq!(http_request.uri().path(), "/InputAndOutputWithHeaders");

        let expected_headers = &[("X-Enum", "Foo"), ("X-EnumList", "Foo, Bar, Baz")];
        ::protocol_test_helpers::assert_ok(::protocol_test_helpers::validate_headers(
            &http_request,
            expected_headers,
        ));
    }
    /// Tests responses with string header bindings
    /// Test ID: RestJsonInputAndOutputWithStringHeaders
    #[test]
    fn test_rest_json_input_and_output_with_string_headers_response() {
        /* test case disabled for this protocol (not yet supported) */
    }
    /// Tests responses with numeric header bindings
    /// Test ID: RestJsonInputAndOutputWithNumericHeaders
    #[test]
    fn test_rest_json_input_and_output_with_numeric_headers_response() {
        /* test case disabled for this protocol (not yet supported) */
    }
    /// Tests responses with boolean header bindings
    /// Test ID: RestJsonInputAndOutputWithBooleanHeaders
    #[test]
    fn test_rest_json_input_and_output_with_boolean_headers_response() {
        /* test case disabled for this protocol (not yet supported) */
    }
    /// Tests responses with timestamp header bindings
    /// Test ID: RestJsonInputAndOutputWithTimestampHeaders
    #[test]
    fn test_rest_json_input_and_output_with_timestamp_headers_response() {
        /* test case disabled for this protocol (not yet supported) */
    }
    /// Tests responses with enum header bindings
    /// Test ID: RestJsonInputAndOutputWithEnumHeaders
    #[test]
    fn test_rest_json_input_and_output_with_enum_headers_response() {
        /* test case disabled for this protocol (not yet supported) */
    }
}

/// Blobs are base64 encoded
pub struct JsonBlobs {
    input: JsonBlobsInput,
}
impl JsonBlobs {
    /// Creates a new builder-style object to manufacture [`JsonBlobsInput`](crate::input::JsonBlobsInput)
    pub fn builder() -> crate::input::json_blobs_input::Builder {
        crate::input::json_blobs_input::Builder::default()
    }
    pub fn build_http_request(&self) -> ::http::request::Request<Vec<u8>> {
        JsonBlobsInput::assemble(self.input.request_builder_base(), self.input.build_body())
    }
    pub fn new(input: JsonBlobsInput) -> Self {
        Self { input }
    }
}
#[cfg(test)]
#[allow(unreachable_code, unused_variables)]
mod json_blobs_request_test {

    use crate::input::JsonBlobsInput;
    /// Blobs are base64 encoded
    /// Test ID: RestJsonJsonBlobs
    #[test]
    fn test_rest_json_json_blobs_request() {
        let input = JsonBlobsInput::builder()
            .data(::smithy_types::Blob::new("value"))
            .build();
        let http_request = JsonBlobsInput::assemble(input.input.request_builder_base(), vec![]);

        assert_eq!(http_request.method(), "POST");
        assert_eq!(http_request.uri().path(), "/JsonBlobs");

        let expected_headers = &[("Content-Type", "application/json")];
        ::protocol_test_helpers::assert_ok(::protocol_test_helpers::validate_headers(
            &http_request,
            expected_headers,
        ));
    }
    /// Blobs are base64 encoded
    /// Test ID: RestJsonJsonBlobs
    #[test]
    fn test_rest_json_json_blobs_response() {
        /* test case disabled for this protocol (not yet supported) */
    }
}

/// This example serializes enums as top level properties, in lists, sets, and maps.
pub struct JsonEnums {
    input: JsonEnumsInput,
}
impl JsonEnums {
    /// Creates a new builder-style object to manufacture [`JsonEnumsInput`](crate::input::JsonEnumsInput)
    pub fn builder() -> crate::input::json_enums_input::Builder {
        crate::input::json_enums_input::Builder::default()
    }
    pub fn build_http_request(&self) -> ::http::request::Request<Vec<u8>> {
        JsonEnumsInput::assemble(self.input.request_builder_base(), self.input.build_body())
    }
    pub fn new(input: JsonEnumsInput) -> Self {
        Self { input }
    }
}
#[cfg(test)]
#[allow(unreachable_code, unused_variables)]
mod json_enums_request_test {

    use crate::input::JsonEnumsInput;
    use crate::model::FooEnum;
    /// Serializes simple scalar properties
    /// Test ID: RestJsonJsonEnums
    #[test]
    fn test_rest_json_json_enums_request() {
        let input = JsonEnumsInput::builder()
            .foo_enum1(FooEnum::from("Foo"))
            .foo_enum2(FooEnum::from("0"))
            .foo_enum3(FooEnum::from("1"))
            .foo_enum_list(vec![FooEnum::from("Foo"), FooEnum::from("0")])
            .foo_enum_set({
                let mut ret = ::std::collections::BTreeSet::new();
                ret.insert(FooEnum::from("Foo"));
                ret.insert(FooEnum::from("0"));
                ret
            })
            .foo_enum_map({
                let mut ret = ::std::collections::HashMap::new();
                ret.insert("hi".to_string(), FooEnum::from("Foo"));
                ret.insert("zero".to_string(), FooEnum::from("0"));
                ret
            })
            .build();
        let http_request = JsonEnumsInput::assemble(input.input.request_builder_base(), vec![]);

        assert_eq!(http_request.method(), "PUT");
        assert_eq!(http_request.uri().path(), "/JsonEnums");

        let expected_headers = &[("Content-Type", "application/json")];
        ::protocol_test_helpers::assert_ok(::protocol_test_helpers::validate_headers(
            &http_request,
            expected_headers,
        ));
    }
    /// Serializes simple scalar properties
    /// Test ID: RestJsonJsonEnums
    #[test]
    fn test_rest_json_json_enums_response() {
        /* test case disabled for this protocol (not yet supported) */
    }
}

/// This test case serializes JSON lists for the following cases for both
/// input and output:
/// 1. Normal JSON lists.
/// 2. Normal JSON sets.
/// 3. JSON lists of lists.
/// 4. Lists of structures.
pub struct JsonLists {
    input: JsonListsInput,
}
impl JsonLists {
    /// Creates a new builder-style object to manufacture [`JsonListsInput`](crate::input::JsonListsInput)
    pub fn builder() -> crate::input::json_lists_input::Builder {
        crate::input::json_lists_input::Builder::default()
    }
    pub fn build_http_request(&self) -> ::http::request::Request<Vec<u8>> {
        JsonListsInput::assemble(self.input.request_builder_base(), self.input.build_body())
    }
    pub fn new(input: JsonListsInput) -> Self {
        Self { input }
    }
}
#[cfg(test)]
#[allow(unreachable_code, unused_variables)]
mod json_lists_request_test {

    use crate::input::JsonListsInput;
    use crate::model::FooEnum;
    use crate::model::StructureListMember;
    /// Serializes JSON lists
    /// Test ID: RestJsonLists
    #[test]
    fn test_rest_json_lists_request() {
        let input = JsonListsInput::builder()
            .string_list(vec!["foo".to_string(), "bar".to_string()])
            .string_set({
                let mut ret = ::std::collections::BTreeSet::new();
                ret.insert("foo".to_string());
                ret.insert("bar".to_string());
                ret
            })
            .integer_list(vec![1, 2])
            .boolean_list(vec![true, false])
            .timestamp_list(vec![
                ::smithy_types::Instant::from_epoch_seconds(1398796238),
                ::smithy_types::Instant::from_epoch_seconds(1398796238),
            ])
            .enum_list(vec![FooEnum::from("Foo"), FooEnum::from("0")])
            .nested_string_list(vec![
                vec!["foo".to_string(), "bar".to_string()],
                vec!["baz".to_string(), "qux".to_string()],
            ])
            .structure_list(vec![
                StructureListMember::builder()
                    .a("1".to_string())
                    .b("2".to_string())
                    .build(),
                StructureListMember::builder()
                    .a("3".to_string())
                    .b("4".to_string())
                    .build(),
            ])
            .build();
        let http_request = JsonListsInput::assemble(input.input.request_builder_base(), vec![]);

        assert_eq!(http_request.method(), "PUT");
        assert_eq!(http_request.uri().path(), "/JsonLists");

        let expected_headers = &[("Content-Type", "application/json")];
        ::protocol_test_helpers::assert_ok(::protocol_test_helpers::validate_headers(
            &http_request,
            expected_headers,
        ));
    }
    /// Serializes empty JSON lists
    /// Test ID: RestJsonListsEmpty
    #[test]
    fn test_rest_json_lists_empty_request() {
        let input = JsonListsInput::builder().string_list(vec![]).build();
        let http_request = JsonListsInput::assemble(input.input.request_builder_base(), vec![]);

        assert_eq!(http_request.method(), "PUT");
        assert_eq!(http_request.uri().path(), "/JsonLists");

        let expected_headers = &[("Content-Type", "application/json")];
        ::protocol_test_helpers::assert_ok(::protocol_test_helpers::validate_headers(
            &http_request,
            expected_headers,
        ));
    }
    /// Serializes null values in lists
    /// Test ID: RestJsonListsSerializeNull
    #[test]
    fn test_rest_json_lists_serialize_null_request() {
        let input = JsonListsInput::builder()
            .sparse_string_list(vec![None, Some("hi".to_string())])
            .build();
        let http_request = JsonListsInput::assemble(input.input.request_builder_base(), vec![]);

        assert_eq!(http_request.method(), "PUT");
        assert_eq!(http_request.uri().path(), "/JsonLists");

        let expected_headers = &[("Content-Type", "application/json")];
        ::protocol_test_helpers::assert_ok(::protocol_test_helpers::validate_headers(
            &http_request,
            expected_headers,
        ));
    }
    /// Serializes JSON lists
    /// Test ID: RestJsonLists
    #[test]
    fn test_rest_json_lists_response() {
        /* test case disabled for this protocol (not yet supported) */
    }
    /// Serializes empty JSON lists
    /// Test ID: RestJsonListsEmpty
    #[test]
    fn test_rest_json_lists_empty_response() {
        /* test case disabled for this protocol (not yet supported) */
    }
    /// Serializes null values in sparse lists
    /// Test ID: RestJsonListsSerializeNull
    #[test]
    fn test_rest_json_lists_serialize_null_response() {
        /* test case disabled for this protocol (not yet supported) */
    }
}

/// The example tests basic map serialization.
pub struct JsonMaps {
    input: JsonMapsInput,
}
impl JsonMaps {
    /// Creates a new builder-style object to manufacture [`JsonMapsInput`](crate::input::JsonMapsInput)
    pub fn builder() -> crate::input::json_maps_input::Builder {
        crate::input::json_maps_input::Builder::default()
    }
    pub fn build_http_request(&self) -> ::http::request::Request<Vec<u8>> {
        JsonMapsInput::assemble(self.input.request_builder_base(), self.input.build_body())
    }
    pub fn new(input: JsonMapsInput) -> Self {
        Self { input }
    }
}
#[cfg(test)]
#[allow(unreachable_code, unused_variables)]
mod json_maps_request_test {

    use crate::input::JsonMapsInput;
    use crate::model::GreetingStruct;
    /// Serializes JSON maps
    /// Test ID: RestJsonJsonMaps
    #[test]
    fn test_rest_json_json_maps_request() {
        let input = JsonMapsInput::builder()
            .dense_struct_map({
                let mut ret = ::std::collections::HashMap::new();
                ret.insert(
                    "foo".to_string(),
                    GreetingStruct::builder().hi("there".to_string()).build(),
                );
                ret.insert(
                    "baz".to_string(),
                    GreetingStruct::builder().hi("bye".to_string()).build(),
                );
                ret
            })
            .sparse_struct_map({
                let mut ret = ::std::collections::HashMap::new();
                ret.insert(
                    "foo".to_string(),
                    Some(GreetingStruct::builder().hi("there".to_string()).build()),
                );
                ret.insert(
                    "baz".to_string(),
                    Some(GreetingStruct::builder().hi("bye".to_string()).build()),
                );
                ret
            })
            .build();
        let http_request = JsonMapsInput::assemble(input.input.request_builder_base(), vec![]);

        assert_eq!(http_request.method(), "POST");
        assert_eq!(http_request.uri().path(), "/JsonMaps");

        let expected_headers = &[("Content-Type", "application/json")];
        ::protocol_test_helpers::assert_ok(::protocol_test_helpers::validate_headers(
            &http_request,
            expected_headers,
        ));
    }
    /// Serializes JSON map values in sparse maps
    /// Test ID: RestJsonSerializesNullMapValues
    #[test]
    fn test_rest_json_serializes_null_map_values_request() {
        let input = JsonMapsInput::builder()
            .sparse_boolean_map({
                let mut ret = ::std::collections::HashMap::new();
                ret.insert("x".to_string(), None);
                ret
            })
            .sparse_number_map({
                let mut ret = ::std::collections::HashMap::new();
                ret.insert("x".to_string(), None);
                ret
            })
            .sparse_string_map({
                let mut ret = ::std::collections::HashMap::new();
                ret.insert("x".to_string(), None);
                ret
            })
            .sparse_struct_map({
                let mut ret = ::std::collections::HashMap::new();
                ret.insert("x".to_string(), None);
                ret
            })
            .build();
        let http_request = JsonMapsInput::assemble(input.input.request_builder_base(), vec![]);

        assert_eq!(http_request.method(), "POST");
        assert_eq!(http_request.uri().path(), "/JsonMaps");

        let expected_headers = &[("Content-Type", "application/json")];
        ::protocol_test_helpers::assert_ok(::protocol_test_helpers::validate_headers(
            &http_request,
            expected_headers,
        ));
    }
    /// Ensure that 0 and false are sent over the wire in all maps and lists
    /// Test ID: RestJsonSerializesZeroValuesInMaps
    #[test]
    fn test_rest_json_serializes_zero_values_in_maps_request() {
        let input = JsonMapsInput::builder()
            .dense_number_map({
                let mut ret = ::std::collections::HashMap::new();
                ret.insert("x".to_string(), 0);
                ret
            })
            .sparse_number_map({
                let mut ret = ::std::collections::HashMap::new();
                ret.insert("x".to_string(), Some(0));
                ret
            })
            .dense_boolean_map({
                let mut ret = ::std::collections::HashMap::new();
                ret.insert("x".to_string(), false);
                ret
            })
            .sparse_boolean_map({
                let mut ret = ::std::collections::HashMap::new();
                ret.insert("x".to_string(), Some(false));
                ret
            })
            .build();
        let http_request = JsonMapsInput::assemble(input.input.request_builder_base(), vec![]);

        assert_eq!(http_request.method(), "POST");
        assert_eq!(http_request.uri().path(), "/JsonMaps");

        let expected_headers = &[("Content-Type", "application/json")];
        ::protocol_test_helpers::assert_ok(::protocol_test_helpers::validate_headers(
            &http_request,
            expected_headers,
        ));
    }
    /// Deserializes JSON maps
    /// Test ID: RestJsonJsonMaps
    #[test]
    fn test_rest_json_json_maps_response() {
        /* test case disabled for this protocol (not yet supported) */
    }
    /// Deserializes null JSON map values
    /// Test ID: RestJsonDeserializesNullMapValues
    #[test]
    fn test_rest_json_deserializes_null_map_values_response() {
        /* test case disabled for this protocol (not yet supported) */
    }
    /// Ensure that 0 and false are sent over the wire in all maps and lists
    /// Test ID: RestJsonDeserializesZeroValuesInMaps
    #[test]
    fn test_rest_json_deserializes_zero_values_in_maps_response() {
        /* test case disabled for this protocol (not yet supported) */
    }
}

/// This tests how timestamps are serialized, including using the
/// default format of date-time and various @timestampFormat trait
/// values.
pub struct JsonTimestamps {
    input: JsonTimestampsInput,
}
impl JsonTimestamps {
    /// Creates a new builder-style object to manufacture [`JsonTimestampsInput`](crate::input::JsonTimestampsInput)
    pub fn builder() -> crate::input::json_timestamps_input::Builder {
        crate::input::json_timestamps_input::Builder::default()
    }
    pub fn build_http_request(&self) -> ::http::request::Request<Vec<u8>> {
        JsonTimestampsInput::assemble(self.input.request_builder_base(), self.input.build_body())
    }
    pub fn new(input: JsonTimestampsInput) -> Self {
        Self { input }
    }
}
#[cfg(test)]
#[allow(unreachable_code, unused_variables)]
mod json_timestamps_request_test {

    use crate::input::JsonTimestampsInput;
    /// Tests how normal timestamps are serialized
    /// Test ID: RestJsonJsonTimestamps
    #[test]
    fn test_rest_json_json_timestamps_request() {
        let input = JsonTimestampsInput::builder()
            .normal(::smithy_types::Instant::from_epoch_seconds(1398796238))
            .build();
        let http_request =
            JsonTimestampsInput::assemble(input.input.request_builder_base(), vec![]);

        assert_eq!(http_request.method(), "POST");
        assert_eq!(http_request.uri().path(), "/JsonTimestamps");

        let expected_headers = &[("Content-Type", "application/json")];
        ::protocol_test_helpers::assert_ok(::protocol_test_helpers::validate_headers(
            &http_request,
            expected_headers,
        ));
    }
    /// Ensures that the timestampFormat of date-time works like normal timestamps
    /// Test ID: RestJsonJsonTimestampsWithDateTimeFormat
    #[test]
    fn test_rest_json_json_timestamps_with_date_time_format_request() {
        let input = JsonTimestampsInput::builder()
            .date_time(::smithy_types::Instant::from_epoch_seconds(1398796238))
            .build();
        let http_request =
            JsonTimestampsInput::assemble(input.input.request_builder_base(), vec![]);

        assert_eq!(http_request.method(), "POST");
        assert_eq!(http_request.uri().path(), "/JsonTimestamps");

        let expected_headers = &[("Content-Type", "application/json")];
        ::protocol_test_helpers::assert_ok(::protocol_test_helpers::validate_headers(
            &http_request,
            expected_headers,
        ));
    }
    /// Ensures that the timestampFormat of epoch-seconds works
    /// Test ID: RestJsonJsonTimestampsWithEpochSecondsFormat
    #[test]
    fn test_rest_json_json_timestamps_with_epoch_seconds_format_request() {
        let input = JsonTimestampsInput::builder()
            .epoch_seconds(::smithy_types::Instant::from_epoch_seconds(1398796238))
            .build();
        let http_request =
            JsonTimestampsInput::assemble(input.input.request_builder_base(), vec![]);

        assert_eq!(http_request.method(), "POST");
        assert_eq!(http_request.uri().path(), "/JsonTimestamps");

        let expected_headers = &[("Content-Type", "application/json")];
        ::protocol_test_helpers::assert_ok(::protocol_test_helpers::validate_headers(
            &http_request,
            expected_headers,
        ));
    }
    /// Ensures that the timestampFormat of http-date works
    /// Test ID: RestJsonJsonTimestampsWithHttpDateFormat
    #[test]
    fn test_rest_json_json_timestamps_with_http_date_format_request() {
        let input = JsonTimestampsInput::builder()
            .http_date(::smithy_types::Instant::from_epoch_seconds(1398796238))
            .build();
        let http_request =
            JsonTimestampsInput::assemble(input.input.request_builder_base(), vec![]);

        assert_eq!(http_request.method(), "POST");
        assert_eq!(http_request.uri().path(), "/JsonTimestamps");

        let expected_headers = &[("Content-Type", "application/json")];
        ::protocol_test_helpers::assert_ok(::protocol_test_helpers::validate_headers(
            &http_request,
            expected_headers,
        ));
    }
    /// Tests how normal timestamps are serialized
    /// Test ID: RestJsonJsonTimestamps
    #[test]
    fn test_rest_json_json_timestamps_response() {
        /* test case disabled for this protocol (not yet supported) */
    }
    /// Ensures that the timestampFormat of date-time works like normal timestamps
    /// Test ID: RestJsonJsonTimestampsWithDateTimeFormat
    #[test]
    fn test_rest_json_json_timestamps_with_date_time_format_response() {
        /* test case disabled for this protocol (not yet supported) */
    }
    /// Ensures that the timestampFormat of epoch-seconds works
    /// Test ID: RestJsonJsonTimestampsWithEpochSecondsFormat
    #[test]
    fn test_rest_json_json_timestamps_with_epoch_seconds_format_response() {
        /* test case disabled for this protocol (not yet supported) */
    }
    /// Ensures that the timestampFormat of http-date works
    /// Test ID: RestJsonJsonTimestampsWithHttpDateFormat
    #[test]
    fn test_rest_json_json_timestamps_with_http_date_format_response() {
        /* test case disabled for this protocol (not yet supported) */
    }
}

/// This operation uses unions for inputs and outputs.
pub struct JsonUnions {
    input: JsonUnionsInput,
}
impl JsonUnions {
    /// Creates a new builder-style object to manufacture [`JsonUnionsInput`](crate::input::JsonUnionsInput)
    pub fn builder() -> crate::input::json_unions_input::Builder {
        crate::input::json_unions_input::Builder::default()
    }
    pub fn build_http_request(&self) -> ::http::request::Request<Vec<u8>> {
        JsonUnionsInput::assemble(self.input.request_builder_base(), self.input.build_body())
    }
    pub fn new(input: JsonUnionsInput) -> Self {
        Self { input }
    }
}
#[cfg(test)]
#[allow(unreachable_code, unused_variables)]
mod json_unions_request_test {

    use crate::input::JsonUnionsInput;
    use crate::model::FooEnum;
    use crate::model::GreetingStruct;
    use crate::model::MyUnion;
    /// Serializes a string union value
    /// Test ID: RestJsonSerializeStringUnionValue
    #[test]
    fn test_rest_json_serialize_string_union_value_request() {
        let input = JsonUnionsInput::builder()
            .contents(MyUnion::StringValue("foo".to_string()))
            .build();
        let http_request = JsonUnionsInput::assemble(input.input.request_builder_base(), vec![]);

        assert_eq!(http_request.method(), "PUT");
        assert_eq!(http_request.uri().path(), "/JsonUnions");

        let expected_headers = &[("Content-Type", "application/json")];
        ::protocol_test_helpers::assert_ok(::protocol_test_helpers::validate_headers(
            &http_request,
            expected_headers,
        ));
    }
    /// Serializes a boolean union value
    /// Test ID: RestJsonSerializeBooleanUnionValue
    #[test]
    fn test_rest_json_serialize_boolean_union_value_request() {
        let input = JsonUnionsInput::builder()
            .contents(MyUnion::BooleanValue(true))
            .build();
        let http_request = JsonUnionsInput::assemble(input.input.request_builder_base(), vec![]);

        assert_eq!(http_request.method(), "PUT");
        assert_eq!(http_request.uri().path(), "/JsonUnions");

        let expected_headers = &[("Content-Type", "application/json")];
        ::protocol_test_helpers::assert_ok(::protocol_test_helpers::validate_headers(
            &http_request,
            expected_headers,
        ));
    }
    /// Serializes a number union value
    /// Test ID: RestJsonSerializeNumberUnionValue
    #[test]
    fn test_rest_json_serialize_number_union_value_request() {
        let input = JsonUnionsInput::builder()
            .contents(MyUnion::NumberValue(1))
            .build();
        let http_request = JsonUnionsInput::assemble(input.input.request_builder_base(), vec![]);

        assert_eq!(http_request.method(), "PUT");
        assert_eq!(http_request.uri().path(), "/JsonUnions");

        let expected_headers = &[("Content-Type", "application/json")];
        ::protocol_test_helpers::assert_ok(::protocol_test_helpers::validate_headers(
            &http_request,
            expected_headers,
        ));
    }
    /// Serializes a blob union value
    /// Test ID: RestJsonSerializeBlobUnionValue
    #[test]
    fn test_rest_json_serialize_blob_union_value_request() {
        let input = JsonUnionsInput::builder()
            .contents(MyUnion::BlobValue(::smithy_types::Blob::new("foo")))
            .build();
        let http_request = JsonUnionsInput::assemble(input.input.request_builder_base(), vec![]);

        assert_eq!(http_request.method(), "PUT");
        assert_eq!(http_request.uri().path(), "/JsonUnions");

        let expected_headers = &[("Content-Type", "application/json")];
        ::protocol_test_helpers::assert_ok(::protocol_test_helpers::validate_headers(
            &http_request,
            expected_headers,
        ));
    }
    /// Serializes a timestamp union value
    /// Test ID: RestJsonSerializeTimestampUnionValue
    #[test]
    fn test_rest_json_serialize_timestamp_union_value_request() {
        let input = JsonUnionsInput::builder()
            .contents(MyUnion::TimestampValue(
                ::smithy_types::Instant::from_epoch_seconds(1398796238),
            ))
            .build();
        let http_request = JsonUnionsInput::assemble(input.input.request_builder_base(), vec![]);

        assert_eq!(http_request.method(), "PUT");
        assert_eq!(http_request.uri().path(), "/JsonUnions");

        let expected_headers = &[("Content-Type", "application/json")];
        ::protocol_test_helpers::assert_ok(::protocol_test_helpers::validate_headers(
            &http_request,
            expected_headers,
        ));
    }
    /// Serializes an enum union value
    /// Test ID: RestJsonSerializeEnumUnionValue
    #[test]
    fn test_rest_json_serialize_enum_union_value_request() {
        let input = JsonUnionsInput::builder()
            .contents(MyUnion::EnumValue(FooEnum::from("Foo")))
            .build();
        let http_request = JsonUnionsInput::assemble(input.input.request_builder_base(), vec![]);

        assert_eq!(http_request.method(), "PUT");
        assert_eq!(http_request.uri().path(), "/JsonUnions");

        let expected_headers = &[("Content-Type", "application/json")];
        ::protocol_test_helpers::assert_ok(::protocol_test_helpers::validate_headers(
            &http_request,
            expected_headers,
        ));
    }
    /// Serializes a list union value
    /// Test ID: RestJsonSerializeListUnionValue
    #[test]
    fn test_rest_json_serialize_list_union_value_request() {
        let input = JsonUnionsInput::builder()
            .contents(MyUnion::ListValue(vec![
                "foo".to_string(),
                "bar".to_string(),
            ]))
            .build();
        let http_request = JsonUnionsInput::assemble(input.input.request_builder_base(), vec![]);

        assert_eq!(http_request.method(), "PUT");
        assert_eq!(http_request.uri().path(), "/JsonUnions");

        let expected_headers = &[("Content-Type", "application/json")];
        ::protocol_test_helpers::assert_ok(::protocol_test_helpers::validate_headers(
            &http_request,
            expected_headers,
        ));
    }
    /// Serializes a map union value
    /// Test ID: RestJsonSerializeMapUnionValue
    #[test]
    fn test_rest_json_serialize_map_union_value_request() {
        let input = JsonUnionsInput::builder()
            .contents(MyUnion::MapValue({
                let mut ret = ::std::collections::HashMap::new();
                ret.insert("foo".to_string(), "bar".to_string());
                ret.insert("spam".to_string(), "eggs".to_string());
                ret
            }))
            .build();
        let http_request = JsonUnionsInput::assemble(input.input.request_builder_base(), vec![]);

        assert_eq!(http_request.method(), "PUT");
        assert_eq!(http_request.uri().path(), "/JsonUnions");

        let expected_headers = &[("Content-Type", "application/json")];
        ::protocol_test_helpers::assert_ok(::protocol_test_helpers::validate_headers(
            &http_request,
            expected_headers,
        ));
    }
    /// Serializes a structure union value
    /// Test ID: RestJsonSerializeStructureUnionValue
    #[test]
    fn test_rest_json_serialize_structure_union_value_request() {
        let input = JsonUnionsInput::builder()
            .contents(MyUnion::StructureValue(
                GreetingStruct::builder().hi("hello".to_string()).build(),
            ))
            .build();
        let http_request = JsonUnionsInput::assemble(input.input.request_builder_base(), vec![]);

        assert_eq!(http_request.method(), "PUT");
        assert_eq!(http_request.uri().path(), "/JsonUnions");

        let expected_headers = &[("Content-Type", "application/json")];
        ::protocol_test_helpers::assert_ok(::protocol_test_helpers::validate_headers(
            &http_request,
            expected_headers,
        ));
    }
    /// Deserializes a string union value
    /// Test ID: RestJsonDeserializeStringUnionValue
    #[test]
    fn test_rest_json_deserialize_string_union_value_response() {
        /* test case disabled for this protocol (not yet supported) */
    }
    /// Deserializes a boolean union value
    /// Test ID: RestJsonDeserializeBooleanUnionValue
    #[test]
    fn test_rest_json_deserialize_boolean_union_value_response() {
        /* test case disabled for this protocol (not yet supported) */
    }
    /// Deserializes a number union value
    /// Test ID: RestJsonDeserializeNumberUnionValue
    #[test]
    fn test_rest_json_deserialize_number_union_value_response() {
        /* test case disabled for this protocol (not yet supported) */
    }
    /// Deserializes a blob union value
    /// Test ID: RestJsonDeserializeBlobUnionValue
    #[test]
    fn test_rest_json_deserialize_blob_union_value_response() {
        /* test case disabled for this protocol (not yet supported) */
    }
    /// Deserializes a timestamp union value
    /// Test ID: RestJsonDeserializeTimestampUnionValue
    #[test]
    fn test_rest_json_deserialize_timestamp_union_value_response() {
        /* test case disabled for this protocol (not yet supported) */
    }
    /// Deserializes an enum union value
    /// Test ID: RestJsonDeserializeEnumUnionValue
    #[test]
    fn test_rest_json_deserialize_enum_union_value_response() {
        /* test case disabled for this protocol (not yet supported) */
    }
    /// Deserializes a list union value
    /// Test ID: RestJsonDeserializeListUnionValue
    #[test]
    fn test_rest_json_deserialize_list_union_value_response() {
        /* test case disabled for this protocol (not yet supported) */
    }
    /// Deserializes a map union value
    /// Test ID: RestJsonDeserializeMapUnionValue
    #[test]
    fn test_rest_json_deserialize_map_union_value_response() {
        /* test case disabled for this protocol (not yet supported) */
    }
    /// Deserializes a structure union value
    /// Test ID: RestJsonDeserializeStructureUnionValue
    #[test]
    fn test_rest_json_deserialize_structure_union_value_response() {
        /* test case disabled for this protocol (not yet supported) */
    }
}

/// This example ensures that mediaType strings are base64 encoded in headers.
pub struct MediaTypeHeader {
    input: MediaTypeHeaderInput,
}
impl MediaTypeHeader {
    /// Creates a new builder-style object to manufacture [`MediaTypeHeaderInput`](crate::input::MediaTypeHeaderInput)
    pub fn builder() -> crate::input::media_type_header_input::Builder {
        crate::input::media_type_header_input::Builder::default()
    }
    pub fn build_http_request(&self) -> ::http::request::Request<Vec<u8>> {
        MediaTypeHeaderInput::assemble(self.input.request_builder_base(), self.input.build_body())
    }
    pub fn new(input: MediaTypeHeaderInput) -> Self {
        Self { input }
    }
}
#[cfg(test)]
#[allow(unreachable_code, unused_variables)]
mod media_type_header_request_test {

    use crate::input::MediaTypeHeaderInput;
    /// Headers that target strings with a mediaType are base64 encoded
    /// Test ID: MediaTypeHeaderInputBase64
    #[test]
    fn test_media_type_header_input_base64_request() {
        let input = MediaTypeHeaderInput::builder()
            .json("true".to_string())
            .build();
        let http_request =
            MediaTypeHeaderInput::assemble(input.input.request_builder_base(), vec![]);

        assert_eq!(http_request.method(), "GET");
        assert_eq!(http_request.uri().path(), "/MediaTypeHeader");

        let expected_headers = &[("X-Json", "dHJ1ZQ==")];
        ::protocol_test_helpers::assert_ok(::protocol_test_helpers::validate_headers(
            &http_request,
            expected_headers,
        ));
    }
    /// Headers that target strings with a mediaType are base64 encoded
    /// Test ID: MediaTypeHeaderOutputBase64
    #[test]
    fn test_media_type_header_output_base64_response() {
        /* test case disabled for this protocol (not yet supported) */
    }
}

/// The example tests how requests and responses are serialized when there's
/// no request or response payload because the operation has no input or output.
/// While this should be rare, code generators must support this.
pub struct NoInputAndNoOutput {
    input: NoInputAndNoOutputInput,
}
impl NoInputAndNoOutput {
    /// Creates a new builder-style object to manufacture [`NoInputAndNoOutputInput`](crate::input::NoInputAndNoOutputInput)
    pub fn builder() -> crate::input::no_input_and_no_output_input::Builder {
        crate::input::no_input_and_no_output_input::Builder::default()
    }
    pub fn build_http_request(&self) -> ::http::request::Request<Vec<u8>> {
        NoInputAndNoOutputInput::assemble(
            self.input.request_builder_base(),
            self.input.build_body(),
        )
    }
    pub fn new(input: NoInputAndNoOutputInput) -> Self {
        Self { input }
    }
}
#[cfg(test)]
#[allow(unreachable_code, unused_variables)]
mod no_input_and_no_output_request_test {

    use crate::input::NoInputAndNoOutputInput;
    /// No input serializes no payload
    /// Test ID: RestJsonNoInputAndNoOutput
    #[test]
    fn test_rest_json_no_input_and_no_output_request() {
        let input = NoInputAndNoOutputInput::builder().build();
        let http_request =
            NoInputAndNoOutputInput::assemble(input.input.request_builder_base(), vec![]);

        assert_eq!(http_request.method(), "POST");
        assert_eq!(http_request.uri().path(), "/NoInputAndNoOutput");
    }
    /// No output serializes no payload
    /// Test ID: RestJsonNoInputAndNoOutput
    #[test]
    fn test_rest_json_no_input_and_no_output_response() {
        /* test case disabled for this protocol (not yet supported) */
    }
}

/// The example tests how requests and responses are serialized when there's
/// no request or response payload because the operation has no input and the
/// output is empty. While this should be rare, code generators must support
/// this.
pub struct NoInputAndOutput {
    input: NoInputAndOutputInput,
}
impl NoInputAndOutput {
    /// Creates a new builder-style object to manufacture [`NoInputAndOutputInput`](crate::input::NoInputAndOutputInput)
    pub fn builder() -> crate::input::no_input_and_output_input::Builder {
        crate::input::no_input_and_output_input::Builder::default()
    }
    pub fn build_http_request(&self) -> ::http::request::Request<Vec<u8>> {
        NoInputAndOutputInput::assemble(self.input.request_builder_base(), self.input.build_body())
    }
    pub fn new(input: NoInputAndOutputInput) -> Self {
        Self { input }
    }
}
#[cfg(test)]
#[allow(unreachable_code, unused_variables)]
mod no_input_and_output_request_test {

    use crate::input::NoInputAndOutputInput;
    /// No input serializes no payload
    /// Test ID: RestJsonNoInputAndOutput
    #[test]
    fn test_rest_json_no_input_and_output_request() {
        let input = NoInputAndOutputInput::builder().build();
        let http_request =
            NoInputAndOutputInput::assemble(input.input.request_builder_base(), vec![]);

        assert_eq!(http_request.method(), "POST");
        assert_eq!(http_request.uri().path(), "/NoInputAndOutputOutput");
    }
    /// Empty output serializes no payload
    /// Test ID: RestJsonNoInputAndOutput
    #[test]
    fn test_rest_json_no_input_and_output_response() {
        /* test case disabled for this protocol (not yet supported) */
    }
}

/// Null and empty headers are not sent over the wire.
pub struct NullAndEmptyHeadersClient {
    input: NullAndEmptyHeadersClientInput,
}
impl NullAndEmptyHeadersClient {
    /// Creates a new builder-style object to manufacture [`NullAndEmptyHeadersClientInput`](crate::input::NullAndEmptyHeadersClientInput)
    pub fn builder() -> crate::input::null_and_empty_headers_client_input::Builder {
        crate::input::null_and_empty_headers_client_input::Builder::default()
    }
    pub fn build_http_request(&self) -> ::http::request::Request<Vec<u8>> {
        NullAndEmptyHeadersClientInput::assemble(
            self.input.request_builder_base(),
            self.input.build_body(),
        )
    }
    pub fn new(input: NullAndEmptyHeadersClientInput) -> Self {
        Self { input }
    }
}
#[cfg(test)]
#[allow(unreachable_code, unused_variables)]
mod null_and_empty_headers_client_request_test {

    use crate::input::NullAndEmptyHeadersClientInput;
    /// Do not send null values, empty strings, or empty lists over the wire in headers
    /// Test ID: RestJsonNullAndEmptyHeaders
    #[test]
    fn test_rest_json_null_and_empty_headers_request() {
        let input = NullAndEmptyHeadersClientInput::builder()
            .b("".to_string())
            .c(vec![])
            .build();
        let http_request =
            NullAndEmptyHeadersClientInput::assemble(input.input.request_builder_base(), vec![]);

        assert_eq!(http_request.method(), "GET");
        assert_eq!(http_request.uri().path(), "/NullAndEmptyHeadersClient");

        let forbidden_headers = &["X-A", "X-B", "X-C"];
        ::protocol_test_helpers::assert_ok(::protocol_test_helpers::forbid_headers(
            &http_request,
            forbidden_headers,
        ));
    }
}

/// Null and empty headers are not sent over the wire.
pub struct NullAndEmptyHeadersServer {
    input: NullAndEmptyHeadersServerInput,
}
impl NullAndEmptyHeadersServer {
    /// Creates a new builder-style object to manufacture [`NullAndEmptyHeadersServerInput`](crate::input::NullAndEmptyHeadersServerInput)
    pub fn builder() -> crate::input::null_and_empty_headers_server_input::Builder {
        crate::input::null_and_empty_headers_server_input::Builder::default()
    }
    pub fn build_http_request(&self) -> ::http::request::Request<Vec<u8>> {
        NullAndEmptyHeadersServerInput::assemble(
            self.input.request_builder_base(),
            self.input.build_body(),
        )
    }
    pub fn new(input: NullAndEmptyHeadersServerInput) -> Self {
        Self { input }
    }
}
#[cfg(test)]
#[allow(unreachable_code, unused_variables)]
mod null_and_empty_headers_server_request_test {

    /// Do not send null or empty headers
    /// Test ID: RestJsonNullAndEmptyHeaders
    #[test]
    fn test_rest_json_null_and_empty_headers_response() {
        /* test case disabled for this protocol (not yet supported) */
    }
}

/// Omits null, but serializes empty string value.
pub struct OmitsNullSerializesEmptyString {
    input: OmitsNullSerializesEmptyStringInput,
}
impl OmitsNullSerializesEmptyString {
    /// Creates a new builder-style object to manufacture [`OmitsNullSerializesEmptyStringInput`](crate::input::OmitsNullSerializesEmptyStringInput)
    pub fn builder() -> crate::input::omits_null_serializes_empty_string_input::Builder {
        crate::input::omits_null_serializes_empty_string_input::Builder::default()
    }
    pub fn build_http_request(&self) -> ::http::request::Request<Vec<u8>> {
        OmitsNullSerializesEmptyStringInput::assemble(
            self.input.request_builder_base(),
            self.input.build_body(),
        )
    }
    pub fn new(input: OmitsNullSerializesEmptyStringInput) -> Self {
        Self { input }
    }
}
#[cfg(test)]
#[allow(unreachable_code, unused_variables)]
mod omits_null_serializes_empty_string_request_test {

    use crate::input::OmitsNullSerializesEmptyStringInput;
    /// Serializes empty query strings but omits null
    /// Test ID: RestJsonOmitsNullSerializesEmptyString
    #[test]
    fn test_rest_json_omits_null_serializes_empty_string_request() {
        let input = OmitsNullSerializesEmptyStringInput::builder()
            .empty_string("".to_string())
            .build();
        let http_request = OmitsNullSerializesEmptyStringInput::assemble(
            input.input.request_builder_base(),
            vec![],
        );

        assert_eq!(http_request.method(), "GET");
        assert_eq!(http_request.uri().path(), "/OmitsNullSerializesEmptyString");

        let expected_query_params = &["Empty="];
        ::protocol_test_helpers::assert_ok(::protocol_test_helpers::validate_query_string(
            &http_request,
            expected_query_params,
        ));
    }
}

/// Automatically adds idempotency tokens.
pub struct QueryIdempotencyTokenAutoFill {
    input: QueryIdempotencyTokenAutoFillInput,
}
impl QueryIdempotencyTokenAutoFill {
    /// Creates a new builder-style object to manufacture [`QueryIdempotencyTokenAutoFillInput`](crate::input::QueryIdempotencyTokenAutoFillInput)
    pub fn builder() -> crate::input::query_idempotency_token_auto_fill_input::Builder {
        crate::input::query_idempotency_token_auto_fill_input::Builder::default()
    }
    pub fn build_http_request(&self) -> ::http::request::Request<Vec<u8>> {
        QueryIdempotencyTokenAutoFillInput::assemble(
            self.input.request_builder_base(),
            self.input.build_body(),
        )
    }
    pub fn new(input: QueryIdempotencyTokenAutoFillInput) -> Self {
        Self { input }
    }
}
#[cfg(test)]
#[allow(unreachable_code, unused_variables)]
mod query_idempotency_token_auto_fill_request_test {

    use crate::input::QueryIdempotencyTokenAutoFillInput;
    /// Automatically adds idempotency token when not set
    /// Test ID: RestJsonQueryIdempotencyTokenAutoFill
    #[test]
    #[should_panic]
    fn test_rest_json_query_idempotency_token_auto_fill_request() {
        let input = QueryIdempotencyTokenAutoFillInput::builder().build();
        let http_request = QueryIdempotencyTokenAutoFillInput::assemble(
            input.input.request_builder_base(),
            vec![],
        );

        assert_eq!(http_request.method(), "POST");
        assert_eq!(http_request.uri().path(), "/QueryIdempotencyTokenAutoFill");

        let expected_query_params = &["token=00000000-0000-4000-8000-000000000000"];
        ::protocol_test_helpers::assert_ok(::protocol_test_helpers::validate_query_string(
            &http_request,
            expected_query_params,
        ));
    }
    /// Uses the given idempotency token as-is
    /// Test ID: RestJsonQueryIdempotencyTokenAutoFillIsSet
    #[test]
    fn test_rest_json_query_idempotency_token_auto_fill_is_set_request() {
        let input = QueryIdempotencyTokenAutoFillInput::builder()
            .token("00000000-0000-4000-8000-000000000000".to_string())
            .build();
        let http_request = QueryIdempotencyTokenAutoFillInput::assemble(
            input.input.request_builder_base(),
            vec![],
        );

        assert_eq!(http_request.method(), "POST");
        assert_eq!(http_request.uri().path(), "/QueryIdempotencyTokenAutoFill");

        let expected_query_params = &["token=00000000-0000-4000-8000-000000000000"];
        ::protocol_test_helpers::assert_ok(::protocol_test_helpers::validate_query_string(
            &http_request,
            expected_query_params,
        ));
    }
}

/// Recursive shapes
pub struct RecursiveShapes {
    input: RecursiveShapesInput,
}
impl RecursiveShapes {
    /// Creates a new builder-style object to manufacture [`RecursiveShapesInput`](crate::input::RecursiveShapesInput)
    pub fn builder() -> crate::input::recursive_shapes_input::Builder {
        crate::input::recursive_shapes_input::Builder::default()
    }
    pub fn build_http_request(&self) -> ::http::request::Request<Vec<u8>> {
        RecursiveShapesInput::assemble(self.input.request_builder_base(), self.input.build_body())
    }
    pub fn new(input: RecursiveShapesInput) -> Self {
        Self { input }
    }
}
#[cfg(test)]
#[allow(unreachable_code, unused_variables)]
mod recursive_shapes_request_test {

    use crate::input::RecursiveShapesInput;
    use crate::model::RecursiveShapesInputOutputNested1;
    use crate::model::RecursiveShapesInputOutputNested2;
    /// Serializes recursive structures
    /// Test ID: RestJsonRecursiveShapes
    #[test]
    fn test_rest_json_recursive_shapes_request() {
        let input = RecursiveShapesInput::builder()
            .nested(
                RecursiveShapesInputOutputNested1::builder()
                    .foo("Foo1".to_string())
                    .nested(
                        RecursiveShapesInputOutputNested2::builder()
                            .bar("Bar1".to_string())
                            .recursive_member(
                                RecursiveShapesInputOutputNested1::builder()
                                    .foo("Foo2".to_string())
                                    .nested(
                                        RecursiveShapesInputOutputNested2::builder()
                                            .bar("Bar2".to_string())
                                            .build(),
                                    )
                                    .build(),
                            )
                            .build(),
                    )
                    .build(),
            )
            .build();
        let http_request =
            RecursiveShapesInput::assemble(input.input.request_builder_base(), vec![]);

        assert_eq!(http_request.method(), "PUT");
        assert_eq!(http_request.uri().path(), "/RecursiveShapes");

        let expected_headers = &[("Content-Type", "application/json")];
        ::protocol_test_helpers::assert_ok(::protocol_test_helpers::validate_headers(
            &http_request,
            expected_headers,
        ));
    }
    /// Serializes recursive structures
    /// Test ID: RestJsonRecursiveShapes
    #[test]
    fn test_rest_json_recursive_shapes_response() {
        /* test case disabled for this protocol (not yet supported) */
    }
}

pub struct SimpleScalarProperties {
    input: SimpleScalarPropertiesInput,
}
impl SimpleScalarProperties {
    /// Creates a new builder-style object to manufacture [`SimpleScalarPropertiesInput`](crate::input::SimpleScalarPropertiesInput)
    pub fn builder() -> crate::input::simple_scalar_properties_input::Builder {
        crate::input::simple_scalar_properties_input::Builder::default()
    }
    pub fn build_http_request(&self) -> ::http::request::Request<Vec<u8>> {
        SimpleScalarPropertiesInput::assemble(
            self.input.request_builder_base(),
            self.input.build_body(),
        )
    }
    pub fn new(input: SimpleScalarPropertiesInput) -> Self {
        Self { input }
    }
}
#[cfg(test)]
#[allow(unreachable_code, unused_variables)]
mod simple_scalar_properties_request_test {

    use crate::input::SimpleScalarPropertiesInput;
    /// Serializes simple scalar properties
    /// Test ID: RestJsonSimpleScalarProperties
    #[test]
    fn test_rest_json_simple_scalar_properties_request() {
        let input = SimpleScalarPropertiesInput::builder()
            .foo("Foo".to_string())
            .string_value("string".to_string())
            .true_boolean_value(true)
            .false_boolean_value(false)
            .byte_value(1)
            .short_value(2)
            .integer_value(3)
            .long_value(4)
            .float_value(5.5)
            .double_value(6.5)
            .build();
        let http_request =
            SimpleScalarPropertiesInput::assemble(input.input.request_builder_base(), vec![]);

        assert_eq!(http_request.method(), "PUT");
        assert_eq!(http_request.uri().path(), "/SimpleScalarProperties");

        let expected_headers = &[("Content-Type", "application/json"), ("X-Foo", "Foo")];
        ::protocol_test_helpers::assert_ok(::protocol_test_helpers::validate_headers(
            &http_request,
            expected_headers,
        ));
    }
    /// Rest Json should not serialize null structure values
    /// Test ID: RestJsonDoesntSerializeNullStructureValues
    #[test]
    fn test_rest_json_doesnt_serialize_null_structure_values_request() {
        let input = SimpleScalarPropertiesInput::builder().build();
        let http_request =
            SimpleScalarPropertiesInput::assemble(input.input.request_builder_base(), vec![]);

        assert_eq!(http_request.method(), "PUT");
        assert_eq!(http_request.uri().path(), "/SimpleScalarProperties");

        let expected_headers = &[("Content-Type", "application/json")];
        ::protocol_test_helpers::assert_ok(::protocol_test_helpers::validate_headers(
            &http_request,
            expected_headers,
        ));
    }
    /// Serializes simple scalar properties
    /// Test ID: RestJsonSimpleScalarProperties
    #[test]
    fn test_rest_json_simple_scalar_properties_response() {
        /* test case disabled for this protocol (not yet supported) */
    }
    /// Rest Json should not deserialize null structure values
    /// Test ID: RestJsonDoesntDeserializeNullStructureValues
    #[test]
    fn test_rest_json_doesnt_deserialize_null_structure_values_response() {
        /* test case disabled for this protocol (not yet supported) */
    }
}

/// This examples serializes a streaming blob shape in the request body.
/// In this example, no JSON document is synthesized because the payload is
/// not a structure or a union type.
pub struct StreamingTraits {
    input: StreamingTraitsInput,
}
impl StreamingTraits {
    /// Creates a new builder-style object to manufacture [`StreamingTraitsInput`](crate::input::StreamingTraitsInput)
    pub fn builder() -> crate::input::streaming_traits_input::Builder {
        crate::input::streaming_traits_input::Builder::default()
    }
    pub fn build_http_request(&self) -> ::http::request::Request<Vec<u8>> {
        StreamingTraitsInput::assemble(self.input.request_builder_base(), self.input.build_body())
    }
    pub fn new(input: StreamingTraitsInput) -> Self {
        Self { input }
    }
}
#[cfg(test)]
#[allow(unreachable_code, unused_variables)]
mod streaming_traits_request_test {

    use crate::input::StreamingTraitsInput;
    /// Serializes a blob in the HTTP payload
    /// Test ID: RestJsonStreamingTraitsWithBlob
    #[test]
    fn test_rest_json_streaming_traits_with_blob_request() {
        let input = StreamingTraitsInput::builder()
            .foo("Foo".to_string())
            .blob(::smithy_types::Blob::new("blobby blob blob"))
            .build();
        let http_request =
            StreamingTraitsInput::assemble(input.input.request_builder_base(), vec![]);

        assert_eq!(http_request.method(), "POST");
        assert_eq!(http_request.uri().path(), "/StreamingTraits");

        let expected_headers = &[
            ("Content-Type", "application/octet-stream"),
            ("X-Foo", "Foo"),
        ];
        ::protocol_test_helpers::assert_ok(::protocol_test_helpers::validate_headers(
            &http_request,
            expected_headers,
        ));
    }
    /// Serializes an empty blob in the HTTP payload
    /// Test ID: RestJsonStreamingTraitsWithNoBlobBody
    #[test]
    fn test_rest_json_streaming_traits_with_no_blob_body_request() {
        let input = StreamingTraitsInput::builder()
            .foo("Foo".to_string())
            .build();
        let http_request =
            StreamingTraitsInput::assemble(input.input.request_builder_base(), vec![]);

        assert_eq!(http_request.method(), "POST");
        assert_eq!(http_request.uri().path(), "/StreamingTraits");

        let expected_headers = &[("X-Foo", "Foo")];
        ::protocol_test_helpers::assert_ok(::protocol_test_helpers::validate_headers(
            &http_request,
            expected_headers,
        ));
    }
    /// Serializes a blob in the HTTP payload
    /// Test ID: RestJsonStreamingTraitsWithBlob
    #[test]
    fn test_rest_json_streaming_traits_with_blob_response() {
        /* test case disabled for this protocol (not yet supported) */
    }
    /// Serializes an empty blob in the HTTP payload
    /// Test ID: RestJsonStreamingTraitsWithNoBlobBody
    #[test]
    fn test_rest_json_streaming_traits_with_no_blob_body_response() {
        /* test case disabled for this protocol (not yet supported) */
    }
}

/// This examples serializes a streaming blob shape with a required content
/// length in the request body.
/// In this example, no JSON document is synthesized because the payload is
/// not a structure or a union type.
pub struct StreamingTraitsRequireLength {
    input: StreamingTraitsRequireLengthInput,
}
impl StreamingTraitsRequireLength {
    /// Creates a new builder-style object to manufacture [`StreamingTraitsRequireLengthInput`](crate::input::StreamingTraitsRequireLengthInput)
    pub fn builder() -> crate::input::streaming_traits_require_length_input::Builder {
        crate::input::streaming_traits_require_length_input::Builder::default()
    }
    pub fn build_http_request(&self) -> ::http::request::Request<Vec<u8>> {
        StreamingTraitsRequireLengthInput::assemble(
            self.input.request_builder_base(),
            self.input.build_body(),
        )
    }
    pub fn new(input: StreamingTraitsRequireLengthInput) -> Self {
        Self { input }
    }
}
#[cfg(test)]
#[allow(unreachable_code, unused_variables)]
mod streaming_traits_require_length_request_test {

    use crate::input::StreamingTraitsRequireLengthInput;
    /// Serializes a blob in the HTTP payload with a required length
    /// Test ID: RestJsonStreamingTraitsRequireLengthWithBlob
    #[test]
    fn test_rest_json_streaming_traits_require_length_with_blob_request() {
        let input = StreamingTraitsRequireLengthInput::builder()
            .foo("Foo".to_string())
            .blob(::smithy_types::Blob::new("blobby blob blob"))
            .build();
        let http_request =
            StreamingTraitsRequireLengthInput::assemble(input.input.request_builder_base(), vec![]);

        assert_eq!(http_request.method(), "POST");
        assert_eq!(http_request.uri().path(), "/StreamingTraitsRequireLength");

        let expected_headers = &[
            ("Content-Type", "application/octet-stream"),
            ("X-Foo", "Foo"),
        ];
        ::protocol_test_helpers::assert_ok(::protocol_test_helpers::validate_headers(
            &http_request,
            expected_headers,
        ));
        let required_headers = &["Content-Length"];
        ::protocol_test_helpers::assert_ok(::protocol_test_helpers::require_headers(
            &http_request,
            required_headers,
        ));
    }
    /// Serializes an empty blob in the HTTP payload
    /// Test ID: RestJsonStreamingTraitsRequireLengthWithNoBlobBody
    #[test]
    fn test_rest_json_streaming_traits_require_length_with_no_blob_body_request() {
        let input = StreamingTraitsRequireLengthInput::builder()
            .foo("Foo".to_string())
            .build();
        let http_request =
            StreamingTraitsRequireLengthInput::assemble(input.input.request_builder_base(), vec![]);

        assert_eq!(http_request.method(), "POST");
        assert_eq!(http_request.uri().path(), "/StreamingTraitsRequireLength");

        let expected_headers = &[("X-Foo", "Foo")];
        ::protocol_test_helpers::assert_ok(::protocol_test_helpers::validate_headers(
            &http_request,
            expected_headers,
        ));
    }
    /// Serializes a blob in the HTTP payload with a required length
    /// Test ID: RestJsonStreamingTraitsRequireLengthWithBlob
    #[test]
    fn test_rest_json_streaming_traits_require_length_with_blob_response() {
        /* test case disabled for this protocol (not yet supported) */
    }
    /// Serializes an empty blob in the HTTP payload
    /// Test ID: RestJsonStreamingTraitsRequireLengthWithNoBlobBody
    #[test]
    fn test_rest_json_streaming_traits_require_length_with_no_blob_body_response() {
        /* test case disabled for this protocol (not yet supported) */
    }
}

/// This examples serializes a streaming media-typed blob shape in the request body.
/// This examples uses a `@mediaType` trait on the payload to force a custom
/// content-type to be serialized.
pub struct StreamingTraitsWithMediaType {
    input: StreamingTraitsWithMediaTypeInput,
}
impl StreamingTraitsWithMediaType {
    /// Creates a new builder-style object to manufacture [`StreamingTraitsWithMediaTypeInput`](crate::input::StreamingTraitsWithMediaTypeInput)
    pub fn builder() -> crate::input::streaming_traits_with_media_type_input::Builder {
        crate::input::streaming_traits_with_media_type_input::Builder::default()
    }
    pub fn build_http_request(&self) -> ::http::request::Request<Vec<u8>> {
        StreamingTraitsWithMediaTypeInput::assemble(
            self.input.request_builder_base(),
            self.input.build_body(),
        )
    }
    pub fn new(input: StreamingTraitsWithMediaTypeInput) -> Self {
        Self { input }
    }
}
#[cfg(test)]
#[allow(unreachable_code, unused_variables)]
mod streaming_traits_with_media_type_request_test {

    use crate::input::StreamingTraitsWithMediaTypeInput;
    /// Serializes a blob in the HTTP payload with a content-type
    /// Test ID: RestJsonStreamingTraitsWithMediaTypeWithBlob
    #[test]
    fn test_rest_json_streaming_traits_with_media_type_with_blob_request() {
        let input = StreamingTraitsWithMediaTypeInput::builder()
            .foo("Foo".to_string())
            .blob(::smithy_types::Blob::new("blobby blob blob"))
            .build();
        let http_request =
            StreamingTraitsWithMediaTypeInput::assemble(input.input.request_builder_base(), vec![]);

        assert_eq!(http_request.method(), "POST");
        assert_eq!(http_request.uri().path(), "/StreamingTraitsWithMediaType");

        let expected_headers = &[("Content-Type", "text/plain"), ("X-Foo", "Foo")];
        ::protocol_test_helpers::assert_ok(::protocol_test_helpers::validate_headers(
            &http_request,
            expected_headers,
        ));
    }
    /// Serializes a blob in the HTTP payload with a content-type
    /// Test ID: RestJsonStreamingTraitsWithMediaTypeWithBlob
    #[test]
    fn test_rest_json_streaming_traits_with_media_type_with_blob_response() {
        /* test case disabled for this protocol (not yet supported) */
    }
}

/// This example tests how timestamp request and response headers are serialized.
pub struct TimestampFormatHeaders {
    input: TimestampFormatHeadersInput,
}
impl TimestampFormatHeaders {
    /// Creates a new builder-style object to manufacture [`TimestampFormatHeadersInput`](crate::input::TimestampFormatHeadersInput)
    pub fn builder() -> crate::input::timestamp_format_headers_input::Builder {
        crate::input::timestamp_format_headers_input::Builder::default()
    }
    pub fn build_http_request(&self) -> ::http::request::Request<Vec<u8>> {
        TimestampFormatHeadersInput::assemble(
            self.input.request_builder_base(),
            self.input.build_body(),
        )
    }
    pub fn new(input: TimestampFormatHeadersInput) -> Self {
        Self { input }
    }
}
#[cfg(test)]
#[allow(unreachable_code, unused_variables)]
mod timestamp_format_headers_request_test {

    use crate::input::TimestampFormatHeadersInput;
    /// Tests how timestamp request headers are serialized
    /// Test ID: RestJsonTimestampFormatHeaders
    #[test]
    fn test_rest_json_timestamp_format_headers_request() {
        let input = TimestampFormatHeadersInput::builder()
            .member_epoch_seconds(::smithy_types::Instant::from_epoch_seconds(1576540098))
            .member_http_date(::smithy_types::Instant::from_epoch_seconds(1576540098))
            .member_date_time(::smithy_types::Instant::from_epoch_seconds(1576540098))
            .default_format(::smithy_types::Instant::from_epoch_seconds(1576540098))
            .target_epoch_seconds(::smithy_types::Instant::from_epoch_seconds(1576540098))
            .target_http_date(::smithy_types::Instant::from_epoch_seconds(1576540098))
            .target_date_time(::smithy_types::Instant::from_epoch_seconds(1576540098))
            .build();
        let http_request =
            TimestampFormatHeadersInput::assemble(input.input.request_builder_base(), vec![]);

        assert_eq!(http_request.method(), "POST");
        assert_eq!(http_request.uri().path(), "/TimestampFormatHeaders");

        let expected_headers = &[
            ("X-defaultFormat", "Mon, 16 Dec 2019 23:48:18 GMT"),
            ("X-memberDateTime", "2019-12-16T23:48:18Z"),
            ("X-memberEpochSeconds", "1576540098"),
            ("X-memberHttpDate", "Mon, 16 Dec 2019 23:48:18 GMT"),
            ("X-targetDateTime", "2019-12-16T23:48:18Z"),
            ("X-targetEpochSeconds", "1576540098"),
            ("X-targetHttpDate", "Mon, 16 Dec 2019 23:48:18 GMT"),
        ];
        ::protocol_test_helpers::assert_ok(::protocol_test_helpers::validate_headers(
            &http_request,
            expected_headers,
        ));
    }
    /// Tests how timestamp response headers are serialized
    /// Test ID: RestJsonTimestampFormatHeaders
    #[test]
    fn test_rest_json_timestamp_format_headers_response() {
        /* test case disabled for this protocol (not yet supported) */
    }
}
