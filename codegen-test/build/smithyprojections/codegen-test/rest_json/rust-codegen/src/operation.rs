// Code generated by software.amazon.smithy.rust.codegen.smithy-rs. DO NOT EDIT.
use crate::model::FooEnum;
use crate::model::GreetingStruct;
use crate::model::MyUnion;
use crate::model::NestedPayload;
use crate::model::RecursiveShapesInputOutputNested1;
use crate::model::StructureListMember;
use smithy_types::Blob;
use smithy_types::Document;
use smithy_types::Instant;
use std::collections::BTreeSet;
use std::collections::HashMap;
use std::fmt::Write;
impl AllQueryStringTypesInput {
    fn uri_base(&self, output: &mut String) {
        write!(output, "/AllQueryStringTypesInput").expect("formatting should succeed")
    }
    fn uri_query(&self, output: &mut String) {
        let mut params = Vec::new();
        if let Some(inner_1) = &self.query_string {
            params.push(("String", ::smithy_http::query::fmt_string(&inner_1)))
        }
        if let Some(inner_2) = &self.query_string_list {
            for inner_3 in inner_2 {
                params.push(("StringList", ::smithy_http::query::fmt_string(&inner_3)))
            }
        }
        if let Some(inner_4) = &self.query_string_set {
            for inner_5 in inner_4 {
                params.push(("StringSet", ::smithy_http::query::fmt_string(&inner_5)))
            }
        }
        if let Some(inner_6) = &self.query_byte {
            params.push(("Byte", ::smithy_http::query::fmt_default(&inner_6)))
        }
        if let Some(inner_7) = &self.query_short {
            params.push(("Short", ::smithy_http::query::fmt_default(&inner_7)))
        }
        if let Some(inner_8) = &self.query_integer {
            params.push(("Integer", ::smithy_http::query::fmt_default(&inner_8)))
        }
        if let Some(inner_9) = &self.query_integer_list {
            for inner_10 in inner_9 {
                params.push(("IntegerList", ::smithy_http::query::fmt_default(&inner_10)))
            }
        }
        if let Some(inner_11) = &self.query_integer_set {
            for inner_12 in inner_11 {
                params.push(("IntegerSet", ::smithy_http::query::fmt_default(&inner_12)))
            }
        }
        if let Some(inner_13) = &self.query_long {
            params.push(("Long", ::smithy_http::query::fmt_default(&inner_13)))
        }
        if let Some(inner_14) = &self.query_float {
            params.push(("Float", ::smithy_http::query::fmt_default(&inner_14)))
        }
        if let Some(inner_15) = &self.query_double {
            params.push(("Double", ::smithy_http::query::fmt_default(&inner_15)))
        }
        if let Some(inner_16) = &self.query_double_list {
            for inner_17 in inner_16 {
                params.push(("DoubleList", ::smithy_http::query::fmt_default(&inner_17)))
            }
        }
        if let Some(inner_18) = &self.query_boolean {
            params.push(("Boolean", ::smithy_http::query::fmt_default(&inner_18)))
        }
        if let Some(inner_19) = &self.query_boolean_list {
            for inner_20 in inner_19 {
                params.push(("BooleanList", ::smithy_http::query::fmt_default(&inner_20)))
            }
        }
        if let Some(inner_21) = &self.query_timestamp {
            params.push((
                "Timestamp",
                ::smithy_http::query::fmt_timestamp(
                    inner_21,
                    ::smithy_types::instant::Format::DateTime,
                ),
            ))
        }
        if let Some(inner_22) = &self.query_timestamp_list {
            for inner_23 in inner_22 {
                params.push((
                    "TimestampList",
                    ::smithy_http::query::fmt_timestamp(
                        inner_23,
                        ::smithy_types::instant::Format::DateTime,
                    ),
                ))
            }
        }
        if let Some(inner_24) = &self.query_enum {
            params.push(("Enum", ::smithy_http::query::fmt_string(&inner_24.as_str())))
        }
        if let Some(inner_25) = &self.query_enum_list {
            for inner_26 in inner_25 {
                params.push((
                    "EnumList",
                    ::smithy_http::query::fmt_string(&inner_26.as_str()),
                ))
            }
        }
        ::smithy_http::query::write(params, output)
    }
    fn update_http_builder(&self, builder: ::http::request::Builder) -> ::http::request::Builder {
        let mut uri = String::new();
        self.uri_base(&mut uri);
        self.uri_query(&mut uri);
        builder.method("GET").uri(uri)
    }
    pub fn request_builder_base(&self) -> ::http::request::Builder {
        let builder = ::http::request::Builder::new();
        let builder = builder.header("Content-Type", "application/json");
        self.update_http_builder(builder)
    }
    pub fn build_body(&self) -> Vec<u8> {
        todo!()
    }
    pub fn assemble(
        builder: ::http::request::Builder,
        body: Vec<u8>,
    ) -> ::http::request::Request<Vec<u8>> {
        builder
            .header(::http::header::CONTENT_LENGTH, body.len())
            .body(body)
            .expect("http request should be valid")
    }
}
#[cfg(test)]
#[allow(unreachable_code, unused_variables)]
mod all_query_string_types_request_test {

    use crate::model::FooEnum;
    use crate::operation::AllQueryStringTypesInput;
    /// Serializes query string parameters with all supported types
    /// Test ID: RestJsonAllQueryStringTypes
    #[test]
    fn test_rest_json_all_query_string_types_request() {
        let input = AllQueryStringTypesInput::builder()
            .query_string("Hello there".to_string())
            .query_string_list(vec!["a".to_string(), "b".to_string(), "c".to_string()])
            .query_string_set({
                let mut ret = ::std::collections::BTreeSet::new();
                ret.insert("a".to_string());
                ret.insert("b".to_string());
                ret.insert("c".to_string());
                ret
            })
            .query_byte(1)
            .query_short(2)
            .query_integer(3)
            .query_integer_list(vec![1, 2, 3])
            .query_integer_set(vec![1, 2, 3])
            .query_long(4)
            .query_float(1.1)
            .query_double(1.1)
            .query_double_list(vec![1.1, 2.1, 3.1])
            .query_boolean(true)
            .query_boolean_list(vec![true, false, true])
            .query_timestamp(::smithy_types::Instant::from_epoch_seconds(1))
            .query_timestamp_list(vec![
                ::smithy_types::Instant::from_epoch_seconds(1),
                ::smithy_types::Instant::from_epoch_seconds(2),
                ::smithy_types::Instant::from_epoch_seconds(3),
            ])
            .query_enum(FooEnum::from("Foo"))
            .query_enum_list(vec![
                FooEnum::from("Foo"),
                FooEnum::from("Baz"),
                FooEnum::from("Bar"),
            ])
            .build();
        let http_request = AllQueryStringTypesInput::assemble(input.request_builder_base(), vec![]);

        assert_eq!(http_request.method(), "GET");
        assert_eq!(http_request.uri().path(), "/AllQueryStringTypesInput");

        let expected_query_params = &[
            "String=Hello%20there",
            "StringList=a",
            "StringList=b",
            "StringList=c",
            "StringSet=a",
            "StringSet=b",
            "StringSet=c",
            "Byte=1",
            "Short=2",
            "Integer=3",
            "IntegerList=1",
            "IntegerList=2",
            "IntegerList=3",
            "IntegerSet=1",
            "IntegerSet=2",
            "IntegerSet=3",
            "Long=4",
            "Float=1.1",
            "Double=1.1",
            "DoubleList=1.1",
            "DoubleList=2.1",
            "DoubleList=3.1",
            "Boolean=true",
            "BooleanList=true",
            "BooleanList=false",
            "BooleanList=true",
            "Timestamp=1970-01-01T00%3A00%3A01Z",
            "TimestampList=1970-01-01T00%3A00%3A01Z",
            "TimestampList=1970-01-01T00%3A00%3A02Z",
            "TimestampList=1970-01-01T00%3A00%3A03Z",
            "Enum=Foo",
            "EnumList=Foo",
            "EnumList=Baz",
            "EnumList=Bar",
        ];
        ::protocol_test_helpers::assert_ok(::protocol_test_helpers::validate_query_string(
            &http_request,
            expected_query_params,
        ));
    }
}

impl ConstantAndVariableQueryStringInput {
    fn uri_base(&self, output: &mut String) {
        write!(output, "/ConstantAndVariableQueryString").expect("formatting should succeed")
    }
    fn uri_query(&self, output: &mut String) {
        let mut params = Vec::new();
        if let Some(inner_27) = &self.baz {
            params.push(("baz", ::smithy_http::query::fmt_string(&inner_27)))
        }
        if let Some(inner_28) = &self.maybe_set {
            params.push(("maybeSet", ::smithy_http::query::fmt_string(&inner_28)))
        }
        ::smithy_http::query::write(params, output)
    }
    fn update_http_builder(&self, builder: ::http::request::Builder) -> ::http::request::Builder {
        let mut uri = String::new();
        self.uri_base(&mut uri);
        self.uri_query(&mut uri);
        builder.method("GET").uri(uri)
    }
    pub fn request_builder_base(&self) -> ::http::request::Builder {
        let builder = ::http::request::Builder::new();
        let builder = builder.header("Content-Type", "application/json");
        self.update_http_builder(builder)
    }
    pub fn build_body(&self) -> Vec<u8> {
        todo!()
    }
    pub fn assemble(
        builder: ::http::request::Builder,
        body: Vec<u8>,
    ) -> ::http::request::Request<Vec<u8>> {
        builder
            .header(::http::header::CONTENT_LENGTH, body.len())
            .body(body)
            .expect("http request should be valid")
    }
}
#[cfg(test)]
#[allow(unreachable_code, unused_variables)]
mod constant_and_variable_query_string_request_test {

    use crate::operation::ConstantAndVariableQueryStringInput;
    /// Mixes constant and variable query string parameters
    /// Test ID: RestJsonConstantAndVariableQueryStringMissingOneValue
    #[test]
    #[should_panic]
    fn test_rest_json_constant_and_variable_query_string_missing_one_value_request() {
        let input = ConstantAndVariableQueryStringInput::builder()
            .baz("bam".to_string())
            .build();
        let http_request =
            ConstantAndVariableQueryStringInput::assemble(input.request_builder_base(), vec![]);

        assert_eq!(http_request.method(), "GET");
        assert_eq!(http_request.uri().path(), "/ConstantAndVariableQueryString");

        let expected_query_params = &["foo=bar", "baz=bam"];
        ::protocol_test_helpers::assert_ok(::protocol_test_helpers::validate_query_string(
            &http_request,
            expected_query_params,
        ));
        let forbid_params = &["maybeSet"];
        ::protocol_test_helpers::assert_ok(::protocol_test_helpers::forbid_query_params(
            &http_request,
            forbid_params,
        ));
    }
    /// Mixes constant and variable query string parameters
    /// Test ID: RestJsonConstantAndVariableQueryStringAllValues
    #[test]
    #[should_panic]
    fn test_rest_json_constant_and_variable_query_string_all_values_request() {
        let input = ConstantAndVariableQueryStringInput::builder()
            .baz("bam".to_string())
            .maybe_set("yes".to_string())
            .build();
        let http_request =
            ConstantAndVariableQueryStringInput::assemble(input.request_builder_base(), vec![]);

        assert_eq!(http_request.method(), "GET");
        assert_eq!(http_request.uri().path(), "/ConstantAndVariableQueryString");

        let expected_query_params = &["foo=bar", "baz=bam", "maybeSet=yes"];
        ::protocol_test_helpers::assert_ok(::protocol_test_helpers::validate_query_string(
            &http_request,
            expected_query_params,
        ));
    }
}

impl ConstantQueryStringInput {
    fn uri_base(&self, output: &mut String) {
        write!(
            output,
            "/ConstantQueryString/{hello}",
            hello = ::smithy_http::label::fmt_string(&self.hello, false)
        )
        .expect("formatting should succeed")
    }
    fn update_http_builder(&self, builder: ::http::request::Builder) -> ::http::request::Builder {
        let mut uri = String::new();
        self.uri_base(&mut uri);
        builder.method("GET").uri(uri)
    }
    pub fn request_builder_base(&self) -> ::http::request::Builder {
        let builder = ::http::request::Builder::new();
        let builder = builder.header("Content-Type", "application/json");
        self.update_http_builder(builder)
    }
    pub fn build_body(&self) -> Vec<u8> {
        todo!()
    }
    pub fn assemble(
        builder: ::http::request::Builder,
        body: Vec<u8>,
    ) -> ::http::request::Request<Vec<u8>> {
        builder
            .header(::http::header::CONTENT_LENGTH, body.len())
            .body(body)
            .expect("http request should be valid")
    }
}
#[cfg(test)]
#[allow(unreachable_code, unused_variables)]
mod constant_query_string_request_test {

    use crate::operation::ConstantQueryStringInput;
    /// Includes constant query string parameters
    /// Test ID: RestJsonConstantQueryString
    #[test]
    #[should_panic]
    fn test_rest_json_constant_query_string_request() {
        let input = ConstantQueryStringInput::builder()
            .hello("hi".to_string())
            .build();
        let http_request = ConstantQueryStringInput::assemble(input.request_builder_base(), vec![]);

        assert_eq!(http_request.method(), "GET");
        assert_eq!(http_request.uri().path(), "/ConstantQueryString/hi");

        let expected_query_params = &["foo=bar", "hello"];
        ::protocol_test_helpers::assert_ok(::protocol_test_helpers::validate_query_string(
            &http_request,
            expected_query_params,
        ));
    }
}

impl EmptyInputAndEmptyOutputInput {
    fn uri_base(&self, output: &mut String) {
        write!(output, "/EmptyInputAndEmptyOutput").expect("formatting should succeed")
    }
    fn update_http_builder(&self, builder: ::http::request::Builder) -> ::http::request::Builder {
        let mut uri = String::new();
        self.uri_base(&mut uri);
        builder.method("POST").uri(uri)
    }
    pub fn request_builder_base(&self) -> ::http::request::Builder {
        let builder = ::http::request::Builder::new();
        let builder = builder.header("Content-Type", "application/json");
        self.update_http_builder(builder)
    }
    pub fn build_body(&self) -> Vec<u8> {
        todo!()
    }
    pub fn assemble(
        builder: ::http::request::Builder,
        body: Vec<u8>,
    ) -> ::http::request::Request<Vec<u8>> {
        builder
            .header(::http::header::CONTENT_LENGTH, body.len())
            .body(body)
            .expect("http request should be valid")
    }
}
#[cfg(test)]
#[allow(unreachable_code, unused_variables)]
mod empty_input_and_empty_output_request_test {

    use crate::operation::EmptyInputAndEmptyOutputInput;
    /// Empty input serializes no payload
    /// Test ID: RestJsonEmptyInputAndEmptyOutput
    #[test]
    fn test_rest_json_empty_input_and_empty_output_request() {
        let input = EmptyInputAndEmptyOutputInput::builder().build();
        let http_request =
            EmptyInputAndEmptyOutputInput::assemble(input.request_builder_base(), vec![]);

        assert_eq!(http_request.method(), "POST");
        assert_eq!(http_request.uri().path(), "/EmptyInputAndEmptyOutput");
    }
    /// Empty output serializes no payload
    /// Test ID: RestJsonEmptyInputAndEmptyOutput
    #[test]
    fn test_rest_json_empty_input_and_empty_output_response() {
        /* test case disabled for this protocol (not yet supported) */
    }
    /// Empty output serializes no payload
    /// Test ID: RestJsonEmptyInputAndEmptyJsonObjectOutput
    #[test]
    fn test_rest_json_empty_input_and_empty_json_object_output_response() {
        /* test case disabled for this protocol (not yet supported) */
    }
}

impl GreetingWithErrorsInput {
    fn uri_base(&self, output: &mut String) {
        write!(output, "/GreetingWithErrors").expect("formatting should succeed")
    }
    fn update_http_builder(&self, builder: ::http::request::Builder) -> ::http::request::Builder {
        let mut uri = String::new();
        self.uri_base(&mut uri);
        builder.method("PUT").uri(uri)
    }
    pub fn request_builder_base(&self) -> ::http::request::Builder {
        let builder = ::http::request::Builder::new();
        let builder = builder.header("Content-Type", "application/json");
        self.update_http_builder(builder)
    }
    pub fn build_body(&self) -> Vec<u8> {
        todo!()
    }
    pub fn assemble(
        builder: ::http::request::Builder,
        body: Vec<u8>,
    ) -> ::http::request::Request<Vec<u8>> {
        builder
            .header(::http::header::CONTENT_LENGTH, body.len())
            .body(body)
            .expect("http request should be valid")
    }
}
#[cfg(test)]
#[allow(unreachable_code, unused_variables)]
mod greeting_with_errors_request_test {

    /// Ensures that operations with errors successfully know how to deserialize the successful response
    /// Test ID: RestJsonGreetingWithErrors
    #[test]
    fn test_rest_json_greeting_with_errors_response() {
        /* test case disabled for this protocol (not yet supported) */
    }
    /// Parses simple JSON errors
    /// Test ID: RestJsonInvalidGreetingError
    #[test]
    fn test_rest_json_invalid_greeting_error_response() {
        /* test case disabled for this protocol (not yet supported) */
    }
    /// Serializes a complex error with no message member
    /// Test ID: RestJsonComplexErrorWithNoMessage
    #[test]
    fn test_rest_json_complex_error_with_no_message_response() {
        /* test case disabled for this protocol (not yet supported) */
    }
    /// Test ID: RestJsonEmptyComplexErrorWithNoMessage
    #[test]
    fn test_rest_json_empty_complex_error_with_no_message_response() {
        /* test case disabled for this protocol (not yet supported) */
    }
    /// Serializes the X-Amzn-ErrorType header. For an example service, see Amazon EKS.
    /// Test ID: RestJsonFooErrorUsingXAmznErrorType
    #[test]
    fn test_rest_json_foo_error_using_x_amzn_error_type_response() {
        /* test case disabled for this protocol (not yet supported) */
    }
    /// Some X-Amzn-Errortype headers contain URLs. Clients need to split the URL on ':' and take only the first half of the string. For example, 'ValidationException:http://internal.amazon.com/coral/com.amazon.coral.validate/'
    /// is to be interpreted as 'ValidationException'.
    ///
    /// For an example service see Amazon Polly.
    /// Test ID: RestJsonFooErrorUsingXAmznErrorTypeWithUri
    #[test]
    fn test_rest_json_foo_error_using_x_amzn_error_type_with_uri_response() {
        /* test case disabled for this protocol (not yet supported) */
    }
    /// X-Amzn-Errortype might contain a URL and a namespace. Client should extract only the shape name. This is a pathalogical case that might not actually happen in any deployed AWS service.
    /// Test ID: RestJsonFooErrorUsingXAmznErrorTypeWithUriAndNamespace
    #[test]
    fn test_rest_json_foo_error_using_x_amzn_error_type_with_uri_and_namespace_response() {
        /* test case disabled for this protocol (not yet supported) */
    }
    /// This example uses the 'code' property in the output rather than X-Amzn-Errortype. Some services do this though it's preferable to send the X-Amzn-Errortype. Client implementations must first check for the X-Amzn-Errortype and then check for a top-level 'code' property.
    ///
    /// For example service see Amazon S3 Glacier.
    /// Test ID: RestJsonFooErrorUsingCode
    #[test]
    fn test_rest_json_foo_error_using_code_response() {
        /* test case disabled for this protocol (not yet supported) */
    }
    /// Some services serialize errors using code, and it might contain a namespace. Clients should just take the last part of the string after '#'.
    /// Test ID: RestJsonFooErrorUsingCodeAndNamespace
    #[test]
    fn test_rest_json_foo_error_using_code_and_namespace_response() {
        /* test case disabled for this protocol (not yet supported) */
    }
    /// Some services serialize errors using code, and it might contain a namespace. It also might contain a URI. Clients should just take the last part of the string after '#' and before ":". This is a pathalogical case that might not occur in any deployed AWS service.
    /// Test ID: RestJsonFooErrorUsingCodeUriAndNamespace
    #[test]
    fn test_rest_json_foo_error_using_code_uri_and_namespace_response() {
        /* test case disabled for this protocol (not yet supported) */
    }
    /// Some services serialize errors using __type.
    /// Test ID: RestJsonFooErrorWithDunderType
    #[test]
    fn test_rest_json_foo_error_with_dunder_type_response() {
        /* test case disabled for this protocol (not yet supported) */
    }
    /// Some services serialize errors using __type, and it might contain a namespace. Clients should just take the last part of the string after '#'.
    /// Test ID: RestJsonFooErrorWithDunderTypeAndNamespace
    #[test]
    fn test_rest_json_foo_error_with_dunder_type_and_namespace_response() {
        /* test case disabled for this protocol (not yet supported) */
    }
    /// Some services serialize errors using __type, and it might contain a namespace. It also might contain a URI. Clients should just take the last part of the string after '#' and before ":". This is a pathalogical case that might not occur in any deployed AWS service.
    /// Test ID: RestJsonFooErrorWithDunderTypeUriAndNamespace
    #[test]
    fn test_rest_json_foo_error_with_dunder_type_uri_and_namespace_response() {
        /* test case disabled for this protocol (not yet supported) */
    }
}

impl HttpPayloadTraitsInput {
    fn uri_base(&self, output: &mut String) {
        write!(output, "/HttpPayloadTraits").expect("formatting should succeed")
    }
    fn add_headers(&self, mut builder: ::http::request::Builder) -> ::http::request::Builder {
        if let Some(inner_29) = &self.foo {
            let formatted_30 = ::smithy_http::query::fmt_string(&inner_29);
            if !formatted_30.is_empty() {
                builder = builder.header("X-Foo", ::smithy_http::query::fmt_string(&inner_29));
            }
        }
        builder
    }
    fn update_http_builder(&self, builder: ::http::request::Builder) -> ::http::request::Builder {
        let mut uri = String::new();
        self.uri_base(&mut uri);
        let builder = self.add_headers(builder);
        builder.method("POST").uri(uri)
    }
    pub fn request_builder_base(&self) -> ::http::request::Builder {
        let builder = ::http::request::Builder::new();
        let builder = builder.header("Content-Type", "application/octet-stream");
        self.update_http_builder(builder)
    }
    pub fn build_body(&self) -> Vec<u8> {
        todo!()
    }
    pub fn assemble(
        builder: ::http::request::Builder,
        body: Vec<u8>,
    ) -> ::http::request::Request<Vec<u8>> {
        builder
            .header(::http::header::CONTENT_LENGTH, body.len())
            .body(body)
            .expect("http request should be valid")
    }
}
#[cfg(test)]
#[allow(unreachable_code, unused_variables)]
mod http_payload_traits_request_test {

    use crate::operation::HttpPayloadTraitsInput;
    /// Serializes a blob in the HTTP payload
    /// Test ID: RestJsonHttpPayloadTraitsWithBlob
    #[test]
    fn test_rest_json_http_payload_traits_with_blob_request() {
        let input = HttpPayloadTraitsInput::builder()
            .foo("Foo".to_string())
            .blob(::smithy_types::Blob::new("blobby blob blob"))
            .build();
        let http_request = HttpPayloadTraitsInput::assemble(input.request_builder_base(), vec![]);

        assert_eq!(http_request.method(), "POST");
        assert_eq!(http_request.uri().path(), "/HttpPayloadTraits");

        let expected_headers = &[("X-Foo", "Foo")];
        ::protocol_test_helpers::assert_ok(::protocol_test_helpers::validate_headers(
            &http_request,
            expected_headers,
        ));
        let required_headers = &["Content-Length"];
        ::protocol_test_helpers::assert_ok(::protocol_test_helpers::require_headers(
            &http_request,
            required_headers,
        ));
    }
    /// Serializes an empty blob in the HTTP payload
    /// Test ID: RestJsonHttpPayloadTraitsWithNoBlobBody
    #[test]
    fn test_rest_json_http_payload_traits_with_no_blob_body_request() {
        let input = HttpPayloadTraitsInput::builder()
            .foo("Foo".to_string())
            .build();
        let http_request = HttpPayloadTraitsInput::assemble(input.request_builder_base(), vec![]);

        assert_eq!(http_request.method(), "POST");
        assert_eq!(http_request.uri().path(), "/HttpPayloadTraits");

        let expected_headers = &[("X-Foo", "Foo")];
        ::protocol_test_helpers::assert_ok(::protocol_test_helpers::validate_headers(
            &http_request,
            expected_headers,
        ));
    }
    /// Serializes a blob in the HTTP payload
    /// Test ID: RestJsonHttpPayloadTraitsWithBlob
    #[test]
    fn test_rest_json_http_payload_traits_with_blob_response() {
        /* test case disabled for this protocol (not yet supported) */
    }
    /// Serializes an empty blob in the HTTP payload
    /// Test ID: RestJsonHttpPayloadTraitsWithNoBlobBody
    #[test]
    fn test_rest_json_http_payload_traits_with_no_blob_body_response() {
        /* test case disabled for this protocol (not yet supported) */
    }
}

impl HttpPayloadTraitsWithMediaTypeInput {
    fn uri_base(&self, output: &mut String) {
        write!(output, "/HttpPayloadTraitsWithMediaType").expect("formatting should succeed")
    }
    fn add_headers(&self, mut builder: ::http::request::Builder) -> ::http::request::Builder {
        if let Some(inner_31) = &self.foo {
            let formatted_32 = ::smithy_http::query::fmt_string(&inner_31);
            if !formatted_32.is_empty() {
                builder = builder.header("X-Foo", ::smithy_http::query::fmt_string(&inner_31));
            }
        }
        builder
    }
    fn update_http_builder(&self, builder: ::http::request::Builder) -> ::http::request::Builder {
        let mut uri = String::new();
        self.uri_base(&mut uri);
        let builder = self.add_headers(builder);
        builder.method("POST").uri(uri)
    }
    pub fn request_builder_base(&self) -> ::http::request::Builder {
        let builder = ::http::request::Builder::new();
        let builder = builder.header("Content-Type", "text/plain");
        self.update_http_builder(builder)
    }
    pub fn build_body(&self) -> Vec<u8> {
        todo!()
    }
    pub fn assemble(
        builder: ::http::request::Builder,
        body: Vec<u8>,
    ) -> ::http::request::Request<Vec<u8>> {
        builder
            .header(::http::header::CONTENT_LENGTH, body.len())
            .body(body)
            .expect("http request should be valid")
    }
}
#[cfg(test)]
#[allow(unreachable_code, unused_variables)]
mod http_payload_traits_with_media_type_request_test {

    use crate::operation::HttpPayloadTraitsWithMediaTypeInput;
    /// Serializes a blob in the HTTP payload with a content-type
    /// Test ID: RestJsonHttpPayloadTraitsWithMediaTypeWithBlob
    #[test]
    fn test_rest_json_http_payload_traits_with_media_type_with_blob_request() {
        let input = HttpPayloadTraitsWithMediaTypeInput::builder()
            .foo("Foo".to_string())
            .blob(::smithy_types::Blob::new("blobby blob blob"))
            .build();
        let http_request =
            HttpPayloadTraitsWithMediaTypeInput::assemble(input.request_builder_base(), vec![]);

        assert_eq!(http_request.method(), "POST");
        assert_eq!(http_request.uri().path(), "/HttpPayloadTraitsWithMediaType");

        let expected_headers = &[("Content-Type", "text/plain"), ("X-Foo", "Foo")];
        ::protocol_test_helpers::assert_ok(::protocol_test_helpers::validate_headers(
            &http_request,
            expected_headers,
        ));
        let required_headers = &["Content-Length"];
        ::protocol_test_helpers::assert_ok(::protocol_test_helpers::require_headers(
            &http_request,
            required_headers,
        ));
    }
    /// Serializes a blob in the HTTP payload with a content-type
    /// Test ID: RestJsonHttpPayloadTraitsWithMediaTypeWithBlob
    #[test]
    fn test_rest_json_http_payload_traits_with_media_type_with_blob_response() {
        /* test case disabled for this protocol (not yet supported) */
    }
}

impl HttpPayloadWithStructureInput {
    fn uri_base(&self, output: &mut String) {
        write!(output, "/HttpPayloadWithStructure").expect("formatting should succeed")
    }
    fn update_http_builder(&self, builder: ::http::request::Builder) -> ::http::request::Builder {
        let mut uri = String::new();
        self.uri_base(&mut uri);
        builder.method("PUT").uri(uri)
    }
    pub fn request_builder_base(&self) -> ::http::request::Builder {
        let builder = ::http::request::Builder::new();
        let builder = builder.header("Content-Type", "application/json");
        self.update_http_builder(builder)
    }
    pub fn build_body(&self) -> Vec<u8> {
        todo!()
    }
    pub fn assemble(
        builder: ::http::request::Builder,
        body: Vec<u8>,
    ) -> ::http::request::Request<Vec<u8>> {
        builder
            .header(::http::header::CONTENT_LENGTH, body.len())
            .body(body)
            .expect("http request should be valid")
    }
}
#[cfg(test)]
#[allow(unreachable_code, unused_variables)]
mod http_payload_with_structure_request_test {

    use crate::model::NestedPayload;
    use crate::operation::HttpPayloadWithStructureInput;
    /// Serializes a structure in the payload
    /// Test ID: RestJsonHttpPayloadWithStructure
    #[test]
    fn test_rest_json_http_payload_with_structure_request() {
        let input = HttpPayloadWithStructureInput::builder()
            .nested(
                NestedPayload::builder()
                    .greeting("hello".to_string())
                    .name("Phreddy".to_string())
                    .build(),
            )
            .build();
        let http_request =
            HttpPayloadWithStructureInput::assemble(input.request_builder_base(), vec![]);

        assert_eq!(http_request.method(), "PUT");
        assert_eq!(http_request.uri().path(), "/HttpPayloadWithStructure");

        let expected_headers = &[("Content-Type", "application/json")];
        ::protocol_test_helpers::assert_ok(::protocol_test_helpers::validate_headers(
            &http_request,
            expected_headers,
        ));
        let required_headers = &["Content-Length"];
        ::protocol_test_helpers::assert_ok(::protocol_test_helpers::require_headers(
            &http_request,
            required_headers,
        ));
    }
    /// Serializes a structure in the payload
    /// Test ID: RestJsonHttpPayloadWithStructure
    #[test]
    fn test_rest_json_http_payload_with_structure_response() {
        /* test case disabled for this protocol (not yet supported) */
    }
}

impl HttpPrefixHeadersInput {
    fn uri_base(&self, output: &mut String) {
        write!(output, "/HttpPrefixHeaders").expect("formatting should succeed")
    }
    fn add_headers(&self, mut builder: ::http::request::Builder) -> ::http::request::Builder {
        if let Some(inner_33) = &self.foo {
            let formatted_34 = ::smithy_http::query::fmt_string(&inner_33);
            if !formatted_34.is_empty() {
                builder = builder.header("X-Foo", ::smithy_http::query::fmt_string(&inner_33));
            }
        }
        builder
    }
    fn update_http_builder(&self, builder: ::http::request::Builder) -> ::http::request::Builder {
        let mut uri = String::new();
        self.uri_base(&mut uri);
        let builder = self.add_headers(builder);
        builder.method("GET").uri(uri)
    }
    pub fn request_builder_base(&self) -> ::http::request::Builder {
        let builder = ::http::request::Builder::new();
        let builder = builder.header("Content-Type", "application/json");
        self.update_http_builder(builder)
    }
    pub fn build_body(&self) -> Vec<u8> {
        todo!()
    }
    pub fn assemble(
        builder: ::http::request::Builder,
        body: Vec<u8>,
    ) -> ::http::request::Request<Vec<u8>> {
        builder
            .header(::http::header::CONTENT_LENGTH, body.len())
            .body(body)
            .expect("http request should be valid")
    }
}
#[cfg(test)]
#[allow(unreachable_code, unused_variables)]
mod http_prefix_headers_request_test {

    use crate::operation::HttpPrefixHeadersInput;
    /// Adds headers by prefix
    /// Test ID: RestJsonHttpPrefixHeadersArePresent
    #[test]
    #[should_panic]
    fn test_rest_json_http_prefix_headers_are_present_request() {
        let input = HttpPrefixHeadersInput::builder()
            .foo("Foo".to_string())
            .foo_map({
                let mut ret = ::std::collections::HashMap::new();
                ret.insert("Abc".to_string(), "Abc value".to_string());
                ret.insert("Def".to_string(), "Def value".to_string());
                ret
            })
            .build();
        let http_request = HttpPrefixHeadersInput::assemble(input.request_builder_base(), vec![]);

        assert_eq!(http_request.method(), "GET");
        assert_eq!(http_request.uri().path(), "/HttpPrefixHeaders");

        let expected_headers = &[
            ("X-Foo", "Foo"),
            ("X-Foo-Abc", "Abc value"),
            ("X-Foo-Def", "Def value"),
        ];
        ::protocol_test_helpers::assert_ok(::protocol_test_helpers::validate_headers(
            &http_request,
            expected_headers,
        ));
    }
    /// No prefix headers are serialized because the value is empty
    /// Test ID: RestJsonHttpPrefixHeadersAreNotPresent
    #[test]
    fn test_rest_json_http_prefix_headers_are_not_present_request() {
        let input = HttpPrefixHeadersInput::builder()
            .foo("Foo".to_string())
            .foo_map(::std::collections::HashMap::new())
            .build();
        let http_request = HttpPrefixHeadersInput::assemble(input.request_builder_base(), vec![]);

        assert_eq!(http_request.method(), "GET");
        assert_eq!(http_request.uri().path(), "/HttpPrefixHeaders");

        let expected_headers = &[("X-Foo", "Foo")];
        ::protocol_test_helpers::assert_ok(::protocol_test_helpers::validate_headers(
            &http_request,
            expected_headers,
        ));
    }
    /// Adds headers by prefix
    /// Test ID: RestJsonHttpPrefixHeadersArePresent
    #[test]
    #[should_panic]
    fn test_rest_json_http_prefix_headers_are_present_response() {
        /* test case disabled for this protocol (not yet supported) */
        todo!()
    }
}

impl HttpPrefixHeadersResponseInput {
    fn uri_base(&self, output: &mut String) {
        write!(output, "/HttpPrefixHeadersResponse").expect("formatting should succeed")
    }
    fn update_http_builder(&self, builder: ::http::request::Builder) -> ::http::request::Builder {
        let mut uri = String::new();
        self.uri_base(&mut uri);
        builder.method("GET").uri(uri)
    }
    pub fn request_builder_base(&self) -> ::http::request::Builder {
        let builder = ::http::request::Builder::new();
        let builder = builder.header("Content-Type", "application/json");
        self.update_http_builder(builder)
    }
    pub fn build_body(&self) -> Vec<u8> {
        todo!()
    }
    pub fn assemble(
        builder: ::http::request::Builder,
        body: Vec<u8>,
    ) -> ::http::request::Request<Vec<u8>> {
        builder
            .header(::http::header::CONTENT_LENGTH, body.len())
            .body(body)
            .expect("http request should be valid")
    }
}
#[cfg(test)]
#[allow(unreachable_code, unused_variables)]
mod http_prefix_headers_response_request_test {

    /// (de)serializes all response headers
    /// Test ID: HttpPrefixHeadersResponse
    #[test]
    fn test_http_prefix_headers_response_response() {
        /* test case disabled for this protocol (not yet supported) */
    }
}

impl HttpRequestWithGreedyLabelInPathInput {
    fn uri_base(&self, output: &mut String) {
        write!(
            output,
            "/HttpRequestWithGreedyLabelInPath/foo/{foo}/baz/{baz}",
            foo = ::smithy_http::label::fmt_string(&self.foo, false),
            baz = ::smithy_http::label::fmt_string(&self.baz, true)
        )
        .expect("formatting should succeed")
    }
    fn update_http_builder(&self, builder: ::http::request::Builder) -> ::http::request::Builder {
        let mut uri = String::new();
        self.uri_base(&mut uri);
        builder.method("GET").uri(uri)
    }
    pub fn request_builder_base(&self) -> ::http::request::Builder {
        let builder = ::http::request::Builder::new();
        let builder = builder.header("Content-Type", "application/json");
        self.update_http_builder(builder)
    }
    pub fn build_body(&self) -> Vec<u8> {
        todo!()
    }
    pub fn assemble(
        builder: ::http::request::Builder,
        body: Vec<u8>,
    ) -> ::http::request::Request<Vec<u8>> {
        builder
            .header(::http::header::CONTENT_LENGTH, body.len())
            .body(body)
            .expect("http request should be valid")
    }
}
#[cfg(test)]
#[allow(unreachable_code, unused_variables)]
mod http_request_with_greedy_label_in_path_request_test {

    use crate::operation::HttpRequestWithGreedyLabelInPathInput;
    /// Serializes greedy labels and normal labels
    /// Test ID: RestJsonHttpRequestWithGreedyLabelInPath
    #[test]
    fn test_rest_json_http_request_with_greedy_label_in_path_request() {
        let input = HttpRequestWithGreedyLabelInPathInput::builder()
            .foo("hello".to_string())
            .baz("there/guy".to_string())
            .build();
        let http_request =
            HttpRequestWithGreedyLabelInPathInput::assemble(input.request_builder_base(), vec![]);

        assert_eq!(http_request.method(), "GET");
        assert_eq!(
            http_request.uri().path(),
            "/HttpRequestWithGreedyLabelInPath/foo/hello/baz/there/guy"
        );
    }
}

impl HttpRequestWithLabelsInput {
    fn uri_base(&self, output: &mut String) {
        write!(output, "/HttpRequestWithLabels/{string}/{short}/{integer}/{long}/{float}/{double}/{boolean}/{timestamp}", string = ::smithy_http::label::fmt_string(&self.string, false), short = ::smithy_http::label::fmt_default(&self.short), integer = ::smithy_http::label::fmt_default(&self.integer), long = ::smithy_http::label::fmt_default(&self.long), float = ::smithy_http::label::fmt_default(&self.float), double = ::smithy_http::label::fmt_default(&self.double), boolean = ::smithy_http::label::fmt_default(&self.boolean), timestamp = ::smithy_http::label::fmt_timestamp(&self.timestamp, ::smithy_types::instant::Format::DateTime)).expect("formatting should succeed")
    }
    fn update_http_builder(&self, builder: ::http::request::Builder) -> ::http::request::Builder {
        let mut uri = String::new();
        self.uri_base(&mut uri);
        builder.method("GET").uri(uri)
    }
    pub fn request_builder_base(&self) -> ::http::request::Builder {
        let builder = ::http::request::Builder::new();
        let builder = builder.header("Content-Type", "application/json");
        self.update_http_builder(builder)
    }
    pub fn build_body(&self) -> Vec<u8> {
        todo!()
    }
    pub fn assemble(
        builder: ::http::request::Builder,
        body: Vec<u8>,
    ) -> ::http::request::Request<Vec<u8>> {
        builder
            .header(::http::header::CONTENT_LENGTH, body.len())
            .body(body)
            .expect("http request should be valid")
    }
}
#[cfg(test)]
#[allow(unreachable_code, unused_variables)]
mod http_request_with_labels_request_test {

    use crate::operation::HttpRequestWithLabelsInput;
    /// Sends a GET request that uses URI label bindings
    /// Test ID: RestJsonInputWithHeadersAndAllParams
    #[test]
    fn test_rest_json_input_with_headers_and_all_params_request() {
        let input = HttpRequestWithLabelsInput::builder()
            .string("string".to_string())
            .short(1)
            .integer(2)
            .long(3)
            .float(4.1)
            .double(5.1)
            .boolean(true)
            .timestamp(::smithy_types::Instant::from_epoch_seconds(1576540098))
            .build()
            .unwrap();
        let http_request =
            HttpRequestWithLabelsInput::assemble(input.request_builder_base(), vec![]);

        assert_eq!(http_request.method(), "GET");
        assert_eq!(
            http_request.uri().path(),
            "/HttpRequestWithLabels/string/1/2/3/4.1/5.1/true/2019-12-16T23%3A48%3A18Z"
        );
    }
}

impl HttpRequestWithLabelsAndTimestampFormatInput {
    fn uri_base(&self, output: &mut String) {
        write!(output, "/HttpRequestWithLabelsAndTimestampFormat/{memberEpochSeconds}/{memberHttpDate}/{memberDateTime}/{defaultFormat}/{targetEpochSeconds}/{targetHttpDate}/{targetDateTime}", memberEpochSeconds = ::smithy_http::label::fmt_timestamp(&self.member_epoch_seconds, ::smithy_types::instant::Format::EpochSeconds), memberHttpDate = ::smithy_http::label::fmt_timestamp(&self.member_http_date, ::smithy_types::instant::Format::HttpDate), memberDateTime = ::smithy_http::label::fmt_timestamp(&self.member_date_time, ::smithy_types::instant::Format::DateTime), defaultFormat = ::smithy_http::label::fmt_timestamp(&self.default_format, ::smithy_types::instant::Format::DateTime), targetEpochSeconds = ::smithy_http::label::fmt_timestamp(&self.target_epoch_seconds, ::smithy_types::instant::Format::EpochSeconds), targetHttpDate = ::smithy_http::label::fmt_timestamp(&self.target_http_date, ::smithy_types::instant::Format::HttpDate), targetDateTime = ::smithy_http::label::fmt_timestamp(&self.target_date_time, ::smithy_types::instant::Format::DateTime)).expect("formatting should succeed")
    }
    fn update_http_builder(&self, builder: ::http::request::Builder) -> ::http::request::Builder {
        let mut uri = String::new();
        self.uri_base(&mut uri);
        builder.method("GET").uri(uri)
    }
    pub fn request_builder_base(&self) -> ::http::request::Builder {
        let builder = ::http::request::Builder::new();
        let builder = builder.header("Content-Type", "application/json");
        self.update_http_builder(builder)
    }
    pub fn build_body(&self) -> Vec<u8> {
        todo!()
    }
    pub fn assemble(
        builder: ::http::request::Builder,
        body: Vec<u8>,
    ) -> ::http::request::Request<Vec<u8>> {
        builder
            .header(::http::header::CONTENT_LENGTH, body.len())
            .body(body)
            .expect("http request should be valid")
    }
}
#[cfg(test)]
#[allow(unreachable_code, unused_variables)]
mod http_request_with_labels_and_timestamp_format_request_test {

    use crate::operation::HttpRequestWithLabelsAndTimestampFormatInput;
    /// Serializes different timestamp formats in URI labels
    /// Test ID: RestJsonHttpRequestWithLabelsAndTimestampFormat
    #[test]
    fn test_rest_json_http_request_with_labels_and_timestamp_format_request() {
        let input = HttpRequestWithLabelsAndTimestampFormatInput::builder()
            .member_epoch_seconds(::smithy_types::Instant::from_epoch_seconds(1576540098))
            .member_http_date(::smithy_types::Instant::from_epoch_seconds(1576540098))
            .member_date_time(::smithy_types::Instant::from_epoch_seconds(1576540098))
            .default_format(::smithy_types::Instant::from_epoch_seconds(1576540098))
            .target_epoch_seconds(::smithy_types::Instant::from_epoch_seconds(1576540098))
            .target_http_date(::smithy_types::Instant::from_epoch_seconds(1576540098))
            .target_date_time(::smithy_types::Instant::from_epoch_seconds(1576540098))
            .build()
            .unwrap();
        let http_request = HttpRequestWithLabelsAndTimestampFormatInput::assemble(
            input.request_builder_base(),
            vec![],
        );

        assert_eq!(http_request.method(), "GET");
        assert_eq!(http_request.uri().path(), "/HttpRequestWithLabelsAndTimestampFormat/1576540098/Mon%2C%2016%20Dec%202019%2023%3A48%3A18%20GMT/2019-12-16T23%3A48%3A18Z/2019-12-16T23%3A48%3A18Z/1576540098/Mon%2C%2016%20Dec%202019%2023%3A48%3A18%20GMT/2019-12-16T23%3A48%3A18Z");
    }
}

impl HttpResponseCodeInput {
    fn uri_base(&self, output: &mut String) {
        write!(output, "/HttpResponseCode").expect("formatting should succeed")
    }
    fn update_http_builder(&self, builder: ::http::request::Builder) -> ::http::request::Builder {
        let mut uri = String::new();
        self.uri_base(&mut uri);
        builder.method("PUT").uri(uri)
    }
    pub fn request_builder_base(&self) -> ::http::request::Builder {
        let builder = ::http::request::Builder::new();
        let builder = builder.header("Content-Type", "application/json");
        self.update_http_builder(builder)
    }
    pub fn build_body(&self) -> Vec<u8> {
        todo!()
    }
    pub fn assemble(
        builder: ::http::request::Builder,
        body: Vec<u8>,
    ) -> ::http::request::Request<Vec<u8>> {
        builder
            .header(::http::header::CONTENT_LENGTH, body.len())
            .body(body)
            .expect("http request should be valid")
    }
}
#[cfg(test)]
#[allow(unreachable_code, unused_variables)]
mod http_response_code_request_test {

    /// Binds the http response code to an output structure.
    /// Test ID: RestJsonHttpResponseCode
    #[test]
    fn test_rest_json_http_response_code_response() {
        /* test case disabled for this protocol (not yet supported) */
    }
}

impl IgnoreQueryParamsInResponseInput {
    fn uri_base(&self, output: &mut String) {
        write!(output, "/IgnoreQueryParamsInResponse").expect("formatting should succeed")
    }
    fn update_http_builder(&self, builder: ::http::request::Builder) -> ::http::request::Builder {
        let mut uri = String::new();
        self.uri_base(&mut uri);
        builder.method("GET").uri(uri)
    }
    pub fn request_builder_base(&self) -> ::http::request::Builder {
        let builder = ::http::request::Builder::new();
        let builder = builder.header("Content-Type", "application/json");
        self.update_http_builder(builder)
    }
    pub fn build_body(&self) -> Vec<u8> {
        todo!()
    }
    pub fn assemble(
        builder: ::http::request::Builder,
        body: Vec<u8>,
    ) -> ::http::request::Request<Vec<u8>> {
        builder
            .header(::http::header::CONTENT_LENGTH, body.len())
            .body(body)
            .expect("http request should be valid")
    }
}
#[cfg(test)]
#[allow(unreachable_code, unused_variables)]
mod ignore_query_params_in_response_request_test {

    /// Query parameters must be ignored when serializing the output of an operation
    /// Test ID: RestJsonIgnoreQueryParamsInResponse
    #[test]
    fn test_rest_json_ignore_query_params_in_response_response() {
        /* test case disabled for this protocol (not yet supported) */
    }
}

impl InlineDocumentInput {
    fn uri_base(&self, output: &mut String) {
        write!(output, "/InlineDocument").expect("formatting should succeed")
    }
    fn update_http_builder(&self, builder: ::http::request::Builder) -> ::http::request::Builder {
        let mut uri = String::new();
        self.uri_base(&mut uri);
        builder.method("PUT").uri(uri)
    }
    pub fn request_builder_base(&self) -> ::http::request::Builder {
        let builder = ::http::request::Builder::new();
        let builder = builder.header("Content-Type", "application/json");
        self.update_http_builder(builder)
    }
    pub fn build_body(&self) -> Vec<u8> {
        todo!()
    }
    pub fn assemble(
        builder: ::http::request::Builder,
        body: Vec<u8>,
    ) -> ::http::request::Request<Vec<u8>> {
        builder
            .header(::http::header::CONTENT_LENGTH, body.len())
            .body(body)
            .expect("http request should be valid")
    }
}
#[cfg(test)]
#[allow(unreachable_code, unused_variables)]
mod inline_document_request_test {

    use crate::operation::InlineDocumentInput;
    /// Serializes inline documents as part of the JSON request payload with no escaping.
    /// Test ID: InlineDocumentInput
    #[test]
    #[should_panic]
    fn test_inline_document_input_request() {
        let input =InlineDocumentInput::builder()
        .string_value(
            "string".to_string()
        )
        .document_value(
            todo!() /* (document: `aws.protocoltests.restjson#Document`) software.amazon.smithy.model.node.ObjectNode@2cd3bb4e */
        )
        .build()
        .unwrap()
        ;
        let http_request = InlineDocumentInput::assemble(input.request_builder_base(), vec![]);

        assert_eq!(http_request.method(), "PUT");
        assert_eq!(http_request.uri().path(), "/InlineDocument");

        let expected_headers = &[("Content-Type", "application/json")];
        ::protocol_test_helpers::assert_ok(::protocol_test_helpers::validate_headers(
            &http_request,
            expected_headers,
        ));
    }
    /// Serializes inline documents as part of the JSON response payload with no escaping.
    /// Test ID: InlineDocumentOutput
    #[test]
    fn test_inline_document_output_response() {
        /* test case disabled for this protocol (not yet supported) */
    }
}

impl InlineDocumentAsPayloadInput {
    fn uri_base(&self, output: &mut String) {
        write!(output, "/InlineDocumentAsPayload").expect("formatting should succeed")
    }
    fn update_http_builder(&self, builder: ::http::request::Builder) -> ::http::request::Builder {
        let mut uri = String::new();
        self.uri_base(&mut uri);
        builder.method("PUT").uri(uri)
    }
    pub fn request_builder_base(&self) -> ::http::request::Builder {
        let builder = ::http::request::Builder::new();
        let builder = builder.header("Content-Type", "application/json");
        self.update_http_builder(builder)
    }
    pub fn build_body(&self) -> Vec<u8> {
        todo!()
    }
    pub fn assemble(
        builder: ::http::request::Builder,
        body: Vec<u8>,
    ) -> ::http::request::Request<Vec<u8>> {
        builder
            .header(::http::header::CONTENT_LENGTH, body.len())
            .body(body)
            .expect("http request should be valid")
    }
}
#[cfg(test)]
#[allow(unreachable_code, unused_variables)]
mod inline_document_as_payload_request_test {

    use crate::operation::InlineDocumentAsPayloadInput;
    /// Serializes an inline document as the target of the httpPayload trait.
    /// Test ID: InlineDocumentAsPayloadInput
    #[test]
    #[should_panic]
    fn test_inline_document_as_payload_input_request() {
        let input =InlineDocumentAsPayloadInput::builder()
        .document_value(
            todo!() /* (document: `aws.protocoltests.restjson#Document`) software.amazon.smithy.model.node.ObjectNode@2cd3bb4e */
        )
        .build()
        .unwrap()
        ;
        let http_request =
            InlineDocumentAsPayloadInput::assemble(input.request_builder_base(), vec![]);

        assert_eq!(http_request.method(), "PUT");
        assert_eq!(http_request.uri().path(), "/InlineDocumentAsPayload");

        let expected_headers = &[("Content-Type", "application/json")];
        ::protocol_test_helpers::assert_ok(::protocol_test_helpers::validate_headers(
            &http_request,
            expected_headers,
        ));
    }
    /// Serializes an inline document as the target of the httpPayload trait.
    /// Test ID: InlineDocumentAsPayloadInputOutput
    #[test]
    fn test_inline_document_as_payload_input_output_response() {
        /* test case disabled for this protocol (not yet supported) */
    }
}

impl InputAndOutputWithHeadersInput {
    fn uri_base(&self, output: &mut String) {
        write!(output, "/InputAndOutputWithHeaders").expect("formatting should succeed")
    }
    fn add_headers(&self, mut builder: ::http::request::Builder) -> ::http::request::Builder {
        if let Some(inner_35) = &self.header_string {
            let formatted_36 = ::smithy_http::query::fmt_string(&inner_35);
            if !formatted_36.is_empty() {
                builder = builder.header("X-String", ::smithy_http::query::fmt_string(&inner_35));
            }
        }
        if let Some(inner_37) = &self.header_byte {
            let formatted_38 = ::smithy_http::query::fmt_default(&inner_37);
            if !formatted_38.is_empty() {
                builder = builder.header("X-Byte", ::smithy_http::query::fmt_default(&inner_37));
            }
        }
        if let Some(inner_39) = &self.header_short {
            let formatted_40 = ::smithy_http::query::fmt_default(&inner_39);
            if !formatted_40.is_empty() {
                builder = builder.header("X-Short", ::smithy_http::query::fmt_default(&inner_39));
            }
        }
        if let Some(inner_41) = &self.header_integer {
            let formatted_42 = ::smithy_http::query::fmt_default(&inner_41);
            if !formatted_42.is_empty() {
                builder = builder.header("X-Integer", ::smithy_http::query::fmt_default(&inner_41));
            }
        }
        if let Some(inner_43) = &self.header_long {
            let formatted_44 = ::smithy_http::query::fmt_default(&inner_43);
            if !formatted_44.is_empty() {
                builder = builder.header("X-Long", ::smithy_http::query::fmt_default(&inner_43));
            }
        }
        if let Some(inner_45) = &self.header_float {
            let formatted_46 = ::smithy_http::query::fmt_default(&inner_45);
            if !formatted_46.is_empty() {
                builder = builder.header("X-Float", ::smithy_http::query::fmt_default(&inner_45));
            }
        }
        if let Some(inner_47) = &self.header_double {
            let formatted_48 = ::smithy_http::query::fmt_default(&inner_47);
            if !formatted_48.is_empty() {
                builder = builder.header("X-Double", ::smithy_http::query::fmt_default(&inner_47));
            }
        }
        if let Some(inner_49) = &self.header_true_bool {
            let formatted_50 = ::smithy_http::query::fmt_default(&inner_49);
            if !formatted_50.is_empty() {
                builder =
                    builder.header("X-Boolean1", ::smithy_http::query::fmt_default(&inner_49));
            }
        }
        if let Some(inner_51) = &self.header_false_bool {
            let formatted_52 = ::smithy_http::query::fmt_default(&inner_51);
            if !formatted_52.is_empty() {
                builder =
                    builder.header("X-Boolean2", ::smithy_http::query::fmt_default(&inner_51));
            }
        }
        if let Some(inner_53) = &self.header_string_list {
            for inner_54 in inner_53 {
                let formatted_55 = ::smithy_http::query::fmt_string(&inner_54);
                if !formatted_55.is_empty() {
                    builder =
                        builder.header("X-StringList", ::smithy_http::query::fmt_string(&inner_54));
                }
            }
        }
        if let Some(inner_56) = &self.header_string_set {
            for inner_57 in inner_56 {
                let formatted_58 = ::smithy_http::query::fmt_string(&inner_57);
                if !formatted_58.is_empty() {
                    builder =
                        builder.header("X-StringSet", ::smithy_http::query::fmt_string(&inner_57));
                }
            }
        }
        if let Some(inner_59) = &self.header_integer_list {
            for inner_60 in inner_59 {
                let formatted_61 = ::smithy_http::query::fmt_default(&inner_60);
                if !formatted_61.is_empty() {
                    builder = builder.header(
                        "X-IntegerList",
                        ::smithy_http::query::fmt_default(&inner_60),
                    );
                }
            }
        }
        if let Some(inner_62) = &self.header_boolean_list {
            for inner_63 in inner_62 {
                let formatted_64 = ::smithy_http::query::fmt_default(&inner_63);
                if !formatted_64.is_empty() {
                    builder = builder.header(
                        "X-BooleanList",
                        ::smithy_http::query::fmt_default(&inner_63),
                    );
                }
            }
        }
        if let Some(inner_65) = &self.header_timestamp_list {
            for inner_66 in inner_65 {
                let formatted_67 = inner_66.fmt(::smithy_types::instant::Format::HttpDate);
                if !formatted_67.is_empty() {
                    builder = builder.header(
                        "X-TimestampList",
                        inner_66.fmt(::smithy_types::instant::Format::HttpDate),
                    );
                }
            }
        }
        if let Some(inner_68) = &self.header_enum {
            let formatted_69 = ::smithy_http::query::fmt_string(&inner_68.as_str());
            if !formatted_69.is_empty() {
                builder = builder.header(
                    "X-Enum",
                    ::smithy_http::query::fmt_string(&inner_68.as_str()),
                );
            }
        }
        if let Some(inner_70) = &self.header_enum_list {
            for inner_71 in inner_70 {
                let formatted_72 = ::smithy_http::query::fmt_string(&inner_71.as_str());
                if !formatted_72.is_empty() {
                    builder = builder.header(
                        "X-EnumList",
                        ::smithy_http::query::fmt_string(&inner_71.as_str()),
                    );
                }
            }
        }
        builder
    }
    fn update_http_builder(&self, builder: ::http::request::Builder) -> ::http::request::Builder {
        let mut uri = String::new();
        self.uri_base(&mut uri);
        let builder = self.add_headers(builder);
        builder.method("POST").uri(uri)
    }
    pub fn request_builder_base(&self) -> ::http::request::Builder {
        let builder = ::http::request::Builder::new();
        let builder = builder.header("Content-Type", "application/json");
        self.update_http_builder(builder)
    }
    pub fn build_body(&self) -> Vec<u8> {
        todo!()
    }
    pub fn assemble(
        builder: ::http::request::Builder,
        body: Vec<u8>,
    ) -> ::http::request::Request<Vec<u8>> {
        builder
            .header(::http::header::CONTENT_LENGTH, body.len())
            .body(body)
            .expect("http request should be valid")
    }
}
#[cfg(test)]
#[allow(unreachable_code, unused_variables)]
mod input_and_output_with_headers_request_test {

    use crate::model::FooEnum;
    use crate::operation::InputAndOutputWithHeadersInput;
    /// Tests requests with string header bindings
    /// Test ID: RestJsonInputAndOutputWithStringHeaders
    #[test]
    fn test_rest_json_input_and_output_with_string_headers_request() {
        let input = InputAndOutputWithHeadersInput::builder()
            .header_string("Hello".to_string())
            .header_string_list(vec!["a".to_string(), "b".to_string(), "c".to_string()])
            .header_string_set({
                let mut ret = ::std::collections::BTreeSet::new();
                ret.insert("a".to_string());
                ret.insert("b".to_string());
                ret.insert("c".to_string());
                ret
            })
            .build();
        let http_request =
            InputAndOutputWithHeadersInput::assemble(input.request_builder_base(), vec![]);

        assert_eq!(http_request.method(), "POST");
        assert_eq!(http_request.uri().path(), "/InputAndOutputWithHeaders");

        let expected_headers = &[
            ("X-String", "Hello"),
            ("X-StringList", "a, b, c"),
            ("X-StringSet", "a, b, c"),
        ];
        ::protocol_test_helpers::assert_ok(::protocol_test_helpers::validate_headers(
            &http_request,
            expected_headers,
        ));
    }
    /// Tests requests with numeric header bindings
    /// Test ID: RestJsonInputAndOutputWithNumericHeaders
    #[test]
    fn test_rest_json_input_and_output_with_numeric_headers_request() {
        let input = InputAndOutputWithHeadersInput::builder()
            .header_byte(1)
            .header_short(123)
            .header_integer(123)
            .header_long(123)
            .header_float(1.1)
            .header_double(1.1)
            .header_integer_list(vec![1, 2, 3])
            .build();
        let http_request =
            InputAndOutputWithHeadersInput::assemble(input.request_builder_base(), vec![]);

        assert_eq!(http_request.method(), "POST");
        assert_eq!(http_request.uri().path(), "/InputAndOutputWithHeaders");

        let expected_headers = &[
            ("X-Byte", "1"),
            ("X-Double", "1.1"),
            ("X-Float", "1.1"),
            ("X-Integer", "123"),
            ("X-IntegerList", "1, 2, 3"),
            ("X-Long", "123"),
            ("X-Short", "123"),
        ];
        ::protocol_test_helpers::assert_ok(::protocol_test_helpers::validate_headers(
            &http_request,
            expected_headers,
        ));
    }
    /// Tests requests with boolean header bindings
    /// Test ID: RestJsonInputAndOutputWithBooleanHeaders
    #[test]
    fn test_rest_json_input_and_output_with_boolean_headers_request() {
        let input = InputAndOutputWithHeadersInput::builder()
            .header_true_bool(true)
            .header_false_bool(false)
            .header_boolean_list(vec![true, false, true])
            .build();
        let http_request =
            InputAndOutputWithHeadersInput::assemble(input.request_builder_base(), vec![]);

        assert_eq!(http_request.method(), "POST");
        assert_eq!(http_request.uri().path(), "/InputAndOutputWithHeaders");

        let expected_headers = &[
            ("X-Boolean1", "true"),
            ("X-Boolean2", "false"),
            ("X-BooleanList", "true, false, true"),
        ];
        ::protocol_test_helpers::assert_ok(::protocol_test_helpers::validate_headers(
            &http_request,
            expected_headers,
        ));
    }
    /// Tests requests with timestamp header bindings
    /// Test ID: RestJsonInputAndOutputWithTimestampHeaders
    #[test]
    fn test_rest_json_input_and_output_with_timestamp_headers_request() {
        let input = InputAndOutputWithHeadersInput::builder()
            .header_timestamp_list(vec![
                ::smithy_types::Instant::from_epoch_seconds(1576540098),
                ::smithy_types::Instant::from_epoch_seconds(1576540098),
            ])
            .build();
        let http_request =
            InputAndOutputWithHeadersInput::assemble(input.request_builder_base(), vec![]);

        assert_eq!(http_request.method(), "POST");
        assert_eq!(http_request.uri().path(), "/InputAndOutputWithHeaders");

        let expected_headers = &[(
            "X-TimestampList",
            "Mon, 16 Dec 2019 23:48:18 GMT, Mon, 16 Dec 2019 23:48:18 GMT",
        )];
        ::protocol_test_helpers::assert_ok(::protocol_test_helpers::validate_headers(
            &http_request,
            expected_headers,
        ));
    }
    /// Tests requests with enum header bindings
    /// Test ID: RestJsonInputAndOutputWithEnumHeaders
    #[test]
    fn test_rest_json_input_and_output_with_enum_headers_request() {
        let input = InputAndOutputWithHeadersInput::builder()
            .header_enum(FooEnum::from("Foo"))
            .header_enum_list(vec![
                FooEnum::from("Foo"),
                FooEnum::from("Bar"),
                FooEnum::from("Baz"),
            ])
            .build();
        let http_request =
            InputAndOutputWithHeadersInput::assemble(input.request_builder_base(), vec![]);

        assert_eq!(http_request.method(), "POST");
        assert_eq!(http_request.uri().path(), "/InputAndOutputWithHeaders");

        let expected_headers = &[("X-Enum", "Foo"), ("X-EnumList", "Foo, Bar, Baz")];
        ::protocol_test_helpers::assert_ok(::protocol_test_helpers::validate_headers(
            &http_request,
            expected_headers,
        ));
    }
    /// Tests responses with string header bindings
    /// Test ID: RestJsonInputAndOutputWithStringHeaders
    #[test]
    fn test_rest_json_input_and_output_with_string_headers_response() {
        /* test case disabled for this protocol (not yet supported) */
    }
    /// Tests responses with numeric header bindings
    /// Test ID: RestJsonInputAndOutputWithNumericHeaders
    #[test]
    fn test_rest_json_input_and_output_with_numeric_headers_response() {
        /* test case disabled for this protocol (not yet supported) */
    }
    /// Tests responses with boolean header bindings
    /// Test ID: RestJsonInputAndOutputWithBooleanHeaders
    #[test]
    fn test_rest_json_input_and_output_with_boolean_headers_response() {
        /* test case disabled for this protocol (not yet supported) */
    }
    /// Tests responses with timestamp header bindings
    /// Test ID: RestJsonInputAndOutputWithTimestampHeaders
    #[test]
    fn test_rest_json_input_and_output_with_timestamp_headers_response() {
        /* test case disabled for this protocol (not yet supported) */
    }
    /// Tests responses with enum header bindings
    /// Test ID: RestJsonInputAndOutputWithEnumHeaders
    #[test]
    fn test_rest_json_input_and_output_with_enum_headers_response() {
        /* test case disabled for this protocol (not yet supported) */
    }
}

impl JsonBlobsInput {
    fn uri_base(&self, output: &mut String) {
        write!(output, "/JsonBlobs").expect("formatting should succeed")
    }
    fn update_http_builder(&self, builder: ::http::request::Builder) -> ::http::request::Builder {
        let mut uri = String::new();
        self.uri_base(&mut uri);
        builder.method("POST").uri(uri)
    }
    pub fn request_builder_base(&self) -> ::http::request::Builder {
        let builder = ::http::request::Builder::new();
        let builder = builder.header("Content-Type", "application/json");
        self.update_http_builder(builder)
    }
    pub fn build_body(&self) -> Vec<u8> {
        todo!()
    }
    pub fn assemble(
        builder: ::http::request::Builder,
        body: Vec<u8>,
    ) -> ::http::request::Request<Vec<u8>> {
        builder
            .header(::http::header::CONTENT_LENGTH, body.len())
            .body(body)
            .expect("http request should be valid")
    }
}
#[cfg(test)]
#[allow(unreachable_code, unused_variables)]
mod json_blobs_request_test {

    use crate::operation::JsonBlobsInput;
    /// Blobs are base64 encoded
    /// Test ID: RestJsonJsonBlobs
    #[test]
    fn test_rest_json_json_blobs_request() {
        let input = JsonBlobsInput::builder()
            .data(::smithy_types::Blob::new("value"))
            .build();
        let http_request = JsonBlobsInput::assemble(input.request_builder_base(), vec![]);

        assert_eq!(http_request.method(), "POST");
        assert_eq!(http_request.uri().path(), "/JsonBlobs");

        let expected_headers = &[("Content-Type", "application/json")];
        ::protocol_test_helpers::assert_ok(::protocol_test_helpers::validate_headers(
            &http_request,
            expected_headers,
        ));
    }
    /// Blobs are base64 encoded
    /// Test ID: RestJsonJsonBlobs
    #[test]
    fn test_rest_json_json_blobs_response() {
        /* test case disabled for this protocol (not yet supported) */
    }
}

impl JsonEnumsInput {
    fn uri_base(&self, output: &mut String) {
        write!(output, "/JsonEnums").expect("formatting should succeed")
    }
    fn update_http_builder(&self, builder: ::http::request::Builder) -> ::http::request::Builder {
        let mut uri = String::new();
        self.uri_base(&mut uri);
        builder.method("PUT").uri(uri)
    }
    pub fn request_builder_base(&self) -> ::http::request::Builder {
        let builder = ::http::request::Builder::new();
        let builder = builder.header("Content-Type", "application/json");
        self.update_http_builder(builder)
    }
    pub fn build_body(&self) -> Vec<u8> {
        todo!()
    }
    pub fn assemble(
        builder: ::http::request::Builder,
        body: Vec<u8>,
    ) -> ::http::request::Request<Vec<u8>> {
        builder
            .header(::http::header::CONTENT_LENGTH, body.len())
            .body(body)
            .expect("http request should be valid")
    }
}
#[cfg(test)]
#[allow(unreachable_code, unused_variables)]
mod json_enums_request_test {

    use crate::model::FooEnum;
    use crate::operation::JsonEnumsInput;
    /// Serializes simple scalar properties
    /// Test ID: RestJsonJsonEnums
    #[test]
    fn test_rest_json_json_enums_request() {
        let input = JsonEnumsInput::builder()
            .foo_enum1(FooEnum::from("Foo"))
            .foo_enum2(FooEnum::from("0"))
            .foo_enum3(FooEnum::from("1"))
            .foo_enum_list(vec![FooEnum::from("Foo"), FooEnum::from("0")])
            .foo_enum_set({
                let mut ret = ::std::collections::BTreeSet::new();
                ret.insert(FooEnum::from("Foo"));
                ret.insert(FooEnum::from("0"));
                ret
            })
            .foo_enum_map({
                let mut ret = ::std::collections::HashMap::new();
                ret.insert("hi".to_string(), FooEnum::from("Foo"));
                ret.insert("zero".to_string(), FooEnum::from("0"));
                ret
            })
            .build();
        let http_request = JsonEnumsInput::assemble(input.request_builder_base(), vec![]);

        assert_eq!(http_request.method(), "PUT");
        assert_eq!(http_request.uri().path(), "/JsonEnums");

        let expected_headers = &[("Content-Type", "application/json")];
        ::protocol_test_helpers::assert_ok(::protocol_test_helpers::validate_headers(
            &http_request,
            expected_headers,
        ));
    }
    /// Serializes simple scalar properties
    /// Test ID: RestJsonJsonEnums
    #[test]
    fn test_rest_json_json_enums_response() {
        /* test case disabled for this protocol (not yet supported) */
    }
}

impl JsonListsInput {
    fn uri_base(&self, output: &mut String) {
        write!(output, "/JsonLists").expect("formatting should succeed")
    }
    fn update_http_builder(&self, builder: ::http::request::Builder) -> ::http::request::Builder {
        let mut uri = String::new();
        self.uri_base(&mut uri);
        builder.method("PUT").uri(uri)
    }
    pub fn request_builder_base(&self) -> ::http::request::Builder {
        let builder = ::http::request::Builder::new();
        let builder = builder.header("Content-Type", "application/json");
        self.update_http_builder(builder)
    }
    pub fn build_body(&self) -> Vec<u8> {
        todo!()
    }
    pub fn assemble(
        builder: ::http::request::Builder,
        body: Vec<u8>,
    ) -> ::http::request::Request<Vec<u8>> {
        builder
            .header(::http::header::CONTENT_LENGTH, body.len())
            .body(body)
            .expect("http request should be valid")
    }
}
#[cfg(test)]
#[allow(unreachable_code, unused_variables)]
mod json_lists_request_test {

    use crate::model::FooEnum;
    use crate::model::StructureListMember;
    use crate::operation::JsonListsInput;
    /// Serializes JSON lists
    /// Test ID: RestJsonLists
    #[test]
    fn test_rest_json_lists_request() {
        let input = JsonListsInput::builder()
            .string_list(vec!["foo".to_string(), "bar".to_string()])
            .string_set({
                let mut ret = ::std::collections::BTreeSet::new();
                ret.insert("foo".to_string());
                ret.insert("bar".to_string());
                ret
            })
            .integer_list(vec![1, 2])
            .boolean_list(vec![true, false])
            .timestamp_list(vec![
                ::smithy_types::Instant::from_epoch_seconds(1398796238),
                ::smithy_types::Instant::from_epoch_seconds(1398796238),
            ])
            .enum_list(vec![FooEnum::from("Foo"), FooEnum::from("0")])
            .nested_string_list(vec![
                vec!["foo".to_string(), "bar".to_string()],
                vec!["baz".to_string(), "qux".to_string()],
            ])
            .structure_list(vec![
                StructureListMember::builder()
                    .a("1".to_string())
                    .b("2".to_string())
                    .build(),
                StructureListMember::builder()
                    .a("3".to_string())
                    .b("4".to_string())
                    .build(),
            ])
            .build();
        let http_request = JsonListsInput::assemble(input.request_builder_base(), vec![]);

        assert_eq!(http_request.method(), "PUT");
        assert_eq!(http_request.uri().path(), "/JsonLists");

        let expected_headers = &[("Content-Type", "application/json")];
        ::protocol_test_helpers::assert_ok(::protocol_test_helpers::validate_headers(
            &http_request,
            expected_headers,
        ));
    }
    /// Serializes empty JSON lists
    /// Test ID: RestJsonListsEmpty
    #[test]
    fn test_rest_json_lists_empty_request() {
        let input = JsonListsInput::builder().string_list(vec![]).build();
        let http_request = JsonListsInput::assemble(input.request_builder_base(), vec![]);

        assert_eq!(http_request.method(), "PUT");
        assert_eq!(http_request.uri().path(), "/JsonLists");

        let expected_headers = &[("Content-Type", "application/json")];
        ::protocol_test_helpers::assert_ok(::protocol_test_helpers::validate_headers(
            &http_request,
            expected_headers,
        ));
    }
    /// Serializes null values in lists
    /// Test ID: RestJsonListsSerializeNull
    #[test]
    fn test_rest_json_lists_serialize_null_request() {
        let input = JsonListsInput::builder()
            .sparse_string_list(vec![None, Some("hi".to_string())])
            .build();
        let http_request = JsonListsInput::assemble(input.request_builder_base(), vec![]);

        assert_eq!(http_request.method(), "PUT");
        assert_eq!(http_request.uri().path(), "/JsonLists");

        let expected_headers = &[("Content-Type", "application/json")];
        ::protocol_test_helpers::assert_ok(::protocol_test_helpers::validate_headers(
            &http_request,
            expected_headers,
        ));
    }
    /// Serializes JSON lists
    /// Test ID: RestJsonLists
    #[test]
    fn test_rest_json_lists_response() {
        /* test case disabled for this protocol (not yet supported) */
    }
    /// Serializes empty JSON lists
    /// Test ID: RestJsonListsEmpty
    #[test]
    fn test_rest_json_lists_empty_response() {
        /* test case disabled for this protocol (not yet supported) */
    }
    /// Serializes null values in sparse lists
    /// Test ID: RestJsonListsSerializeNull
    #[test]
    fn test_rest_json_lists_serialize_null_response() {
        /* test case disabled for this protocol (not yet supported) */
    }
}

impl JsonMapsInput {
    fn uri_base(&self, output: &mut String) {
        write!(output, "/JsonMaps").expect("formatting should succeed")
    }
    fn update_http_builder(&self, builder: ::http::request::Builder) -> ::http::request::Builder {
        let mut uri = String::new();
        self.uri_base(&mut uri);
        builder.method("POST").uri(uri)
    }
    pub fn request_builder_base(&self) -> ::http::request::Builder {
        let builder = ::http::request::Builder::new();
        let builder = builder.header("Content-Type", "application/json");
        self.update_http_builder(builder)
    }
    pub fn build_body(&self) -> Vec<u8> {
        todo!()
    }
    pub fn assemble(
        builder: ::http::request::Builder,
        body: Vec<u8>,
    ) -> ::http::request::Request<Vec<u8>> {
        builder
            .header(::http::header::CONTENT_LENGTH, body.len())
            .body(body)
            .expect("http request should be valid")
    }
}
#[cfg(test)]
#[allow(unreachable_code, unused_variables)]
mod json_maps_request_test {

    use crate::model::GreetingStruct;
    use crate::operation::JsonMapsInput;
    /// Serializes JSON maps
    /// Test ID: RestJsonJsonMaps
    #[test]
    fn test_rest_json_json_maps_request() {
        let input = JsonMapsInput::builder()
            .dense_struct_map({
                let mut ret = ::std::collections::HashMap::new();
                ret.insert(
                    "foo".to_string(),
                    GreetingStruct::builder().hi("there".to_string()).build(),
                );
                ret.insert(
                    "baz".to_string(),
                    GreetingStruct::builder().hi("bye".to_string()).build(),
                );
                ret
            })
            .sparse_struct_map({
                let mut ret = ::std::collections::HashMap::new();
                ret.insert(
                    "foo".to_string(),
                    Some(GreetingStruct::builder().hi("there".to_string()).build()),
                );
                ret.insert(
                    "baz".to_string(),
                    Some(GreetingStruct::builder().hi("bye".to_string()).build()),
                );
                ret
            })
            .build();
        let http_request = JsonMapsInput::assemble(input.request_builder_base(), vec![]);

        assert_eq!(http_request.method(), "POST");
        assert_eq!(http_request.uri().path(), "/JsonMaps");

        let expected_headers = &[("Content-Type", "application/json")];
        ::protocol_test_helpers::assert_ok(::protocol_test_helpers::validate_headers(
            &http_request,
            expected_headers,
        ));
    }
    /// Serializes JSON map values in sparse maps
    /// Test ID: RestJsonSerializesNullMapValues
    #[test]
    fn test_rest_json_serializes_null_map_values_request() {
        let input = JsonMapsInput::builder()
            .sparse_boolean_map({
                let mut ret = ::std::collections::HashMap::new();
                ret.insert("x".to_string(), None);
                ret
            })
            .sparse_number_map({
                let mut ret = ::std::collections::HashMap::new();
                ret.insert("x".to_string(), None);
                ret
            })
            .sparse_string_map({
                let mut ret = ::std::collections::HashMap::new();
                ret.insert("x".to_string(), None);
                ret
            })
            .sparse_struct_map({
                let mut ret = ::std::collections::HashMap::new();
                ret.insert("x".to_string(), None);
                ret
            })
            .build();
        let http_request = JsonMapsInput::assemble(input.request_builder_base(), vec![]);

        assert_eq!(http_request.method(), "POST");
        assert_eq!(http_request.uri().path(), "/JsonMaps");

        let expected_headers = &[("Content-Type", "application/json")];
        ::protocol_test_helpers::assert_ok(::protocol_test_helpers::validate_headers(
            &http_request,
            expected_headers,
        ));
    }
    /// Ensure that 0 and false are sent over the wire in all maps and lists
    /// Test ID: RestJsonSerializesZeroValuesInMaps
    #[test]
    fn test_rest_json_serializes_zero_values_in_maps_request() {
        let input = JsonMapsInput::builder()
            .dense_number_map({
                let mut ret = ::std::collections::HashMap::new();
                ret.insert("x".to_string(), 0);
                ret
            })
            .sparse_number_map({
                let mut ret = ::std::collections::HashMap::new();
                ret.insert("x".to_string(), Some(0));
                ret
            })
            .dense_boolean_map({
                let mut ret = ::std::collections::HashMap::new();
                ret.insert("x".to_string(), false);
                ret
            })
            .sparse_boolean_map({
                let mut ret = ::std::collections::HashMap::new();
                ret.insert("x".to_string(), Some(false));
                ret
            })
            .build();
        let http_request = JsonMapsInput::assemble(input.request_builder_base(), vec![]);

        assert_eq!(http_request.method(), "POST");
        assert_eq!(http_request.uri().path(), "/JsonMaps");

        let expected_headers = &[("Content-Type", "application/json")];
        ::protocol_test_helpers::assert_ok(::protocol_test_helpers::validate_headers(
            &http_request,
            expected_headers,
        ));
    }
    /// Deserializes JSON maps
    /// Test ID: RestJsonJsonMaps
    #[test]
    fn test_rest_json_json_maps_response() {
        /* test case disabled for this protocol (not yet supported) */
    }
    /// Deserializes null JSON map values
    /// Test ID: RestJsonDeserializesNullMapValues
    #[test]
    fn test_rest_json_deserializes_null_map_values_response() {
        /* test case disabled for this protocol (not yet supported) */
    }
    /// Ensure that 0 and false are sent over the wire in all maps and lists
    /// Test ID: RestJsonDeserializesZeroValuesInMaps
    #[test]
    fn test_rest_json_deserializes_zero_values_in_maps_response() {
        /* test case disabled for this protocol (not yet supported) */
    }
}

impl JsonTimestampsInput {
    fn uri_base(&self, output: &mut String) {
        write!(output, "/JsonTimestamps").expect("formatting should succeed")
    }
    fn update_http_builder(&self, builder: ::http::request::Builder) -> ::http::request::Builder {
        let mut uri = String::new();
        self.uri_base(&mut uri);
        builder.method("POST").uri(uri)
    }
    pub fn request_builder_base(&self) -> ::http::request::Builder {
        let builder = ::http::request::Builder::new();
        let builder = builder.header("Content-Type", "application/json");
        self.update_http_builder(builder)
    }
    pub fn build_body(&self) -> Vec<u8> {
        todo!()
    }
    pub fn assemble(
        builder: ::http::request::Builder,
        body: Vec<u8>,
    ) -> ::http::request::Request<Vec<u8>> {
        builder
            .header(::http::header::CONTENT_LENGTH, body.len())
            .body(body)
            .expect("http request should be valid")
    }
}
#[cfg(test)]
#[allow(unreachable_code, unused_variables)]
mod json_timestamps_request_test {

    use crate::operation::JsonTimestampsInput;
    /// Tests how normal timestamps are serialized
    /// Test ID: RestJsonJsonTimestamps
    #[test]
    fn test_rest_json_json_timestamps_request() {
        let input = JsonTimestampsInput::builder()
            .normal(::smithy_types::Instant::from_epoch_seconds(1398796238))
            .build();
        let http_request = JsonTimestampsInput::assemble(input.request_builder_base(), vec![]);

        assert_eq!(http_request.method(), "POST");
        assert_eq!(http_request.uri().path(), "/JsonTimestamps");

        let expected_headers = &[("Content-Type", "application/json")];
        ::protocol_test_helpers::assert_ok(::protocol_test_helpers::validate_headers(
            &http_request,
            expected_headers,
        ));
    }
    /// Ensures that the timestampFormat of date-time works like normal timestamps
    /// Test ID: RestJsonJsonTimestampsWithDateTimeFormat
    #[test]
    fn test_rest_json_json_timestamps_with_date_time_format_request() {
        let input = JsonTimestampsInput::builder()
            .date_time(::smithy_types::Instant::from_epoch_seconds(1398796238))
            .build();
        let http_request = JsonTimestampsInput::assemble(input.request_builder_base(), vec![]);

        assert_eq!(http_request.method(), "POST");
        assert_eq!(http_request.uri().path(), "/JsonTimestamps");

        let expected_headers = &[("Content-Type", "application/json")];
        ::protocol_test_helpers::assert_ok(::protocol_test_helpers::validate_headers(
            &http_request,
            expected_headers,
        ));
    }
    /// Ensures that the timestampFormat of epoch-seconds works
    /// Test ID: RestJsonJsonTimestampsWithEpochSecondsFormat
    #[test]
    fn test_rest_json_json_timestamps_with_epoch_seconds_format_request() {
        let input = JsonTimestampsInput::builder()
            .epoch_seconds(::smithy_types::Instant::from_epoch_seconds(1398796238))
            .build();
        let http_request = JsonTimestampsInput::assemble(input.request_builder_base(), vec![]);

        assert_eq!(http_request.method(), "POST");
        assert_eq!(http_request.uri().path(), "/JsonTimestamps");

        let expected_headers = &[("Content-Type", "application/json")];
        ::protocol_test_helpers::assert_ok(::protocol_test_helpers::validate_headers(
            &http_request,
            expected_headers,
        ));
    }
    /// Ensures that the timestampFormat of http-date works
    /// Test ID: RestJsonJsonTimestampsWithHttpDateFormat
    #[test]
    fn test_rest_json_json_timestamps_with_http_date_format_request() {
        let input = JsonTimestampsInput::builder()
            .http_date(::smithy_types::Instant::from_epoch_seconds(1398796238))
            .build();
        let http_request = JsonTimestampsInput::assemble(input.request_builder_base(), vec![]);

        assert_eq!(http_request.method(), "POST");
        assert_eq!(http_request.uri().path(), "/JsonTimestamps");

        let expected_headers = &[("Content-Type", "application/json")];
        ::protocol_test_helpers::assert_ok(::protocol_test_helpers::validate_headers(
            &http_request,
            expected_headers,
        ));
    }
    /// Tests how normal timestamps are serialized
    /// Test ID: RestJsonJsonTimestamps
    #[test]
    fn test_rest_json_json_timestamps_response() {
        /* test case disabled for this protocol (not yet supported) */
    }
    /// Ensures that the timestampFormat of date-time works like normal timestamps
    /// Test ID: RestJsonJsonTimestampsWithDateTimeFormat
    #[test]
    fn test_rest_json_json_timestamps_with_date_time_format_response() {
        /* test case disabled for this protocol (not yet supported) */
    }
    /// Ensures that the timestampFormat of epoch-seconds works
    /// Test ID: RestJsonJsonTimestampsWithEpochSecondsFormat
    #[test]
    fn test_rest_json_json_timestamps_with_epoch_seconds_format_response() {
        /* test case disabled for this protocol (not yet supported) */
    }
    /// Ensures that the timestampFormat of http-date works
    /// Test ID: RestJsonJsonTimestampsWithHttpDateFormat
    #[test]
    fn test_rest_json_json_timestamps_with_http_date_format_response() {
        /* test case disabled for this protocol (not yet supported) */
    }
}

impl JsonUnionsInput {
    fn uri_base(&self, output: &mut String) {
        write!(output, "/JsonUnions").expect("formatting should succeed")
    }
    fn update_http_builder(&self, builder: ::http::request::Builder) -> ::http::request::Builder {
        let mut uri = String::new();
        self.uri_base(&mut uri);
        builder.method("PUT").uri(uri)
    }
    pub fn request_builder_base(&self) -> ::http::request::Builder {
        let builder = ::http::request::Builder::new();
        let builder = builder.header("Content-Type", "application/json");
        self.update_http_builder(builder)
    }
    pub fn build_body(&self) -> Vec<u8> {
        todo!()
    }
    pub fn assemble(
        builder: ::http::request::Builder,
        body: Vec<u8>,
    ) -> ::http::request::Request<Vec<u8>> {
        builder
            .header(::http::header::CONTENT_LENGTH, body.len())
            .body(body)
            .expect("http request should be valid")
    }
}
#[cfg(test)]
#[allow(unreachable_code, unused_variables)]
mod json_unions_request_test {

    use crate::model::FooEnum;
    use crate::model::GreetingStruct;
    use crate::model::MyUnion;
    use crate::operation::JsonUnionsInput;
    /// Serializes a string union value
    /// Test ID: RestJsonSerializeStringUnionValue
    #[test]
    fn test_rest_json_serialize_string_union_value_request() {
        let input = JsonUnionsInput::builder()
            .contents(MyUnion::StringValue("foo".to_string()))
            .build();
        let http_request = JsonUnionsInput::assemble(input.request_builder_base(), vec![]);

        assert_eq!(http_request.method(), "PUT");
        assert_eq!(http_request.uri().path(), "/JsonUnions");

        let expected_headers = &[("Content-Type", "application/json")];
        ::protocol_test_helpers::assert_ok(::protocol_test_helpers::validate_headers(
            &http_request,
            expected_headers,
        ));
    }
    /// Serializes a boolean union value
    /// Test ID: RestJsonSerializeBooleanUnionValue
    #[test]
    fn test_rest_json_serialize_boolean_union_value_request() {
        let input = JsonUnionsInput::builder()
            .contents(MyUnion::BooleanValue(true))
            .build();
        let http_request = JsonUnionsInput::assemble(input.request_builder_base(), vec![]);

        assert_eq!(http_request.method(), "PUT");
        assert_eq!(http_request.uri().path(), "/JsonUnions");

        let expected_headers = &[("Content-Type", "application/json")];
        ::protocol_test_helpers::assert_ok(::protocol_test_helpers::validate_headers(
            &http_request,
            expected_headers,
        ));
    }
    /// Serializes a number union value
    /// Test ID: RestJsonSerializeNumberUnionValue
    #[test]
    fn test_rest_json_serialize_number_union_value_request() {
        let input = JsonUnionsInput::builder()
            .contents(MyUnion::NumberValue(1))
            .build();
        let http_request = JsonUnionsInput::assemble(input.request_builder_base(), vec![]);

        assert_eq!(http_request.method(), "PUT");
        assert_eq!(http_request.uri().path(), "/JsonUnions");

        let expected_headers = &[("Content-Type", "application/json")];
        ::protocol_test_helpers::assert_ok(::protocol_test_helpers::validate_headers(
            &http_request,
            expected_headers,
        ));
    }
    /// Serializes a blob union value
    /// Test ID: RestJsonSerializeBlobUnionValue
    #[test]
    fn test_rest_json_serialize_blob_union_value_request() {
        let input = JsonUnionsInput::builder()
            .contents(MyUnion::BlobValue(::smithy_types::Blob::new("foo")))
            .build();
        let http_request = JsonUnionsInput::assemble(input.request_builder_base(), vec![]);

        assert_eq!(http_request.method(), "PUT");
        assert_eq!(http_request.uri().path(), "/JsonUnions");

        let expected_headers = &[("Content-Type", "application/json")];
        ::protocol_test_helpers::assert_ok(::protocol_test_helpers::validate_headers(
            &http_request,
            expected_headers,
        ));
    }
    /// Serializes a timestamp union value
    /// Test ID: RestJsonSerializeTimestampUnionValue
    #[test]
    fn test_rest_json_serialize_timestamp_union_value_request() {
        let input = JsonUnionsInput::builder()
            .contents(MyUnion::TimestampValue(
                ::smithy_types::Instant::from_epoch_seconds(1398796238),
            ))
            .build();
        let http_request = JsonUnionsInput::assemble(input.request_builder_base(), vec![]);

        assert_eq!(http_request.method(), "PUT");
        assert_eq!(http_request.uri().path(), "/JsonUnions");

        let expected_headers = &[("Content-Type", "application/json")];
        ::protocol_test_helpers::assert_ok(::protocol_test_helpers::validate_headers(
            &http_request,
            expected_headers,
        ));
    }
    /// Serializes an enum union value
    /// Test ID: RestJsonSerializeEnumUnionValue
    #[test]
    fn test_rest_json_serialize_enum_union_value_request() {
        let input = JsonUnionsInput::builder()
            .contents(MyUnion::EnumValue(FooEnum::from("Foo")))
            .build();
        let http_request = JsonUnionsInput::assemble(input.request_builder_base(), vec![]);

        assert_eq!(http_request.method(), "PUT");
        assert_eq!(http_request.uri().path(), "/JsonUnions");

        let expected_headers = &[("Content-Type", "application/json")];
        ::protocol_test_helpers::assert_ok(::protocol_test_helpers::validate_headers(
            &http_request,
            expected_headers,
        ));
    }
    /// Serializes a list union value
    /// Test ID: RestJsonSerializeListUnionValue
    #[test]
    fn test_rest_json_serialize_list_union_value_request() {
        let input = JsonUnionsInput::builder()
            .contents(MyUnion::ListValue(vec![
                "foo".to_string(),
                "bar".to_string(),
            ]))
            .build();
        let http_request = JsonUnionsInput::assemble(input.request_builder_base(), vec![]);

        assert_eq!(http_request.method(), "PUT");
        assert_eq!(http_request.uri().path(), "/JsonUnions");

        let expected_headers = &[("Content-Type", "application/json")];
        ::protocol_test_helpers::assert_ok(::protocol_test_helpers::validate_headers(
            &http_request,
            expected_headers,
        ));
    }
    /// Serializes a map union value
    /// Test ID: RestJsonSerializeMapUnionValue
    #[test]
    fn test_rest_json_serialize_map_union_value_request() {
        let input = JsonUnionsInput::builder()
            .contents(MyUnion::MapValue({
                let mut ret = ::std::collections::HashMap::new();
                ret.insert("foo".to_string(), "bar".to_string());
                ret.insert("spam".to_string(), "eggs".to_string());
                ret
            }))
            .build();
        let http_request = JsonUnionsInput::assemble(input.request_builder_base(), vec![]);

        assert_eq!(http_request.method(), "PUT");
        assert_eq!(http_request.uri().path(), "/JsonUnions");

        let expected_headers = &[("Content-Type", "application/json")];
        ::protocol_test_helpers::assert_ok(::protocol_test_helpers::validate_headers(
            &http_request,
            expected_headers,
        ));
    }
    /// Serializes a structure union value
    /// Test ID: RestJsonSerializeStructureUnionValue
    #[test]
    fn test_rest_json_serialize_structure_union_value_request() {
        let input = JsonUnionsInput::builder()
            .contents(MyUnion::StructureValue(
                GreetingStruct::builder().hi("hello".to_string()).build(),
            ))
            .build();
        let http_request = JsonUnionsInput::assemble(input.request_builder_base(), vec![]);

        assert_eq!(http_request.method(), "PUT");
        assert_eq!(http_request.uri().path(), "/JsonUnions");

        let expected_headers = &[("Content-Type", "application/json")];
        ::protocol_test_helpers::assert_ok(::protocol_test_helpers::validate_headers(
            &http_request,
            expected_headers,
        ));
    }
    /// Deserializes a string union value
    /// Test ID: RestJsonDeserializeStringUnionValue
    #[test]
    fn test_rest_json_deserialize_string_union_value_response() {
        /* test case disabled for this protocol (not yet supported) */
    }
    /// Deserializes a boolean union value
    /// Test ID: RestJsonDeserializeBooleanUnionValue
    #[test]
    fn test_rest_json_deserialize_boolean_union_value_response() {
        /* test case disabled for this protocol (not yet supported) */
    }
    /// Deserializes a number union value
    /// Test ID: RestJsonDeserializeNumberUnionValue
    #[test]
    fn test_rest_json_deserialize_number_union_value_response() {
        /* test case disabled for this protocol (not yet supported) */
    }
    /// Deserializes a blob union value
    /// Test ID: RestJsonDeserializeBlobUnionValue
    #[test]
    fn test_rest_json_deserialize_blob_union_value_response() {
        /* test case disabled for this protocol (not yet supported) */
    }
    /// Deserializes a timestamp union value
    /// Test ID: RestJsonDeserializeTimestampUnionValue
    #[test]
    fn test_rest_json_deserialize_timestamp_union_value_response() {
        /* test case disabled for this protocol (not yet supported) */
    }
    /// Deserializes an enum union value
    /// Test ID: RestJsonDeserializeEnumUnionValue
    #[test]
    fn test_rest_json_deserialize_enum_union_value_response() {
        /* test case disabled for this protocol (not yet supported) */
    }
    /// Deserializes a list union value
    /// Test ID: RestJsonDeserializeListUnionValue
    #[test]
    fn test_rest_json_deserialize_list_union_value_response() {
        /* test case disabled for this protocol (not yet supported) */
    }
    /// Deserializes a map union value
    /// Test ID: RestJsonDeserializeMapUnionValue
    #[test]
    fn test_rest_json_deserialize_map_union_value_response() {
        /* test case disabled for this protocol (not yet supported) */
    }
    /// Deserializes a structure union value
    /// Test ID: RestJsonDeserializeStructureUnionValue
    #[test]
    fn test_rest_json_deserialize_structure_union_value_response() {
        /* test case disabled for this protocol (not yet supported) */
    }
}

impl MediaTypeHeaderInput {
    fn uri_base(&self, output: &mut String) {
        write!(output, "/MediaTypeHeader").expect("formatting should succeed")
    }
    fn add_headers(&self, mut builder: ::http::request::Builder) -> ::http::request::Builder {
        if let Some(inner_73) = &self.json {
            let formatted_74 = ::smithy_http::base64::encode(&inner_73);
            if !formatted_74.is_empty() {
                builder = builder.header("X-Json", ::smithy_http::base64::encode(&inner_73));
            }
        }
        builder
    }
    fn update_http_builder(&self, builder: ::http::request::Builder) -> ::http::request::Builder {
        let mut uri = String::new();
        self.uri_base(&mut uri);
        let builder = self.add_headers(builder);
        builder.method("GET").uri(uri)
    }
    pub fn request_builder_base(&self) -> ::http::request::Builder {
        let builder = ::http::request::Builder::new();
        let builder = builder.header("Content-Type", "application/json");
        self.update_http_builder(builder)
    }
    pub fn build_body(&self) -> Vec<u8> {
        todo!()
    }
    pub fn assemble(
        builder: ::http::request::Builder,
        body: Vec<u8>,
    ) -> ::http::request::Request<Vec<u8>> {
        builder
            .header(::http::header::CONTENT_LENGTH, body.len())
            .body(body)
            .expect("http request should be valid")
    }
}
#[cfg(test)]
#[allow(unreachable_code, unused_variables)]
mod media_type_header_request_test {

    use crate::operation::MediaTypeHeaderInput;
    /// Headers that target strings with a mediaType are base64 encoded
    /// Test ID: MediaTypeHeaderInputBase64
    #[test]
    fn test_media_type_header_input_base64_request() {
        let input = MediaTypeHeaderInput::builder()
            .json("true".to_string())
            .build();
        let http_request = MediaTypeHeaderInput::assemble(input.request_builder_base(), vec![]);

        assert_eq!(http_request.method(), "GET");
        assert_eq!(http_request.uri().path(), "/MediaTypeHeader");

        let expected_headers = &[("X-Json", "dHJ1ZQ==")];
        ::protocol_test_helpers::assert_ok(::protocol_test_helpers::validate_headers(
            &http_request,
            expected_headers,
        ));
    }
    /// Headers that target strings with a mediaType are base64 encoded
    /// Test ID: MediaTypeHeaderOutputBase64
    #[test]
    fn test_media_type_header_output_base64_response() {
        /* test case disabled for this protocol (not yet supported) */
    }
}

impl NoInputAndNoOutputInput {
    fn uri_base(&self, output: &mut String) {
        write!(output, "/NoInputAndNoOutput").expect("formatting should succeed")
    }
    fn update_http_builder(&self, builder: ::http::request::Builder) -> ::http::request::Builder {
        let mut uri = String::new();
        self.uri_base(&mut uri);
        builder.method("POST").uri(uri)
    }
    pub fn request_builder_base(&self) -> ::http::request::Builder {
        let builder = ::http::request::Builder::new();
        let builder = builder.header("Content-Type", "application/json");
        self.update_http_builder(builder)
    }
    pub fn build_body(&self) -> Vec<u8> {
        todo!()
    }
    pub fn assemble(
        builder: ::http::request::Builder,
        body: Vec<u8>,
    ) -> ::http::request::Request<Vec<u8>> {
        builder
            .header(::http::header::CONTENT_LENGTH, body.len())
            .body(body)
            .expect("http request should be valid")
    }
}
#[cfg(test)]
#[allow(unreachable_code, unused_variables)]
mod no_input_and_no_output_request_test {

    use crate::operation::NoInputAndNoOutputInput;
    /// No input serializes no payload
    /// Test ID: RestJsonNoInputAndNoOutput
    #[test]
    fn test_rest_json_no_input_and_no_output_request() {
        let input = NoInputAndNoOutputInput::builder().build();
        let http_request = NoInputAndNoOutputInput::assemble(input.request_builder_base(), vec![]);

        assert_eq!(http_request.method(), "POST");
        assert_eq!(http_request.uri().path(), "/NoInputAndNoOutput");
    }
    /// No output serializes no payload
    /// Test ID: RestJsonNoInputAndNoOutput
    #[test]
    fn test_rest_json_no_input_and_no_output_response() {
        /* test case disabled for this protocol (not yet supported) */
    }
}

impl NoInputAndOutputInput {
    fn uri_base(&self, output: &mut String) {
        write!(output, "/NoInputAndOutputOutput").expect("formatting should succeed")
    }
    fn update_http_builder(&self, builder: ::http::request::Builder) -> ::http::request::Builder {
        let mut uri = String::new();
        self.uri_base(&mut uri);
        builder.method("POST").uri(uri)
    }
    pub fn request_builder_base(&self) -> ::http::request::Builder {
        let builder = ::http::request::Builder::new();
        let builder = builder.header("Content-Type", "application/json");
        self.update_http_builder(builder)
    }
    pub fn build_body(&self) -> Vec<u8> {
        todo!()
    }
    pub fn assemble(
        builder: ::http::request::Builder,
        body: Vec<u8>,
    ) -> ::http::request::Request<Vec<u8>> {
        builder
            .header(::http::header::CONTENT_LENGTH, body.len())
            .body(body)
            .expect("http request should be valid")
    }
}
#[cfg(test)]
#[allow(unreachable_code, unused_variables)]
mod no_input_and_output_request_test {

    use crate::operation::NoInputAndOutputInput;
    /// No input serializes no payload
    /// Test ID: RestJsonNoInputAndOutput
    #[test]
    fn test_rest_json_no_input_and_output_request() {
        let input = NoInputAndOutputInput::builder().build();
        let http_request = NoInputAndOutputInput::assemble(input.request_builder_base(), vec![]);

        assert_eq!(http_request.method(), "POST");
        assert_eq!(http_request.uri().path(), "/NoInputAndOutputOutput");
    }
    /// Empty output serializes no payload
    /// Test ID: RestJsonNoInputAndOutput
    #[test]
    fn test_rest_json_no_input_and_output_response() {
        /* test case disabled for this protocol (not yet supported) */
    }
}

impl NullAndEmptyHeadersClientInput {
    fn uri_base(&self, output: &mut String) {
        write!(output, "/NullAndEmptyHeadersClient").expect("formatting should succeed")
    }
    fn add_headers(&self, mut builder: ::http::request::Builder) -> ::http::request::Builder {
        if let Some(inner_75) = &self.a {
            let formatted_76 = ::smithy_http::query::fmt_string(&inner_75);
            if !formatted_76.is_empty() {
                builder = builder.header("X-A", ::smithy_http::query::fmt_string(&inner_75));
            }
        }
        if let Some(inner_77) = &self.b {
            let formatted_78 = ::smithy_http::query::fmt_string(&inner_77);
            if !formatted_78.is_empty() {
                builder = builder.header("X-B", ::smithy_http::query::fmt_string(&inner_77));
            }
        }
        if let Some(inner_79) = &self.c {
            for inner_80 in inner_79 {
                let formatted_81 = ::smithy_http::query::fmt_string(&inner_80);
                if !formatted_81.is_empty() {
                    builder = builder.header("X-C", ::smithy_http::query::fmt_string(&inner_80));
                }
            }
        }
        builder
    }
    fn update_http_builder(&self, builder: ::http::request::Builder) -> ::http::request::Builder {
        let mut uri = String::new();
        self.uri_base(&mut uri);
        let builder = self.add_headers(builder);
        builder.method("GET").uri(uri)
    }
    pub fn request_builder_base(&self) -> ::http::request::Builder {
        let builder = ::http::request::Builder::new();
        let builder = builder.header("Content-Type", "application/json");
        self.update_http_builder(builder)
    }
    pub fn build_body(&self) -> Vec<u8> {
        todo!()
    }
    pub fn assemble(
        builder: ::http::request::Builder,
        body: Vec<u8>,
    ) -> ::http::request::Request<Vec<u8>> {
        builder
            .header(::http::header::CONTENT_LENGTH, body.len())
            .body(body)
            .expect("http request should be valid")
    }
}
#[cfg(test)]
#[allow(unreachable_code, unused_variables)]
mod null_and_empty_headers_client_request_test {

    use crate::operation::NullAndEmptyHeadersClientInput;
    /// Do not send null values, empty strings, or empty lists over the wire in headers
    /// Test ID: RestJsonNullAndEmptyHeaders
    #[test]
    fn test_rest_json_null_and_empty_headers_request() {
        let input = NullAndEmptyHeadersClientInput::builder()
            .b("".to_string())
            .c(vec![])
            .build();
        let http_request =
            NullAndEmptyHeadersClientInput::assemble(input.request_builder_base(), vec![]);

        assert_eq!(http_request.method(), "GET");
        assert_eq!(http_request.uri().path(), "/NullAndEmptyHeadersClient");

        let forbidden_headers = &["X-A", "X-B", "X-C"];
        ::protocol_test_helpers::assert_ok(::protocol_test_helpers::forbid_headers(
            &http_request,
            forbidden_headers,
        ));
    }
}

impl NullAndEmptyHeadersServerInput {
    fn uri_base(&self, output: &mut String) {
        write!(output, "/NullAndEmptyHeadersServer").expect("formatting should succeed")
    }
    fn add_headers(&self, mut builder: ::http::request::Builder) -> ::http::request::Builder {
        if let Some(inner_82) = &self.a {
            let formatted_83 = ::smithy_http::query::fmt_string(&inner_82);
            if !formatted_83.is_empty() {
                builder = builder.header("X-A", ::smithy_http::query::fmt_string(&inner_82));
            }
        }
        if let Some(inner_84) = &self.b {
            let formatted_85 = ::smithy_http::query::fmt_string(&inner_84);
            if !formatted_85.is_empty() {
                builder = builder.header("X-B", ::smithy_http::query::fmt_string(&inner_84));
            }
        }
        if let Some(inner_86) = &self.c {
            for inner_87 in inner_86 {
                let formatted_88 = ::smithy_http::query::fmt_string(&inner_87);
                if !formatted_88.is_empty() {
                    builder = builder.header("X-C", ::smithy_http::query::fmt_string(&inner_87));
                }
            }
        }
        builder
    }
    fn update_http_builder(&self, builder: ::http::request::Builder) -> ::http::request::Builder {
        let mut uri = String::new();
        self.uri_base(&mut uri);
        let builder = self.add_headers(builder);
        builder.method("GET").uri(uri)
    }
    pub fn request_builder_base(&self) -> ::http::request::Builder {
        let builder = ::http::request::Builder::new();
        let builder = builder.header("Content-Type", "application/json");
        self.update_http_builder(builder)
    }
    pub fn build_body(&self) -> Vec<u8> {
        todo!()
    }
    pub fn assemble(
        builder: ::http::request::Builder,
        body: Vec<u8>,
    ) -> ::http::request::Request<Vec<u8>> {
        builder
            .header(::http::header::CONTENT_LENGTH, body.len())
            .body(body)
            .expect("http request should be valid")
    }
}
#[cfg(test)]
#[allow(unreachable_code, unused_variables)]
mod null_and_empty_headers_server_request_test {

    /// Do not send null or empty headers
    /// Test ID: RestJsonNullAndEmptyHeaders
    #[test]
    fn test_rest_json_null_and_empty_headers_response() {
        /* test case disabled for this protocol (not yet supported) */
    }
}

impl OmitsNullSerializesEmptyStringInput {
    fn uri_base(&self, output: &mut String) {
        write!(output, "/OmitsNullSerializesEmptyString").expect("formatting should succeed")
    }
    fn uri_query(&self, output: &mut String) {
        let mut params = Vec::new();
        if let Some(inner_89) = &self.null_value {
            params.push(("Null", ::smithy_http::query::fmt_string(&inner_89)))
        }
        if let Some(inner_90) = &self.empty_string {
            params.push(("Empty", ::smithy_http::query::fmt_string(&inner_90)))
        }
        ::smithy_http::query::write(params, output)
    }
    fn update_http_builder(&self, builder: ::http::request::Builder) -> ::http::request::Builder {
        let mut uri = String::new();
        self.uri_base(&mut uri);
        self.uri_query(&mut uri);
        builder.method("GET").uri(uri)
    }
    pub fn request_builder_base(&self) -> ::http::request::Builder {
        let builder = ::http::request::Builder::new();
        let builder = builder.header("Content-Type", "application/json");
        self.update_http_builder(builder)
    }
    pub fn build_body(&self) -> Vec<u8> {
        todo!()
    }
    pub fn assemble(
        builder: ::http::request::Builder,
        body: Vec<u8>,
    ) -> ::http::request::Request<Vec<u8>> {
        builder
            .header(::http::header::CONTENT_LENGTH, body.len())
            .body(body)
            .expect("http request should be valid")
    }
}
#[cfg(test)]
#[allow(unreachable_code, unused_variables)]
mod omits_null_serializes_empty_string_request_test {

    use crate::operation::OmitsNullSerializesEmptyStringInput;
    /// Serializes empty query strings but omits null
    /// Test ID: RestJsonOmitsNullSerializesEmptyString
    #[test]
    fn test_rest_json_omits_null_serializes_empty_string_request() {
        let input = OmitsNullSerializesEmptyStringInput::builder()
            .empty_string("".to_string())
            .build();
        let http_request =
            OmitsNullSerializesEmptyStringInput::assemble(input.request_builder_base(), vec![]);

        assert_eq!(http_request.method(), "GET");
        assert_eq!(http_request.uri().path(), "/OmitsNullSerializesEmptyString");

        let expected_query_params = &["Empty="];
        ::protocol_test_helpers::assert_ok(::protocol_test_helpers::validate_query_string(
            &http_request,
            expected_query_params,
        ));
    }
}

impl QueryIdempotencyTokenAutoFillInput {
    fn uri_base(&self, output: &mut String) {
        write!(output, "/QueryIdempotencyTokenAutoFill").expect("formatting should succeed")
    }
    fn uri_query(&self, output: &mut String) {
        let mut params = Vec::new();
        if let Some(inner_91) = &self.token {
            params.push(("token", ::smithy_http::query::fmt_string(&inner_91)))
        }
        ::smithy_http::query::write(params, output)
    }
    fn update_http_builder(&self, builder: ::http::request::Builder) -> ::http::request::Builder {
        let mut uri = String::new();
        self.uri_base(&mut uri);
        self.uri_query(&mut uri);
        builder.method("POST").uri(uri)
    }
    pub fn request_builder_base(&self) -> ::http::request::Builder {
        let builder = ::http::request::Builder::new();
        let builder = builder.header("Content-Type", "application/json");
        self.update_http_builder(builder)
    }
    pub fn build_body(&self) -> Vec<u8> {
        todo!()
    }
    pub fn assemble(
        builder: ::http::request::Builder,
        body: Vec<u8>,
    ) -> ::http::request::Request<Vec<u8>> {
        builder
            .header(::http::header::CONTENT_LENGTH, body.len())
            .body(body)
            .expect("http request should be valid")
    }
}
#[cfg(test)]
#[allow(unreachable_code, unused_variables)]
mod query_idempotency_token_auto_fill_request_test {

    use crate::operation::QueryIdempotencyTokenAutoFillInput;
    /// Automatically adds idempotency token when not set
    /// Test ID: RestJsonQueryIdempotencyTokenAutoFill
    #[test]
    #[should_panic]
    fn test_rest_json_query_idempotency_token_auto_fill_request() {
        let input = QueryIdempotencyTokenAutoFillInput::builder().build();
        let http_request =
            QueryIdempotencyTokenAutoFillInput::assemble(input.request_builder_base(), vec![]);

        assert_eq!(http_request.method(), "POST");
        assert_eq!(http_request.uri().path(), "/QueryIdempotencyTokenAutoFill");

        let expected_query_params = &["token=00000000-0000-4000-8000-000000000000"];
        ::protocol_test_helpers::assert_ok(::protocol_test_helpers::validate_query_string(
            &http_request,
            expected_query_params,
        ));
    }
    /// Uses the given idempotency token as-is
    /// Test ID: RestJsonQueryIdempotencyTokenAutoFillIsSet
    #[test]
    fn test_rest_json_query_idempotency_token_auto_fill_is_set_request() {
        let input = QueryIdempotencyTokenAutoFillInput::builder()
            .token("00000000-0000-4000-8000-000000000000".to_string())
            .build();
        let http_request =
            QueryIdempotencyTokenAutoFillInput::assemble(input.request_builder_base(), vec![]);

        assert_eq!(http_request.method(), "POST");
        assert_eq!(http_request.uri().path(), "/QueryIdempotencyTokenAutoFill");

        let expected_query_params = &["token=00000000-0000-4000-8000-000000000000"];
        ::protocol_test_helpers::assert_ok(::protocol_test_helpers::validate_query_string(
            &http_request,
            expected_query_params,
        ));
    }
}

impl RecursiveShapesInput {
    fn uri_base(&self, output: &mut String) {
        write!(output, "/RecursiveShapes").expect("formatting should succeed")
    }
    fn update_http_builder(&self, builder: ::http::request::Builder) -> ::http::request::Builder {
        let mut uri = String::new();
        self.uri_base(&mut uri);
        builder.method("PUT").uri(uri)
    }
    pub fn request_builder_base(&self) -> ::http::request::Builder {
        let builder = ::http::request::Builder::new();
        let builder = builder.header("Content-Type", "application/json");
        self.update_http_builder(builder)
    }
    pub fn build_body(&self) -> Vec<u8> {
        todo!()
    }
    pub fn assemble(
        builder: ::http::request::Builder,
        body: Vec<u8>,
    ) -> ::http::request::Request<Vec<u8>> {
        builder
            .header(::http::header::CONTENT_LENGTH, body.len())
            .body(body)
            .expect("http request should be valid")
    }
}
#[cfg(test)]
#[allow(unreachable_code, unused_variables)]
mod recursive_shapes_request_test {

    use crate::model::RecursiveShapesInputOutputNested1;
    use crate::model::RecursiveShapesInputOutputNested2;
    use crate::operation::RecursiveShapesInput;
    /// Serializes recursive structures
    /// Test ID: RestJsonRecursiveShapes
    #[test]
    fn test_rest_json_recursive_shapes_request() {
        let input = RecursiveShapesInput::builder()
            .nested(
                RecursiveShapesInputOutputNested1::builder()
                    .foo("Foo1".to_string())
                    .nested(
                        RecursiveShapesInputOutputNested2::builder()
                            .bar("Bar1".to_string())
                            .recursive_member(
                                RecursiveShapesInputOutputNested1::builder()
                                    .foo("Foo2".to_string())
                                    .nested(
                                        RecursiveShapesInputOutputNested2::builder()
                                            .bar("Bar2".to_string())
                                            .build(),
                                    )
                                    .build(),
                            )
                            .build(),
                    )
                    .build(),
            )
            .build();
        let http_request = RecursiveShapesInput::assemble(input.request_builder_base(), vec![]);

        assert_eq!(http_request.method(), "PUT");
        assert_eq!(http_request.uri().path(), "/RecursiveShapes");

        let expected_headers = &[("Content-Type", "application/json")];
        ::protocol_test_helpers::assert_ok(::protocol_test_helpers::validate_headers(
            &http_request,
            expected_headers,
        ));
    }
    /// Serializes recursive structures
    /// Test ID: RestJsonRecursiveShapes
    #[test]
    fn test_rest_json_recursive_shapes_response() {
        /* test case disabled for this protocol (not yet supported) */
    }
}

impl SimpleScalarPropertiesInput {
    fn uri_base(&self, output: &mut String) {
        write!(output, "/SimpleScalarProperties").expect("formatting should succeed")
    }
    fn add_headers(&self, mut builder: ::http::request::Builder) -> ::http::request::Builder {
        if let Some(inner_92) = &self.foo {
            let formatted_93 = ::smithy_http::query::fmt_string(&inner_92);
            if !formatted_93.is_empty() {
                builder = builder.header("X-Foo", ::smithy_http::query::fmt_string(&inner_92));
            }
        }
        builder
    }
    fn update_http_builder(&self, builder: ::http::request::Builder) -> ::http::request::Builder {
        let mut uri = String::new();
        self.uri_base(&mut uri);
        let builder = self.add_headers(builder);
        builder.method("PUT").uri(uri)
    }
    pub fn request_builder_base(&self) -> ::http::request::Builder {
        let builder = ::http::request::Builder::new();
        let builder = builder.header("Content-Type", "application/json");
        self.update_http_builder(builder)
    }
    pub fn build_body(&self) -> Vec<u8> {
        todo!()
    }
    pub fn assemble(
        builder: ::http::request::Builder,
        body: Vec<u8>,
    ) -> ::http::request::Request<Vec<u8>> {
        builder
            .header(::http::header::CONTENT_LENGTH, body.len())
            .body(body)
            .expect("http request should be valid")
    }
}
#[cfg(test)]
#[allow(unreachable_code, unused_variables)]
mod simple_scalar_properties_request_test {

    use crate::operation::SimpleScalarPropertiesInput;
    /// Serializes simple scalar properties
    /// Test ID: RestJsonSimpleScalarProperties
    #[test]
    fn test_rest_json_simple_scalar_properties_request() {
        let input = SimpleScalarPropertiesInput::builder()
            .foo("Foo".to_string())
            .string_value("string".to_string())
            .true_boolean_value(true)
            .false_boolean_value(false)
            .byte_value(1)
            .short_value(2)
            .integer_value(3)
            .long_value(4)
            .float_value(5.5)
            .double_value(6.5)
            .build();
        let http_request =
            SimpleScalarPropertiesInput::assemble(input.request_builder_base(), vec![]);

        assert_eq!(http_request.method(), "PUT");
        assert_eq!(http_request.uri().path(), "/SimpleScalarProperties");

        let expected_headers = &[("Content-Type", "application/json"), ("X-Foo", "Foo")];
        ::protocol_test_helpers::assert_ok(::protocol_test_helpers::validate_headers(
            &http_request,
            expected_headers,
        ));
    }
    /// Rest Json should not serialize null structure values
    /// Test ID: RestJsonDoesntSerializeNullStructureValues
    #[test]
    fn test_rest_json_doesnt_serialize_null_structure_values_request() {
        let input = SimpleScalarPropertiesInput::builder().build();
        let http_request =
            SimpleScalarPropertiesInput::assemble(input.request_builder_base(), vec![]);

        assert_eq!(http_request.method(), "PUT");
        assert_eq!(http_request.uri().path(), "/SimpleScalarProperties");

        let expected_headers = &[("Content-Type", "application/json")];
        ::protocol_test_helpers::assert_ok(::protocol_test_helpers::validate_headers(
            &http_request,
            expected_headers,
        ));
    }
    /// Serializes simple scalar properties
    /// Test ID: RestJsonSimpleScalarProperties
    #[test]
    fn test_rest_json_simple_scalar_properties_response() {
        /* test case disabled for this protocol (not yet supported) */
    }
    /// Rest Json should not deserialize null structure values
    /// Test ID: RestJsonDoesntDeserializeNullStructureValues
    #[test]
    fn test_rest_json_doesnt_deserialize_null_structure_values_response() {
        /* test case disabled for this protocol (not yet supported) */
    }
}

impl StreamingTraitsInput {
    fn uri_base(&self, output: &mut String) {
        write!(output, "/StreamingTraits").expect("formatting should succeed")
    }
    fn add_headers(&self, mut builder: ::http::request::Builder) -> ::http::request::Builder {
        if let Some(inner_94) = &self.foo {
            let formatted_95 = ::smithy_http::query::fmt_string(&inner_94);
            if !formatted_95.is_empty() {
                builder = builder.header("X-Foo", ::smithy_http::query::fmt_string(&inner_94));
            }
        }
        builder
    }
    fn update_http_builder(&self, builder: ::http::request::Builder) -> ::http::request::Builder {
        let mut uri = String::new();
        self.uri_base(&mut uri);
        let builder = self.add_headers(builder);
        builder.method("POST").uri(uri)
    }
    pub fn request_builder_base(&self) -> ::http::request::Builder {
        let builder = ::http::request::Builder::new();
        let builder = builder.header("Content-Type", "application/octet-stream");
        self.update_http_builder(builder)
    }
    pub fn build_body(&self) -> Vec<u8> {
        todo!()
    }
    pub fn assemble(
        builder: ::http::request::Builder,
        body: Vec<u8>,
    ) -> ::http::request::Request<Vec<u8>> {
        builder
            .header(::http::header::CONTENT_LENGTH, body.len())
            .body(body)
            .expect("http request should be valid")
    }
}
#[cfg(test)]
#[allow(unreachable_code, unused_variables)]
mod streaming_traits_request_test {

    use crate::operation::StreamingTraitsInput;
    /// Serializes a blob in the HTTP payload
    /// Test ID: RestJsonStreamingTraitsWithBlob
    #[test]
    fn test_rest_json_streaming_traits_with_blob_request() {
        let input = StreamingTraitsInput::builder()
            .foo("Foo".to_string())
            .blob(::smithy_types::Blob::new("blobby blob blob"))
            .build();
        let http_request = StreamingTraitsInput::assemble(input.request_builder_base(), vec![]);

        assert_eq!(http_request.method(), "POST");
        assert_eq!(http_request.uri().path(), "/StreamingTraits");

        let expected_headers = &[
            ("Content-Type", "application/octet-stream"),
            ("X-Foo", "Foo"),
        ];
        ::protocol_test_helpers::assert_ok(::protocol_test_helpers::validate_headers(
            &http_request,
            expected_headers,
        ));
    }
    /// Serializes an empty blob in the HTTP payload
    /// Test ID: RestJsonStreamingTraitsWithNoBlobBody
    #[test]
    fn test_rest_json_streaming_traits_with_no_blob_body_request() {
        let input = StreamingTraitsInput::builder()
            .foo("Foo".to_string())
            .build();
        let http_request = StreamingTraitsInput::assemble(input.request_builder_base(), vec![]);

        assert_eq!(http_request.method(), "POST");
        assert_eq!(http_request.uri().path(), "/StreamingTraits");

        let expected_headers = &[("X-Foo", "Foo")];
        ::protocol_test_helpers::assert_ok(::protocol_test_helpers::validate_headers(
            &http_request,
            expected_headers,
        ));
    }
    /// Serializes a blob in the HTTP payload
    /// Test ID: RestJsonStreamingTraitsWithBlob
    #[test]
    fn test_rest_json_streaming_traits_with_blob_response() {
        /* test case disabled for this protocol (not yet supported) */
    }
    /// Serializes an empty blob in the HTTP payload
    /// Test ID: RestJsonStreamingTraitsWithNoBlobBody
    #[test]
    fn test_rest_json_streaming_traits_with_no_blob_body_response() {
        /* test case disabled for this protocol (not yet supported) */
    }
}

impl StreamingTraitsRequireLengthInput {
    fn uri_base(&self, output: &mut String) {
        write!(output, "/StreamingTraitsRequireLength").expect("formatting should succeed")
    }
    fn add_headers(&self, mut builder: ::http::request::Builder) -> ::http::request::Builder {
        if let Some(inner_96) = &self.foo {
            let formatted_97 = ::smithy_http::query::fmt_string(&inner_96);
            if !formatted_97.is_empty() {
                builder = builder.header("X-Foo", ::smithy_http::query::fmt_string(&inner_96));
            }
        }
        builder
    }
    fn update_http_builder(&self, builder: ::http::request::Builder) -> ::http::request::Builder {
        let mut uri = String::new();
        self.uri_base(&mut uri);
        let builder = self.add_headers(builder);
        builder.method("POST").uri(uri)
    }
    pub fn request_builder_base(&self) -> ::http::request::Builder {
        let builder = ::http::request::Builder::new();
        let builder = builder.header("Content-Type", "application/octet-stream");
        self.update_http_builder(builder)
    }
    pub fn build_body(&self) -> Vec<u8> {
        todo!()
    }
    pub fn assemble(
        builder: ::http::request::Builder,
        body: Vec<u8>,
    ) -> ::http::request::Request<Vec<u8>> {
        builder
            .header(::http::header::CONTENT_LENGTH, body.len())
            .body(body)
            .expect("http request should be valid")
    }
}
#[cfg(test)]
#[allow(unreachable_code, unused_variables)]
mod streaming_traits_require_length_request_test {

    use crate::operation::StreamingTraitsRequireLengthInput;
    /// Serializes a blob in the HTTP payload with a required length
    /// Test ID: RestJsonStreamingTraitsRequireLengthWithBlob
    #[test]
    fn test_rest_json_streaming_traits_require_length_with_blob_request() {
        let input = StreamingTraitsRequireLengthInput::builder()
            .foo("Foo".to_string())
            .blob(::smithy_types::Blob::new("blobby blob blob"))
            .build();
        let http_request =
            StreamingTraitsRequireLengthInput::assemble(input.request_builder_base(), vec![]);

        assert_eq!(http_request.method(), "POST");
        assert_eq!(http_request.uri().path(), "/StreamingTraitsRequireLength");

        let expected_headers = &[
            ("Content-Type", "application/octet-stream"),
            ("X-Foo", "Foo"),
        ];
        ::protocol_test_helpers::assert_ok(::protocol_test_helpers::validate_headers(
            &http_request,
            expected_headers,
        ));
        let required_headers = &["Content-Length"];
        ::protocol_test_helpers::assert_ok(::protocol_test_helpers::require_headers(
            &http_request,
            required_headers,
        ));
    }
    /// Serializes an empty blob in the HTTP payload
    /// Test ID: RestJsonStreamingTraitsRequireLengthWithNoBlobBody
    #[test]
    fn test_rest_json_streaming_traits_require_length_with_no_blob_body_request() {
        let input = StreamingTraitsRequireLengthInput::builder()
            .foo("Foo".to_string())
            .build();
        let http_request =
            StreamingTraitsRequireLengthInput::assemble(input.request_builder_base(), vec![]);

        assert_eq!(http_request.method(), "POST");
        assert_eq!(http_request.uri().path(), "/StreamingTraitsRequireLength");

        let expected_headers = &[("X-Foo", "Foo")];
        ::protocol_test_helpers::assert_ok(::protocol_test_helpers::validate_headers(
            &http_request,
            expected_headers,
        ));
    }
    /// Serializes a blob in the HTTP payload with a required length
    /// Test ID: RestJsonStreamingTraitsRequireLengthWithBlob
    #[test]
    fn test_rest_json_streaming_traits_require_length_with_blob_response() {
        /* test case disabled for this protocol (not yet supported) */
    }
    /// Serializes an empty blob in the HTTP payload
    /// Test ID: RestJsonStreamingTraitsRequireLengthWithNoBlobBody
    #[test]
    fn test_rest_json_streaming_traits_require_length_with_no_blob_body_response() {
        /* test case disabled for this protocol (not yet supported) */
    }
}

impl StreamingTraitsWithMediaTypeInput {
    fn uri_base(&self, output: &mut String) {
        write!(output, "/StreamingTraitsWithMediaType").expect("formatting should succeed")
    }
    fn add_headers(&self, mut builder: ::http::request::Builder) -> ::http::request::Builder {
        if let Some(inner_98) = &self.foo {
            let formatted_99 = ::smithy_http::query::fmt_string(&inner_98);
            if !formatted_99.is_empty() {
                builder = builder.header("X-Foo", ::smithy_http::query::fmt_string(&inner_98));
            }
        }
        builder
    }
    fn update_http_builder(&self, builder: ::http::request::Builder) -> ::http::request::Builder {
        let mut uri = String::new();
        self.uri_base(&mut uri);
        let builder = self.add_headers(builder);
        builder.method("POST").uri(uri)
    }
    pub fn request_builder_base(&self) -> ::http::request::Builder {
        let builder = ::http::request::Builder::new();
        let builder = builder.header("Content-Type", "text/plain");
        self.update_http_builder(builder)
    }
    pub fn build_body(&self) -> Vec<u8> {
        todo!()
    }
    pub fn assemble(
        builder: ::http::request::Builder,
        body: Vec<u8>,
    ) -> ::http::request::Request<Vec<u8>> {
        builder
            .header(::http::header::CONTENT_LENGTH, body.len())
            .body(body)
            .expect("http request should be valid")
    }
}
#[cfg(test)]
#[allow(unreachable_code, unused_variables)]
mod streaming_traits_with_media_type_request_test {

    use crate::operation::StreamingTraitsWithMediaTypeInput;
    /// Serializes a blob in the HTTP payload with a content-type
    /// Test ID: RestJsonStreamingTraitsWithMediaTypeWithBlob
    #[test]
    fn test_rest_json_streaming_traits_with_media_type_with_blob_request() {
        let input = StreamingTraitsWithMediaTypeInput::builder()
            .foo("Foo".to_string())
            .blob(::smithy_types::Blob::new("blobby blob blob"))
            .build();
        let http_request =
            StreamingTraitsWithMediaTypeInput::assemble(input.request_builder_base(), vec![]);

        assert_eq!(http_request.method(), "POST");
        assert_eq!(http_request.uri().path(), "/StreamingTraitsWithMediaType");

        let expected_headers = &[("Content-Type", "text/plain"), ("X-Foo", "Foo")];
        ::protocol_test_helpers::assert_ok(::protocol_test_helpers::validate_headers(
            &http_request,
            expected_headers,
        ));
    }
    /// Serializes a blob in the HTTP payload with a content-type
    /// Test ID: RestJsonStreamingTraitsWithMediaTypeWithBlob
    #[test]
    fn test_rest_json_streaming_traits_with_media_type_with_blob_response() {
        /* test case disabled for this protocol (not yet supported) */
    }
}

impl TimestampFormatHeadersInput {
    fn uri_base(&self, output: &mut String) {
        write!(output, "/TimestampFormatHeaders").expect("formatting should succeed")
    }
    fn add_headers(&self, mut builder: ::http::request::Builder) -> ::http::request::Builder {
        if let Some(inner_100) = &self.member_epoch_seconds {
            let formatted_101 = inner_100.fmt(::smithy_types::instant::Format::EpochSeconds);
            if !formatted_101.is_empty() {
                builder = builder.header(
                    "X-memberEpochSeconds",
                    inner_100.fmt(::smithy_types::instant::Format::EpochSeconds),
                );
            }
        }
        if let Some(inner_102) = &self.member_http_date {
            let formatted_103 = inner_102.fmt(::smithy_types::instant::Format::HttpDate);
            if !formatted_103.is_empty() {
                builder = builder.header(
                    "X-memberHttpDate",
                    inner_102.fmt(::smithy_types::instant::Format::HttpDate),
                );
            }
        }
        if let Some(inner_104) = &self.member_date_time {
            let formatted_105 = inner_104.fmt(::smithy_types::instant::Format::DateTime);
            if !formatted_105.is_empty() {
                builder = builder.header(
                    "X-memberDateTime",
                    inner_104.fmt(::smithy_types::instant::Format::DateTime),
                );
            }
        }
        if let Some(inner_106) = &self.default_format {
            let formatted_107 = inner_106.fmt(::smithy_types::instant::Format::HttpDate);
            if !formatted_107.is_empty() {
                builder = builder.header(
                    "X-defaultFormat",
                    inner_106.fmt(::smithy_types::instant::Format::HttpDate),
                );
            }
        }
        if let Some(inner_108) = &self.target_epoch_seconds {
            let formatted_109 = inner_108.fmt(::smithy_types::instant::Format::EpochSeconds);
            if !formatted_109.is_empty() {
                builder = builder.header(
                    "X-targetEpochSeconds",
                    inner_108.fmt(::smithy_types::instant::Format::EpochSeconds),
                );
            }
        }
        if let Some(inner_110) = &self.target_http_date {
            let formatted_111 = inner_110.fmt(::smithy_types::instant::Format::HttpDate);
            if !formatted_111.is_empty() {
                builder = builder.header(
                    "X-targetHttpDate",
                    inner_110.fmt(::smithy_types::instant::Format::HttpDate),
                );
            }
        }
        if let Some(inner_112) = &self.target_date_time {
            let formatted_113 = inner_112.fmt(::smithy_types::instant::Format::DateTime);
            if !formatted_113.is_empty() {
                builder = builder.header(
                    "X-targetDateTime",
                    inner_112.fmt(::smithy_types::instant::Format::DateTime),
                );
            }
        }
        builder
    }
    fn update_http_builder(&self, builder: ::http::request::Builder) -> ::http::request::Builder {
        let mut uri = String::new();
        self.uri_base(&mut uri);
        let builder = self.add_headers(builder);
        builder.method("POST").uri(uri)
    }
    pub fn request_builder_base(&self) -> ::http::request::Builder {
        let builder = ::http::request::Builder::new();
        let builder = builder.header("Content-Type", "application/json");
        self.update_http_builder(builder)
    }
    pub fn build_body(&self) -> Vec<u8> {
        todo!()
    }
    pub fn assemble(
        builder: ::http::request::Builder,
        body: Vec<u8>,
    ) -> ::http::request::Request<Vec<u8>> {
        builder
            .header(::http::header::CONTENT_LENGTH, body.len())
            .body(body)
            .expect("http request should be valid")
    }
}
#[cfg(test)]
#[allow(unreachable_code, unused_variables)]
mod timestamp_format_headers_request_test {

    use crate::operation::TimestampFormatHeadersInput;
    /// Tests how timestamp request headers are serialized
    /// Test ID: RestJsonTimestampFormatHeaders
    #[test]
    fn test_rest_json_timestamp_format_headers_request() {
        let input = TimestampFormatHeadersInput::builder()
            .member_epoch_seconds(::smithy_types::Instant::from_epoch_seconds(1576540098))
            .member_http_date(::smithy_types::Instant::from_epoch_seconds(1576540098))
            .member_date_time(::smithy_types::Instant::from_epoch_seconds(1576540098))
            .default_format(::smithy_types::Instant::from_epoch_seconds(1576540098))
            .target_epoch_seconds(::smithy_types::Instant::from_epoch_seconds(1576540098))
            .target_http_date(::smithy_types::Instant::from_epoch_seconds(1576540098))
            .target_date_time(::smithy_types::Instant::from_epoch_seconds(1576540098))
            .build();
        let http_request =
            TimestampFormatHeadersInput::assemble(input.request_builder_base(), vec![]);

        assert_eq!(http_request.method(), "POST");
        assert_eq!(http_request.uri().path(), "/TimestampFormatHeaders");

        let expected_headers = &[
            ("X-defaultFormat", "Mon, 16 Dec 2019 23:48:18 GMT"),
            ("X-memberDateTime", "2019-12-16T23:48:18Z"),
            ("X-memberEpochSeconds", "1576540098"),
            ("X-memberHttpDate", "Mon, 16 Dec 2019 23:48:18 GMT"),
            ("X-targetDateTime", "2019-12-16T23:48:18Z"),
            ("X-targetEpochSeconds", "1576540098"),
            ("X-targetHttpDate", "Mon, 16 Dec 2019 23:48:18 GMT"),
        ];
        ::protocol_test_helpers::assert_ok(::protocol_test_helpers::validate_headers(
            &http_request,
            expected_headers,
        ));
    }
    /// Tests how timestamp response headers are serialized
    /// Test ID: RestJsonTimestampFormatHeaders
    #[test]
    fn test_rest_json_timestamp_format_headers_response() {
        /* test case disabled for this protocol (not yet supported) */
    }
}

/// A shared structure that contains a single union member.
#[non_exhaustive]
#[derive(::std::clone::Clone, ::std::cmp::PartialEq, ::std::fmt::Debug)]
pub struct JsonUnionsOutput {
    /// A union with a representative set of types for members.
    pub contents: Option<MyUnion>,
}
impl JsonUnionsOutput {
    /// Creates a new builder-style object to manufacture [`JsonUnionsOutput`](crate::operation::JsonUnionsOutput)
    pub fn builder() -> crate::operation::json_unions_output::Builder {
        crate::operation::json_unions_output::Builder::default()
    }
}
/// See [`JsonUnionsOutput`](crate::operation::JsonUnionsOutput)
pub mod json_unions_output {

    use crate::model::MyUnion;
    use crate::operation::JsonUnionsOutput;
    /// A builder for [`JsonUnionsOutput`](crate::operation::JsonUnionsOutput)
    #[non_exhaustive]
    #[derive(Debug, Clone, Default)]
    pub struct Builder {
        contents: Option<MyUnion>,
    }
    impl Builder {
        /// A union with a representative set of types for members.
        pub fn contents(mut self, inp: MyUnion) -> Self {
            self.contents = Some(inp);
            self
        }
        /// Consumes the builder and constructs a [`JsonUnionsOutput`](crate::operation::JsonUnionsOutput)
        pub fn build(self) -> JsonUnionsOutput {
            JsonUnionsOutput {
                contents: self.contents,
            }
        }
    }
}

/// A shared structure that contains a single union member.
#[non_exhaustive]
#[derive(::std::clone::Clone, ::std::cmp::PartialEq, ::std::fmt::Debug)]
pub struct JsonUnionsInput {
    /// A union with a representative set of types for members.
    pub contents: Option<MyUnion>,
}
impl JsonUnionsInput {
    /// Creates a new builder-style object to manufacture [`JsonUnionsInput`](crate::operation::JsonUnionsInput)
    pub fn builder() -> crate::operation::json_unions_input::Builder {
        crate::operation::json_unions_input::Builder::default()
    }
}
/// See [`JsonUnionsInput`](crate::operation::JsonUnionsInput)
pub mod json_unions_input {

    use crate::model::MyUnion;
    use crate::operation::JsonUnionsInput;
    /// A builder for [`JsonUnionsInput`](crate::operation::JsonUnionsInput)
    #[non_exhaustive]
    #[derive(Debug, Clone, Default)]
    pub struct Builder {
        contents: Option<MyUnion>,
    }
    impl Builder {
        /// A union with a representative set of types for members.
        pub fn contents(mut self, inp: MyUnion) -> Self {
            self.contents = Some(inp);
            self
        }
        /// Consumes the builder and constructs a [`JsonUnionsInput`](crate::operation::JsonUnionsInput)
        pub fn build(self) -> JsonUnionsInput {
            JsonUnionsInput {
                contents: self.contents,
            }
        }
    }
}

#[non_exhaustive]
#[derive(::std::clone::Clone, ::std::cmp::PartialEq, ::std::fmt::Debug)]
pub struct InlineDocumentAsPayloadOutput {
    pub document_value: Document,
}
impl InlineDocumentAsPayloadOutput {
    /// Creates a new builder-style object to manufacture [`InlineDocumentAsPayloadOutput`](crate::operation::InlineDocumentAsPayloadOutput)
    pub fn builder() -> crate::operation::inline_document_as_payload_output::Builder {
        crate::operation::inline_document_as_payload_output::Builder::default()
    }
}
/// See [`InlineDocumentAsPayloadOutput`](crate::operation::InlineDocumentAsPayloadOutput)
pub mod inline_document_as_payload_output {

    use crate::operation::InlineDocumentAsPayloadOutput;
    use smithy_types::Document;
    /// A builder for [`InlineDocumentAsPayloadOutput`](crate::operation::InlineDocumentAsPayloadOutput)
    #[non_exhaustive]
    #[derive(Debug, Clone, Default)]
    pub struct Builder {
        document_value: Option<Document>,
    }
    impl Builder {
        pub fn document_value(mut self, inp: Document) -> Self {
            self.document_value = Some(inp);
            self
        }
        /// Consumes the builder and constructs a [`InlineDocumentAsPayloadOutput`](crate::operation::InlineDocumentAsPayloadOutput)
        pub fn build(self) -> Result<InlineDocumentAsPayloadOutput, String> {
            Ok(InlineDocumentAsPayloadOutput {
                document_value: self.document_value.ok_or(
                    "document_value is required when building InlineDocumentAsPayloadOutput",
                )?,
            })
        }
    }
}

#[non_exhaustive]
#[derive(::std::clone::Clone, ::std::cmp::PartialEq, ::std::fmt::Debug)]
pub struct InlineDocumentAsPayloadInput {
    pub document_value: Document,
}
impl InlineDocumentAsPayloadInput {
    /// Creates a new builder-style object to manufacture [`InlineDocumentAsPayloadInput`](crate::operation::InlineDocumentAsPayloadInput)
    pub fn builder() -> crate::operation::inline_document_as_payload_input::Builder {
        crate::operation::inline_document_as_payload_input::Builder::default()
    }
}
/// See [`InlineDocumentAsPayloadInput`](crate::operation::InlineDocumentAsPayloadInput)
pub mod inline_document_as_payload_input {

    use crate::operation::InlineDocumentAsPayloadInput;
    use smithy_types::Document;
    /// A builder for [`InlineDocumentAsPayloadInput`](crate::operation::InlineDocumentAsPayloadInput)
    #[non_exhaustive]
    #[derive(Debug, Clone, Default)]
    pub struct Builder {
        document_value: Option<Document>,
    }
    impl Builder {
        pub fn document_value(mut self, inp: Document) -> Self {
            self.document_value = Some(inp);
            self
        }
        /// Consumes the builder and constructs a [`InlineDocumentAsPayloadInput`](crate::operation::InlineDocumentAsPayloadInput)
        pub fn build(self) -> Result<InlineDocumentAsPayloadInput, String> {
            Ok(InlineDocumentAsPayloadInput {
                document_value: self.document_value.ok_or(
                    "document_value is required when building InlineDocumentAsPayloadInput",
                )?,
            })
        }
    }
}

#[non_exhaustive]
#[derive(::std::clone::Clone, ::std::cmp::PartialEq, ::std::fmt::Debug)]
pub struct InlineDocumentOutput {
    pub string_value: Option<String>,
    pub document_value: Document,
}
impl InlineDocumentOutput {
    /// Creates a new builder-style object to manufacture [`InlineDocumentOutput`](crate::operation::InlineDocumentOutput)
    pub fn builder() -> crate::operation::inline_document_output::Builder {
        crate::operation::inline_document_output::Builder::default()
    }
}
/// See [`InlineDocumentOutput`](crate::operation::InlineDocumentOutput)
pub mod inline_document_output {

    use crate::operation::InlineDocumentOutput;
    use smithy_types::Document;
    /// A builder for [`InlineDocumentOutput`](crate::operation::InlineDocumentOutput)
    #[non_exhaustive]
    #[derive(Debug, Clone, Default)]
    pub struct Builder {
        string_value: Option<String>,
        document_value: Option<Document>,
    }
    impl Builder {
        pub fn string_value(mut self, inp: impl Into<String>) -> Self {
            self.string_value = Some(inp.into());
            self
        }
        pub fn document_value(mut self, inp: Document) -> Self {
            self.document_value = Some(inp);
            self
        }
        /// Consumes the builder and constructs a [`InlineDocumentOutput`](crate::operation::InlineDocumentOutput)
        pub fn build(self) -> Result<InlineDocumentOutput, String> {
            Ok(InlineDocumentOutput {
                string_value: self.string_value,
                document_value: self
                    .document_value
                    .ok_or("document_value is required when building InlineDocumentOutput")?,
            })
        }
    }
}

#[non_exhaustive]
#[derive(::std::clone::Clone, ::std::cmp::PartialEq, ::std::fmt::Debug)]
pub struct InlineDocumentInput {
    pub string_value: Option<String>,
    pub document_value: Document,
}
impl InlineDocumentInput {
    /// Creates a new builder-style object to manufacture [`InlineDocumentInput`](crate::operation::InlineDocumentInput)
    pub fn builder() -> crate::operation::inline_document_input::Builder {
        crate::operation::inline_document_input::Builder::default()
    }
}
/// See [`InlineDocumentInput`](crate::operation::InlineDocumentInput)
pub mod inline_document_input {

    use crate::operation::InlineDocumentInput;
    use smithy_types::Document;
    /// A builder for [`InlineDocumentInput`](crate::operation::InlineDocumentInput)
    #[non_exhaustive]
    #[derive(Debug, Clone, Default)]
    pub struct Builder {
        string_value: Option<String>,
        document_value: Option<Document>,
    }
    impl Builder {
        pub fn string_value(mut self, inp: impl Into<String>) -> Self {
            self.string_value = Some(inp.into());
            self
        }
        pub fn document_value(mut self, inp: Document) -> Self {
            self.document_value = Some(inp);
            self
        }
        /// Consumes the builder and constructs a [`InlineDocumentInput`](crate::operation::InlineDocumentInput)
        pub fn build(self) -> Result<InlineDocumentInput, String> {
            Ok(InlineDocumentInput {
                string_value: self.string_value,
                document_value: self
                    .document_value
                    .ok_or("document_value is required when building InlineDocumentInput")?,
            })
        }
    }
}

#[non_exhaustive]
#[derive(::std::clone::Clone, ::std::cmp::PartialEq, ::std::fmt::Debug)]
pub struct JsonBlobsOutput {
    pub data: Option<Blob>,
}
impl JsonBlobsOutput {
    /// Creates a new builder-style object to manufacture [`JsonBlobsOutput`](crate::operation::JsonBlobsOutput)
    pub fn builder() -> crate::operation::json_blobs_output::Builder {
        crate::operation::json_blobs_output::Builder::default()
    }
}
/// See [`JsonBlobsOutput`](crate::operation::JsonBlobsOutput)
pub mod json_blobs_output {

    use crate::operation::JsonBlobsOutput;
    use smithy_types::Blob;
    /// A builder for [`JsonBlobsOutput`](crate::operation::JsonBlobsOutput)
    #[non_exhaustive]
    #[derive(Debug, Clone, Default)]
    pub struct Builder {
        data: Option<Blob>,
    }
    impl Builder {
        pub fn data(mut self, inp: Blob) -> Self {
            self.data = Some(inp);
            self
        }
        /// Consumes the builder and constructs a [`JsonBlobsOutput`](crate::operation::JsonBlobsOutput)
        pub fn build(self) -> JsonBlobsOutput {
            JsonBlobsOutput { data: self.data }
        }
    }
}

#[non_exhaustive]
#[derive(::std::clone::Clone, ::std::cmp::PartialEq, ::std::fmt::Debug)]
pub struct JsonBlobsInput {
    pub data: Option<Blob>,
}
impl JsonBlobsInput {
    /// Creates a new builder-style object to manufacture [`JsonBlobsInput`](crate::operation::JsonBlobsInput)
    pub fn builder() -> crate::operation::json_blobs_input::Builder {
        crate::operation::json_blobs_input::Builder::default()
    }
}
/// See [`JsonBlobsInput`](crate::operation::JsonBlobsInput)
pub mod json_blobs_input {

    use crate::operation::JsonBlobsInput;
    use smithy_types::Blob;
    /// A builder for [`JsonBlobsInput`](crate::operation::JsonBlobsInput)
    #[non_exhaustive]
    #[derive(Debug, Clone, Default)]
    pub struct Builder {
        data: Option<Blob>,
    }
    impl Builder {
        pub fn data(mut self, inp: Blob) -> Self {
            self.data = Some(inp);
            self
        }
        /// Consumes the builder and constructs a [`JsonBlobsInput`](crate::operation::JsonBlobsInput)
        pub fn build(self) -> JsonBlobsInput {
            JsonBlobsInput { data: self.data }
        }
    }
}

#[non_exhaustive]
#[derive(::std::clone::Clone, ::std::cmp::PartialEq, ::std::fmt::Debug)]
pub struct JsonMapsOutput {
    pub dense_struct_map: Option<HashMap<String, GreetingStruct>>,
    pub sparse_struct_map: Option<HashMap<String, Option<GreetingStruct>>>,
    pub dense_number_map: Option<HashMap<String, i32>>,
    pub dense_boolean_map: Option<HashMap<String, bool>>,
    pub dense_string_map: Option<HashMap<String, String>>,
    pub sparse_number_map: Option<HashMap<String, Option<i32>>>,
    pub sparse_boolean_map: Option<HashMap<String, Option<bool>>>,
    pub sparse_string_map: Option<HashMap<String, Option<String>>>,
}
impl JsonMapsOutput {
    /// Creates a new builder-style object to manufacture [`JsonMapsOutput`](crate::operation::JsonMapsOutput)
    pub fn builder() -> crate::operation::json_maps_output::Builder {
        crate::operation::json_maps_output::Builder::default()
    }
}
/// See [`JsonMapsOutput`](crate::operation::JsonMapsOutput)
pub mod json_maps_output {

    use crate::model::GreetingStruct;
    use crate::operation::JsonMapsOutput;
    use std::collections::HashMap;
    /// A builder for [`JsonMapsOutput`](crate::operation::JsonMapsOutput)
    #[non_exhaustive]
    #[derive(Debug, Clone, Default)]
    pub struct Builder {
        dense_struct_map: Option<HashMap<String, GreetingStruct>>,
        sparse_struct_map: Option<HashMap<String, Option<GreetingStruct>>>,
        dense_number_map: Option<HashMap<String, i32>>,
        dense_boolean_map: Option<HashMap<String, bool>>,
        dense_string_map: Option<HashMap<String, String>>,
        sparse_number_map: Option<HashMap<String, Option<i32>>>,
        sparse_boolean_map: Option<HashMap<String, Option<bool>>>,
        sparse_string_map: Option<HashMap<String, Option<String>>>,
    }
    impl Builder {
        pub fn dense_struct_map(mut self, inp: HashMap<String, GreetingStruct>) -> Self {
            self.dense_struct_map = Some(inp);
            self
        }
        pub fn sparse_struct_map(mut self, inp: HashMap<String, Option<GreetingStruct>>) -> Self {
            self.sparse_struct_map = Some(inp);
            self
        }
        pub fn dense_number_map(mut self, inp: HashMap<String, i32>) -> Self {
            self.dense_number_map = Some(inp);
            self
        }
        pub fn dense_boolean_map(mut self, inp: HashMap<String, bool>) -> Self {
            self.dense_boolean_map = Some(inp);
            self
        }
        pub fn dense_string_map(mut self, inp: HashMap<String, String>) -> Self {
            self.dense_string_map = Some(inp);
            self
        }
        pub fn sparse_number_map(mut self, inp: HashMap<String, Option<i32>>) -> Self {
            self.sparse_number_map = Some(inp);
            self
        }
        pub fn sparse_boolean_map(mut self, inp: HashMap<String, Option<bool>>) -> Self {
            self.sparse_boolean_map = Some(inp);
            self
        }
        pub fn sparse_string_map(mut self, inp: HashMap<String, Option<String>>) -> Self {
            self.sparse_string_map = Some(inp);
            self
        }
        /// Consumes the builder and constructs a [`JsonMapsOutput`](crate::operation::JsonMapsOutput)
        pub fn build(self) -> JsonMapsOutput {
            JsonMapsOutput {
                dense_struct_map: self.dense_struct_map,
                sparse_struct_map: self.sparse_struct_map,
                dense_number_map: self.dense_number_map,
                dense_boolean_map: self.dense_boolean_map,
                dense_string_map: self.dense_string_map,
                sparse_number_map: self.sparse_number_map,
                sparse_boolean_map: self.sparse_boolean_map,
                sparse_string_map: self.sparse_string_map,
            }
        }
    }
}

#[non_exhaustive]
#[derive(::std::clone::Clone, ::std::cmp::PartialEq, ::std::fmt::Debug)]
pub struct JsonMapsInput {
    pub dense_struct_map: Option<HashMap<String, GreetingStruct>>,
    pub sparse_struct_map: Option<HashMap<String, Option<GreetingStruct>>>,
    pub dense_number_map: Option<HashMap<String, i32>>,
    pub dense_boolean_map: Option<HashMap<String, bool>>,
    pub dense_string_map: Option<HashMap<String, String>>,
    pub sparse_number_map: Option<HashMap<String, Option<i32>>>,
    pub sparse_boolean_map: Option<HashMap<String, Option<bool>>>,
    pub sparse_string_map: Option<HashMap<String, Option<String>>>,
}
impl JsonMapsInput {
    /// Creates a new builder-style object to manufacture [`JsonMapsInput`](crate::operation::JsonMapsInput)
    pub fn builder() -> crate::operation::json_maps_input::Builder {
        crate::operation::json_maps_input::Builder::default()
    }
}
/// See [`JsonMapsInput`](crate::operation::JsonMapsInput)
pub mod json_maps_input {

    use crate::model::GreetingStruct;
    use crate::operation::JsonMapsInput;
    use std::collections::HashMap;
    /// A builder for [`JsonMapsInput`](crate::operation::JsonMapsInput)
    #[non_exhaustive]
    #[derive(Debug, Clone, Default)]
    pub struct Builder {
        dense_struct_map: Option<HashMap<String, GreetingStruct>>,
        sparse_struct_map: Option<HashMap<String, Option<GreetingStruct>>>,
        dense_number_map: Option<HashMap<String, i32>>,
        dense_boolean_map: Option<HashMap<String, bool>>,
        dense_string_map: Option<HashMap<String, String>>,
        sparse_number_map: Option<HashMap<String, Option<i32>>>,
        sparse_boolean_map: Option<HashMap<String, Option<bool>>>,
        sparse_string_map: Option<HashMap<String, Option<String>>>,
    }
    impl Builder {
        pub fn dense_struct_map(mut self, inp: HashMap<String, GreetingStruct>) -> Self {
            self.dense_struct_map = Some(inp);
            self
        }
        pub fn sparse_struct_map(mut self, inp: HashMap<String, Option<GreetingStruct>>) -> Self {
            self.sparse_struct_map = Some(inp);
            self
        }
        pub fn dense_number_map(mut self, inp: HashMap<String, i32>) -> Self {
            self.dense_number_map = Some(inp);
            self
        }
        pub fn dense_boolean_map(mut self, inp: HashMap<String, bool>) -> Self {
            self.dense_boolean_map = Some(inp);
            self
        }
        pub fn dense_string_map(mut self, inp: HashMap<String, String>) -> Self {
            self.dense_string_map = Some(inp);
            self
        }
        pub fn sparse_number_map(mut self, inp: HashMap<String, Option<i32>>) -> Self {
            self.sparse_number_map = Some(inp);
            self
        }
        pub fn sparse_boolean_map(mut self, inp: HashMap<String, Option<bool>>) -> Self {
            self.sparse_boolean_map = Some(inp);
            self
        }
        pub fn sparse_string_map(mut self, inp: HashMap<String, Option<String>>) -> Self {
            self.sparse_string_map = Some(inp);
            self
        }
        /// Consumes the builder and constructs a [`JsonMapsInput`](crate::operation::JsonMapsInput)
        pub fn build(self) -> JsonMapsInput {
            JsonMapsInput {
                dense_struct_map: self.dense_struct_map,
                sparse_struct_map: self.sparse_struct_map,
                dense_number_map: self.dense_number_map,
                dense_boolean_map: self.dense_boolean_map,
                dense_string_map: self.dense_string_map,
                sparse_number_map: self.sparse_number_map,
                sparse_boolean_map: self.sparse_boolean_map,
                sparse_string_map: self.sparse_string_map,
            }
        }
    }
}

#[non_exhaustive]
#[derive(::std::clone::Clone, ::std::cmp::PartialEq, ::std::fmt::Debug)]
pub struct JsonListsOutput {
    pub string_list: Option<Vec<String>>,
    pub sparse_string_list: Option<Vec<Option<String>>>,
    pub string_set: Option<BTreeSet<String>>,
    pub integer_list: Option<Vec<i32>>,
    pub boolean_list: Option<Vec<bool>>,
    pub timestamp_list: Option<Vec<Instant>>,
    pub enum_list: Option<Vec<FooEnum>>,
    /// A list of lists of strings.
    pub nested_string_list: Option<Vec<Vec<String>>>,
    pub structure_list: Option<Vec<StructureListMember>>,
}
impl JsonListsOutput {
    /// Creates a new builder-style object to manufacture [`JsonListsOutput`](crate::operation::JsonListsOutput)
    pub fn builder() -> crate::operation::json_lists_output::Builder {
        crate::operation::json_lists_output::Builder::default()
    }
}
/// See [`JsonListsOutput`](crate::operation::JsonListsOutput)
pub mod json_lists_output {

    use crate::model::FooEnum;
    use crate::model::StructureListMember;
    use crate::operation::JsonListsOutput;
    use smithy_types::Instant;
    use std::collections::BTreeSet;
    /// A builder for [`JsonListsOutput`](crate::operation::JsonListsOutput)
    #[non_exhaustive]
    #[derive(Debug, Clone, Default)]
    pub struct Builder {
        string_list: Option<Vec<String>>,
        sparse_string_list: Option<Vec<Option<String>>>,
        string_set: Option<BTreeSet<String>>,
        integer_list: Option<Vec<i32>>,
        boolean_list: Option<Vec<bool>>,
        timestamp_list: Option<Vec<Instant>>,
        enum_list: Option<Vec<FooEnum>>,
        nested_string_list: Option<Vec<Vec<String>>>,
        structure_list: Option<Vec<StructureListMember>>,
    }
    impl Builder {
        pub fn string_list(mut self, inp: Vec<String>) -> Self {
            self.string_list = Some(inp);
            self
        }
        pub fn sparse_string_list(mut self, inp: Vec<Option<String>>) -> Self {
            self.sparse_string_list = Some(inp);
            self
        }
        pub fn string_set(mut self, inp: BTreeSet<String>) -> Self {
            self.string_set = Some(inp);
            self
        }
        pub fn integer_list(mut self, inp: Vec<i32>) -> Self {
            self.integer_list = Some(inp);
            self
        }
        pub fn boolean_list(mut self, inp: Vec<bool>) -> Self {
            self.boolean_list = Some(inp);
            self
        }
        pub fn timestamp_list(mut self, inp: Vec<Instant>) -> Self {
            self.timestamp_list = Some(inp);
            self
        }
        pub fn enum_list(mut self, inp: Vec<FooEnum>) -> Self {
            self.enum_list = Some(inp);
            self
        }
        /// A list of lists of strings.
        pub fn nested_string_list(mut self, inp: Vec<Vec<String>>) -> Self {
            self.nested_string_list = Some(inp);
            self
        }
        pub fn structure_list(mut self, inp: Vec<StructureListMember>) -> Self {
            self.structure_list = Some(inp);
            self
        }
        /// Consumes the builder and constructs a [`JsonListsOutput`](crate::operation::JsonListsOutput)
        pub fn build(self) -> JsonListsOutput {
            JsonListsOutput {
                string_list: self.string_list,
                sparse_string_list: self.sparse_string_list,
                string_set: self.string_set,
                integer_list: self.integer_list,
                boolean_list: self.boolean_list,
                timestamp_list: self.timestamp_list,
                enum_list: self.enum_list,
                nested_string_list: self.nested_string_list,
                structure_list: self.structure_list,
            }
        }
    }
}

#[non_exhaustive]
#[derive(::std::clone::Clone, ::std::cmp::PartialEq, ::std::fmt::Debug)]
pub struct JsonListsInput {
    pub string_list: Option<Vec<String>>,
    pub sparse_string_list: Option<Vec<Option<String>>>,
    pub string_set: Option<BTreeSet<String>>,
    pub integer_list: Option<Vec<i32>>,
    pub boolean_list: Option<Vec<bool>>,
    pub timestamp_list: Option<Vec<Instant>>,
    pub enum_list: Option<Vec<FooEnum>>,
    /// A list of lists of strings.
    pub nested_string_list: Option<Vec<Vec<String>>>,
    pub structure_list: Option<Vec<StructureListMember>>,
}
impl JsonListsInput {
    /// Creates a new builder-style object to manufacture [`JsonListsInput`](crate::operation::JsonListsInput)
    pub fn builder() -> crate::operation::json_lists_input::Builder {
        crate::operation::json_lists_input::Builder::default()
    }
}
/// See [`JsonListsInput`](crate::operation::JsonListsInput)
pub mod json_lists_input {

    use crate::model::FooEnum;
    use crate::model::StructureListMember;
    use crate::operation::JsonListsInput;
    use smithy_types::Instant;
    use std::collections::BTreeSet;
    /// A builder for [`JsonListsInput`](crate::operation::JsonListsInput)
    #[non_exhaustive]
    #[derive(Debug, Clone, Default)]
    pub struct Builder {
        string_list: Option<Vec<String>>,
        sparse_string_list: Option<Vec<Option<String>>>,
        string_set: Option<BTreeSet<String>>,
        integer_list: Option<Vec<i32>>,
        boolean_list: Option<Vec<bool>>,
        timestamp_list: Option<Vec<Instant>>,
        enum_list: Option<Vec<FooEnum>>,
        nested_string_list: Option<Vec<Vec<String>>>,
        structure_list: Option<Vec<StructureListMember>>,
    }
    impl Builder {
        pub fn string_list(mut self, inp: Vec<String>) -> Self {
            self.string_list = Some(inp);
            self
        }
        pub fn sparse_string_list(mut self, inp: Vec<Option<String>>) -> Self {
            self.sparse_string_list = Some(inp);
            self
        }
        pub fn string_set(mut self, inp: BTreeSet<String>) -> Self {
            self.string_set = Some(inp);
            self
        }
        pub fn integer_list(mut self, inp: Vec<i32>) -> Self {
            self.integer_list = Some(inp);
            self
        }
        pub fn boolean_list(mut self, inp: Vec<bool>) -> Self {
            self.boolean_list = Some(inp);
            self
        }
        pub fn timestamp_list(mut self, inp: Vec<Instant>) -> Self {
            self.timestamp_list = Some(inp);
            self
        }
        pub fn enum_list(mut self, inp: Vec<FooEnum>) -> Self {
            self.enum_list = Some(inp);
            self
        }
        /// A list of lists of strings.
        pub fn nested_string_list(mut self, inp: Vec<Vec<String>>) -> Self {
            self.nested_string_list = Some(inp);
            self
        }
        pub fn structure_list(mut self, inp: Vec<StructureListMember>) -> Self {
            self.structure_list = Some(inp);
            self
        }
        /// Consumes the builder and constructs a [`JsonListsInput`](crate::operation::JsonListsInput)
        pub fn build(self) -> JsonListsInput {
            JsonListsInput {
                string_list: self.string_list,
                sparse_string_list: self.sparse_string_list,
                string_set: self.string_set,
                integer_list: self.integer_list,
                boolean_list: self.boolean_list,
                timestamp_list: self.timestamp_list,
                enum_list: self.enum_list,
                nested_string_list: self.nested_string_list,
                structure_list: self.structure_list,
            }
        }
    }
}

#[non_exhaustive]
#[derive(::std::clone::Clone, ::std::cmp::PartialEq, ::std::fmt::Debug)]
pub struct RecursiveShapesOutput {
    pub nested: Option<RecursiveShapesInputOutputNested1>,
}
impl RecursiveShapesOutput {
    /// Creates a new builder-style object to manufacture [`RecursiveShapesOutput`](crate::operation::RecursiveShapesOutput)
    pub fn builder() -> crate::operation::recursive_shapes_output::Builder {
        crate::operation::recursive_shapes_output::Builder::default()
    }
}
/// See [`RecursiveShapesOutput`](crate::operation::RecursiveShapesOutput)
pub mod recursive_shapes_output {

    use crate::model::RecursiveShapesInputOutputNested1;
    use crate::operation::RecursiveShapesOutput;
    /// A builder for [`RecursiveShapesOutput`](crate::operation::RecursiveShapesOutput)
    #[non_exhaustive]
    #[derive(Debug, Clone, Default)]
    pub struct Builder {
        nested: Option<RecursiveShapesInputOutputNested1>,
    }
    impl Builder {
        pub fn nested(mut self, inp: RecursiveShapesInputOutputNested1) -> Self {
            self.nested = Some(inp);
            self
        }
        /// Consumes the builder and constructs a [`RecursiveShapesOutput`](crate::operation::RecursiveShapesOutput)
        pub fn build(self) -> RecursiveShapesOutput {
            RecursiveShapesOutput {
                nested: self.nested,
            }
        }
    }
}

#[non_exhaustive]
#[derive(::std::clone::Clone, ::std::cmp::PartialEq, ::std::fmt::Debug)]
pub struct RecursiveShapesInput {
    pub nested: Option<RecursiveShapesInputOutputNested1>,
}
impl RecursiveShapesInput {
    /// Creates a new builder-style object to manufacture [`RecursiveShapesInput`](crate::operation::RecursiveShapesInput)
    pub fn builder() -> crate::operation::recursive_shapes_input::Builder {
        crate::operation::recursive_shapes_input::Builder::default()
    }
}
/// See [`RecursiveShapesInput`](crate::operation::RecursiveShapesInput)
pub mod recursive_shapes_input {

    use crate::model::RecursiveShapesInputOutputNested1;
    use crate::operation::RecursiveShapesInput;
    /// A builder for [`RecursiveShapesInput`](crate::operation::RecursiveShapesInput)
    #[non_exhaustive]
    #[derive(Debug, Clone, Default)]
    pub struct Builder {
        nested: Option<RecursiveShapesInputOutputNested1>,
    }
    impl Builder {
        pub fn nested(mut self, inp: RecursiveShapesInputOutputNested1) -> Self {
            self.nested = Some(inp);
            self
        }
        /// Consumes the builder and constructs a [`RecursiveShapesInput`](crate::operation::RecursiveShapesInput)
        pub fn build(self) -> RecursiveShapesInput {
            RecursiveShapesInput {
                nested: self.nested,
            }
        }
    }
}

#[non_exhaustive]
#[derive(::std::clone::Clone, ::std::cmp::PartialEq, ::std::fmt::Debug)]
pub struct JsonEnumsOutput {
    pub foo_enum1: Option<FooEnum>,
    pub foo_enum2: Option<FooEnum>,
    pub foo_enum3: Option<FooEnum>,
    pub foo_enum_list: Option<Vec<FooEnum>>,
    pub foo_enum_set: Option<BTreeSet<FooEnum>>,
    pub foo_enum_map: Option<HashMap<String, FooEnum>>,
}
impl JsonEnumsOutput {
    /// Creates a new builder-style object to manufacture [`JsonEnumsOutput`](crate::operation::JsonEnumsOutput)
    pub fn builder() -> crate::operation::json_enums_output::Builder {
        crate::operation::json_enums_output::Builder::default()
    }
}
/// See [`JsonEnumsOutput`](crate::operation::JsonEnumsOutput)
pub mod json_enums_output {

    use crate::model::FooEnum;
    use crate::operation::JsonEnumsOutput;
    use std::collections::BTreeSet;
    use std::collections::HashMap;
    /// A builder for [`JsonEnumsOutput`](crate::operation::JsonEnumsOutput)
    #[non_exhaustive]
    #[derive(Debug, Clone, Default)]
    pub struct Builder {
        foo_enum1: Option<FooEnum>,
        foo_enum2: Option<FooEnum>,
        foo_enum3: Option<FooEnum>,
        foo_enum_list: Option<Vec<FooEnum>>,
        foo_enum_set: Option<BTreeSet<FooEnum>>,
        foo_enum_map: Option<HashMap<String, FooEnum>>,
    }
    impl Builder {
        pub fn foo_enum1(mut self, inp: FooEnum) -> Self {
            self.foo_enum1 = Some(inp);
            self
        }
        pub fn foo_enum2(mut self, inp: FooEnum) -> Self {
            self.foo_enum2 = Some(inp);
            self
        }
        pub fn foo_enum3(mut self, inp: FooEnum) -> Self {
            self.foo_enum3 = Some(inp);
            self
        }
        pub fn foo_enum_list(mut self, inp: Vec<FooEnum>) -> Self {
            self.foo_enum_list = Some(inp);
            self
        }
        pub fn foo_enum_set(mut self, inp: BTreeSet<FooEnum>) -> Self {
            self.foo_enum_set = Some(inp);
            self
        }
        pub fn foo_enum_map(mut self, inp: HashMap<String, FooEnum>) -> Self {
            self.foo_enum_map = Some(inp);
            self
        }
        /// Consumes the builder and constructs a [`JsonEnumsOutput`](crate::operation::JsonEnumsOutput)
        pub fn build(self) -> JsonEnumsOutput {
            JsonEnumsOutput {
                foo_enum1: self.foo_enum1,
                foo_enum2: self.foo_enum2,
                foo_enum3: self.foo_enum3,
                foo_enum_list: self.foo_enum_list,
                foo_enum_set: self.foo_enum_set,
                foo_enum_map: self.foo_enum_map,
            }
        }
    }
}

#[non_exhaustive]
#[derive(::std::clone::Clone, ::std::cmp::PartialEq, ::std::fmt::Debug)]
pub struct JsonEnumsInput {
    pub foo_enum1: Option<FooEnum>,
    pub foo_enum2: Option<FooEnum>,
    pub foo_enum3: Option<FooEnum>,
    pub foo_enum_list: Option<Vec<FooEnum>>,
    pub foo_enum_set: Option<BTreeSet<FooEnum>>,
    pub foo_enum_map: Option<HashMap<String, FooEnum>>,
}
impl JsonEnumsInput {
    /// Creates a new builder-style object to manufacture [`JsonEnumsInput`](crate::operation::JsonEnumsInput)
    pub fn builder() -> crate::operation::json_enums_input::Builder {
        crate::operation::json_enums_input::Builder::default()
    }
}
/// See [`JsonEnumsInput`](crate::operation::JsonEnumsInput)
pub mod json_enums_input {

    use crate::model::FooEnum;
    use crate::operation::JsonEnumsInput;
    use std::collections::BTreeSet;
    use std::collections::HashMap;
    /// A builder for [`JsonEnumsInput`](crate::operation::JsonEnumsInput)
    #[non_exhaustive]
    #[derive(Debug, Clone, Default)]
    pub struct Builder {
        foo_enum1: Option<FooEnum>,
        foo_enum2: Option<FooEnum>,
        foo_enum3: Option<FooEnum>,
        foo_enum_list: Option<Vec<FooEnum>>,
        foo_enum_set: Option<BTreeSet<FooEnum>>,
        foo_enum_map: Option<HashMap<String, FooEnum>>,
    }
    impl Builder {
        pub fn foo_enum1(mut self, inp: FooEnum) -> Self {
            self.foo_enum1 = Some(inp);
            self
        }
        pub fn foo_enum2(mut self, inp: FooEnum) -> Self {
            self.foo_enum2 = Some(inp);
            self
        }
        pub fn foo_enum3(mut self, inp: FooEnum) -> Self {
            self.foo_enum3 = Some(inp);
            self
        }
        pub fn foo_enum_list(mut self, inp: Vec<FooEnum>) -> Self {
            self.foo_enum_list = Some(inp);
            self
        }
        pub fn foo_enum_set(mut self, inp: BTreeSet<FooEnum>) -> Self {
            self.foo_enum_set = Some(inp);
            self
        }
        pub fn foo_enum_map(mut self, inp: HashMap<String, FooEnum>) -> Self {
            self.foo_enum_map = Some(inp);
            self
        }
        /// Consumes the builder and constructs a [`JsonEnumsInput`](crate::operation::JsonEnumsInput)
        pub fn build(self) -> JsonEnumsInput {
            JsonEnumsInput {
                foo_enum1: self.foo_enum1,
                foo_enum2: self.foo_enum2,
                foo_enum3: self.foo_enum3,
                foo_enum_list: self.foo_enum_list,
                foo_enum_set: self.foo_enum_set,
                foo_enum_map: self.foo_enum_map,
            }
        }
    }
}

#[non_exhaustive]
#[derive(::std::clone::Clone, ::std::cmp::PartialEq, ::std::fmt::Debug)]
pub struct JsonTimestampsOutput {
    pub normal: Option<Instant>,
    pub date_time: Option<Instant>,
    pub epoch_seconds: Option<Instant>,
    pub http_date: Option<Instant>,
}
impl JsonTimestampsOutput {
    /// Creates a new builder-style object to manufacture [`JsonTimestampsOutput`](crate::operation::JsonTimestampsOutput)
    pub fn builder() -> crate::operation::json_timestamps_output::Builder {
        crate::operation::json_timestamps_output::Builder::default()
    }
}
/// See [`JsonTimestampsOutput`](crate::operation::JsonTimestampsOutput)
pub mod json_timestamps_output {

    use crate::operation::JsonTimestampsOutput;
    use smithy_types::Instant;
    /// A builder for [`JsonTimestampsOutput`](crate::operation::JsonTimestampsOutput)
    #[non_exhaustive]
    #[derive(Debug, Clone, Default)]
    pub struct Builder {
        normal: Option<Instant>,
        date_time: Option<Instant>,
        epoch_seconds: Option<Instant>,
        http_date: Option<Instant>,
    }
    impl Builder {
        pub fn normal(mut self, inp: Instant) -> Self {
            self.normal = Some(inp);
            self
        }
        pub fn date_time(mut self, inp: Instant) -> Self {
            self.date_time = Some(inp);
            self
        }
        pub fn epoch_seconds(mut self, inp: Instant) -> Self {
            self.epoch_seconds = Some(inp);
            self
        }
        pub fn http_date(mut self, inp: Instant) -> Self {
            self.http_date = Some(inp);
            self
        }
        /// Consumes the builder and constructs a [`JsonTimestampsOutput`](crate::operation::JsonTimestampsOutput)
        pub fn build(self) -> JsonTimestampsOutput {
            JsonTimestampsOutput {
                normal: self.normal,
                date_time: self.date_time,
                epoch_seconds: self.epoch_seconds,
                http_date: self.http_date,
            }
        }
    }
}

#[non_exhaustive]
#[derive(::std::clone::Clone, ::std::cmp::PartialEq, ::std::fmt::Debug)]
pub struct JsonTimestampsInput {
    pub normal: Option<Instant>,
    pub date_time: Option<Instant>,
    pub epoch_seconds: Option<Instant>,
    pub http_date: Option<Instant>,
}
impl JsonTimestampsInput {
    /// Creates a new builder-style object to manufacture [`JsonTimestampsInput`](crate::operation::JsonTimestampsInput)
    pub fn builder() -> crate::operation::json_timestamps_input::Builder {
        crate::operation::json_timestamps_input::Builder::default()
    }
}
/// See [`JsonTimestampsInput`](crate::operation::JsonTimestampsInput)
pub mod json_timestamps_input {

    use crate::operation::JsonTimestampsInput;
    use smithy_types::Instant;
    /// A builder for [`JsonTimestampsInput`](crate::operation::JsonTimestampsInput)
    #[non_exhaustive]
    #[derive(Debug, Clone, Default)]
    pub struct Builder {
        normal: Option<Instant>,
        date_time: Option<Instant>,
        epoch_seconds: Option<Instant>,
        http_date: Option<Instant>,
    }
    impl Builder {
        pub fn normal(mut self, inp: Instant) -> Self {
            self.normal = Some(inp);
            self
        }
        pub fn date_time(mut self, inp: Instant) -> Self {
            self.date_time = Some(inp);
            self
        }
        pub fn epoch_seconds(mut self, inp: Instant) -> Self {
            self.epoch_seconds = Some(inp);
            self
        }
        pub fn http_date(mut self, inp: Instant) -> Self {
            self.http_date = Some(inp);
            self
        }
        /// Consumes the builder and constructs a [`JsonTimestampsInput`](crate::operation::JsonTimestampsInput)
        pub fn build(self) -> JsonTimestampsInput {
            JsonTimestampsInput {
                normal: self.normal,
                date_time: self.date_time,
                epoch_seconds: self.epoch_seconds,
                http_date: self.http_date,
            }
        }
    }
}

#[non_exhaustive]
#[derive(::std::clone::Clone, ::std::cmp::PartialEq, ::std::fmt::Debug)]
pub struct SimpleScalarPropertiesOutput {
    pub foo: Option<String>,
    pub string_value: Option<String>,
    pub true_boolean_value: Option<bool>,
    pub false_boolean_value: Option<bool>,
    pub byte_value: Option<i8>,
    pub short_value: Option<i16>,
    pub integer_value: Option<i32>,
    pub long_value: Option<i64>,
    pub float_value: Option<f32>,
    pub double_value: Option<f64>,
}
impl SimpleScalarPropertiesOutput {
    /// Creates a new builder-style object to manufacture [`SimpleScalarPropertiesOutput`](crate::operation::SimpleScalarPropertiesOutput)
    pub fn builder() -> crate::operation::simple_scalar_properties_output::Builder {
        crate::operation::simple_scalar_properties_output::Builder::default()
    }
}
/// See [`SimpleScalarPropertiesOutput`](crate::operation::SimpleScalarPropertiesOutput)
pub mod simple_scalar_properties_output {

    use crate::operation::SimpleScalarPropertiesOutput;
    /// A builder for [`SimpleScalarPropertiesOutput`](crate::operation::SimpleScalarPropertiesOutput)
    #[non_exhaustive]
    #[derive(Debug, Clone, Default)]
    pub struct Builder {
        foo: Option<String>,
        string_value: Option<String>,
        true_boolean_value: Option<bool>,
        false_boolean_value: Option<bool>,
        byte_value: Option<i8>,
        short_value: Option<i16>,
        integer_value: Option<i32>,
        long_value: Option<i64>,
        float_value: Option<f32>,
        double_value: Option<f64>,
    }
    impl Builder {
        pub fn foo(mut self, inp: impl Into<String>) -> Self {
            self.foo = Some(inp.into());
            self
        }
        pub fn string_value(mut self, inp: impl Into<String>) -> Self {
            self.string_value = Some(inp.into());
            self
        }
        pub fn true_boolean_value(mut self, inp: bool) -> Self {
            self.true_boolean_value = Some(inp);
            self
        }
        pub fn false_boolean_value(mut self, inp: bool) -> Self {
            self.false_boolean_value = Some(inp);
            self
        }
        pub fn byte_value(mut self, inp: i8) -> Self {
            self.byte_value = Some(inp);
            self
        }
        pub fn short_value(mut self, inp: i16) -> Self {
            self.short_value = Some(inp);
            self
        }
        pub fn integer_value(mut self, inp: i32) -> Self {
            self.integer_value = Some(inp);
            self
        }
        pub fn long_value(mut self, inp: i64) -> Self {
            self.long_value = Some(inp);
            self
        }
        pub fn float_value(mut self, inp: f32) -> Self {
            self.float_value = Some(inp);
            self
        }
        pub fn double_value(mut self, inp: f64) -> Self {
            self.double_value = Some(inp);
            self
        }
        /// Consumes the builder and constructs a [`SimpleScalarPropertiesOutput`](crate::operation::SimpleScalarPropertiesOutput)
        pub fn build(self) -> SimpleScalarPropertiesOutput {
            SimpleScalarPropertiesOutput {
                foo: self.foo,
                string_value: self.string_value,
                true_boolean_value: self.true_boolean_value,
                false_boolean_value: self.false_boolean_value,
                byte_value: self.byte_value,
                short_value: self.short_value,
                integer_value: self.integer_value,
                long_value: self.long_value,
                float_value: self.float_value,
                double_value: self.double_value,
            }
        }
    }
}

#[non_exhaustive]
#[derive(::std::clone::Clone, ::std::cmp::PartialEq, ::std::fmt::Debug)]
pub struct SimpleScalarPropertiesInput {
    pub foo: Option<String>,
    pub string_value: Option<String>,
    pub true_boolean_value: Option<bool>,
    pub false_boolean_value: Option<bool>,
    pub byte_value: Option<i8>,
    pub short_value: Option<i16>,
    pub integer_value: Option<i32>,
    pub long_value: Option<i64>,
    pub float_value: Option<f32>,
    pub double_value: Option<f64>,
}
impl SimpleScalarPropertiesInput {
    /// Creates a new builder-style object to manufacture [`SimpleScalarPropertiesInput`](crate::operation::SimpleScalarPropertiesInput)
    pub fn builder() -> crate::operation::simple_scalar_properties_input::Builder {
        crate::operation::simple_scalar_properties_input::Builder::default()
    }
}
/// See [`SimpleScalarPropertiesInput`](crate::operation::SimpleScalarPropertiesInput)
pub mod simple_scalar_properties_input {

    use crate::operation::SimpleScalarPropertiesInput;
    /// A builder for [`SimpleScalarPropertiesInput`](crate::operation::SimpleScalarPropertiesInput)
    #[non_exhaustive]
    #[derive(Debug, Clone, Default)]
    pub struct Builder {
        foo: Option<String>,
        string_value: Option<String>,
        true_boolean_value: Option<bool>,
        false_boolean_value: Option<bool>,
        byte_value: Option<i8>,
        short_value: Option<i16>,
        integer_value: Option<i32>,
        long_value: Option<i64>,
        float_value: Option<f32>,
        double_value: Option<f64>,
    }
    impl Builder {
        pub fn foo(mut self, inp: impl Into<String>) -> Self {
            self.foo = Some(inp.into());
            self
        }
        pub fn string_value(mut self, inp: impl Into<String>) -> Self {
            self.string_value = Some(inp.into());
            self
        }
        pub fn true_boolean_value(mut self, inp: bool) -> Self {
            self.true_boolean_value = Some(inp);
            self
        }
        pub fn false_boolean_value(mut self, inp: bool) -> Self {
            self.false_boolean_value = Some(inp);
            self
        }
        pub fn byte_value(mut self, inp: i8) -> Self {
            self.byte_value = Some(inp);
            self
        }
        pub fn short_value(mut self, inp: i16) -> Self {
            self.short_value = Some(inp);
            self
        }
        pub fn integer_value(mut self, inp: i32) -> Self {
            self.integer_value = Some(inp);
            self
        }
        pub fn long_value(mut self, inp: i64) -> Self {
            self.long_value = Some(inp);
            self
        }
        pub fn float_value(mut self, inp: f32) -> Self {
            self.float_value = Some(inp);
            self
        }
        pub fn double_value(mut self, inp: f64) -> Self {
            self.double_value = Some(inp);
            self
        }
        /// Consumes the builder and constructs a [`SimpleScalarPropertiesInput`](crate::operation::SimpleScalarPropertiesInput)
        pub fn build(self) -> SimpleScalarPropertiesInput {
            SimpleScalarPropertiesInput {
                foo: self.foo,
                string_value: self.string_value,
                true_boolean_value: self.true_boolean_value,
                false_boolean_value: self.false_boolean_value,
                byte_value: self.byte_value,
                short_value: self.short_value,
                integer_value: self.integer_value,
                long_value: self.long_value,
                float_value: self.float_value,
                double_value: self.double_value,
            }
        }
    }
}

#[non_exhaustive]
#[derive(::std::clone::Clone, ::std::cmp::PartialEq, ::std::fmt::Debug)]
pub struct GreetingWithErrorsOutput {
    pub greeting: Option<String>,
}
impl GreetingWithErrorsOutput {
    /// Creates a new builder-style object to manufacture [`GreetingWithErrorsOutput`](crate::operation::GreetingWithErrorsOutput)
    pub fn builder() -> crate::operation::greeting_with_errors_output::Builder {
        crate::operation::greeting_with_errors_output::Builder::default()
    }
}
/// See [`GreetingWithErrorsOutput`](crate::operation::GreetingWithErrorsOutput)
pub mod greeting_with_errors_output {

    use crate::operation::GreetingWithErrorsOutput;
    /// A builder for [`GreetingWithErrorsOutput`](crate::operation::GreetingWithErrorsOutput)
    #[non_exhaustive]
    #[derive(Debug, Clone, Default)]
    pub struct Builder {
        greeting: Option<String>,
    }
    impl Builder {
        pub fn greeting(mut self, inp: impl Into<String>) -> Self {
            self.greeting = Some(inp.into());
            self
        }
        /// Consumes the builder and constructs a [`GreetingWithErrorsOutput`](crate::operation::GreetingWithErrorsOutput)
        pub fn build(self) -> GreetingWithErrorsOutput {
            GreetingWithErrorsOutput {
                greeting: self.greeting,
            }
        }
    }
}

#[non_exhaustive]
#[derive(::std::clone::Clone, ::std::cmp::PartialEq, ::std::fmt::Debug)]
pub struct GreetingWithErrorsInput {}
impl GreetingWithErrorsInput {
    /// Creates a new builder-style object to manufacture [`GreetingWithErrorsInput`](crate::operation::GreetingWithErrorsInput)
    pub fn builder() -> crate::operation::greeting_with_errors_input::Builder {
        crate::operation::greeting_with_errors_input::Builder::default()
    }
}
/// See [`GreetingWithErrorsInput`](crate::operation::GreetingWithErrorsInput)
pub mod greeting_with_errors_input {

    use crate::operation::GreetingWithErrorsInput;
    /// A builder for [`GreetingWithErrorsInput`](crate::operation::GreetingWithErrorsInput)
    #[non_exhaustive]
    #[derive(Debug, Clone, Default)]
    pub struct Builder {}
    impl Builder {
        /// Consumes the builder and constructs a [`GreetingWithErrorsInput`](crate::operation::GreetingWithErrorsInput)
        pub fn build(self) -> GreetingWithErrorsInput {
            GreetingWithErrorsInput {}
        }
    }
}

#[non_exhaustive]
#[derive(::std::clone::Clone, ::std::cmp::PartialEq, ::std::fmt::Debug)]
pub struct StreamingTraitsWithMediaTypeOutput {
    pub foo: Option<String>,
    pub blob: Option<Blob>,
}
impl StreamingTraitsWithMediaTypeOutput {
    /// Creates a new builder-style object to manufacture [`StreamingTraitsWithMediaTypeOutput`](crate::operation::StreamingTraitsWithMediaTypeOutput)
    pub fn builder() -> crate::operation::streaming_traits_with_media_type_output::Builder {
        crate::operation::streaming_traits_with_media_type_output::Builder::default()
    }
}
/// See [`StreamingTraitsWithMediaTypeOutput`](crate::operation::StreamingTraitsWithMediaTypeOutput)
pub mod streaming_traits_with_media_type_output {

    use crate::operation::StreamingTraitsWithMediaTypeOutput;
    use smithy_types::Blob;
    /// A builder for [`StreamingTraitsWithMediaTypeOutput`](crate::operation::StreamingTraitsWithMediaTypeOutput)
    #[non_exhaustive]
    #[derive(Debug, Clone, Default)]
    pub struct Builder {
        foo: Option<String>,
        blob: Option<Blob>,
    }
    impl Builder {
        pub fn foo(mut self, inp: impl Into<String>) -> Self {
            self.foo = Some(inp.into());
            self
        }
        pub fn blob(mut self, inp: Blob) -> Self {
            self.blob = Some(inp);
            self
        }
        /// Consumes the builder and constructs a [`StreamingTraitsWithMediaTypeOutput`](crate::operation::StreamingTraitsWithMediaTypeOutput)
        pub fn build(self) -> StreamingTraitsWithMediaTypeOutput {
            StreamingTraitsWithMediaTypeOutput {
                foo: self.foo,
                blob: self.blob,
            }
        }
    }
}

#[non_exhaustive]
#[derive(::std::clone::Clone, ::std::cmp::PartialEq, ::std::fmt::Debug)]
pub struct StreamingTraitsWithMediaTypeInput {
    pub foo: Option<String>,
    pub blob: Option<Blob>,
}
impl StreamingTraitsWithMediaTypeInput {
    /// Creates a new builder-style object to manufacture [`StreamingTraitsWithMediaTypeInput`](crate::operation::StreamingTraitsWithMediaTypeInput)
    pub fn builder() -> crate::operation::streaming_traits_with_media_type_input::Builder {
        crate::operation::streaming_traits_with_media_type_input::Builder::default()
    }
}
/// See [`StreamingTraitsWithMediaTypeInput`](crate::operation::StreamingTraitsWithMediaTypeInput)
pub mod streaming_traits_with_media_type_input {

    use crate::operation::StreamingTraitsWithMediaTypeInput;
    use smithy_types::Blob;
    /// A builder for [`StreamingTraitsWithMediaTypeInput`](crate::operation::StreamingTraitsWithMediaTypeInput)
    #[non_exhaustive]
    #[derive(Debug, Clone, Default)]
    pub struct Builder {
        foo: Option<String>,
        blob: Option<Blob>,
    }
    impl Builder {
        pub fn foo(mut self, inp: impl Into<String>) -> Self {
            self.foo = Some(inp.into());
            self
        }
        pub fn blob(mut self, inp: Blob) -> Self {
            self.blob = Some(inp);
            self
        }
        /// Consumes the builder and constructs a [`StreamingTraitsWithMediaTypeInput`](crate::operation::StreamingTraitsWithMediaTypeInput)
        pub fn build(self) -> StreamingTraitsWithMediaTypeInput {
            StreamingTraitsWithMediaTypeInput {
                foo: self.foo,
                blob: self.blob,
            }
        }
    }
}

#[non_exhaustive]
#[derive(::std::clone::Clone, ::std::cmp::PartialEq, ::std::fmt::Debug)]
pub struct StreamingTraitsRequireLengthOutput {
    pub foo: Option<String>,
    pub blob: Option<Blob>,
}
impl StreamingTraitsRequireLengthOutput {
    /// Creates a new builder-style object to manufacture [`StreamingTraitsRequireLengthOutput`](crate::operation::StreamingTraitsRequireLengthOutput)
    pub fn builder() -> crate::operation::streaming_traits_require_length_output::Builder {
        crate::operation::streaming_traits_require_length_output::Builder::default()
    }
}
/// See [`StreamingTraitsRequireLengthOutput`](crate::operation::StreamingTraitsRequireLengthOutput)
pub mod streaming_traits_require_length_output {

    use crate::operation::StreamingTraitsRequireLengthOutput;
    use smithy_types::Blob;
    /// A builder for [`StreamingTraitsRequireLengthOutput`](crate::operation::StreamingTraitsRequireLengthOutput)
    #[non_exhaustive]
    #[derive(Debug, Clone, Default)]
    pub struct Builder {
        foo: Option<String>,
        blob: Option<Blob>,
    }
    impl Builder {
        pub fn foo(mut self, inp: impl Into<String>) -> Self {
            self.foo = Some(inp.into());
            self
        }
        pub fn blob(mut self, inp: Blob) -> Self {
            self.blob = Some(inp);
            self
        }
        /// Consumes the builder and constructs a [`StreamingTraitsRequireLengthOutput`](crate::operation::StreamingTraitsRequireLengthOutput)
        pub fn build(self) -> StreamingTraitsRequireLengthOutput {
            StreamingTraitsRequireLengthOutput {
                foo: self.foo,
                blob: self.blob,
            }
        }
    }
}

#[non_exhaustive]
#[derive(::std::clone::Clone, ::std::cmp::PartialEq, ::std::fmt::Debug)]
pub struct StreamingTraitsRequireLengthInput {
    pub foo: Option<String>,
    pub blob: Option<Blob>,
}
impl StreamingTraitsRequireLengthInput {
    /// Creates a new builder-style object to manufacture [`StreamingTraitsRequireLengthInput`](crate::operation::StreamingTraitsRequireLengthInput)
    pub fn builder() -> crate::operation::streaming_traits_require_length_input::Builder {
        crate::operation::streaming_traits_require_length_input::Builder::default()
    }
}
/// See [`StreamingTraitsRequireLengthInput`](crate::operation::StreamingTraitsRequireLengthInput)
pub mod streaming_traits_require_length_input {

    use crate::operation::StreamingTraitsRequireLengthInput;
    use smithy_types::Blob;
    /// A builder for [`StreamingTraitsRequireLengthInput`](crate::operation::StreamingTraitsRequireLengthInput)
    #[non_exhaustive]
    #[derive(Debug, Clone, Default)]
    pub struct Builder {
        foo: Option<String>,
        blob: Option<Blob>,
    }
    impl Builder {
        pub fn foo(mut self, inp: impl Into<String>) -> Self {
            self.foo = Some(inp.into());
            self
        }
        pub fn blob(mut self, inp: Blob) -> Self {
            self.blob = Some(inp);
            self
        }
        /// Consumes the builder and constructs a [`StreamingTraitsRequireLengthInput`](crate::operation::StreamingTraitsRequireLengthInput)
        pub fn build(self) -> StreamingTraitsRequireLengthInput {
            StreamingTraitsRequireLengthInput {
                foo: self.foo,
                blob: self.blob,
            }
        }
    }
}

#[non_exhaustive]
#[derive(::std::clone::Clone, ::std::cmp::PartialEq, ::std::fmt::Debug)]
pub struct StreamingTraitsOutput {
    pub foo: Option<String>,
    pub blob: Option<Blob>,
}
impl StreamingTraitsOutput {
    /// Creates a new builder-style object to manufacture [`StreamingTraitsOutput`](crate::operation::StreamingTraitsOutput)
    pub fn builder() -> crate::operation::streaming_traits_output::Builder {
        crate::operation::streaming_traits_output::Builder::default()
    }
}
/// See [`StreamingTraitsOutput`](crate::operation::StreamingTraitsOutput)
pub mod streaming_traits_output {

    use crate::operation::StreamingTraitsOutput;
    use smithy_types::Blob;
    /// A builder for [`StreamingTraitsOutput`](crate::operation::StreamingTraitsOutput)
    #[non_exhaustive]
    #[derive(Debug, Clone, Default)]
    pub struct Builder {
        foo: Option<String>,
        blob: Option<Blob>,
    }
    impl Builder {
        pub fn foo(mut self, inp: impl Into<String>) -> Self {
            self.foo = Some(inp.into());
            self
        }
        pub fn blob(mut self, inp: Blob) -> Self {
            self.blob = Some(inp);
            self
        }
        /// Consumes the builder and constructs a [`StreamingTraitsOutput`](crate::operation::StreamingTraitsOutput)
        pub fn build(self) -> StreamingTraitsOutput {
            StreamingTraitsOutput {
                foo: self.foo,
                blob: self.blob,
            }
        }
    }
}

#[non_exhaustive]
#[derive(::std::clone::Clone, ::std::cmp::PartialEq, ::std::fmt::Debug)]
pub struct StreamingTraitsInput {
    pub foo: Option<String>,
    pub blob: Option<Blob>,
}
impl StreamingTraitsInput {
    /// Creates a new builder-style object to manufacture [`StreamingTraitsInput`](crate::operation::StreamingTraitsInput)
    pub fn builder() -> crate::operation::streaming_traits_input::Builder {
        crate::operation::streaming_traits_input::Builder::default()
    }
}
/// See [`StreamingTraitsInput`](crate::operation::StreamingTraitsInput)
pub mod streaming_traits_input {

    use crate::operation::StreamingTraitsInput;
    use smithy_types::Blob;
    /// A builder for [`StreamingTraitsInput`](crate::operation::StreamingTraitsInput)
    #[non_exhaustive]
    #[derive(Debug, Clone, Default)]
    pub struct Builder {
        foo: Option<String>,
        blob: Option<Blob>,
    }
    impl Builder {
        pub fn foo(mut self, inp: impl Into<String>) -> Self {
            self.foo = Some(inp.into());
            self
        }
        pub fn blob(mut self, inp: Blob) -> Self {
            self.blob = Some(inp);
            self
        }
        /// Consumes the builder and constructs a [`StreamingTraitsInput`](crate::operation::StreamingTraitsInput)
        pub fn build(self) -> StreamingTraitsInput {
            StreamingTraitsInput {
                foo: self.foo,
                blob: self.blob,
            }
        }
    }
}

#[non_exhaustive]
#[derive(::std::clone::Clone, ::std::cmp::PartialEq, ::std::fmt::Debug)]
pub struct HttpResponseCodeOutput {
    pub status: Option<i32>,
}
impl HttpResponseCodeOutput {
    /// Creates a new builder-style object to manufacture [`HttpResponseCodeOutput`](crate::operation::HttpResponseCodeOutput)
    pub fn builder() -> crate::operation::http_response_code_output::Builder {
        crate::operation::http_response_code_output::Builder::default()
    }
}
/// See [`HttpResponseCodeOutput`](crate::operation::HttpResponseCodeOutput)
pub mod http_response_code_output {

    use crate::operation::HttpResponseCodeOutput;
    /// A builder for [`HttpResponseCodeOutput`](crate::operation::HttpResponseCodeOutput)
    #[non_exhaustive]
    #[derive(Debug, Clone, Default)]
    pub struct Builder {
        status: Option<i32>,
    }
    impl Builder {
        pub fn status(mut self, inp: i32) -> Self {
            self.status = Some(inp);
            self
        }
        /// Consumes the builder and constructs a [`HttpResponseCodeOutput`](crate::operation::HttpResponseCodeOutput)
        pub fn build(self) -> HttpResponseCodeOutput {
            HttpResponseCodeOutput {
                status: self.status,
            }
        }
    }
}

#[non_exhaustive]
#[derive(::std::clone::Clone, ::std::cmp::PartialEq, ::std::fmt::Debug)]
pub struct HttpResponseCodeInput {}
impl HttpResponseCodeInput {
    /// Creates a new builder-style object to manufacture [`HttpResponseCodeInput`](crate::operation::HttpResponseCodeInput)
    pub fn builder() -> crate::operation::http_response_code_input::Builder {
        crate::operation::http_response_code_input::Builder::default()
    }
}
/// See [`HttpResponseCodeInput`](crate::operation::HttpResponseCodeInput)
pub mod http_response_code_input {

    use crate::operation::HttpResponseCodeInput;
    /// A builder for [`HttpResponseCodeInput`](crate::operation::HttpResponseCodeInput)
    #[non_exhaustive]
    #[derive(Debug, Clone, Default)]
    pub struct Builder {}
    impl Builder {
        /// Consumes the builder and constructs a [`HttpResponseCodeInput`](crate::operation::HttpResponseCodeInput)
        pub fn build(self) -> HttpResponseCodeInput {
            HttpResponseCodeInput {}
        }
    }
}

#[non_exhaustive]
#[derive(::std::clone::Clone, ::std::cmp::PartialEq, ::std::fmt::Debug)]
pub struct HttpPayloadWithStructureOutput {
    pub nested: Option<NestedPayload>,
}
impl HttpPayloadWithStructureOutput {
    /// Creates a new builder-style object to manufacture [`HttpPayloadWithStructureOutput`](crate::operation::HttpPayloadWithStructureOutput)
    pub fn builder() -> crate::operation::http_payload_with_structure_output::Builder {
        crate::operation::http_payload_with_structure_output::Builder::default()
    }
}
/// See [`HttpPayloadWithStructureOutput`](crate::operation::HttpPayloadWithStructureOutput)
pub mod http_payload_with_structure_output {

    use crate::model::NestedPayload;
    use crate::operation::HttpPayloadWithStructureOutput;
    /// A builder for [`HttpPayloadWithStructureOutput`](crate::operation::HttpPayloadWithStructureOutput)
    #[non_exhaustive]
    #[derive(Debug, Clone, Default)]
    pub struct Builder {
        nested: Option<NestedPayload>,
    }
    impl Builder {
        pub fn nested(mut self, inp: NestedPayload) -> Self {
            self.nested = Some(inp);
            self
        }
        /// Consumes the builder and constructs a [`HttpPayloadWithStructureOutput`](crate::operation::HttpPayloadWithStructureOutput)
        pub fn build(self) -> HttpPayloadWithStructureOutput {
            HttpPayloadWithStructureOutput {
                nested: self.nested,
            }
        }
    }
}

#[non_exhaustive]
#[derive(::std::clone::Clone, ::std::cmp::PartialEq, ::std::fmt::Debug)]
pub struct HttpPayloadWithStructureInput {
    pub nested: Option<NestedPayload>,
}
impl HttpPayloadWithStructureInput {
    /// Creates a new builder-style object to manufacture [`HttpPayloadWithStructureInput`](crate::operation::HttpPayloadWithStructureInput)
    pub fn builder() -> crate::operation::http_payload_with_structure_input::Builder {
        crate::operation::http_payload_with_structure_input::Builder::default()
    }
}
/// See [`HttpPayloadWithStructureInput`](crate::operation::HttpPayloadWithStructureInput)
pub mod http_payload_with_structure_input {

    use crate::model::NestedPayload;
    use crate::operation::HttpPayloadWithStructureInput;
    /// A builder for [`HttpPayloadWithStructureInput`](crate::operation::HttpPayloadWithStructureInput)
    #[non_exhaustive]
    #[derive(Debug, Clone, Default)]
    pub struct Builder {
        nested: Option<NestedPayload>,
    }
    impl Builder {
        pub fn nested(mut self, inp: NestedPayload) -> Self {
            self.nested = Some(inp);
            self
        }
        /// Consumes the builder and constructs a [`HttpPayloadWithStructureInput`](crate::operation::HttpPayloadWithStructureInput)
        pub fn build(self) -> HttpPayloadWithStructureInput {
            HttpPayloadWithStructureInput {
                nested: self.nested,
            }
        }
    }
}

#[non_exhaustive]
#[derive(::std::clone::Clone, ::std::cmp::PartialEq, ::std::fmt::Debug)]
pub struct HttpPayloadTraitsWithMediaTypeOutput {
    pub foo: Option<String>,
    pub blob: Option<Blob>,
}
impl HttpPayloadTraitsWithMediaTypeOutput {
    /// Creates a new builder-style object to manufacture [`HttpPayloadTraitsWithMediaTypeOutput`](crate::operation::HttpPayloadTraitsWithMediaTypeOutput)
    pub fn builder() -> crate::operation::http_payload_traits_with_media_type_output::Builder {
        crate::operation::http_payload_traits_with_media_type_output::Builder::default()
    }
}
/// See [`HttpPayloadTraitsWithMediaTypeOutput`](crate::operation::HttpPayloadTraitsWithMediaTypeOutput)
pub mod http_payload_traits_with_media_type_output {

    use crate::operation::HttpPayloadTraitsWithMediaTypeOutput;
    use smithy_types::Blob;
    /// A builder for [`HttpPayloadTraitsWithMediaTypeOutput`](crate::operation::HttpPayloadTraitsWithMediaTypeOutput)
    #[non_exhaustive]
    #[derive(Debug, Clone, Default)]
    pub struct Builder {
        foo: Option<String>,
        blob: Option<Blob>,
    }
    impl Builder {
        pub fn foo(mut self, inp: impl Into<String>) -> Self {
            self.foo = Some(inp.into());
            self
        }
        pub fn blob(mut self, inp: Blob) -> Self {
            self.blob = Some(inp);
            self
        }
        /// Consumes the builder and constructs a [`HttpPayloadTraitsWithMediaTypeOutput`](crate::operation::HttpPayloadTraitsWithMediaTypeOutput)
        pub fn build(self) -> HttpPayloadTraitsWithMediaTypeOutput {
            HttpPayloadTraitsWithMediaTypeOutput {
                foo: self.foo,
                blob: self.blob,
            }
        }
    }
}

#[non_exhaustive]
#[derive(::std::clone::Clone, ::std::cmp::PartialEq, ::std::fmt::Debug)]
pub struct HttpPayloadTraitsWithMediaTypeInput {
    pub foo: Option<String>,
    pub blob: Option<Blob>,
}
impl HttpPayloadTraitsWithMediaTypeInput {
    /// Creates a new builder-style object to manufacture [`HttpPayloadTraitsWithMediaTypeInput`](crate::operation::HttpPayloadTraitsWithMediaTypeInput)
    pub fn builder() -> crate::operation::http_payload_traits_with_media_type_input::Builder {
        crate::operation::http_payload_traits_with_media_type_input::Builder::default()
    }
}
/// See [`HttpPayloadTraitsWithMediaTypeInput`](crate::operation::HttpPayloadTraitsWithMediaTypeInput)
pub mod http_payload_traits_with_media_type_input {

    use crate::operation::HttpPayloadTraitsWithMediaTypeInput;
    use smithy_types::Blob;
    /// A builder for [`HttpPayloadTraitsWithMediaTypeInput`](crate::operation::HttpPayloadTraitsWithMediaTypeInput)
    #[non_exhaustive]
    #[derive(Debug, Clone, Default)]
    pub struct Builder {
        foo: Option<String>,
        blob: Option<Blob>,
    }
    impl Builder {
        pub fn foo(mut self, inp: impl Into<String>) -> Self {
            self.foo = Some(inp.into());
            self
        }
        pub fn blob(mut self, inp: Blob) -> Self {
            self.blob = Some(inp);
            self
        }
        /// Consumes the builder and constructs a [`HttpPayloadTraitsWithMediaTypeInput`](crate::operation::HttpPayloadTraitsWithMediaTypeInput)
        pub fn build(self) -> HttpPayloadTraitsWithMediaTypeInput {
            HttpPayloadTraitsWithMediaTypeInput {
                foo: self.foo,
                blob: self.blob,
            }
        }
    }
}

#[non_exhaustive]
#[derive(::std::clone::Clone, ::std::cmp::PartialEq, ::std::fmt::Debug)]
pub struct HttpPayloadTraitsOutput {
    pub foo: Option<String>,
    pub blob: Option<Blob>,
}
impl HttpPayloadTraitsOutput {
    /// Creates a new builder-style object to manufacture [`HttpPayloadTraitsOutput`](crate::operation::HttpPayloadTraitsOutput)
    pub fn builder() -> crate::operation::http_payload_traits_output::Builder {
        crate::operation::http_payload_traits_output::Builder::default()
    }
}
/// See [`HttpPayloadTraitsOutput`](crate::operation::HttpPayloadTraitsOutput)
pub mod http_payload_traits_output {

    use crate::operation::HttpPayloadTraitsOutput;
    use smithy_types::Blob;
    /// A builder for [`HttpPayloadTraitsOutput`](crate::operation::HttpPayloadTraitsOutput)
    #[non_exhaustive]
    #[derive(Debug, Clone, Default)]
    pub struct Builder {
        foo: Option<String>,
        blob: Option<Blob>,
    }
    impl Builder {
        pub fn foo(mut self, inp: impl Into<String>) -> Self {
            self.foo = Some(inp.into());
            self
        }
        pub fn blob(mut self, inp: Blob) -> Self {
            self.blob = Some(inp);
            self
        }
        /// Consumes the builder and constructs a [`HttpPayloadTraitsOutput`](crate::operation::HttpPayloadTraitsOutput)
        pub fn build(self) -> HttpPayloadTraitsOutput {
            HttpPayloadTraitsOutput {
                foo: self.foo,
                blob: self.blob,
            }
        }
    }
}

#[non_exhaustive]
#[derive(::std::clone::Clone, ::std::cmp::PartialEq, ::std::fmt::Debug)]
pub struct HttpPayloadTraitsInput {
    pub foo: Option<String>,
    pub blob: Option<Blob>,
}
impl HttpPayloadTraitsInput {
    /// Creates a new builder-style object to manufacture [`HttpPayloadTraitsInput`](crate::operation::HttpPayloadTraitsInput)
    pub fn builder() -> crate::operation::http_payload_traits_input::Builder {
        crate::operation::http_payload_traits_input::Builder::default()
    }
}
/// See [`HttpPayloadTraitsInput`](crate::operation::HttpPayloadTraitsInput)
pub mod http_payload_traits_input {

    use crate::operation::HttpPayloadTraitsInput;
    use smithy_types::Blob;
    /// A builder for [`HttpPayloadTraitsInput`](crate::operation::HttpPayloadTraitsInput)
    #[non_exhaustive]
    #[derive(Debug, Clone, Default)]
    pub struct Builder {
        foo: Option<String>,
        blob: Option<Blob>,
    }
    impl Builder {
        pub fn foo(mut self, inp: impl Into<String>) -> Self {
            self.foo = Some(inp.into());
            self
        }
        pub fn blob(mut self, inp: Blob) -> Self {
            self.blob = Some(inp);
            self
        }
        /// Consumes the builder and constructs a [`HttpPayloadTraitsInput`](crate::operation::HttpPayloadTraitsInput)
        pub fn build(self) -> HttpPayloadTraitsInput {
            HttpPayloadTraitsInput {
                foo: self.foo,
                blob: self.blob,
            }
        }
    }
}

#[non_exhaustive]
#[derive(::std::clone::Clone, ::std::cmp::PartialEq, ::std::fmt::Debug)]
pub struct HttpPrefixHeadersResponseOutput {
    pub prefix_headers: Option<HashMap<String, String>>,
}
impl HttpPrefixHeadersResponseOutput {
    /// Creates a new builder-style object to manufacture [`HttpPrefixHeadersResponseOutput`](crate::operation::HttpPrefixHeadersResponseOutput)
    pub fn builder() -> crate::operation::http_prefix_headers_response_output::Builder {
        crate::operation::http_prefix_headers_response_output::Builder::default()
    }
}
/// See [`HttpPrefixHeadersResponseOutput`](crate::operation::HttpPrefixHeadersResponseOutput)
pub mod http_prefix_headers_response_output {

    use crate::operation::HttpPrefixHeadersResponseOutput;
    use std::collections::HashMap;
    /// A builder for [`HttpPrefixHeadersResponseOutput`](crate::operation::HttpPrefixHeadersResponseOutput)
    #[non_exhaustive]
    #[derive(Debug, Clone, Default)]
    pub struct Builder {
        prefix_headers: Option<HashMap<String, String>>,
    }
    impl Builder {
        pub fn prefix_headers(mut self, inp: HashMap<String, String>) -> Self {
            self.prefix_headers = Some(inp);
            self
        }
        /// Consumes the builder and constructs a [`HttpPrefixHeadersResponseOutput`](crate::operation::HttpPrefixHeadersResponseOutput)
        pub fn build(self) -> HttpPrefixHeadersResponseOutput {
            HttpPrefixHeadersResponseOutput {
                prefix_headers: self.prefix_headers,
            }
        }
    }
}

#[non_exhaustive]
#[derive(::std::clone::Clone, ::std::cmp::PartialEq, ::std::fmt::Debug)]
pub struct HttpPrefixHeadersResponseInput {}
impl HttpPrefixHeadersResponseInput {
    /// Creates a new builder-style object to manufacture [`HttpPrefixHeadersResponseInput`](crate::operation::HttpPrefixHeadersResponseInput)
    pub fn builder() -> crate::operation::http_prefix_headers_response_input::Builder {
        crate::operation::http_prefix_headers_response_input::Builder::default()
    }
}
/// See [`HttpPrefixHeadersResponseInput`](crate::operation::HttpPrefixHeadersResponseInput)
pub mod http_prefix_headers_response_input {

    use crate::operation::HttpPrefixHeadersResponseInput;
    /// A builder for [`HttpPrefixHeadersResponseInput`](crate::operation::HttpPrefixHeadersResponseInput)
    #[non_exhaustive]
    #[derive(Debug, Clone, Default)]
    pub struct Builder {}
    impl Builder {
        /// Consumes the builder and constructs a [`HttpPrefixHeadersResponseInput`](crate::operation::HttpPrefixHeadersResponseInput)
        pub fn build(self) -> HttpPrefixHeadersResponseInput {
            HttpPrefixHeadersResponseInput {}
        }
    }
}

#[non_exhaustive]
#[derive(::std::clone::Clone, ::std::cmp::PartialEq, ::std::fmt::Debug)]
pub struct HttpPrefixHeadersOutput {
    pub foo: Option<String>,
    pub foo_map: Option<HashMap<String, String>>,
}
impl HttpPrefixHeadersOutput {
    /// Creates a new builder-style object to manufacture [`HttpPrefixHeadersOutput`](crate::operation::HttpPrefixHeadersOutput)
    pub fn builder() -> crate::operation::http_prefix_headers_output::Builder {
        crate::operation::http_prefix_headers_output::Builder::default()
    }
}
/// See [`HttpPrefixHeadersOutput`](crate::operation::HttpPrefixHeadersOutput)
pub mod http_prefix_headers_output {

    use crate::operation::HttpPrefixHeadersOutput;
    use std::collections::HashMap;
    /// A builder for [`HttpPrefixHeadersOutput`](crate::operation::HttpPrefixHeadersOutput)
    #[non_exhaustive]
    #[derive(Debug, Clone, Default)]
    pub struct Builder {
        foo: Option<String>,
        foo_map: Option<HashMap<String, String>>,
    }
    impl Builder {
        pub fn foo(mut self, inp: impl Into<String>) -> Self {
            self.foo = Some(inp.into());
            self
        }
        pub fn foo_map(mut self, inp: HashMap<String, String>) -> Self {
            self.foo_map = Some(inp);
            self
        }
        /// Consumes the builder and constructs a [`HttpPrefixHeadersOutput`](crate::operation::HttpPrefixHeadersOutput)
        pub fn build(self) -> HttpPrefixHeadersOutput {
            HttpPrefixHeadersOutput {
                foo: self.foo,
                foo_map: self.foo_map,
            }
        }
    }
}

#[non_exhaustive]
#[derive(::std::clone::Clone, ::std::cmp::PartialEq, ::std::fmt::Debug)]
pub struct HttpPrefixHeadersInput {
    pub foo: Option<String>,
    pub foo_map: Option<HashMap<String, String>>,
}
impl HttpPrefixHeadersInput {
    /// Creates a new builder-style object to manufacture [`HttpPrefixHeadersInput`](crate::operation::HttpPrefixHeadersInput)
    pub fn builder() -> crate::operation::http_prefix_headers_input::Builder {
        crate::operation::http_prefix_headers_input::Builder::default()
    }
}
/// See [`HttpPrefixHeadersInput`](crate::operation::HttpPrefixHeadersInput)
pub mod http_prefix_headers_input {

    use crate::operation::HttpPrefixHeadersInput;
    use std::collections::HashMap;
    /// A builder for [`HttpPrefixHeadersInput`](crate::operation::HttpPrefixHeadersInput)
    #[non_exhaustive]
    #[derive(Debug, Clone, Default)]
    pub struct Builder {
        foo: Option<String>,
        foo_map: Option<HashMap<String, String>>,
    }
    impl Builder {
        pub fn foo(mut self, inp: impl Into<String>) -> Self {
            self.foo = Some(inp.into());
            self
        }
        pub fn foo_map(mut self, inp: HashMap<String, String>) -> Self {
            self.foo_map = Some(inp);
            self
        }
        /// Consumes the builder and constructs a [`HttpPrefixHeadersInput`](crate::operation::HttpPrefixHeadersInput)
        pub fn build(self) -> HttpPrefixHeadersInput {
            HttpPrefixHeadersInput {
                foo: self.foo,
                foo_map: self.foo_map,
            }
        }
    }
}

#[non_exhaustive]
#[derive(::std::clone::Clone, ::std::cmp::PartialEq, ::std::fmt::Debug)]
pub struct QueryIdempotencyTokenAutoFillOutput {}
impl QueryIdempotencyTokenAutoFillOutput {
    /// Creates a new builder-style object to manufacture [`QueryIdempotencyTokenAutoFillOutput`](crate::operation::QueryIdempotencyTokenAutoFillOutput)
    pub fn builder() -> crate::operation::query_idempotency_token_auto_fill_output::Builder {
        crate::operation::query_idempotency_token_auto_fill_output::Builder::default()
    }
}
/// See [`QueryIdempotencyTokenAutoFillOutput`](crate::operation::QueryIdempotencyTokenAutoFillOutput)
pub mod query_idempotency_token_auto_fill_output {

    use crate::operation::QueryIdempotencyTokenAutoFillOutput;
    /// A builder for [`QueryIdempotencyTokenAutoFillOutput`](crate::operation::QueryIdempotencyTokenAutoFillOutput)
    #[non_exhaustive]
    #[derive(Debug, Clone, Default)]
    pub struct Builder {}
    impl Builder {
        /// Consumes the builder and constructs a [`QueryIdempotencyTokenAutoFillOutput`](crate::operation::QueryIdempotencyTokenAutoFillOutput)
        pub fn build(self) -> QueryIdempotencyTokenAutoFillOutput {
            QueryIdempotencyTokenAutoFillOutput {}
        }
    }
}

#[non_exhaustive]
#[derive(::std::clone::Clone, ::std::cmp::PartialEq, ::std::fmt::Debug)]
pub struct QueryIdempotencyTokenAutoFillInput {
    pub token: Option<String>,
}
impl QueryIdempotencyTokenAutoFillInput {
    /// Creates a new builder-style object to manufacture [`QueryIdempotencyTokenAutoFillInput`](crate::operation::QueryIdempotencyTokenAutoFillInput)
    pub fn builder() -> crate::operation::query_idempotency_token_auto_fill_input::Builder {
        crate::operation::query_idempotency_token_auto_fill_input::Builder::default()
    }
}
/// See [`QueryIdempotencyTokenAutoFillInput`](crate::operation::QueryIdempotencyTokenAutoFillInput)
pub mod query_idempotency_token_auto_fill_input {

    use crate::operation::QueryIdempotencyTokenAutoFillInput;
    /// A builder for [`QueryIdempotencyTokenAutoFillInput`](crate::operation::QueryIdempotencyTokenAutoFillInput)
    #[non_exhaustive]
    #[derive(Debug, Clone, Default)]
    pub struct Builder {
        token: Option<String>,
    }
    impl Builder {
        pub fn token(mut self, inp: impl Into<String>) -> Self {
            self.token = Some(inp.into());
            self
        }
        /// Consumes the builder and constructs a [`QueryIdempotencyTokenAutoFillInput`](crate::operation::QueryIdempotencyTokenAutoFillInput)
        pub fn build(self) -> QueryIdempotencyTokenAutoFillInput {
            QueryIdempotencyTokenAutoFillInput { token: self.token }
        }
    }
}

#[non_exhaustive]
#[derive(::std::clone::Clone, ::std::cmp::PartialEq, ::std::fmt::Debug)]
pub struct OmitsNullSerializesEmptyStringOutput {}
impl OmitsNullSerializesEmptyStringOutput {
    /// Creates a new builder-style object to manufacture [`OmitsNullSerializesEmptyStringOutput`](crate::operation::OmitsNullSerializesEmptyStringOutput)
    pub fn builder() -> crate::operation::omits_null_serializes_empty_string_output::Builder {
        crate::operation::omits_null_serializes_empty_string_output::Builder::default()
    }
}
/// See [`OmitsNullSerializesEmptyStringOutput`](crate::operation::OmitsNullSerializesEmptyStringOutput)
pub mod omits_null_serializes_empty_string_output {

    use crate::operation::OmitsNullSerializesEmptyStringOutput;
    /// A builder for [`OmitsNullSerializesEmptyStringOutput`](crate::operation::OmitsNullSerializesEmptyStringOutput)
    #[non_exhaustive]
    #[derive(Debug, Clone, Default)]
    pub struct Builder {}
    impl Builder {
        /// Consumes the builder and constructs a [`OmitsNullSerializesEmptyStringOutput`](crate::operation::OmitsNullSerializesEmptyStringOutput)
        pub fn build(self) -> OmitsNullSerializesEmptyStringOutput {
            OmitsNullSerializesEmptyStringOutput {}
        }
    }
}

#[non_exhaustive]
#[derive(::std::clone::Clone, ::std::cmp::PartialEq, ::std::fmt::Debug)]
pub struct OmitsNullSerializesEmptyStringInput {
    pub null_value: Option<String>,
    pub empty_string: Option<String>,
}
impl OmitsNullSerializesEmptyStringInput {
    /// Creates a new builder-style object to manufacture [`OmitsNullSerializesEmptyStringInput`](crate::operation::OmitsNullSerializesEmptyStringInput)
    pub fn builder() -> crate::operation::omits_null_serializes_empty_string_input::Builder {
        crate::operation::omits_null_serializes_empty_string_input::Builder::default()
    }
}
/// See [`OmitsNullSerializesEmptyStringInput`](crate::operation::OmitsNullSerializesEmptyStringInput)
pub mod omits_null_serializes_empty_string_input {

    use crate::operation::OmitsNullSerializesEmptyStringInput;
    /// A builder for [`OmitsNullSerializesEmptyStringInput`](crate::operation::OmitsNullSerializesEmptyStringInput)
    #[non_exhaustive]
    #[derive(Debug, Clone, Default)]
    pub struct Builder {
        null_value: Option<String>,
        empty_string: Option<String>,
    }
    impl Builder {
        pub fn null_value(mut self, inp: impl Into<String>) -> Self {
            self.null_value = Some(inp.into());
            self
        }
        pub fn empty_string(mut self, inp: impl Into<String>) -> Self {
            self.empty_string = Some(inp.into());
            self
        }
        /// Consumes the builder and constructs a [`OmitsNullSerializesEmptyStringInput`](crate::operation::OmitsNullSerializesEmptyStringInput)
        pub fn build(self) -> OmitsNullSerializesEmptyStringInput {
            OmitsNullSerializesEmptyStringInput {
                null_value: self.null_value,
                empty_string: self.empty_string,
            }
        }
    }
}

#[non_exhaustive]
#[derive(::std::clone::Clone, ::std::cmp::PartialEq, ::std::fmt::Debug)]
pub struct IgnoreQueryParamsInResponseOutput {
    pub baz: Option<String>,
}
impl IgnoreQueryParamsInResponseOutput {
    /// Creates a new builder-style object to manufacture [`IgnoreQueryParamsInResponseOutput`](crate::operation::IgnoreQueryParamsInResponseOutput)
    pub fn builder() -> crate::operation::ignore_query_params_in_response_output::Builder {
        crate::operation::ignore_query_params_in_response_output::Builder::default()
    }
}
/// See [`IgnoreQueryParamsInResponseOutput`](crate::operation::IgnoreQueryParamsInResponseOutput)
pub mod ignore_query_params_in_response_output {

    use crate::operation::IgnoreQueryParamsInResponseOutput;
    /// A builder for [`IgnoreQueryParamsInResponseOutput`](crate::operation::IgnoreQueryParamsInResponseOutput)
    #[non_exhaustive]
    #[derive(Debug, Clone, Default)]
    pub struct Builder {
        baz: Option<String>,
    }
    impl Builder {
        pub fn baz(mut self, inp: impl Into<String>) -> Self {
            self.baz = Some(inp.into());
            self
        }
        /// Consumes the builder and constructs a [`IgnoreQueryParamsInResponseOutput`](crate::operation::IgnoreQueryParamsInResponseOutput)
        pub fn build(self) -> IgnoreQueryParamsInResponseOutput {
            IgnoreQueryParamsInResponseOutput { baz: self.baz }
        }
    }
}

#[non_exhaustive]
#[derive(::std::clone::Clone, ::std::cmp::PartialEq, ::std::fmt::Debug)]
pub struct IgnoreQueryParamsInResponseInput {}
impl IgnoreQueryParamsInResponseInput {
    /// Creates a new builder-style object to manufacture [`IgnoreQueryParamsInResponseInput`](crate::operation::IgnoreQueryParamsInResponseInput)
    pub fn builder() -> crate::operation::ignore_query_params_in_response_input::Builder {
        crate::operation::ignore_query_params_in_response_input::Builder::default()
    }
}
/// See [`IgnoreQueryParamsInResponseInput`](crate::operation::IgnoreQueryParamsInResponseInput)
pub mod ignore_query_params_in_response_input {

    use crate::operation::IgnoreQueryParamsInResponseInput;
    /// A builder for [`IgnoreQueryParamsInResponseInput`](crate::operation::IgnoreQueryParamsInResponseInput)
    #[non_exhaustive]
    #[derive(Debug, Clone, Default)]
    pub struct Builder {}
    impl Builder {
        /// Consumes the builder and constructs a [`IgnoreQueryParamsInResponseInput`](crate::operation::IgnoreQueryParamsInResponseInput)
        pub fn build(self) -> IgnoreQueryParamsInResponseInput {
            IgnoreQueryParamsInResponseInput {}
        }
    }
}

#[non_exhaustive]
#[derive(::std::clone::Clone, ::std::cmp::PartialEq, ::std::fmt::Debug)]
pub struct ConstantAndVariableQueryStringOutput {}
impl ConstantAndVariableQueryStringOutput {
    /// Creates a new builder-style object to manufacture [`ConstantAndVariableQueryStringOutput`](crate::operation::ConstantAndVariableQueryStringOutput)
    pub fn builder() -> crate::operation::constant_and_variable_query_string_output::Builder {
        crate::operation::constant_and_variable_query_string_output::Builder::default()
    }
}
/// See [`ConstantAndVariableQueryStringOutput`](crate::operation::ConstantAndVariableQueryStringOutput)
pub mod constant_and_variable_query_string_output {

    use crate::operation::ConstantAndVariableQueryStringOutput;
    /// A builder for [`ConstantAndVariableQueryStringOutput`](crate::operation::ConstantAndVariableQueryStringOutput)
    #[non_exhaustive]
    #[derive(Debug, Clone, Default)]
    pub struct Builder {}
    impl Builder {
        /// Consumes the builder and constructs a [`ConstantAndVariableQueryStringOutput`](crate::operation::ConstantAndVariableQueryStringOutput)
        pub fn build(self) -> ConstantAndVariableQueryStringOutput {
            ConstantAndVariableQueryStringOutput {}
        }
    }
}

#[non_exhaustive]
#[derive(::std::clone::Clone, ::std::cmp::PartialEq, ::std::fmt::Debug)]
pub struct ConstantAndVariableQueryStringInput {
    pub baz: Option<String>,
    pub maybe_set: Option<String>,
}
impl ConstantAndVariableQueryStringInput {
    /// Creates a new builder-style object to manufacture [`ConstantAndVariableQueryStringInput`](crate::operation::ConstantAndVariableQueryStringInput)
    pub fn builder() -> crate::operation::constant_and_variable_query_string_input::Builder {
        crate::operation::constant_and_variable_query_string_input::Builder::default()
    }
}
/// See [`ConstantAndVariableQueryStringInput`](crate::operation::ConstantAndVariableQueryStringInput)
pub mod constant_and_variable_query_string_input {

    use crate::operation::ConstantAndVariableQueryStringInput;
    /// A builder for [`ConstantAndVariableQueryStringInput`](crate::operation::ConstantAndVariableQueryStringInput)
    #[non_exhaustive]
    #[derive(Debug, Clone, Default)]
    pub struct Builder {
        baz: Option<String>,
        maybe_set: Option<String>,
    }
    impl Builder {
        pub fn baz(mut self, inp: impl Into<String>) -> Self {
            self.baz = Some(inp.into());
            self
        }
        pub fn maybe_set(mut self, inp: impl Into<String>) -> Self {
            self.maybe_set = Some(inp.into());
            self
        }
        /// Consumes the builder and constructs a [`ConstantAndVariableQueryStringInput`](crate::operation::ConstantAndVariableQueryStringInput)
        pub fn build(self) -> ConstantAndVariableQueryStringInput {
            ConstantAndVariableQueryStringInput {
                baz: self.baz,
                maybe_set: self.maybe_set,
            }
        }
    }
}

#[non_exhaustive]
#[derive(::std::clone::Clone, ::std::cmp::PartialEq, ::std::fmt::Debug)]
pub struct ConstantQueryStringOutput {}
impl ConstantQueryStringOutput {
    /// Creates a new builder-style object to manufacture [`ConstantQueryStringOutput`](crate::operation::ConstantQueryStringOutput)
    pub fn builder() -> crate::operation::constant_query_string_output::Builder {
        crate::operation::constant_query_string_output::Builder::default()
    }
}
/// See [`ConstantQueryStringOutput`](crate::operation::ConstantQueryStringOutput)
pub mod constant_query_string_output {

    use crate::operation::ConstantQueryStringOutput;
    /// A builder for [`ConstantQueryStringOutput`](crate::operation::ConstantQueryStringOutput)
    #[non_exhaustive]
    #[derive(Debug, Clone, Default)]
    pub struct Builder {}
    impl Builder {
        /// Consumes the builder and constructs a [`ConstantQueryStringOutput`](crate::operation::ConstantQueryStringOutput)
        pub fn build(self) -> ConstantQueryStringOutput {
            ConstantQueryStringOutput {}
        }
    }
}

#[non_exhaustive]
#[derive(::std::clone::Clone, ::std::cmp::PartialEq, ::std::fmt::Debug)]
pub struct ConstantQueryStringInput {
    pub hello: String,
}
impl ConstantQueryStringInput {
    /// Creates a new builder-style object to manufacture [`ConstantQueryStringInput`](crate::operation::ConstantQueryStringInput)
    pub fn builder() -> crate::operation::constant_query_string_input::Builder {
        crate::operation::constant_query_string_input::Builder::default()
    }
}
/// See [`ConstantQueryStringInput`](crate::operation::ConstantQueryStringInput)
pub mod constant_query_string_input {

    use crate::operation::ConstantQueryStringInput;
    /// A builder for [`ConstantQueryStringInput`](crate::operation::ConstantQueryStringInput)
    #[non_exhaustive]
    #[derive(Debug, Clone, Default)]
    pub struct Builder {
        hello: Option<String>,
    }
    impl Builder {
        pub fn hello(mut self, inp: impl Into<String>) -> Self {
            self.hello = Some(inp.into());
            self
        }
        /// Consumes the builder and constructs a [`ConstantQueryStringInput`](crate::operation::ConstantQueryStringInput)
        pub fn build(self) -> ConstantQueryStringInput {
            ConstantQueryStringInput {
                hello: self.hello.unwrap_or_default(),
            }
        }
    }
}

#[non_exhaustive]
#[derive(::std::clone::Clone, ::std::cmp::PartialEq, ::std::fmt::Debug)]
pub struct AllQueryStringTypesOutput {}
impl AllQueryStringTypesOutput {
    /// Creates a new builder-style object to manufacture [`AllQueryStringTypesOutput`](crate::operation::AllQueryStringTypesOutput)
    pub fn builder() -> crate::operation::all_query_string_types_output::Builder {
        crate::operation::all_query_string_types_output::Builder::default()
    }
}
/// See [`AllQueryStringTypesOutput`](crate::operation::AllQueryStringTypesOutput)
pub mod all_query_string_types_output {

    use crate::operation::AllQueryStringTypesOutput;
    /// A builder for [`AllQueryStringTypesOutput`](crate::operation::AllQueryStringTypesOutput)
    #[non_exhaustive]
    #[derive(Debug, Clone, Default)]
    pub struct Builder {}
    impl Builder {
        /// Consumes the builder and constructs a [`AllQueryStringTypesOutput`](crate::operation::AllQueryStringTypesOutput)
        pub fn build(self) -> AllQueryStringTypesOutput {
            AllQueryStringTypesOutput {}
        }
    }
}

#[non_exhaustive]
#[derive(::std::clone::Clone, ::std::cmp::PartialEq, ::std::fmt::Debug)]
pub struct AllQueryStringTypesInput {
    pub query_string: Option<String>,
    pub query_string_list: Option<Vec<String>>,
    pub query_string_set: Option<BTreeSet<String>>,
    pub query_byte: Option<i8>,
    pub query_short: Option<i16>,
    pub query_integer: Option<i32>,
    pub query_integer_list: Option<Vec<i32>>,
    pub query_integer_set: Option<Vec<i32>>,
    pub query_long: Option<i64>,
    pub query_float: Option<f32>,
    pub query_double: Option<f64>,
    pub query_double_list: Option<Vec<f64>>,
    pub query_boolean: Option<bool>,
    pub query_boolean_list: Option<Vec<bool>>,
    pub query_timestamp: Option<Instant>,
    pub query_timestamp_list: Option<Vec<Instant>>,
    pub query_enum: Option<FooEnum>,
    pub query_enum_list: Option<Vec<FooEnum>>,
}
impl AllQueryStringTypesInput {
    /// Creates a new builder-style object to manufacture [`AllQueryStringTypesInput`](crate::operation::AllQueryStringTypesInput)
    pub fn builder() -> crate::operation::all_query_string_types_input::Builder {
        crate::operation::all_query_string_types_input::Builder::default()
    }
}
/// See [`AllQueryStringTypesInput`](crate::operation::AllQueryStringTypesInput)
pub mod all_query_string_types_input {

    use crate::model::FooEnum;
    use crate::operation::AllQueryStringTypesInput;
    use smithy_types::Instant;
    use std::collections::BTreeSet;
    /// A builder for [`AllQueryStringTypesInput`](crate::operation::AllQueryStringTypesInput)
    #[non_exhaustive]
    #[derive(Debug, Clone, Default)]
    pub struct Builder {
        query_string: Option<String>,
        query_string_list: Option<Vec<String>>,
        query_string_set: Option<BTreeSet<String>>,
        query_byte: Option<i8>,
        query_short: Option<i16>,
        query_integer: Option<i32>,
        query_integer_list: Option<Vec<i32>>,
        query_integer_set: Option<Vec<i32>>,
        query_long: Option<i64>,
        query_float: Option<f32>,
        query_double: Option<f64>,
        query_double_list: Option<Vec<f64>>,
        query_boolean: Option<bool>,
        query_boolean_list: Option<Vec<bool>>,
        query_timestamp: Option<Instant>,
        query_timestamp_list: Option<Vec<Instant>>,
        query_enum: Option<FooEnum>,
        query_enum_list: Option<Vec<FooEnum>>,
    }
    impl Builder {
        pub fn query_string(mut self, inp: impl Into<String>) -> Self {
            self.query_string = Some(inp.into());
            self
        }
        pub fn query_string_list(mut self, inp: Vec<String>) -> Self {
            self.query_string_list = Some(inp);
            self
        }
        pub fn query_string_set(mut self, inp: BTreeSet<String>) -> Self {
            self.query_string_set = Some(inp);
            self
        }
        pub fn query_byte(mut self, inp: i8) -> Self {
            self.query_byte = Some(inp);
            self
        }
        pub fn query_short(mut self, inp: i16) -> Self {
            self.query_short = Some(inp);
            self
        }
        pub fn query_integer(mut self, inp: i32) -> Self {
            self.query_integer = Some(inp);
            self
        }
        pub fn query_integer_list(mut self, inp: Vec<i32>) -> Self {
            self.query_integer_list = Some(inp);
            self
        }
        pub fn query_integer_set(mut self, inp: Vec<i32>) -> Self {
            self.query_integer_set = Some(inp);
            self
        }
        pub fn query_long(mut self, inp: i64) -> Self {
            self.query_long = Some(inp);
            self
        }
        pub fn query_float(mut self, inp: f32) -> Self {
            self.query_float = Some(inp);
            self
        }
        pub fn query_double(mut self, inp: f64) -> Self {
            self.query_double = Some(inp);
            self
        }
        pub fn query_double_list(mut self, inp: Vec<f64>) -> Self {
            self.query_double_list = Some(inp);
            self
        }
        pub fn query_boolean(mut self, inp: bool) -> Self {
            self.query_boolean = Some(inp);
            self
        }
        pub fn query_boolean_list(mut self, inp: Vec<bool>) -> Self {
            self.query_boolean_list = Some(inp);
            self
        }
        pub fn query_timestamp(mut self, inp: Instant) -> Self {
            self.query_timestamp = Some(inp);
            self
        }
        pub fn query_timestamp_list(mut self, inp: Vec<Instant>) -> Self {
            self.query_timestamp_list = Some(inp);
            self
        }
        pub fn query_enum(mut self, inp: FooEnum) -> Self {
            self.query_enum = Some(inp);
            self
        }
        pub fn query_enum_list(mut self, inp: Vec<FooEnum>) -> Self {
            self.query_enum_list = Some(inp);
            self
        }
        /// Consumes the builder and constructs a [`AllQueryStringTypesInput`](crate::operation::AllQueryStringTypesInput)
        pub fn build(self) -> AllQueryStringTypesInput {
            AllQueryStringTypesInput {
                query_string: self.query_string,
                query_string_list: self.query_string_list,
                query_string_set: self.query_string_set,
                query_byte: self.query_byte,
                query_short: self.query_short,
                query_integer: self.query_integer,
                query_integer_list: self.query_integer_list,
                query_integer_set: self.query_integer_set,
                query_long: self.query_long,
                query_float: self.query_float,
                query_double: self.query_double,
                query_double_list: self.query_double_list,
                query_boolean: self.query_boolean,
                query_boolean_list: self.query_boolean_list,
                query_timestamp: self.query_timestamp,
                query_timestamp_list: self.query_timestamp_list,
                query_enum: self.query_enum,
                query_enum_list: self.query_enum_list,
            }
        }
    }
}

#[non_exhaustive]
#[derive(::std::clone::Clone, ::std::cmp::PartialEq, ::std::fmt::Debug)]
pub struct HttpRequestWithGreedyLabelInPathOutput {}
impl HttpRequestWithGreedyLabelInPathOutput {
    /// Creates a new builder-style object to manufacture [`HttpRequestWithGreedyLabelInPathOutput`](crate::operation::HttpRequestWithGreedyLabelInPathOutput)
    pub fn builder() -> crate::operation::http_request_with_greedy_label_in_path_output::Builder {
        crate::operation::http_request_with_greedy_label_in_path_output::Builder::default()
    }
}
/// See [`HttpRequestWithGreedyLabelInPathOutput`](crate::operation::HttpRequestWithGreedyLabelInPathOutput)
pub mod http_request_with_greedy_label_in_path_output {

    use crate::operation::HttpRequestWithGreedyLabelInPathOutput;
    /// A builder for [`HttpRequestWithGreedyLabelInPathOutput`](crate::operation::HttpRequestWithGreedyLabelInPathOutput)
    #[non_exhaustive]
    #[derive(Debug, Clone, Default)]
    pub struct Builder {}
    impl Builder {
        /// Consumes the builder and constructs a [`HttpRequestWithGreedyLabelInPathOutput`](crate::operation::HttpRequestWithGreedyLabelInPathOutput)
        pub fn build(self) -> HttpRequestWithGreedyLabelInPathOutput {
            HttpRequestWithGreedyLabelInPathOutput {}
        }
    }
}

#[non_exhaustive]
#[derive(::std::clone::Clone, ::std::cmp::PartialEq, ::std::fmt::Debug)]
pub struct HttpRequestWithGreedyLabelInPathInput {
    pub foo: String,
    pub baz: String,
}
impl HttpRequestWithGreedyLabelInPathInput {
    /// Creates a new builder-style object to manufacture [`HttpRequestWithGreedyLabelInPathInput`](crate::operation::HttpRequestWithGreedyLabelInPathInput)
    pub fn builder() -> crate::operation::http_request_with_greedy_label_in_path_input::Builder {
        crate::operation::http_request_with_greedy_label_in_path_input::Builder::default()
    }
}
/// See [`HttpRequestWithGreedyLabelInPathInput`](crate::operation::HttpRequestWithGreedyLabelInPathInput)
pub mod http_request_with_greedy_label_in_path_input {

    use crate::operation::HttpRequestWithGreedyLabelInPathInput;
    /// A builder for [`HttpRequestWithGreedyLabelInPathInput`](crate::operation::HttpRequestWithGreedyLabelInPathInput)
    #[non_exhaustive]
    #[derive(Debug, Clone, Default)]
    pub struct Builder {
        foo: Option<String>,
        baz: Option<String>,
    }
    impl Builder {
        pub fn foo(mut self, inp: impl Into<String>) -> Self {
            self.foo = Some(inp.into());
            self
        }
        pub fn baz(mut self, inp: impl Into<String>) -> Self {
            self.baz = Some(inp.into());
            self
        }
        /// Consumes the builder and constructs a [`HttpRequestWithGreedyLabelInPathInput`](crate::operation::HttpRequestWithGreedyLabelInPathInput)
        pub fn build(self) -> HttpRequestWithGreedyLabelInPathInput {
            HttpRequestWithGreedyLabelInPathInput {
                foo: self.foo.unwrap_or_default(),
                baz: self.baz.unwrap_or_default(),
            }
        }
    }
}

#[non_exhaustive]
#[derive(::std::clone::Clone, ::std::cmp::PartialEq, ::std::fmt::Debug)]
pub struct HttpRequestWithLabelsAndTimestampFormatOutput {}
impl HttpRequestWithLabelsAndTimestampFormatOutput {
    /// Creates a new builder-style object to manufacture [`HttpRequestWithLabelsAndTimestampFormatOutput`](crate::operation::HttpRequestWithLabelsAndTimestampFormatOutput)
    pub fn builder(
    ) -> crate::operation::http_request_with_labels_and_timestamp_format_output::Builder {
        crate::operation::http_request_with_labels_and_timestamp_format_output::Builder::default()
    }
}
/// See [`HttpRequestWithLabelsAndTimestampFormatOutput`](crate::operation::HttpRequestWithLabelsAndTimestampFormatOutput)
pub mod http_request_with_labels_and_timestamp_format_output {

    use crate::operation::HttpRequestWithLabelsAndTimestampFormatOutput;
    /// A builder for [`HttpRequestWithLabelsAndTimestampFormatOutput`](crate::operation::HttpRequestWithLabelsAndTimestampFormatOutput)
    #[non_exhaustive]
    #[derive(Debug, Clone, Default)]
    pub struct Builder {}
    impl Builder {
        /// Consumes the builder and constructs a [`HttpRequestWithLabelsAndTimestampFormatOutput`](crate::operation::HttpRequestWithLabelsAndTimestampFormatOutput)
        pub fn build(self) -> HttpRequestWithLabelsAndTimestampFormatOutput {
            HttpRequestWithLabelsAndTimestampFormatOutput {}
        }
    }
}

#[non_exhaustive]
#[derive(::std::clone::Clone, ::std::cmp::PartialEq, ::std::fmt::Debug)]
pub struct HttpRequestWithLabelsAndTimestampFormatInput {
    pub member_epoch_seconds: Instant,
    pub member_http_date: Instant,
    pub member_date_time: Instant,
    pub default_format: Instant,
    pub target_epoch_seconds: Instant,
    pub target_http_date: Instant,
    pub target_date_time: Instant,
}
impl HttpRequestWithLabelsAndTimestampFormatInput {
    /// Creates a new builder-style object to manufacture [`HttpRequestWithLabelsAndTimestampFormatInput`](crate::operation::HttpRequestWithLabelsAndTimestampFormatInput)
    pub fn builder(
    ) -> crate::operation::http_request_with_labels_and_timestamp_format_input::Builder {
        crate::operation::http_request_with_labels_and_timestamp_format_input::Builder::default()
    }
}
/// See [`HttpRequestWithLabelsAndTimestampFormatInput`](crate::operation::HttpRequestWithLabelsAndTimestampFormatInput)
pub mod http_request_with_labels_and_timestamp_format_input {

    use crate::operation::HttpRequestWithLabelsAndTimestampFormatInput;
    use smithy_types::Instant;
    /// A builder for [`HttpRequestWithLabelsAndTimestampFormatInput`](crate::operation::HttpRequestWithLabelsAndTimestampFormatInput)
    #[non_exhaustive]
    #[derive(Debug, Clone, Default)]
    pub struct Builder {
        member_epoch_seconds: Option<Instant>,
        member_http_date: Option<Instant>,
        member_date_time: Option<Instant>,
        default_format: Option<Instant>,
        target_epoch_seconds: Option<Instant>,
        target_http_date: Option<Instant>,
        target_date_time: Option<Instant>,
    }
    impl Builder {
        pub fn member_epoch_seconds(mut self, inp: Instant) -> Self {
            self.member_epoch_seconds = Some(inp);
            self
        }
        pub fn member_http_date(mut self, inp: Instant) -> Self {
            self.member_http_date = Some(inp);
            self
        }
        pub fn member_date_time(mut self, inp: Instant) -> Self {
            self.member_date_time = Some(inp);
            self
        }
        pub fn default_format(mut self, inp: Instant) -> Self {
            self.default_format = Some(inp);
            self
        }
        pub fn target_epoch_seconds(mut self, inp: Instant) -> Self {
            self.target_epoch_seconds = Some(inp);
            self
        }
        pub fn target_http_date(mut self, inp: Instant) -> Self {
            self.target_http_date = Some(inp);
            self
        }
        pub fn target_date_time(mut self, inp: Instant) -> Self {
            self.target_date_time = Some(inp);
            self
        }
        /// Consumes the builder and constructs a [`HttpRequestWithLabelsAndTimestampFormatInput`](crate::operation::HttpRequestWithLabelsAndTimestampFormatInput)
        pub fn build(self) -> Result<HttpRequestWithLabelsAndTimestampFormatInput, String> {
            Ok(
                HttpRequestWithLabelsAndTimestampFormatInput {
                    member_epoch_seconds: self.member_epoch_seconds.ok_or("member_epoch_seconds is required when building HttpRequestWithLabelsAndTimestampFormatInput")?,
                    member_http_date: self.member_http_date.ok_or("member_http_date is required when building HttpRequestWithLabelsAndTimestampFormatInput")?,
                    member_date_time: self.member_date_time.ok_or("member_date_time is required when building HttpRequestWithLabelsAndTimestampFormatInput")?,
                    default_format: self.default_format.ok_or("default_format is required when building HttpRequestWithLabelsAndTimestampFormatInput")?,
                    target_epoch_seconds: self.target_epoch_seconds.ok_or("target_epoch_seconds is required when building HttpRequestWithLabelsAndTimestampFormatInput")?,
                    target_http_date: self.target_http_date.ok_or("target_http_date is required when building HttpRequestWithLabelsAndTimestampFormatInput")?,
                    target_date_time: self.target_date_time.ok_or("target_date_time is required when building HttpRequestWithLabelsAndTimestampFormatInput")?,
                }
            )
        }
    }
}

#[non_exhaustive]
#[derive(::std::clone::Clone, ::std::cmp::PartialEq, ::std::fmt::Debug)]
pub struct HttpRequestWithLabelsOutput {}
impl HttpRequestWithLabelsOutput {
    /// Creates a new builder-style object to manufacture [`HttpRequestWithLabelsOutput`](crate::operation::HttpRequestWithLabelsOutput)
    pub fn builder() -> crate::operation::http_request_with_labels_output::Builder {
        crate::operation::http_request_with_labels_output::Builder::default()
    }
}
/// See [`HttpRequestWithLabelsOutput`](crate::operation::HttpRequestWithLabelsOutput)
pub mod http_request_with_labels_output {

    use crate::operation::HttpRequestWithLabelsOutput;
    /// A builder for [`HttpRequestWithLabelsOutput`](crate::operation::HttpRequestWithLabelsOutput)
    #[non_exhaustive]
    #[derive(Debug, Clone, Default)]
    pub struct Builder {}
    impl Builder {
        /// Consumes the builder and constructs a [`HttpRequestWithLabelsOutput`](crate::operation::HttpRequestWithLabelsOutput)
        pub fn build(self) -> HttpRequestWithLabelsOutput {
            HttpRequestWithLabelsOutput {}
        }
    }
}

#[non_exhaustive]
#[derive(::std::clone::Clone, ::std::cmp::PartialEq, ::std::fmt::Debug)]
pub struct HttpRequestWithLabelsInput {
    pub string: String,
    pub short: i16,
    pub integer: i32,
    pub long: i64,
    pub float: f32,
    pub double: f64,
    /// Serialized in the path as true or false.
    pub boolean: bool,
    /// Note that this member has no format, so it's serialized as an RFC 3399 date-time.
    pub timestamp: Instant,
}
impl HttpRequestWithLabelsInput {
    /// Creates a new builder-style object to manufacture [`HttpRequestWithLabelsInput`](crate::operation::HttpRequestWithLabelsInput)
    pub fn builder() -> crate::operation::http_request_with_labels_input::Builder {
        crate::operation::http_request_with_labels_input::Builder::default()
    }
}
/// See [`HttpRequestWithLabelsInput`](crate::operation::HttpRequestWithLabelsInput)
pub mod http_request_with_labels_input {

    use crate::operation::HttpRequestWithLabelsInput;
    use smithy_types::Instant;
    /// A builder for [`HttpRequestWithLabelsInput`](crate::operation::HttpRequestWithLabelsInput)
    #[non_exhaustive]
    #[derive(Debug, Clone, Default)]
    pub struct Builder {
        string: Option<String>,
        short: Option<i16>,
        integer: Option<i32>,
        long: Option<i64>,
        float: Option<f32>,
        double: Option<f64>,
        boolean: Option<bool>,
        timestamp: Option<Instant>,
    }
    impl Builder {
        pub fn string(mut self, inp: impl Into<String>) -> Self {
            self.string = Some(inp.into());
            self
        }
        pub fn short(mut self, inp: i16) -> Self {
            self.short = Some(inp);
            self
        }
        pub fn integer(mut self, inp: i32) -> Self {
            self.integer = Some(inp);
            self
        }
        pub fn long(mut self, inp: i64) -> Self {
            self.long = Some(inp);
            self
        }
        pub fn float(mut self, inp: f32) -> Self {
            self.float = Some(inp);
            self
        }
        pub fn double(mut self, inp: f64) -> Self {
            self.double = Some(inp);
            self
        }
        /// Serialized in the path as true or false.
        pub fn boolean(mut self, inp: bool) -> Self {
            self.boolean = Some(inp);
            self
        }
        /// Note that this member has no format, so it's serialized as an RFC 3399 date-time.
        pub fn timestamp(mut self, inp: Instant) -> Self {
            self.timestamp = Some(inp);
            self
        }
        /// Consumes the builder and constructs a [`HttpRequestWithLabelsInput`](crate::operation::HttpRequestWithLabelsInput)
        pub fn build(self) -> Result<HttpRequestWithLabelsInput, String> {
            Ok(HttpRequestWithLabelsInput {
                string: self.string.unwrap_or_default(),
                short: self.short.unwrap_or_default(),
                integer: self.integer.unwrap_or_default(),
                long: self.long.unwrap_or_default(),
                float: self.float.unwrap_or_default(),
                double: self.double.unwrap_or_default(),
                boolean: self.boolean.unwrap_or_default(),
                timestamp: self
                    .timestamp
                    .ok_or("timestamp is required when building HttpRequestWithLabelsInput")?,
            })
        }
    }
}

#[non_exhaustive]
#[derive(::std::clone::Clone, ::std::cmp::PartialEq, ::std::fmt::Debug)]
pub struct MediaTypeHeaderOutput {
    pub json: Option<String>,
}
impl MediaTypeHeaderOutput {
    /// Creates a new builder-style object to manufacture [`MediaTypeHeaderOutput`](crate::operation::MediaTypeHeaderOutput)
    pub fn builder() -> crate::operation::media_type_header_output::Builder {
        crate::operation::media_type_header_output::Builder::default()
    }
}
/// See [`MediaTypeHeaderOutput`](crate::operation::MediaTypeHeaderOutput)
pub mod media_type_header_output {

    use crate::operation::MediaTypeHeaderOutput;
    /// A builder for [`MediaTypeHeaderOutput`](crate::operation::MediaTypeHeaderOutput)
    #[non_exhaustive]
    #[derive(Debug, Clone, Default)]
    pub struct Builder {
        json: Option<String>,
    }
    impl Builder {
        pub fn json(mut self, inp: impl Into<String>) -> Self {
            self.json = Some(inp.into());
            self
        }
        /// Consumes the builder and constructs a [`MediaTypeHeaderOutput`](crate::operation::MediaTypeHeaderOutput)
        pub fn build(self) -> MediaTypeHeaderOutput {
            MediaTypeHeaderOutput { json: self.json }
        }
    }
}

#[non_exhaustive]
#[derive(::std::clone::Clone, ::std::cmp::PartialEq, ::std::fmt::Debug)]
pub struct MediaTypeHeaderInput {
    pub json: Option<String>,
}
impl MediaTypeHeaderInput {
    /// Creates a new builder-style object to manufacture [`MediaTypeHeaderInput`](crate::operation::MediaTypeHeaderInput)
    pub fn builder() -> crate::operation::media_type_header_input::Builder {
        crate::operation::media_type_header_input::Builder::default()
    }
}
/// See [`MediaTypeHeaderInput`](crate::operation::MediaTypeHeaderInput)
pub mod media_type_header_input {

    use crate::operation::MediaTypeHeaderInput;
    /// A builder for [`MediaTypeHeaderInput`](crate::operation::MediaTypeHeaderInput)
    #[non_exhaustive]
    #[derive(Debug, Clone, Default)]
    pub struct Builder {
        json: Option<String>,
    }
    impl Builder {
        pub fn json(mut self, inp: impl Into<String>) -> Self {
            self.json = Some(inp.into());
            self
        }
        /// Consumes the builder and constructs a [`MediaTypeHeaderInput`](crate::operation::MediaTypeHeaderInput)
        pub fn build(self) -> MediaTypeHeaderInput {
            MediaTypeHeaderInput { json: self.json }
        }
    }
}

#[non_exhaustive]
#[derive(::std::clone::Clone, ::std::cmp::PartialEq, ::std::fmt::Debug)]
pub struct TimestampFormatHeadersOutput {
    pub member_epoch_seconds: Option<Instant>,
    pub member_http_date: Option<Instant>,
    pub member_date_time: Option<Instant>,
    pub default_format: Option<Instant>,
    pub target_epoch_seconds: Option<Instant>,
    pub target_http_date: Option<Instant>,
    pub target_date_time: Option<Instant>,
}
impl TimestampFormatHeadersOutput {
    /// Creates a new builder-style object to manufacture [`TimestampFormatHeadersOutput`](crate::operation::TimestampFormatHeadersOutput)
    pub fn builder() -> crate::operation::timestamp_format_headers_output::Builder {
        crate::operation::timestamp_format_headers_output::Builder::default()
    }
}
/// See [`TimestampFormatHeadersOutput`](crate::operation::TimestampFormatHeadersOutput)
pub mod timestamp_format_headers_output {

    use crate::operation::TimestampFormatHeadersOutput;
    use smithy_types::Instant;
    /// A builder for [`TimestampFormatHeadersOutput`](crate::operation::TimestampFormatHeadersOutput)
    #[non_exhaustive]
    #[derive(Debug, Clone, Default)]
    pub struct Builder {
        member_epoch_seconds: Option<Instant>,
        member_http_date: Option<Instant>,
        member_date_time: Option<Instant>,
        default_format: Option<Instant>,
        target_epoch_seconds: Option<Instant>,
        target_http_date: Option<Instant>,
        target_date_time: Option<Instant>,
    }
    impl Builder {
        pub fn member_epoch_seconds(mut self, inp: Instant) -> Self {
            self.member_epoch_seconds = Some(inp);
            self
        }
        pub fn member_http_date(mut self, inp: Instant) -> Self {
            self.member_http_date = Some(inp);
            self
        }
        pub fn member_date_time(mut self, inp: Instant) -> Self {
            self.member_date_time = Some(inp);
            self
        }
        pub fn default_format(mut self, inp: Instant) -> Self {
            self.default_format = Some(inp);
            self
        }
        pub fn target_epoch_seconds(mut self, inp: Instant) -> Self {
            self.target_epoch_seconds = Some(inp);
            self
        }
        pub fn target_http_date(mut self, inp: Instant) -> Self {
            self.target_http_date = Some(inp);
            self
        }
        pub fn target_date_time(mut self, inp: Instant) -> Self {
            self.target_date_time = Some(inp);
            self
        }
        /// Consumes the builder and constructs a [`TimestampFormatHeadersOutput`](crate::operation::TimestampFormatHeadersOutput)
        pub fn build(self) -> TimestampFormatHeadersOutput {
            TimestampFormatHeadersOutput {
                member_epoch_seconds: self.member_epoch_seconds,
                member_http_date: self.member_http_date,
                member_date_time: self.member_date_time,
                default_format: self.default_format,
                target_epoch_seconds: self.target_epoch_seconds,
                target_http_date: self.target_http_date,
                target_date_time: self.target_date_time,
            }
        }
    }
}

#[non_exhaustive]
#[derive(::std::clone::Clone, ::std::cmp::PartialEq, ::std::fmt::Debug)]
pub struct TimestampFormatHeadersInput {
    pub member_epoch_seconds: Option<Instant>,
    pub member_http_date: Option<Instant>,
    pub member_date_time: Option<Instant>,
    pub default_format: Option<Instant>,
    pub target_epoch_seconds: Option<Instant>,
    pub target_http_date: Option<Instant>,
    pub target_date_time: Option<Instant>,
}
impl TimestampFormatHeadersInput {
    /// Creates a new builder-style object to manufacture [`TimestampFormatHeadersInput`](crate::operation::TimestampFormatHeadersInput)
    pub fn builder() -> crate::operation::timestamp_format_headers_input::Builder {
        crate::operation::timestamp_format_headers_input::Builder::default()
    }
}
/// See [`TimestampFormatHeadersInput`](crate::operation::TimestampFormatHeadersInput)
pub mod timestamp_format_headers_input {

    use crate::operation::TimestampFormatHeadersInput;
    use smithy_types::Instant;
    /// A builder for [`TimestampFormatHeadersInput`](crate::operation::TimestampFormatHeadersInput)
    #[non_exhaustive]
    #[derive(Debug, Clone, Default)]
    pub struct Builder {
        member_epoch_seconds: Option<Instant>,
        member_http_date: Option<Instant>,
        member_date_time: Option<Instant>,
        default_format: Option<Instant>,
        target_epoch_seconds: Option<Instant>,
        target_http_date: Option<Instant>,
        target_date_time: Option<Instant>,
    }
    impl Builder {
        pub fn member_epoch_seconds(mut self, inp: Instant) -> Self {
            self.member_epoch_seconds = Some(inp);
            self
        }
        pub fn member_http_date(mut self, inp: Instant) -> Self {
            self.member_http_date = Some(inp);
            self
        }
        pub fn member_date_time(mut self, inp: Instant) -> Self {
            self.member_date_time = Some(inp);
            self
        }
        pub fn default_format(mut self, inp: Instant) -> Self {
            self.default_format = Some(inp);
            self
        }
        pub fn target_epoch_seconds(mut self, inp: Instant) -> Self {
            self.target_epoch_seconds = Some(inp);
            self
        }
        pub fn target_http_date(mut self, inp: Instant) -> Self {
            self.target_http_date = Some(inp);
            self
        }
        pub fn target_date_time(mut self, inp: Instant) -> Self {
            self.target_date_time = Some(inp);
            self
        }
        /// Consumes the builder and constructs a [`TimestampFormatHeadersInput`](crate::operation::TimestampFormatHeadersInput)
        pub fn build(self) -> TimestampFormatHeadersInput {
            TimestampFormatHeadersInput {
                member_epoch_seconds: self.member_epoch_seconds,
                member_http_date: self.member_http_date,
                member_date_time: self.member_date_time,
                default_format: self.default_format,
                target_epoch_seconds: self.target_epoch_seconds,
                target_http_date: self.target_http_date,
                target_date_time: self.target_date_time,
            }
        }
    }
}

#[non_exhaustive]
#[derive(::std::clone::Clone, ::std::cmp::PartialEq, ::std::fmt::Debug)]
pub struct NullAndEmptyHeadersServerOutput {
    pub a: Option<String>,
    pub b: Option<String>,
    pub c: Option<Vec<String>>,
}
impl NullAndEmptyHeadersServerOutput {
    /// Creates a new builder-style object to manufacture [`NullAndEmptyHeadersServerOutput`](crate::operation::NullAndEmptyHeadersServerOutput)
    pub fn builder() -> crate::operation::null_and_empty_headers_server_output::Builder {
        crate::operation::null_and_empty_headers_server_output::Builder::default()
    }
}
/// See [`NullAndEmptyHeadersServerOutput`](crate::operation::NullAndEmptyHeadersServerOutput)
pub mod null_and_empty_headers_server_output {

    use crate::operation::NullAndEmptyHeadersServerOutput;
    /// A builder for [`NullAndEmptyHeadersServerOutput`](crate::operation::NullAndEmptyHeadersServerOutput)
    #[non_exhaustive]
    #[derive(Debug, Clone, Default)]
    pub struct Builder {
        a: Option<String>,
        b: Option<String>,
        c: Option<Vec<String>>,
    }
    impl Builder {
        pub fn a(mut self, inp: impl Into<String>) -> Self {
            self.a = Some(inp.into());
            self
        }
        pub fn b(mut self, inp: impl Into<String>) -> Self {
            self.b = Some(inp.into());
            self
        }
        pub fn c(mut self, inp: Vec<String>) -> Self {
            self.c = Some(inp);
            self
        }
        /// Consumes the builder and constructs a [`NullAndEmptyHeadersServerOutput`](crate::operation::NullAndEmptyHeadersServerOutput)
        pub fn build(self) -> NullAndEmptyHeadersServerOutput {
            NullAndEmptyHeadersServerOutput {
                a: self.a,
                b: self.b,
                c: self.c,
            }
        }
    }
}

#[non_exhaustive]
#[derive(::std::clone::Clone, ::std::cmp::PartialEq, ::std::fmt::Debug)]
pub struct NullAndEmptyHeadersServerInput {
    pub a: Option<String>,
    pub b: Option<String>,
    pub c: Option<Vec<String>>,
}
impl NullAndEmptyHeadersServerInput {
    /// Creates a new builder-style object to manufacture [`NullAndEmptyHeadersServerInput`](crate::operation::NullAndEmptyHeadersServerInput)
    pub fn builder() -> crate::operation::null_and_empty_headers_server_input::Builder {
        crate::operation::null_and_empty_headers_server_input::Builder::default()
    }
}
/// See [`NullAndEmptyHeadersServerInput`](crate::operation::NullAndEmptyHeadersServerInput)
pub mod null_and_empty_headers_server_input {

    use crate::operation::NullAndEmptyHeadersServerInput;
    /// A builder for [`NullAndEmptyHeadersServerInput`](crate::operation::NullAndEmptyHeadersServerInput)
    #[non_exhaustive]
    #[derive(Debug, Clone, Default)]
    pub struct Builder {
        a: Option<String>,
        b: Option<String>,
        c: Option<Vec<String>>,
    }
    impl Builder {
        pub fn a(mut self, inp: impl Into<String>) -> Self {
            self.a = Some(inp.into());
            self
        }
        pub fn b(mut self, inp: impl Into<String>) -> Self {
            self.b = Some(inp.into());
            self
        }
        pub fn c(mut self, inp: Vec<String>) -> Self {
            self.c = Some(inp);
            self
        }
        /// Consumes the builder and constructs a [`NullAndEmptyHeadersServerInput`](crate::operation::NullAndEmptyHeadersServerInput)
        pub fn build(self) -> NullAndEmptyHeadersServerInput {
            NullAndEmptyHeadersServerInput {
                a: self.a,
                b: self.b,
                c: self.c,
            }
        }
    }
}

#[non_exhaustive]
#[derive(::std::clone::Clone, ::std::cmp::PartialEq, ::std::fmt::Debug)]
pub struct NullAndEmptyHeadersClientOutput {
    pub a: Option<String>,
    pub b: Option<String>,
    pub c: Option<Vec<String>>,
}
impl NullAndEmptyHeadersClientOutput {
    /// Creates a new builder-style object to manufacture [`NullAndEmptyHeadersClientOutput`](crate::operation::NullAndEmptyHeadersClientOutput)
    pub fn builder() -> crate::operation::null_and_empty_headers_client_output::Builder {
        crate::operation::null_and_empty_headers_client_output::Builder::default()
    }
}
/// See [`NullAndEmptyHeadersClientOutput`](crate::operation::NullAndEmptyHeadersClientOutput)
pub mod null_and_empty_headers_client_output {

    use crate::operation::NullAndEmptyHeadersClientOutput;
    /// A builder for [`NullAndEmptyHeadersClientOutput`](crate::operation::NullAndEmptyHeadersClientOutput)
    #[non_exhaustive]
    #[derive(Debug, Clone, Default)]
    pub struct Builder {
        a: Option<String>,
        b: Option<String>,
        c: Option<Vec<String>>,
    }
    impl Builder {
        pub fn a(mut self, inp: impl Into<String>) -> Self {
            self.a = Some(inp.into());
            self
        }
        pub fn b(mut self, inp: impl Into<String>) -> Self {
            self.b = Some(inp.into());
            self
        }
        pub fn c(mut self, inp: Vec<String>) -> Self {
            self.c = Some(inp);
            self
        }
        /// Consumes the builder and constructs a [`NullAndEmptyHeadersClientOutput`](crate::operation::NullAndEmptyHeadersClientOutput)
        pub fn build(self) -> NullAndEmptyHeadersClientOutput {
            NullAndEmptyHeadersClientOutput {
                a: self.a,
                b: self.b,
                c: self.c,
            }
        }
    }
}

#[non_exhaustive]
#[derive(::std::clone::Clone, ::std::cmp::PartialEq, ::std::fmt::Debug)]
pub struct NullAndEmptyHeadersClientInput {
    pub a: Option<String>,
    pub b: Option<String>,
    pub c: Option<Vec<String>>,
}
impl NullAndEmptyHeadersClientInput {
    /// Creates a new builder-style object to manufacture [`NullAndEmptyHeadersClientInput`](crate::operation::NullAndEmptyHeadersClientInput)
    pub fn builder() -> crate::operation::null_and_empty_headers_client_input::Builder {
        crate::operation::null_and_empty_headers_client_input::Builder::default()
    }
}
/// See [`NullAndEmptyHeadersClientInput`](crate::operation::NullAndEmptyHeadersClientInput)
pub mod null_and_empty_headers_client_input {

    use crate::operation::NullAndEmptyHeadersClientInput;
    /// A builder for [`NullAndEmptyHeadersClientInput`](crate::operation::NullAndEmptyHeadersClientInput)
    #[non_exhaustive]
    #[derive(Debug, Clone, Default)]
    pub struct Builder {
        a: Option<String>,
        b: Option<String>,
        c: Option<Vec<String>>,
    }
    impl Builder {
        pub fn a(mut self, inp: impl Into<String>) -> Self {
            self.a = Some(inp.into());
            self
        }
        pub fn b(mut self, inp: impl Into<String>) -> Self {
            self.b = Some(inp.into());
            self
        }
        pub fn c(mut self, inp: Vec<String>) -> Self {
            self.c = Some(inp);
            self
        }
        /// Consumes the builder and constructs a [`NullAndEmptyHeadersClientInput`](crate::operation::NullAndEmptyHeadersClientInput)
        pub fn build(self) -> NullAndEmptyHeadersClientInput {
            NullAndEmptyHeadersClientInput {
                a: self.a,
                b: self.b,
                c: self.c,
            }
        }
    }
}

#[non_exhaustive]
#[derive(::std::clone::Clone, ::std::cmp::PartialEq, ::std::fmt::Debug)]
pub struct InputAndOutputWithHeadersOutput {
    pub header_string: Option<String>,
    pub header_byte: Option<i8>,
    pub header_short: Option<i16>,
    pub header_integer: Option<i32>,
    pub header_long: Option<i64>,
    pub header_float: Option<f32>,
    pub header_double: Option<f64>,
    pub header_true_bool: Option<bool>,
    pub header_false_bool: Option<bool>,
    pub header_string_list: Option<Vec<String>>,
    pub header_string_set: Option<BTreeSet<String>>,
    pub header_integer_list: Option<Vec<i32>>,
    pub header_boolean_list: Option<Vec<bool>>,
    pub header_timestamp_list: Option<Vec<Instant>>,
    pub header_enum: Option<FooEnum>,
    pub header_enum_list: Option<Vec<FooEnum>>,
}
impl InputAndOutputWithHeadersOutput {
    /// Creates a new builder-style object to manufacture [`InputAndOutputWithHeadersOutput`](crate::operation::InputAndOutputWithHeadersOutput)
    pub fn builder() -> crate::operation::input_and_output_with_headers_output::Builder {
        crate::operation::input_and_output_with_headers_output::Builder::default()
    }
}
/// See [`InputAndOutputWithHeadersOutput`](crate::operation::InputAndOutputWithHeadersOutput)
pub mod input_and_output_with_headers_output {

    use crate::model::FooEnum;
    use crate::operation::InputAndOutputWithHeadersOutput;
    use smithy_types::Instant;
    use std::collections::BTreeSet;
    /// A builder for [`InputAndOutputWithHeadersOutput`](crate::operation::InputAndOutputWithHeadersOutput)
    #[non_exhaustive]
    #[derive(Debug, Clone, Default)]
    pub struct Builder {
        header_string: Option<String>,
        header_byte: Option<i8>,
        header_short: Option<i16>,
        header_integer: Option<i32>,
        header_long: Option<i64>,
        header_float: Option<f32>,
        header_double: Option<f64>,
        header_true_bool: Option<bool>,
        header_false_bool: Option<bool>,
        header_string_list: Option<Vec<String>>,
        header_string_set: Option<BTreeSet<String>>,
        header_integer_list: Option<Vec<i32>>,
        header_boolean_list: Option<Vec<bool>>,
        header_timestamp_list: Option<Vec<Instant>>,
        header_enum: Option<FooEnum>,
        header_enum_list: Option<Vec<FooEnum>>,
    }
    impl Builder {
        pub fn header_string(mut self, inp: impl Into<String>) -> Self {
            self.header_string = Some(inp.into());
            self
        }
        pub fn header_byte(mut self, inp: i8) -> Self {
            self.header_byte = Some(inp);
            self
        }
        pub fn header_short(mut self, inp: i16) -> Self {
            self.header_short = Some(inp);
            self
        }
        pub fn header_integer(mut self, inp: i32) -> Self {
            self.header_integer = Some(inp);
            self
        }
        pub fn header_long(mut self, inp: i64) -> Self {
            self.header_long = Some(inp);
            self
        }
        pub fn header_float(mut self, inp: f32) -> Self {
            self.header_float = Some(inp);
            self
        }
        pub fn header_double(mut self, inp: f64) -> Self {
            self.header_double = Some(inp);
            self
        }
        pub fn header_true_bool(mut self, inp: bool) -> Self {
            self.header_true_bool = Some(inp);
            self
        }
        pub fn header_false_bool(mut self, inp: bool) -> Self {
            self.header_false_bool = Some(inp);
            self
        }
        pub fn header_string_list(mut self, inp: Vec<String>) -> Self {
            self.header_string_list = Some(inp);
            self
        }
        pub fn header_string_set(mut self, inp: BTreeSet<String>) -> Self {
            self.header_string_set = Some(inp);
            self
        }
        pub fn header_integer_list(mut self, inp: Vec<i32>) -> Self {
            self.header_integer_list = Some(inp);
            self
        }
        pub fn header_boolean_list(mut self, inp: Vec<bool>) -> Self {
            self.header_boolean_list = Some(inp);
            self
        }
        pub fn header_timestamp_list(mut self, inp: Vec<Instant>) -> Self {
            self.header_timestamp_list = Some(inp);
            self
        }
        pub fn header_enum(mut self, inp: FooEnum) -> Self {
            self.header_enum = Some(inp);
            self
        }
        pub fn header_enum_list(mut self, inp: Vec<FooEnum>) -> Self {
            self.header_enum_list = Some(inp);
            self
        }
        /// Consumes the builder and constructs a [`InputAndOutputWithHeadersOutput`](crate::operation::InputAndOutputWithHeadersOutput)
        pub fn build(self) -> InputAndOutputWithHeadersOutput {
            InputAndOutputWithHeadersOutput {
                header_string: self.header_string,
                header_byte: self.header_byte,
                header_short: self.header_short,
                header_integer: self.header_integer,
                header_long: self.header_long,
                header_float: self.header_float,
                header_double: self.header_double,
                header_true_bool: self.header_true_bool,
                header_false_bool: self.header_false_bool,
                header_string_list: self.header_string_list,
                header_string_set: self.header_string_set,
                header_integer_list: self.header_integer_list,
                header_boolean_list: self.header_boolean_list,
                header_timestamp_list: self.header_timestamp_list,
                header_enum: self.header_enum,
                header_enum_list: self.header_enum_list,
            }
        }
    }
}

#[non_exhaustive]
#[derive(::std::clone::Clone, ::std::cmp::PartialEq, ::std::fmt::Debug)]
pub struct InputAndOutputWithHeadersInput {
    pub header_string: Option<String>,
    pub header_byte: Option<i8>,
    pub header_short: Option<i16>,
    pub header_integer: Option<i32>,
    pub header_long: Option<i64>,
    pub header_float: Option<f32>,
    pub header_double: Option<f64>,
    pub header_true_bool: Option<bool>,
    pub header_false_bool: Option<bool>,
    pub header_string_list: Option<Vec<String>>,
    pub header_string_set: Option<BTreeSet<String>>,
    pub header_integer_list: Option<Vec<i32>>,
    pub header_boolean_list: Option<Vec<bool>>,
    pub header_timestamp_list: Option<Vec<Instant>>,
    pub header_enum: Option<FooEnum>,
    pub header_enum_list: Option<Vec<FooEnum>>,
}
impl InputAndOutputWithHeadersInput {
    /// Creates a new builder-style object to manufacture [`InputAndOutputWithHeadersInput`](crate::operation::InputAndOutputWithHeadersInput)
    pub fn builder() -> crate::operation::input_and_output_with_headers_input::Builder {
        crate::operation::input_and_output_with_headers_input::Builder::default()
    }
}
/// See [`InputAndOutputWithHeadersInput`](crate::operation::InputAndOutputWithHeadersInput)
pub mod input_and_output_with_headers_input {

    use crate::model::FooEnum;
    use crate::operation::InputAndOutputWithHeadersInput;
    use smithy_types::Instant;
    use std::collections::BTreeSet;
    /// A builder for [`InputAndOutputWithHeadersInput`](crate::operation::InputAndOutputWithHeadersInput)
    #[non_exhaustive]
    #[derive(Debug, Clone, Default)]
    pub struct Builder {
        header_string: Option<String>,
        header_byte: Option<i8>,
        header_short: Option<i16>,
        header_integer: Option<i32>,
        header_long: Option<i64>,
        header_float: Option<f32>,
        header_double: Option<f64>,
        header_true_bool: Option<bool>,
        header_false_bool: Option<bool>,
        header_string_list: Option<Vec<String>>,
        header_string_set: Option<BTreeSet<String>>,
        header_integer_list: Option<Vec<i32>>,
        header_boolean_list: Option<Vec<bool>>,
        header_timestamp_list: Option<Vec<Instant>>,
        header_enum: Option<FooEnum>,
        header_enum_list: Option<Vec<FooEnum>>,
    }
    impl Builder {
        pub fn header_string(mut self, inp: impl Into<String>) -> Self {
            self.header_string = Some(inp.into());
            self
        }
        pub fn header_byte(mut self, inp: i8) -> Self {
            self.header_byte = Some(inp);
            self
        }
        pub fn header_short(mut self, inp: i16) -> Self {
            self.header_short = Some(inp);
            self
        }
        pub fn header_integer(mut self, inp: i32) -> Self {
            self.header_integer = Some(inp);
            self
        }
        pub fn header_long(mut self, inp: i64) -> Self {
            self.header_long = Some(inp);
            self
        }
        pub fn header_float(mut self, inp: f32) -> Self {
            self.header_float = Some(inp);
            self
        }
        pub fn header_double(mut self, inp: f64) -> Self {
            self.header_double = Some(inp);
            self
        }
        pub fn header_true_bool(mut self, inp: bool) -> Self {
            self.header_true_bool = Some(inp);
            self
        }
        pub fn header_false_bool(mut self, inp: bool) -> Self {
            self.header_false_bool = Some(inp);
            self
        }
        pub fn header_string_list(mut self, inp: Vec<String>) -> Self {
            self.header_string_list = Some(inp);
            self
        }
        pub fn header_string_set(mut self, inp: BTreeSet<String>) -> Self {
            self.header_string_set = Some(inp);
            self
        }
        pub fn header_integer_list(mut self, inp: Vec<i32>) -> Self {
            self.header_integer_list = Some(inp);
            self
        }
        pub fn header_boolean_list(mut self, inp: Vec<bool>) -> Self {
            self.header_boolean_list = Some(inp);
            self
        }
        pub fn header_timestamp_list(mut self, inp: Vec<Instant>) -> Self {
            self.header_timestamp_list = Some(inp);
            self
        }
        pub fn header_enum(mut self, inp: FooEnum) -> Self {
            self.header_enum = Some(inp);
            self
        }
        pub fn header_enum_list(mut self, inp: Vec<FooEnum>) -> Self {
            self.header_enum_list = Some(inp);
            self
        }
        /// Consumes the builder and constructs a [`InputAndOutputWithHeadersInput`](crate::operation::InputAndOutputWithHeadersInput)
        pub fn build(self) -> InputAndOutputWithHeadersInput {
            InputAndOutputWithHeadersInput {
                header_string: self.header_string,
                header_byte: self.header_byte,
                header_short: self.header_short,
                header_integer: self.header_integer,
                header_long: self.header_long,
                header_float: self.header_float,
                header_double: self.header_double,
                header_true_bool: self.header_true_bool,
                header_false_bool: self.header_false_bool,
                header_string_list: self.header_string_list,
                header_string_set: self.header_string_set,
                header_integer_list: self.header_integer_list,
                header_boolean_list: self.header_boolean_list,
                header_timestamp_list: self.header_timestamp_list,
                header_enum: self.header_enum,
                header_enum_list: self.header_enum_list,
            }
        }
    }
}

#[non_exhaustive]
#[derive(::std::clone::Clone, ::std::cmp::PartialEq, ::std::fmt::Debug)]
pub struct EmptyInputAndEmptyOutputOutput {}
impl EmptyInputAndEmptyOutputOutput {
    /// Creates a new builder-style object to manufacture [`EmptyInputAndEmptyOutputOutput`](crate::operation::EmptyInputAndEmptyOutputOutput)
    pub fn builder() -> crate::operation::empty_input_and_empty_output_output::Builder {
        crate::operation::empty_input_and_empty_output_output::Builder::default()
    }
}
/// See [`EmptyInputAndEmptyOutputOutput`](crate::operation::EmptyInputAndEmptyOutputOutput)
pub mod empty_input_and_empty_output_output {

    use crate::operation::EmptyInputAndEmptyOutputOutput;
    /// A builder for [`EmptyInputAndEmptyOutputOutput`](crate::operation::EmptyInputAndEmptyOutputOutput)
    #[non_exhaustive]
    #[derive(Debug, Clone, Default)]
    pub struct Builder {}
    impl Builder {
        /// Consumes the builder and constructs a [`EmptyInputAndEmptyOutputOutput`](crate::operation::EmptyInputAndEmptyOutputOutput)
        pub fn build(self) -> EmptyInputAndEmptyOutputOutput {
            EmptyInputAndEmptyOutputOutput {}
        }
    }
}

#[non_exhaustive]
#[derive(::std::clone::Clone, ::std::cmp::PartialEq, ::std::fmt::Debug)]
pub struct EmptyInputAndEmptyOutputInput {}
impl EmptyInputAndEmptyOutputInput {
    /// Creates a new builder-style object to manufacture [`EmptyInputAndEmptyOutputInput`](crate::operation::EmptyInputAndEmptyOutputInput)
    pub fn builder() -> crate::operation::empty_input_and_empty_output_input::Builder {
        crate::operation::empty_input_and_empty_output_input::Builder::default()
    }
}
/// See [`EmptyInputAndEmptyOutputInput`](crate::operation::EmptyInputAndEmptyOutputInput)
pub mod empty_input_and_empty_output_input {

    use crate::operation::EmptyInputAndEmptyOutputInput;
    /// A builder for [`EmptyInputAndEmptyOutputInput`](crate::operation::EmptyInputAndEmptyOutputInput)
    #[non_exhaustive]
    #[derive(Debug, Clone, Default)]
    pub struct Builder {}
    impl Builder {
        /// Consumes the builder and constructs a [`EmptyInputAndEmptyOutputInput`](crate::operation::EmptyInputAndEmptyOutputInput)
        pub fn build(self) -> EmptyInputAndEmptyOutputInput {
            EmptyInputAndEmptyOutputInput {}
        }
    }
}

#[non_exhaustive]
#[derive(::std::clone::Clone, ::std::cmp::PartialEq, ::std::fmt::Debug)]
pub struct NoInputAndOutputOutput {}
impl NoInputAndOutputOutput {
    /// Creates a new builder-style object to manufacture [`NoInputAndOutputOutput`](crate::operation::NoInputAndOutputOutput)
    pub fn builder() -> crate::operation::no_input_and_output_output::Builder {
        crate::operation::no_input_and_output_output::Builder::default()
    }
}
/// See [`NoInputAndOutputOutput`](crate::operation::NoInputAndOutputOutput)
pub mod no_input_and_output_output {

    use crate::operation::NoInputAndOutputOutput;
    /// A builder for [`NoInputAndOutputOutput`](crate::operation::NoInputAndOutputOutput)
    #[non_exhaustive]
    #[derive(Debug, Clone, Default)]
    pub struct Builder {}
    impl Builder {
        /// Consumes the builder and constructs a [`NoInputAndOutputOutput`](crate::operation::NoInputAndOutputOutput)
        pub fn build(self) -> NoInputAndOutputOutput {
            NoInputAndOutputOutput {}
        }
    }
}

#[non_exhaustive]
#[derive(::std::clone::Clone, ::std::cmp::PartialEq, ::std::fmt::Debug)]
pub struct NoInputAndOutputInput {}
impl NoInputAndOutputInput {
    /// Creates a new builder-style object to manufacture [`NoInputAndOutputInput`](crate::operation::NoInputAndOutputInput)
    pub fn builder() -> crate::operation::no_input_and_output_input::Builder {
        crate::operation::no_input_and_output_input::Builder::default()
    }
}
/// See [`NoInputAndOutputInput`](crate::operation::NoInputAndOutputInput)
pub mod no_input_and_output_input {

    use crate::operation::NoInputAndOutputInput;
    /// A builder for [`NoInputAndOutputInput`](crate::operation::NoInputAndOutputInput)
    #[non_exhaustive]
    #[derive(Debug, Clone, Default)]
    pub struct Builder {}
    impl Builder {
        /// Consumes the builder and constructs a [`NoInputAndOutputInput`](crate::operation::NoInputAndOutputInput)
        pub fn build(self) -> NoInputAndOutputInput {
            NoInputAndOutputInput {}
        }
    }
}

#[non_exhaustive]
#[derive(::std::clone::Clone, ::std::cmp::PartialEq, ::std::fmt::Debug)]
pub struct NoInputAndNoOutputOutput {}
impl NoInputAndNoOutputOutput {
    /// Creates a new builder-style object to manufacture [`NoInputAndNoOutputOutput`](crate::operation::NoInputAndNoOutputOutput)
    pub fn builder() -> crate::operation::no_input_and_no_output_output::Builder {
        crate::operation::no_input_and_no_output_output::Builder::default()
    }
}
/// See [`NoInputAndNoOutputOutput`](crate::operation::NoInputAndNoOutputOutput)
pub mod no_input_and_no_output_output {

    use crate::operation::NoInputAndNoOutputOutput;
    /// A builder for [`NoInputAndNoOutputOutput`](crate::operation::NoInputAndNoOutputOutput)
    #[non_exhaustive]
    #[derive(Debug, Clone, Default)]
    pub struct Builder {}
    impl Builder {
        /// Consumes the builder and constructs a [`NoInputAndNoOutputOutput`](crate::operation::NoInputAndNoOutputOutput)
        pub fn build(self) -> NoInputAndNoOutputOutput {
            NoInputAndNoOutputOutput {}
        }
    }
}

#[non_exhaustive]
#[derive(::std::clone::Clone, ::std::cmp::PartialEq, ::std::fmt::Debug)]
pub struct NoInputAndNoOutputInput {}
impl NoInputAndNoOutputInput {
    /// Creates a new builder-style object to manufacture [`NoInputAndNoOutputInput`](crate::operation::NoInputAndNoOutputInput)
    pub fn builder() -> crate::operation::no_input_and_no_output_input::Builder {
        crate::operation::no_input_and_no_output_input::Builder::default()
    }
}
/// See [`NoInputAndNoOutputInput`](crate::operation::NoInputAndNoOutputInput)
pub mod no_input_and_no_output_input {

    use crate::operation::NoInputAndNoOutputInput;
    /// A builder for [`NoInputAndNoOutputInput`](crate::operation::NoInputAndNoOutputInput)
    #[non_exhaustive]
    #[derive(Debug, Clone, Default)]
    pub struct Builder {}
    impl Builder {
        /// Consumes the builder and constructs a [`NoInputAndNoOutputInput`](crate::operation::NoInputAndNoOutputInput)
        pub fn build(self) -> NoInputAndNoOutputInput {
            NoInputAndNoOutputInput {}
        }
    }
}
