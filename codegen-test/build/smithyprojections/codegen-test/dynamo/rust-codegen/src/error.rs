// Code generated by software.amazon.smithy.rust.codegen.smithy-rs. DO NOT EDIT.
use crate::model::CancellationReason;
/// <p>The operation tried to access a nonexistent table or index. The resource might not be specified
/// correctly, or its status might not be <code>ACTIVE</code>.</p>
#[non_exhaustive]
#[derive(
    ::serde::Deserialize,
    ::serde::Serialize,
    ::std::clone::Clone,
    ::std::cmp::PartialEq,
    ::std::fmt::Debug,
)]
pub struct ResourceNotFoundError {
    /// <p>The resource which is being requested does not exist.</p>
    #[serde(rename = "message")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub message: Option<String>,
}
impl ResourceNotFoundError {
    /// Creates a new builder-style object to manufacture [`ResourceNotFoundError`](crate::error::ResourceNotFoundError)
    pub fn builder() -> crate::error::resource_not_found_error::Builder {
        crate::error::resource_not_found_error::Builder::default()
    }
}
impl ResourceNotFoundError {
    // TODO: create shared runtime crate
    // fn at_fault(&self) -> ErrorCause { ErrorCause::Client }
    pub fn retryable(&self) -> bool {
        false
    }
    pub fn throttling(&self) -> bool {
        false
    }
}
impl ::std::fmt::Display for ResourceNotFoundError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "ResourceNotFoundError")?;
        if let Some(inner_1) = &self.message {
            write!(f, ": {}", inner_1)?;
        }
        Ok(())
    }
}
impl ::std::error::Error for ResourceNotFoundError {}
/// See [`ResourceNotFoundError`](crate::error::ResourceNotFoundError)
pub mod resource_not_found_error {

    use crate::error::ResourceNotFoundError;
    /// A builder for [`ResourceNotFoundError`](crate::error::ResourceNotFoundError)
    #[non_exhaustive]
    #[derive(Debug, Clone, Default)]
    pub struct Builder {
        message: Option<String>,
    }
    impl Builder {
        /// <p>The resource which is being requested does not exist.</p>
        pub fn message(mut self, inp: impl Into<String>) -> Self {
            self.message = Some(inp.into());
            self
        }
        /// Consumes the builder and constructs a [`ResourceNotFoundError`](crate::error::ResourceNotFoundError)
        pub fn build(self) -> ResourceNotFoundError {
            ResourceNotFoundError {
                message: self.message,
            }
        }
    }
}

/// <p>The operation conflicts with the resource's availability. For example, you attempted to
/// recreate an existing table, or tried to delete a table currently in the <code>CREATING</code>
/// state.</p>
#[non_exhaustive]
#[derive(
    ::serde::Deserialize,
    ::serde::Serialize,
    ::std::clone::Clone,
    ::std::cmp::PartialEq,
    ::std::fmt::Debug,
)]
pub struct ResourceInUseError {
    /// <p>The resource which is being attempted to be changed is in use.</p>
    #[serde(rename = "message")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub message: Option<String>,
}
impl ResourceInUseError {
    /// Creates a new builder-style object to manufacture [`ResourceInUseError`](crate::error::ResourceInUseError)
    pub fn builder() -> crate::error::resource_in_use_error::Builder {
        crate::error::resource_in_use_error::Builder::default()
    }
}
impl ResourceInUseError {
    // TODO: create shared runtime crate
    // fn at_fault(&self) -> ErrorCause { ErrorCause::Client }
    pub fn retryable(&self) -> bool {
        false
    }
    pub fn throttling(&self) -> bool {
        false
    }
}
impl ::std::fmt::Display for ResourceInUseError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "ResourceInUseError")?;
        if let Some(inner_2) = &self.message {
            write!(f, ": {}", inner_2)?;
        }
        Ok(())
    }
}
impl ::std::error::Error for ResourceInUseError {}
/// See [`ResourceInUseError`](crate::error::ResourceInUseError)
pub mod resource_in_use_error {

    use crate::error::ResourceInUseError;
    /// A builder for [`ResourceInUseError`](crate::error::ResourceInUseError)
    #[non_exhaustive]
    #[derive(Debug, Clone, Default)]
    pub struct Builder {
        message: Option<String>,
    }
    impl Builder {
        /// <p>The resource which is being attempted to be changed is in use.</p>
        pub fn message(mut self, inp: impl Into<String>) -> Self {
            self.message = Some(inp.into());
            self
        }
        /// Consumes the builder and constructs a [`ResourceInUseError`](crate::error::ResourceInUseError)
        pub fn build(self) -> ResourceInUseError {
            ResourceInUseError {
                message: self.message,
            }
        }
    }
}

/// <p>There is no limit to the number of daily on-demand backups that can be taken. </p>
/// <p>Up to 50 simultaneous table operations are allowed per account. These operations
/// include <code>CreateTable</code>, <code>UpdateTable</code>,
/// <code>DeleteTable</code>,<code>UpdateTimeToLive</code>,
/// <code>RestoreTableFromBackup</code>, and <code>RestoreTableToPointInTime</code>. </p>
/// <p>The only exception is when you are creating a table with one or more secondary indexes. You can have up to
/// 25 such requests running at a time; however, if the table or index specifications are complex, DynamoDB might temporarily
/// reduce the number of concurrent operations.</p>
/// <p>There is a soft account quota of 256 tables.</p>
#[non_exhaustive]
#[derive(
    ::serde::Deserialize,
    ::serde::Serialize,
    ::std::clone::Clone,
    ::std::cmp::PartialEq,
    ::std::fmt::Debug,
)]
pub struct LimitExceededError {
    /// <p>Too many operations for a given subscriber.</p>
    #[serde(rename = "message")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub message: Option<String>,
}
impl LimitExceededError {
    /// Creates a new builder-style object to manufacture [`LimitExceededError`](crate::error::LimitExceededError)
    pub fn builder() -> crate::error::limit_exceeded_error::Builder {
        crate::error::limit_exceeded_error::Builder::default()
    }
}
impl LimitExceededError {
    // TODO: create shared runtime crate
    // fn at_fault(&self) -> ErrorCause { ErrorCause::Client }
    pub fn retryable(&self) -> bool {
        false
    }
    pub fn throttling(&self) -> bool {
        false
    }
}
impl ::std::fmt::Display for LimitExceededError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "LimitExceededError")?;
        if let Some(inner_3) = &self.message {
            write!(f, ": {}", inner_3)?;
        }
        Ok(())
    }
}
impl ::std::error::Error for LimitExceededError {}
/// See [`LimitExceededError`](crate::error::LimitExceededError)
pub mod limit_exceeded_error {

    use crate::error::LimitExceededError;
    /// A builder for [`LimitExceededError`](crate::error::LimitExceededError)
    #[non_exhaustive]
    #[derive(Debug, Clone, Default)]
    pub struct Builder {
        message: Option<String>,
    }
    impl Builder {
        /// <p>Too many operations for a given subscriber.</p>
        pub fn message(mut self, inp: impl Into<String>) -> Self {
            self.message = Some(inp.into());
            self
        }
        /// Consumes the builder and constructs a [`LimitExceededError`](crate::error::LimitExceededError)
        pub fn build(self) -> LimitExceededError {
            LimitExceededError {
                message: self.message,
            }
        }
    }
}

#[non_exhaustive]
#[derive(
    ::serde::Deserialize,
    ::serde::Serialize,
    ::std::clone::Clone,
    ::std::cmp::PartialEq,
    ::std::fmt::Debug,
)]
pub struct InvalidEndpointError {
    #[serde(rename = "Message")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub message: Option<String>,
}
impl InvalidEndpointError {
    /// Creates a new builder-style object to manufacture [`InvalidEndpointError`](crate::error::InvalidEndpointError)
    pub fn builder() -> crate::error::invalid_endpoint_error::Builder {
        crate::error::invalid_endpoint_error::Builder::default()
    }
}
impl InvalidEndpointError {
    // TODO: create shared runtime crate
    // fn at_fault(&self) -> ErrorCause { ErrorCause::Client }
    pub fn retryable(&self) -> bool {
        false
    }
    pub fn throttling(&self) -> bool {
        false
    }
}
impl ::std::fmt::Display for InvalidEndpointError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "InvalidEndpointError")?;
        Ok(())
    }
}
impl ::std::error::Error for InvalidEndpointError {}
/// See [`InvalidEndpointError`](crate::error::InvalidEndpointError)
pub mod invalid_endpoint_error {

    use crate::error::InvalidEndpointError;
    /// A builder for [`InvalidEndpointError`](crate::error::InvalidEndpointError)
    #[non_exhaustive]
    #[derive(Debug, Clone, Default)]
    pub struct Builder {
        message: Option<String>,
    }
    impl Builder {
        pub fn message(mut self, inp: impl Into<String>) -> Self {
            self.message = Some(inp.into());
            self
        }
        /// Consumes the builder and constructs a [`InvalidEndpointError`](crate::error::InvalidEndpointError)
        pub fn build(self) -> InvalidEndpointError {
            InvalidEndpointError {
                message: self.message,
            }
        }
    }
}

/// <p>An error occurred on the server side.</p>
#[non_exhaustive]
#[derive(
    ::serde::Deserialize,
    ::serde::Serialize,
    ::std::clone::Clone,
    ::std::cmp::PartialEq,
    ::std::fmt::Debug,
)]
pub struct InternalServerError {
    /// <p>The server encountered an internal error trying to fulfill the request.</p>
    #[serde(rename = "message")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub message: Option<String>,
}
impl InternalServerError {
    /// Creates a new builder-style object to manufacture [`InternalServerError`](crate::error::InternalServerError)
    pub fn builder() -> crate::error::internal_server_error::Builder {
        crate::error::internal_server_error::Builder::default()
    }
}
impl InternalServerError {
    // TODO: create shared runtime crate
    // fn at_fault(&self) -> ErrorCause { ErrorCause::Server }
    pub fn retryable(&self) -> bool {
        false
    }
    pub fn throttling(&self) -> bool {
        false
    }
}
impl ::std::fmt::Display for InternalServerError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "InternalServerError")?;
        if let Some(inner_4) = &self.message {
            write!(f, ": {}", inner_4)?;
        }
        Ok(())
    }
}
impl ::std::error::Error for InternalServerError {}
/// See [`InternalServerError`](crate::error::InternalServerError)
pub mod internal_server_error {

    use crate::error::InternalServerError;
    /// A builder for [`InternalServerError`](crate::error::InternalServerError)
    #[non_exhaustive]
    #[derive(Debug, Clone, Default)]
    pub struct Builder {
        message: Option<String>,
    }
    impl Builder {
        /// <p>The server encountered an internal error trying to fulfill the request.</p>
        pub fn message(mut self, inp: impl Into<String>) -> Self {
            self.message = Some(inp.into());
            self
        }
        /// Consumes the builder and constructs a [`InternalServerError`](crate::error::InternalServerError)
        pub fn build(self) -> InternalServerError {
            InternalServerError {
                message: self.message,
            }
        }
    }
}

/// <p>Operation was rejected because there is an ongoing transaction for the item.</p>
#[non_exhaustive]
#[derive(
    ::serde::Deserialize,
    ::serde::Serialize,
    ::std::clone::Clone,
    ::std::cmp::PartialEq,
    ::std::fmt::Debug,
)]
pub struct TransactionConflictError {
    #[serde(rename = "message")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub message: Option<String>,
}
impl TransactionConflictError {
    /// Creates a new builder-style object to manufacture [`TransactionConflictError`](crate::error::TransactionConflictError)
    pub fn builder() -> crate::error::transaction_conflict_error::Builder {
        crate::error::transaction_conflict_error::Builder::default()
    }
}
impl TransactionConflictError {
    // TODO: create shared runtime crate
    // fn at_fault(&self) -> ErrorCause { ErrorCause::Client }
    pub fn retryable(&self) -> bool {
        false
    }
    pub fn throttling(&self) -> bool {
        false
    }
}
impl ::std::fmt::Display for TransactionConflictError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "TransactionConflictError")?;
        if let Some(inner_5) = &self.message {
            write!(f, ": {}", inner_5)?;
        }
        Ok(())
    }
}
impl ::std::error::Error for TransactionConflictError {}
/// See [`TransactionConflictError`](crate::error::TransactionConflictError)
pub mod transaction_conflict_error {

    use crate::error::TransactionConflictError;
    /// A builder for [`TransactionConflictError`](crate::error::TransactionConflictError)
    #[non_exhaustive]
    #[derive(Debug, Clone, Default)]
    pub struct Builder {
        message: Option<String>,
    }
    impl Builder {
        pub fn message(mut self, inp: impl Into<String>) -> Self {
            self.message = Some(inp.into());
            self
        }
        /// Consumes the builder and constructs a [`TransactionConflictError`](crate::error::TransactionConflictError)
        pub fn build(self) -> TransactionConflictError {
            TransactionConflictError {
                message: self.message,
            }
        }
    }
}

/// <p>Throughput exceeds the current throughput quota for your account. Please contact AWS Support at <a href="https://aws.amazon.com/support">AWS Support</a> to request a quota increase.</p>
#[non_exhaustive]
#[derive(
    ::serde::Deserialize,
    ::serde::Serialize,
    ::std::clone::Clone,
    ::std::cmp::PartialEq,
    ::std::fmt::Debug,
)]
pub struct RequestLimitExceeded {
    #[serde(rename = "message")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub message: Option<String>,
}
impl RequestLimitExceeded {
    /// Creates a new builder-style object to manufacture [`RequestLimitExceeded`](crate::error::RequestLimitExceeded)
    pub fn builder() -> crate::error::request_limit_exceeded::Builder {
        crate::error::request_limit_exceeded::Builder::default()
    }
}
impl RequestLimitExceeded {
    // TODO: create shared runtime crate
    // fn at_fault(&self) -> ErrorCause { ErrorCause::Client }
    pub fn retryable(&self) -> bool {
        false
    }
    pub fn throttling(&self) -> bool {
        false
    }
}
impl ::std::fmt::Display for RequestLimitExceeded {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "RequestLimitExceeded")?;
        if let Some(inner_6) = &self.message {
            write!(f, ": {}", inner_6)?;
        }
        Ok(())
    }
}
impl ::std::error::Error for RequestLimitExceeded {}
/// See [`RequestLimitExceeded`](crate::error::RequestLimitExceeded)
pub mod request_limit_exceeded {

    use crate::error::RequestLimitExceeded;
    /// A builder for [`RequestLimitExceeded`](crate::error::RequestLimitExceeded)
    #[non_exhaustive]
    #[derive(Debug, Clone, Default)]
    pub struct Builder {
        message: Option<String>,
    }
    impl Builder {
        pub fn message(mut self, inp: impl Into<String>) -> Self {
            self.message = Some(inp.into());
            self
        }
        /// Consumes the builder and constructs a [`RequestLimitExceeded`](crate::error::RequestLimitExceeded)
        pub fn build(self) -> RequestLimitExceeded {
            RequestLimitExceeded {
                message: self.message,
            }
        }
    }
}

/// <p>Your request rate is too high. The AWS SDKs for DynamoDB automatically retry requests that
/// receive this exception. Your request is eventually successful, unless your retry queue is too
/// large to finish. Reduce the frequency of requests and use exponential backoff. For more
/// information, go to <a href="https://docs.aws.amazon.com/amazondynamodb/latest/developerguide/Programming.Errors.html#Programming.Errors.RetryAndBackoff">Error Retries and Exponential
/// Backoff</a> in the <i>Amazon DynamoDB Developer Guide</i>.</p>
#[non_exhaustive]
#[derive(
    ::serde::Deserialize,
    ::serde::Serialize,
    ::std::clone::Clone,
    ::std::cmp::PartialEq,
    ::std::fmt::Debug,
)]
pub struct ProvisionedThroughputExceededError {
    /// <p>You exceeded your maximum allowed provisioned throughput.</p>
    #[serde(rename = "message")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub message: Option<String>,
}
impl ProvisionedThroughputExceededError {
    /// Creates a new builder-style object to manufacture [`ProvisionedThroughputExceededError`](crate::error::ProvisionedThroughputExceededError)
    pub fn builder() -> crate::error::provisioned_throughput_exceeded_error::Builder {
        crate::error::provisioned_throughput_exceeded_error::Builder::default()
    }
}
impl ProvisionedThroughputExceededError {
    // TODO: create shared runtime crate
    // fn at_fault(&self) -> ErrorCause { ErrorCause::Client }
    pub fn retryable(&self) -> bool {
        false
    }
    pub fn throttling(&self) -> bool {
        false
    }
}
impl ::std::fmt::Display for ProvisionedThroughputExceededError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "ProvisionedThroughputExceededError")?;
        if let Some(inner_7) = &self.message {
            write!(f, ": {}", inner_7)?;
        }
        Ok(())
    }
}
impl ::std::error::Error for ProvisionedThroughputExceededError {}
/// See [`ProvisionedThroughputExceededError`](crate::error::ProvisionedThroughputExceededError)
pub mod provisioned_throughput_exceeded_error {

    use crate::error::ProvisionedThroughputExceededError;
    /// A builder for [`ProvisionedThroughputExceededError`](crate::error::ProvisionedThroughputExceededError)
    #[non_exhaustive]
    #[derive(Debug, Clone, Default)]
    pub struct Builder {
        message: Option<String>,
    }
    impl Builder {
        /// <p>You exceeded your maximum allowed provisioned throughput.</p>
        pub fn message(mut self, inp: impl Into<String>) -> Self {
            self.message = Some(inp.into());
            self
        }
        /// Consumes the builder and constructs a [`ProvisionedThroughputExceededError`](crate::error::ProvisionedThroughputExceededError)
        pub fn build(self) -> ProvisionedThroughputExceededError {
            ProvisionedThroughputExceededError {
                message: self.message,
            }
        }
    }
}

/// <p>An item collection is too large. This exception is only returned for tables that have one or more local secondary indexes.</p>
#[non_exhaustive]
#[derive(
    ::serde::Deserialize,
    ::serde::Serialize,
    ::std::clone::Clone,
    ::std::cmp::PartialEq,
    ::std::fmt::Debug,
)]
pub struct ItemCollectionSizeLimitExceededError {
    /// <p>The total size of an item collection has exceeded the maximum limit of 10 gigabytes.</p>
    #[serde(rename = "message")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub message: Option<String>,
}
impl ItemCollectionSizeLimitExceededError {
    /// Creates a new builder-style object to manufacture [`ItemCollectionSizeLimitExceededError`](crate::error::ItemCollectionSizeLimitExceededError)
    pub fn builder() -> crate::error::item_collection_size_limit_exceeded_error::Builder {
        crate::error::item_collection_size_limit_exceeded_error::Builder::default()
    }
}
impl ItemCollectionSizeLimitExceededError {
    // TODO: create shared runtime crate
    // fn at_fault(&self) -> ErrorCause { ErrorCause::Client }
    pub fn retryable(&self) -> bool {
        false
    }
    pub fn throttling(&self) -> bool {
        false
    }
}
impl ::std::fmt::Display for ItemCollectionSizeLimitExceededError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "ItemCollectionSizeLimitExceededError")?;
        if let Some(inner_8) = &self.message {
            write!(f, ": {}", inner_8)?;
        }
        Ok(())
    }
}
impl ::std::error::Error for ItemCollectionSizeLimitExceededError {}
/// See [`ItemCollectionSizeLimitExceededError`](crate::error::ItemCollectionSizeLimitExceededError)
pub mod item_collection_size_limit_exceeded_error {

    use crate::error::ItemCollectionSizeLimitExceededError;
    /// A builder for [`ItemCollectionSizeLimitExceededError`](crate::error::ItemCollectionSizeLimitExceededError)
    #[non_exhaustive]
    #[derive(Debug, Clone, Default)]
    pub struct Builder {
        message: Option<String>,
    }
    impl Builder {
        /// <p>The total size of an item collection has exceeded the maximum limit of 10 gigabytes.</p>
        pub fn message(mut self, inp: impl Into<String>) -> Self {
            self.message = Some(inp.into());
            self
        }
        /// Consumes the builder and constructs a [`ItemCollectionSizeLimitExceededError`](crate::error::ItemCollectionSizeLimitExceededError)
        pub fn build(self) -> ItemCollectionSizeLimitExceededError {
            ItemCollectionSizeLimitExceededError {
                message: self.message,
            }
        }
    }
}

/// <p>A condition specified in the operation could not be evaluated.</p>
#[non_exhaustive]
#[derive(
    ::serde::Deserialize,
    ::serde::Serialize,
    ::std::clone::Clone,
    ::std::cmp::PartialEq,
    ::std::fmt::Debug,
)]
pub struct ConditionalCheckFailedError {
    /// <p>The conditional request failed.</p>
    #[serde(rename = "message")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub message: Option<String>,
}
impl ConditionalCheckFailedError {
    /// Creates a new builder-style object to manufacture [`ConditionalCheckFailedError`](crate::error::ConditionalCheckFailedError)
    pub fn builder() -> crate::error::conditional_check_failed_error::Builder {
        crate::error::conditional_check_failed_error::Builder::default()
    }
}
impl ConditionalCheckFailedError {
    // TODO: create shared runtime crate
    // fn at_fault(&self) -> ErrorCause { ErrorCause::Client }
    pub fn retryable(&self) -> bool {
        false
    }
    pub fn throttling(&self) -> bool {
        false
    }
}
impl ::std::fmt::Display for ConditionalCheckFailedError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "ConditionalCheckFailedError")?;
        if let Some(inner_9) = &self.message {
            write!(f, ": {}", inner_9)?;
        }
        Ok(())
    }
}
impl ::std::error::Error for ConditionalCheckFailedError {}
/// See [`ConditionalCheckFailedError`](crate::error::ConditionalCheckFailedError)
pub mod conditional_check_failed_error {

    use crate::error::ConditionalCheckFailedError;
    /// A builder for [`ConditionalCheckFailedError`](crate::error::ConditionalCheckFailedError)
    #[non_exhaustive]
    #[derive(Debug, Clone, Default)]
    pub struct Builder {
        message: Option<String>,
    }
    impl Builder {
        /// <p>The conditional request failed.</p>
        pub fn message(mut self, inp: impl Into<String>) -> Self {
            self.message = Some(inp.into());
            self
        }
        /// Consumes the builder and constructs a [`ConditionalCheckFailedError`](crate::error::ConditionalCheckFailedError)
        pub fn build(self) -> ConditionalCheckFailedError {
            ConditionalCheckFailedError {
                message: self.message,
            }
        }
    }
}

/// <p>The specified replica is no longer part of the global table.</p>
#[non_exhaustive]
#[derive(
    ::serde::Deserialize,
    ::serde::Serialize,
    ::std::clone::Clone,
    ::std::cmp::PartialEq,
    ::std::fmt::Debug,
)]
pub struct ReplicaNotFoundError {
    #[serde(rename = "message")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub message: Option<String>,
}
impl ReplicaNotFoundError {
    /// Creates a new builder-style object to manufacture [`ReplicaNotFoundError`](crate::error::ReplicaNotFoundError)
    pub fn builder() -> crate::error::replica_not_found_error::Builder {
        crate::error::replica_not_found_error::Builder::default()
    }
}
impl ReplicaNotFoundError {
    // TODO: create shared runtime crate
    // fn at_fault(&self) -> ErrorCause { ErrorCause::Client }
    pub fn retryable(&self) -> bool {
        false
    }
    pub fn throttling(&self) -> bool {
        false
    }
}
impl ::std::fmt::Display for ReplicaNotFoundError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "ReplicaNotFoundError")?;
        if let Some(inner_10) = &self.message {
            write!(f, ": {}", inner_10)?;
        }
        Ok(())
    }
}
impl ::std::error::Error for ReplicaNotFoundError {}
/// See [`ReplicaNotFoundError`](crate::error::ReplicaNotFoundError)
pub mod replica_not_found_error {

    use crate::error::ReplicaNotFoundError;
    /// A builder for [`ReplicaNotFoundError`](crate::error::ReplicaNotFoundError)
    #[non_exhaustive]
    #[derive(Debug, Clone, Default)]
    pub struct Builder {
        message: Option<String>,
    }
    impl Builder {
        pub fn message(mut self, inp: impl Into<String>) -> Self {
            self.message = Some(inp.into());
            self
        }
        /// Consumes the builder and constructs a [`ReplicaNotFoundError`](crate::error::ReplicaNotFoundError)
        pub fn build(self) -> ReplicaNotFoundError {
            ReplicaNotFoundError {
                message: self.message,
            }
        }
    }
}

/// <p>The operation tried to access a nonexistent index.</p>
#[non_exhaustive]
#[derive(
    ::serde::Deserialize,
    ::serde::Serialize,
    ::std::clone::Clone,
    ::std::cmp::PartialEq,
    ::std::fmt::Debug,
)]
pub struct IndexNotFoundError {
    #[serde(rename = "message")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub message: Option<String>,
}
impl IndexNotFoundError {
    /// Creates a new builder-style object to manufacture [`IndexNotFoundError`](crate::error::IndexNotFoundError)
    pub fn builder() -> crate::error::index_not_found_error::Builder {
        crate::error::index_not_found_error::Builder::default()
    }
}
impl IndexNotFoundError {
    // TODO: create shared runtime crate
    // fn at_fault(&self) -> ErrorCause { ErrorCause::Client }
    pub fn retryable(&self) -> bool {
        false
    }
    pub fn throttling(&self) -> bool {
        false
    }
}
impl ::std::fmt::Display for IndexNotFoundError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "IndexNotFoundError")?;
        if let Some(inner_11) = &self.message {
            write!(f, ": {}", inner_11)?;
        }
        Ok(())
    }
}
impl ::std::error::Error for IndexNotFoundError {}
/// See [`IndexNotFoundError`](crate::error::IndexNotFoundError)
pub mod index_not_found_error {

    use crate::error::IndexNotFoundError;
    /// A builder for [`IndexNotFoundError`](crate::error::IndexNotFoundError)
    #[non_exhaustive]
    #[derive(Debug, Clone, Default)]
    pub struct Builder {
        message: Option<String>,
    }
    impl Builder {
        pub fn message(mut self, inp: impl Into<String>) -> Self {
            self.message = Some(inp.into());
            self
        }
        /// Consumes the builder and constructs a [`IndexNotFoundError`](crate::error::IndexNotFoundError)
        pub fn build(self) -> IndexNotFoundError {
            IndexNotFoundError {
                message: self.message,
            }
        }
    }
}

/// <p>The specified global table does not exist.</p>
#[non_exhaustive]
#[derive(
    ::serde::Deserialize,
    ::serde::Serialize,
    ::std::clone::Clone,
    ::std::cmp::PartialEq,
    ::std::fmt::Debug,
)]
pub struct GlobalTableNotFoundError {
    #[serde(rename = "message")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub message: Option<String>,
}
impl GlobalTableNotFoundError {
    /// Creates a new builder-style object to manufacture [`GlobalTableNotFoundError`](crate::error::GlobalTableNotFoundError)
    pub fn builder() -> crate::error::global_table_not_found_error::Builder {
        crate::error::global_table_not_found_error::Builder::default()
    }
}
impl GlobalTableNotFoundError {
    // TODO: create shared runtime crate
    // fn at_fault(&self) -> ErrorCause { ErrorCause::Client }
    pub fn retryable(&self) -> bool {
        false
    }
    pub fn throttling(&self) -> bool {
        false
    }
}
impl ::std::fmt::Display for GlobalTableNotFoundError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "GlobalTableNotFoundError")?;
        if let Some(inner_12) = &self.message {
            write!(f, ": {}", inner_12)?;
        }
        Ok(())
    }
}
impl ::std::error::Error for GlobalTableNotFoundError {}
/// See [`GlobalTableNotFoundError`](crate::error::GlobalTableNotFoundError)
pub mod global_table_not_found_error {

    use crate::error::GlobalTableNotFoundError;
    /// A builder for [`GlobalTableNotFoundError`](crate::error::GlobalTableNotFoundError)
    #[non_exhaustive]
    #[derive(Debug, Clone, Default)]
    pub struct Builder {
        message: Option<String>,
    }
    impl Builder {
        pub fn message(mut self, inp: impl Into<String>) -> Self {
            self.message = Some(inp.into());
            self
        }
        /// Consumes the builder and constructs a [`GlobalTableNotFoundError`](crate::error::GlobalTableNotFoundError)
        pub fn build(self) -> GlobalTableNotFoundError {
            GlobalTableNotFoundError {
                message: self.message,
            }
        }
    }
}

/// <p>A source table with the name <code>TableName</code> does not currently exist within the subscriber's account.</p>
#[non_exhaustive]
#[derive(
    ::serde::Deserialize,
    ::serde::Serialize,
    ::std::clone::Clone,
    ::std::cmp::PartialEq,
    ::std::fmt::Debug,
)]
pub struct TableNotFoundError {
    #[serde(rename = "message")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub message: Option<String>,
}
impl TableNotFoundError {
    /// Creates a new builder-style object to manufacture [`TableNotFoundError`](crate::error::TableNotFoundError)
    pub fn builder() -> crate::error::table_not_found_error::Builder {
        crate::error::table_not_found_error::Builder::default()
    }
}
impl TableNotFoundError {
    // TODO: create shared runtime crate
    // fn at_fault(&self) -> ErrorCause { ErrorCause::Client }
    pub fn retryable(&self) -> bool {
        false
    }
    pub fn throttling(&self) -> bool {
        false
    }
}
impl ::std::fmt::Display for TableNotFoundError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "TableNotFoundError")?;
        if let Some(inner_13) = &self.message {
            write!(f, ": {}", inner_13)?;
        }
        Ok(())
    }
}
impl ::std::error::Error for TableNotFoundError {}
/// See [`TableNotFoundError`](crate::error::TableNotFoundError)
pub mod table_not_found_error {

    use crate::error::TableNotFoundError;
    /// A builder for [`TableNotFoundError`](crate::error::TableNotFoundError)
    #[non_exhaustive]
    #[derive(Debug, Clone, Default)]
    pub struct Builder {
        message: Option<String>,
    }
    impl Builder {
        pub fn message(mut self, inp: impl Into<String>) -> Self {
            self.message = Some(inp.into());
            self
        }
        /// Consumes the builder and constructs a [`TableNotFoundError`](crate::error::TableNotFoundError)
        pub fn build(self) -> TableNotFoundError {
            TableNotFoundError {
                message: self.message,
            }
        }
    }
}

/// <p>The specified replica is already part of the global table.</p>
#[non_exhaustive]
#[derive(
    ::serde::Deserialize,
    ::serde::Serialize,
    ::std::clone::Clone,
    ::std::cmp::PartialEq,
    ::std::fmt::Debug,
)]
pub struct ReplicaAlreadyExistsError {
    #[serde(rename = "message")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub message: Option<String>,
}
impl ReplicaAlreadyExistsError {
    /// Creates a new builder-style object to manufacture [`ReplicaAlreadyExistsError`](crate::error::ReplicaAlreadyExistsError)
    pub fn builder() -> crate::error::replica_already_exists_error::Builder {
        crate::error::replica_already_exists_error::Builder::default()
    }
}
impl ReplicaAlreadyExistsError {
    // TODO: create shared runtime crate
    // fn at_fault(&self) -> ErrorCause { ErrorCause::Client }
    pub fn retryable(&self) -> bool {
        false
    }
    pub fn throttling(&self) -> bool {
        false
    }
}
impl ::std::fmt::Display for ReplicaAlreadyExistsError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "ReplicaAlreadyExistsError")?;
        if let Some(inner_14) = &self.message {
            write!(f, ": {}", inner_14)?;
        }
        Ok(())
    }
}
impl ::std::error::Error for ReplicaAlreadyExistsError {}
/// See [`ReplicaAlreadyExistsError`](crate::error::ReplicaAlreadyExistsError)
pub mod replica_already_exists_error {

    use crate::error::ReplicaAlreadyExistsError;
    /// A builder for [`ReplicaAlreadyExistsError`](crate::error::ReplicaAlreadyExistsError)
    #[non_exhaustive]
    #[derive(Debug, Clone, Default)]
    pub struct Builder {
        message: Option<String>,
    }
    impl Builder {
        pub fn message(mut self, inp: impl Into<String>) -> Self {
            self.message = Some(inp.into());
            self
        }
        /// Consumes the builder and constructs a [`ReplicaAlreadyExistsError`](crate::error::ReplicaAlreadyExistsError)
        pub fn build(self) -> ReplicaAlreadyExistsError {
            ReplicaAlreadyExistsError {
                message: self.message,
            }
        }
    }
}

/// <p>Backups have not yet been enabled for this table.</p>
#[non_exhaustive]
#[derive(
    ::serde::Deserialize,
    ::serde::Serialize,
    ::std::clone::Clone,
    ::std::cmp::PartialEq,
    ::std::fmt::Debug,
)]
pub struct ContinuousBackupsUnavailableError {
    #[serde(rename = "message")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub message: Option<String>,
}
impl ContinuousBackupsUnavailableError {
    /// Creates a new builder-style object to manufacture [`ContinuousBackupsUnavailableError`](crate::error::ContinuousBackupsUnavailableError)
    pub fn builder() -> crate::error::continuous_backups_unavailable_error::Builder {
        crate::error::continuous_backups_unavailable_error::Builder::default()
    }
}
impl ContinuousBackupsUnavailableError {
    // TODO: create shared runtime crate
    // fn at_fault(&self) -> ErrorCause { ErrorCause::Client }
    pub fn retryable(&self) -> bool {
        false
    }
    pub fn throttling(&self) -> bool {
        false
    }
}
impl ::std::fmt::Display for ContinuousBackupsUnavailableError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "ContinuousBackupsUnavailableError")?;
        if let Some(inner_15) = &self.message {
            write!(f, ": {}", inner_15)?;
        }
        Ok(())
    }
}
impl ::std::error::Error for ContinuousBackupsUnavailableError {}
/// See [`ContinuousBackupsUnavailableError`](crate::error::ContinuousBackupsUnavailableError)
pub mod continuous_backups_unavailable_error {

    use crate::error::ContinuousBackupsUnavailableError;
    /// A builder for [`ContinuousBackupsUnavailableError`](crate::error::ContinuousBackupsUnavailableError)
    #[non_exhaustive]
    #[derive(Debug, Clone, Default)]
    pub struct Builder {
        message: Option<String>,
    }
    impl Builder {
        pub fn message(mut self, inp: impl Into<String>) -> Self {
            self.message = Some(inp.into());
            self
        }
        /// Consumes the builder and constructs a [`ContinuousBackupsUnavailableError`](crate::error::ContinuousBackupsUnavailableError)
        pub fn build(self) -> ContinuousBackupsUnavailableError {
            ContinuousBackupsUnavailableError {
                message: self.message,
            }
        }
    }
}

/// <p>The transaction with the given request token is already in progress.</p>
#[non_exhaustive]
#[derive(
    ::serde::Deserialize,
    ::serde::Serialize,
    ::std::clone::Clone,
    ::std::cmp::PartialEq,
    ::std::fmt::Debug,
)]
pub struct TransactionInProgressError {
    #[serde(rename = "Message")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub message: Option<String>,
}
impl TransactionInProgressError {
    /// Creates a new builder-style object to manufacture [`TransactionInProgressError`](crate::error::TransactionInProgressError)
    pub fn builder() -> crate::error::transaction_in_progress_error::Builder {
        crate::error::transaction_in_progress_error::Builder::default()
    }
}
impl TransactionInProgressError {
    // TODO: create shared runtime crate
    // fn at_fault(&self) -> ErrorCause { ErrorCause::Client }
    pub fn retryable(&self) -> bool {
        false
    }
    pub fn throttling(&self) -> bool {
        false
    }
}
impl ::std::fmt::Display for TransactionInProgressError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "TransactionInProgressError")?;
        Ok(())
    }
}
impl ::std::error::Error for TransactionInProgressError {}
/// See [`TransactionInProgressError`](crate::error::TransactionInProgressError)
pub mod transaction_in_progress_error {

    use crate::error::TransactionInProgressError;
    /// A builder for [`TransactionInProgressError`](crate::error::TransactionInProgressError)
    #[non_exhaustive]
    #[derive(Debug, Clone, Default)]
    pub struct Builder {
        message: Option<String>,
    }
    impl Builder {
        pub fn message(mut self, inp: impl Into<String>) -> Self {
            self.message = Some(inp.into());
            self
        }
        /// Consumes the builder and constructs a [`TransactionInProgressError`](crate::error::TransactionInProgressError)
        pub fn build(self) -> TransactionInProgressError {
            TransactionInProgressError {
                message: self.message,
            }
        }
    }
}

/// <p>The entire transaction request was canceled.</p>
/// <p>DynamoDB cancels a <code>TransactWriteItems</code> request under the following circumstances:</p>
/// <ul>
/// <li>
/// <p>A condition in one of the condition expressions is not met.</p>
/// </li>
/// <li>
/// <p>A table in the <code>TransactWriteItems</code> request is in a different account or region.</p>
/// </li>
/// <li>
/// <p>More than one action in the <code>TransactWriteItems</code> operation targets the same item.</p>
/// </li>
/// <li>
/// <p>There is insufficient provisioned capacity for the transaction to be completed.</p>
/// </li>
/// <li>
/// <p>An item size becomes too large (larger than 400 KB), or a local secondary index (LSI)
/// becomes too large, or a similar validation error occurs because of changes made by the transaction.</p>
/// </li>
/// <li>
/// <p>There is a user error, such as an invalid data format.</p>
/// </li>
/// </ul>
/// <p>DynamoDB cancels a <code>TransactGetItems</code> request under the following circumstances:</p>
/// <ul>
/// <li>
/// <p>There is an ongoing <code>TransactGetItems</code> operation that conflicts with a concurrent
/// <code>PutItem</code>, <code>UpdateItem</code>, <code>DeleteItem</code> or <code>TransactWriteItems</code> request.
/// In this case the <code>TransactGetItems</code> operation fails with a <code>TransactionCanceledException</code>.</p>
/// </li>
/// <li>
/// <p>A table in the <code>TransactGetItems</code> request is in a different account or region.</p>
/// </li>
/// <li>
/// <p>There is insufficient provisioned capacity for the transaction to be completed.</p>
/// </li>
/// <li>
/// <p>There is a user error, such as an invalid data format.</p>
/// </li>
/// </ul>
/// <note>
/// <p>If using Java, DynamoDB lists the cancellation reasons on the <code>CancellationReasons</code> property.  This property is not set for other languages.
/// Transaction cancellation reasons are ordered in the order of requested items, if an item has no error it will have <code>NONE</code> code and <code>Null</code> message.</p>
/// </note>
/// <p>Cancellation reason codes and possible error messages:</p>
/// <ul>
/// <li>
/// <p>No Errors:</p>
/// <ul>
/// <li>
/// <p>Code: <code>NONE</code>
/// </p>
/// </li>
/// <li>
/// <p>Message: <code>null</code>
/// </p>
/// </li>
/// </ul>
/// </li>
/// <li>
/// <p>Conditional Check Failed:</p>
/// <ul>
/// <li>
/// <p>Code: <code>ConditionalCheckFailed</code>
/// </p>
/// </li>
/// <li>
/// <p>Message: The conditional request failed. </p>
/// </li>
/// </ul>
/// </li>
/// <li>
/// <p>Item Collection Size Limit Exceeded:</p>
/// <ul>
/// <li>
/// <p>Code: <code>ItemCollectionSizeLimitExceeded</code>
/// </p>
/// </li>
/// <li>
/// <p>Message: Collection size exceeded.</p>
/// </li>
/// </ul>
/// </li>
/// <li>
/// <p>Transaction Conflict:</p>
/// <ul>
/// <li>
/// <p>Code: <code>TransactionConflict</code>
/// </p>
/// </li>
/// <li>
/// <p>Message: Transaction is ongoing for the item.</p>
/// </li>
/// </ul>
/// </li>
/// <li>
/// <p>Provisioned Throughput Exceeded:</p>
/// <ul>
/// <li>
/// <p>Code: <code>ProvisionedThroughputExceeded</code>
/// </p>
/// </li>
/// <li>
/// <p>Messages: </p>
/// <ul>
/// <li>
/// <p>The level of configured provisioned throughput for the table was exceeded. Consider increasing your provisioning level with the
/// UpdateTable API.</p>
/// <note>
/// <p>This Message is received when provisioned throughput is exceeded is on a provisioned DynamoDB table.</p>
/// </note>
/// </li>
/// <li>
/// <p>The level of configured provisioned throughput for one or more global secondary indexes of the table was exceeded.
/// Consider increasing your provisioning level for the under-provisioned global secondary indexes with the UpdateTable API.</p>
/// <note>
/// <p>This message is returned when provisioned throughput is exceeded is on a provisioned GSI.</p>
/// </note>
/// </li>
/// </ul>
/// </li>
/// </ul>
/// </li>
/// <li>
/// <p>Throttling Error:</p>
/// <ul>
/// <li>
/// <p>Code: <code>ThrottlingError</code>
/// </p>
/// </li>
/// <li>
/// <p>Messages: </p>
/// <ul>
/// <li>
/// <p>Throughput exceeds the current capacity of your table or index.
/// DynamoDB is automatically scaling your table or index so please try
/// again shortly. If exceptions persist, check if you have a hot key:
/// https://docs.aws.amazon.com/amazondynamodb/latest/developerguide/bp-partition-key-design.html.</p>
/// <note>
/// <p>This message is returned when writes get throttled on an On-Demand table as DynamoDB is automatically scaling the table.</p>
/// </note>
/// </li>
/// <li>
/// <p>Throughput exceeds the current capacity for one or more global secondary indexes. DynamoDB is automatically scaling your index so
/// please try again shortly.</p>
/// <note>
/// <p>This message is returned when when writes get throttled on an On-Demand GSI as DynamoDB is automatically scaling the GSI.</p>
/// </note>
/// </li>
/// </ul>
/// </li>
/// </ul>
/// </li>
/// <li>
/// <p>Validation Error:</p>
/// <ul>
/// <li>
/// <p>Code: <code>ValidationError</code>
/// </p>
/// </li>
/// <li>
/// <p>Messages: </p>
/// <ul>
/// <li>
/// <p>One or more parameter values were invalid.</p>
/// </li>
/// <li>
/// <p>The update expression attempted to update the secondary index key beyond allowed size limits.</p>
/// </li>
/// <li>
/// <p>The update expression attempted to update the secondary index key to unsupported type.</p>
/// </li>
/// <li>
/// <p>An operand in the update expression has an incorrect data type.</p>
/// </li>
/// <li>
/// <p>Item size to update has exceeded the maximum allowed size.</p>
/// </li>
/// <li>
/// <p>Number overflow. Attempting to store a number with magnitude larger than supported range.</p>
/// </li>
/// <li>
/// <p>Type mismatch for attribute to update.</p>
/// </li>
/// <li>
/// <p>Nesting Levels have exceeded supported limits.</p>
/// </li>
/// <li>
/// <p>The document path provided in the update expression is invalid for update.</p>
/// </li>
/// <li>
/// <p>The provided expression refers to an attribute that does not exist in the item.</p>
/// </li>
/// </ul>
/// </li>
/// </ul>
/// </li>
/// </ul>
#[non_exhaustive]
#[derive(
    ::serde::Deserialize,
    ::serde::Serialize,
    ::std::clone::Clone,
    ::std::cmp::PartialEq,
    ::std::fmt::Debug,
)]
pub struct TransactionCanceledError {
    #[serde(rename = "Message")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub message: Option<String>,
    /// <p>A list of cancellation reasons.</p>
    #[serde(rename = "CancellationReasons")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub cancellation_reasons: Option<Vec<CancellationReason>>,
}
impl TransactionCanceledError {
    /// Creates a new builder-style object to manufacture [`TransactionCanceledError`](crate::error::TransactionCanceledError)
    pub fn builder() -> crate::error::transaction_canceled_error::Builder {
        crate::error::transaction_canceled_error::Builder::default()
    }
}
impl TransactionCanceledError {
    // TODO: create shared runtime crate
    // fn at_fault(&self) -> ErrorCause { ErrorCause::Client }
    pub fn retryable(&self) -> bool {
        false
    }
    pub fn throttling(&self) -> bool {
        false
    }
}
impl ::std::fmt::Display for TransactionCanceledError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "TransactionCanceledError")?;
        Ok(())
    }
}
impl ::std::error::Error for TransactionCanceledError {}
/// See [`TransactionCanceledError`](crate::error::TransactionCanceledError)
pub mod transaction_canceled_error {

    use crate::error::TransactionCanceledError;
    use crate::model::CancellationReason;
    /// A builder for [`TransactionCanceledError`](crate::error::TransactionCanceledError)
    #[non_exhaustive]
    #[derive(Debug, Clone, Default)]
    pub struct Builder {
        message: Option<String>,
        cancellation_reasons: Option<Vec<CancellationReason>>,
    }
    impl Builder {
        pub fn message(mut self, inp: impl Into<String>) -> Self {
            self.message = Some(inp.into());
            self
        }
        /// <p>A list of cancellation reasons.</p>
        pub fn cancellation_reasons(mut self, inp: Vec<CancellationReason>) -> Self {
            self.cancellation_reasons = Some(inp);
            self
        }
        /// Consumes the builder and constructs a [`TransactionCanceledError`](crate::error::TransactionCanceledError)
        pub fn build(self) -> TransactionCanceledError {
            TransactionCanceledError {
                message: self.message,
                cancellation_reasons: self.cancellation_reasons,
            }
        }
    }
}

/// <p>DynamoDB rejected the request because you retried a request with a different payload but
/// with an idempotent token that was already used.</p>
#[non_exhaustive]
#[derive(
    ::serde::Deserialize,
    ::serde::Serialize,
    ::std::clone::Clone,
    ::std::cmp::PartialEq,
    ::std::fmt::Debug,
)]
pub struct IdempotentParameterMismatchError {
    #[serde(rename = "Message")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub message: Option<String>,
}
impl IdempotentParameterMismatchError {
    /// Creates a new builder-style object to manufacture [`IdempotentParameterMismatchError`](crate::error::IdempotentParameterMismatchError)
    pub fn builder() -> crate::error::idempotent_parameter_mismatch_error::Builder {
        crate::error::idempotent_parameter_mismatch_error::Builder::default()
    }
}
impl IdempotentParameterMismatchError {
    // TODO: create shared runtime crate
    // fn at_fault(&self) -> ErrorCause { ErrorCause::Client }
    pub fn retryable(&self) -> bool {
        false
    }
    pub fn throttling(&self) -> bool {
        false
    }
}
impl ::std::fmt::Display for IdempotentParameterMismatchError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "IdempotentParameterMismatchError")?;
        Ok(())
    }
}
impl ::std::error::Error for IdempotentParameterMismatchError {}
/// See [`IdempotentParameterMismatchError`](crate::error::IdempotentParameterMismatchError)
pub mod idempotent_parameter_mismatch_error {

    use crate::error::IdempotentParameterMismatchError;
    /// A builder for [`IdempotentParameterMismatchError`](crate::error::IdempotentParameterMismatchError)
    #[non_exhaustive]
    #[derive(Debug, Clone, Default)]
    pub struct Builder {
        message: Option<String>,
    }
    impl Builder {
        pub fn message(mut self, inp: impl Into<String>) -> Self {
            self.message = Some(inp.into());
            self
        }
        /// Consumes the builder and constructs a [`IdempotentParameterMismatchError`](crate::error::IdempotentParameterMismatchError)
        pub fn build(self) -> IdempotentParameterMismatchError {
            IdempotentParameterMismatchError {
                message: self.message,
            }
        }
    }
}

/// <p>A target table with the specified name is either being created or deleted. </p>
#[non_exhaustive]
#[derive(
    ::serde::Deserialize,
    ::serde::Serialize,
    ::std::clone::Clone,
    ::std::cmp::PartialEq,
    ::std::fmt::Debug,
)]
pub struct TableInUseError {
    #[serde(rename = "message")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub message: Option<String>,
}
impl TableInUseError {
    /// Creates a new builder-style object to manufacture [`TableInUseError`](crate::error::TableInUseError)
    pub fn builder() -> crate::error::table_in_use_error::Builder {
        crate::error::table_in_use_error::Builder::default()
    }
}
impl TableInUseError {
    // TODO: create shared runtime crate
    // fn at_fault(&self) -> ErrorCause { ErrorCause::Client }
    pub fn retryable(&self) -> bool {
        false
    }
    pub fn throttling(&self) -> bool {
        false
    }
}
impl ::std::fmt::Display for TableInUseError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "TableInUseError")?;
        if let Some(inner_16) = &self.message {
            write!(f, ": {}", inner_16)?;
        }
        Ok(())
    }
}
impl ::std::error::Error for TableInUseError {}
/// See [`TableInUseError`](crate::error::TableInUseError)
pub mod table_in_use_error {

    use crate::error::TableInUseError;
    /// A builder for [`TableInUseError`](crate::error::TableInUseError)
    #[non_exhaustive]
    #[derive(Debug, Clone, Default)]
    pub struct Builder {
        message: Option<String>,
    }
    impl Builder {
        pub fn message(mut self, inp: impl Into<String>) -> Self {
            self.message = Some(inp.into());
            self
        }
        /// Consumes the builder and constructs a [`TableInUseError`](crate::error::TableInUseError)
        pub fn build(self) -> TableInUseError {
            TableInUseError {
                message: self.message,
            }
        }
    }
}

/// <p>A target table with the specified name already exists. </p>
#[non_exhaustive]
#[derive(
    ::serde::Deserialize,
    ::serde::Serialize,
    ::std::clone::Clone,
    ::std::cmp::PartialEq,
    ::std::fmt::Debug,
)]
pub struct TableAlreadyExistsError {
    #[serde(rename = "message")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub message: Option<String>,
}
impl TableAlreadyExistsError {
    /// Creates a new builder-style object to manufacture [`TableAlreadyExistsError`](crate::error::TableAlreadyExistsError)
    pub fn builder() -> crate::error::table_already_exists_error::Builder {
        crate::error::table_already_exists_error::Builder::default()
    }
}
impl TableAlreadyExistsError {
    // TODO: create shared runtime crate
    // fn at_fault(&self) -> ErrorCause { ErrorCause::Client }
    pub fn retryable(&self) -> bool {
        false
    }
    pub fn throttling(&self) -> bool {
        false
    }
}
impl ::std::fmt::Display for TableAlreadyExistsError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "TableAlreadyExistsError")?;
        if let Some(inner_17) = &self.message {
            write!(f, ": {}", inner_17)?;
        }
        Ok(())
    }
}
impl ::std::error::Error for TableAlreadyExistsError {}
/// See [`TableAlreadyExistsError`](crate::error::TableAlreadyExistsError)
pub mod table_already_exists_error {

    use crate::error::TableAlreadyExistsError;
    /// A builder for [`TableAlreadyExistsError`](crate::error::TableAlreadyExistsError)
    #[non_exhaustive]
    #[derive(Debug, Clone, Default)]
    pub struct Builder {
        message: Option<String>,
    }
    impl Builder {
        pub fn message(mut self, inp: impl Into<String>) -> Self {
            self.message = Some(inp.into());
            self
        }
        /// Consumes the builder and constructs a [`TableAlreadyExistsError`](crate::error::TableAlreadyExistsError)
        pub fn build(self) -> TableAlreadyExistsError {
            TableAlreadyExistsError {
                message: self.message,
            }
        }
    }
}

/// <p>Point in time recovery has not yet been enabled for this source table.</p>
#[non_exhaustive]
#[derive(
    ::serde::Deserialize,
    ::serde::Serialize,
    ::std::clone::Clone,
    ::std::cmp::PartialEq,
    ::std::fmt::Debug,
)]
pub struct PointInTimeRecoveryUnavailableError {
    #[serde(rename = "message")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub message: Option<String>,
}
impl PointInTimeRecoveryUnavailableError {
    /// Creates a new builder-style object to manufacture [`PointInTimeRecoveryUnavailableError`](crate::error::PointInTimeRecoveryUnavailableError)
    pub fn builder() -> crate::error::point_in_time_recovery_unavailable_error::Builder {
        crate::error::point_in_time_recovery_unavailable_error::Builder::default()
    }
}
impl PointInTimeRecoveryUnavailableError {
    // TODO: create shared runtime crate
    // fn at_fault(&self) -> ErrorCause { ErrorCause::Client }
    pub fn retryable(&self) -> bool {
        false
    }
    pub fn throttling(&self) -> bool {
        false
    }
}
impl ::std::fmt::Display for PointInTimeRecoveryUnavailableError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "PointInTimeRecoveryUnavailableError")?;
        if let Some(inner_18) = &self.message {
            write!(f, ": {}", inner_18)?;
        }
        Ok(())
    }
}
impl ::std::error::Error for PointInTimeRecoveryUnavailableError {}
/// See [`PointInTimeRecoveryUnavailableError`](crate::error::PointInTimeRecoveryUnavailableError)
pub mod point_in_time_recovery_unavailable_error {

    use crate::error::PointInTimeRecoveryUnavailableError;
    /// A builder for [`PointInTimeRecoveryUnavailableError`](crate::error::PointInTimeRecoveryUnavailableError)
    #[non_exhaustive]
    #[derive(Debug, Clone, Default)]
    pub struct Builder {
        message: Option<String>,
    }
    impl Builder {
        pub fn message(mut self, inp: impl Into<String>) -> Self {
            self.message = Some(inp.into());
            self
        }
        /// Consumes the builder and constructs a [`PointInTimeRecoveryUnavailableError`](crate::error::PointInTimeRecoveryUnavailableError)
        pub fn build(self) -> PointInTimeRecoveryUnavailableError {
            PointInTimeRecoveryUnavailableError {
                message: self.message,
            }
        }
    }
}

/// <p>An invalid restore time was specified. RestoreDateTime must be between EarliestRestorableDateTime and LatestRestorableDateTime.</p>
#[non_exhaustive]
#[derive(
    ::serde::Deserialize,
    ::serde::Serialize,
    ::std::clone::Clone,
    ::std::cmp::PartialEq,
    ::std::fmt::Debug,
)]
pub struct InvalidRestoreTimeError {
    #[serde(rename = "message")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub message: Option<String>,
}
impl InvalidRestoreTimeError {
    /// Creates a new builder-style object to manufacture [`InvalidRestoreTimeError`](crate::error::InvalidRestoreTimeError)
    pub fn builder() -> crate::error::invalid_restore_time_error::Builder {
        crate::error::invalid_restore_time_error::Builder::default()
    }
}
impl InvalidRestoreTimeError {
    // TODO: create shared runtime crate
    // fn at_fault(&self) -> ErrorCause { ErrorCause::Client }
    pub fn retryable(&self) -> bool {
        false
    }
    pub fn throttling(&self) -> bool {
        false
    }
}
impl ::std::fmt::Display for InvalidRestoreTimeError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "InvalidRestoreTimeError")?;
        if let Some(inner_19) = &self.message {
            write!(f, ": {}", inner_19)?;
        }
        Ok(())
    }
}
impl ::std::error::Error for InvalidRestoreTimeError {}
/// See [`InvalidRestoreTimeError`](crate::error::InvalidRestoreTimeError)
pub mod invalid_restore_time_error {

    use crate::error::InvalidRestoreTimeError;
    /// A builder for [`InvalidRestoreTimeError`](crate::error::InvalidRestoreTimeError)
    #[non_exhaustive]
    #[derive(Debug, Clone, Default)]
    pub struct Builder {
        message: Option<String>,
    }
    impl Builder {
        pub fn message(mut self, inp: impl Into<String>) -> Self {
            self.message = Some(inp.into());
            self
        }
        /// Consumes the builder and constructs a [`InvalidRestoreTimeError`](crate::error::InvalidRestoreTimeError)
        pub fn build(self) -> InvalidRestoreTimeError {
            InvalidRestoreTimeError {
                message: self.message,
            }
        }
    }
}

/// <p>Backup not found for the given BackupARN. </p>
#[non_exhaustive]
#[derive(
    ::serde::Deserialize,
    ::serde::Serialize,
    ::std::clone::Clone,
    ::std::cmp::PartialEq,
    ::std::fmt::Debug,
)]
pub struct BackupNotFoundError {
    #[serde(rename = "message")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub message: Option<String>,
}
impl BackupNotFoundError {
    /// Creates a new builder-style object to manufacture [`BackupNotFoundError`](crate::error::BackupNotFoundError)
    pub fn builder() -> crate::error::backup_not_found_error::Builder {
        crate::error::backup_not_found_error::Builder::default()
    }
}
impl BackupNotFoundError {
    // TODO: create shared runtime crate
    // fn at_fault(&self) -> ErrorCause { ErrorCause::Client }
    pub fn retryable(&self) -> bool {
        false
    }
    pub fn throttling(&self) -> bool {
        false
    }
}
impl ::std::fmt::Display for BackupNotFoundError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "BackupNotFoundError")?;
        if let Some(inner_20) = &self.message {
            write!(f, ": {}", inner_20)?;
        }
        Ok(())
    }
}
impl ::std::error::Error for BackupNotFoundError {}
/// See [`BackupNotFoundError`](crate::error::BackupNotFoundError)
pub mod backup_not_found_error {

    use crate::error::BackupNotFoundError;
    /// A builder for [`BackupNotFoundError`](crate::error::BackupNotFoundError)
    #[non_exhaustive]
    #[derive(Debug, Clone, Default)]
    pub struct Builder {
        message: Option<String>,
    }
    impl Builder {
        pub fn message(mut self, inp: impl Into<String>) -> Self {
            self.message = Some(inp.into());
            self
        }
        /// Consumes the builder and constructs a [`BackupNotFoundError`](crate::error::BackupNotFoundError)
        pub fn build(self) -> BackupNotFoundError {
            BackupNotFoundError {
                message: self.message,
            }
        }
    }
}

/// <p>There is another ongoing conflicting backup control plane operation on the table. The backup is either being created, deleted or restored to a table.</p>
#[non_exhaustive]
#[derive(
    ::serde::Deserialize,
    ::serde::Serialize,
    ::std::clone::Clone,
    ::std::cmp::PartialEq,
    ::std::fmt::Debug,
)]
pub struct BackupInUseError {
    #[serde(rename = "message")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub message: Option<String>,
}
impl BackupInUseError {
    /// Creates a new builder-style object to manufacture [`BackupInUseError`](crate::error::BackupInUseError)
    pub fn builder() -> crate::error::backup_in_use_error::Builder {
        crate::error::backup_in_use_error::Builder::default()
    }
}
impl BackupInUseError {
    // TODO: create shared runtime crate
    // fn at_fault(&self) -> ErrorCause { ErrorCause::Client }
    pub fn retryable(&self) -> bool {
        false
    }
    pub fn throttling(&self) -> bool {
        false
    }
}
impl ::std::fmt::Display for BackupInUseError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "BackupInUseError")?;
        if let Some(inner_21) = &self.message {
            write!(f, ": {}", inner_21)?;
        }
        Ok(())
    }
}
impl ::std::error::Error for BackupInUseError {}
/// See [`BackupInUseError`](crate::error::BackupInUseError)
pub mod backup_in_use_error {

    use crate::error::BackupInUseError;
    /// A builder for [`BackupInUseError`](crate::error::BackupInUseError)
    #[non_exhaustive]
    #[derive(Debug, Clone, Default)]
    pub struct Builder {
        message: Option<String>,
    }
    impl Builder {
        pub fn message(mut self, inp: impl Into<String>) -> Self {
            self.message = Some(inp.into());
            self
        }
        /// Consumes the builder and constructs a [`BackupInUseError`](crate::error::BackupInUseError)
        pub fn build(self) -> BackupInUseError {
            BackupInUseError {
                message: self.message,
            }
        }
    }
}

/// <p>The specified <code>ExportTime</code> is outside of the point in time recovery
/// window.</p>
#[non_exhaustive]
#[derive(
    ::serde::Deserialize,
    ::serde::Serialize,
    ::std::clone::Clone,
    ::std::cmp::PartialEq,
    ::std::fmt::Debug,
)]
pub struct InvalidExportTimeError {
    #[serde(rename = "message")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub message: Option<String>,
}
impl InvalidExportTimeError {
    /// Creates a new builder-style object to manufacture [`InvalidExportTimeError`](crate::error::InvalidExportTimeError)
    pub fn builder() -> crate::error::invalid_export_time_error::Builder {
        crate::error::invalid_export_time_error::Builder::default()
    }
}
impl InvalidExportTimeError {
    // TODO: create shared runtime crate
    // fn at_fault(&self) -> ErrorCause { ErrorCause::Client }
    pub fn retryable(&self) -> bool {
        false
    }
    pub fn throttling(&self) -> bool {
        false
    }
}
impl ::std::fmt::Display for InvalidExportTimeError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "InvalidExportTimeError")?;
        if let Some(inner_22) = &self.message {
            write!(f, ": {}", inner_22)?;
        }
        Ok(())
    }
}
impl ::std::error::Error for InvalidExportTimeError {}
/// See [`InvalidExportTimeError`](crate::error::InvalidExportTimeError)
pub mod invalid_export_time_error {

    use crate::error::InvalidExportTimeError;
    /// A builder for [`InvalidExportTimeError`](crate::error::InvalidExportTimeError)
    #[non_exhaustive]
    #[derive(Debug, Clone, Default)]
    pub struct Builder {
        message: Option<String>,
    }
    impl Builder {
        pub fn message(mut self, inp: impl Into<String>) -> Self {
            self.message = Some(inp.into());
            self
        }
        /// Consumes the builder and constructs a [`InvalidExportTimeError`](crate::error::InvalidExportTimeError)
        pub fn build(self) -> InvalidExportTimeError {
            InvalidExportTimeError {
                message: self.message,
            }
        }
    }
}

/// <p>There was a conflict when writing to the specified S3 bucket.</p>
#[non_exhaustive]
#[derive(
    ::serde::Deserialize,
    ::serde::Serialize,
    ::std::clone::Clone,
    ::std::cmp::PartialEq,
    ::std::fmt::Debug,
)]
pub struct ExportConflictError {
    #[serde(rename = "message")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub message: Option<String>,
}
impl ExportConflictError {
    /// Creates a new builder-style object to manufacture [`ExportConflictError`](crate::error::ExportConflictError)
    pub fn builder() -> crate::error::export_conflict_error::Builder {
        crate::error::export_conflict_error::Builder::default()
    }
}
impl ExportConflictError {
    // TODO: create shared runtime crate
    // fn at_fault(&self) -> ErrorCause { ErrorCause::Client }
    pub fn retryable(&self) -> bool {
        false
    }
    pub fn throttling(&self) -> bool {
        false
    }
}
impl ::std::fmt::Display for ExportConflictError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "ExportConflictError")?;
        if let Some(inner_23) = &self.message {
            write!(f, ": {}", inner_23)?;
        }
        Ok(())
    }
}
impl ::std::error::Error for ExportConflictError {}
/// See [`ExportConflictError`](crate::error::ExportConflictError)
pub mod export_conflict_error {

    use crate::error::ExportConflictError;
    /// A builder for [`ExportConflictError`](crate::error::ExportConflictError)
    #[non_exhaustive]
    #[derive(Debug, Clone, Default)]
    pub struct Builder {
        message: Option<String>,
    }
    impl Builder {
        pub fn message(mut self, inp: impl Into<String>) -> Self {
            self.message = Some(inp.into());
            self
        }
        /// Consumes the builder and constructs a [`ExportConflictError`](crate::error::ExportConflictError)
        pub fn build(self) -> ExportConflictError {
            ExportConflictError {
                message: self.message,
            }
        }
    }
}

/// <p>
/// There was an attempt to insert an item with the same primary key as an item that already exists in the DynamoDB table.
/// </p>
#[non_exhaustive]
#[derive(
    ::serde::Deserialize,
    ::serde::Serialize,
    ::std::clone::Clone,
    ::std::cmp::PartialEq,
    ::std::fmt::Debug,
)]
pub struct DuplicateItemError {
    #[serde(rename = "message")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub message: Option<String>,
}
impl DuplicateItemError {
    /// Creates a new builder-style object to manufacture [`DuplicateItemError`](crate::error::DuplicateItemError)
    pub fn builder() -> crate::error::duplicate_item_error::Builder {
        crate::error::duplicate_item_error::Builder::default()
    }
}
impl DuplicateItemError {
    // TODO: create shared runtime crate
    // fn at_fault(&self) -> ErrorCause { ErrorCause::Client }
    pub fn retryable(&self) -> bool {
        false
    }
    pub fn throttling(&self) -> bool {
        false
    }
}
impl ::std::fmt::Display for DuplicateItemError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "DuplicateItemError")?;
        if let Some(inner_24) = &self.message {
            write!(f, ": {}", inner_24)?;
        }
        Ok(())
    }
}
impl ::std::error::Error for DuplicateItemError {}
/// See [`DuplicateItemError`](crate::error::DuplicateItemError)
pub mod duplicate_item_error {

    use crate::error::DuplicateItemError;
    /// A builder for [`DuplicateItemError`](crate::error::DuplicateItemError)
    #[non_exhaustive]
    #[derive(Debug, Clone, Default)]
    pub struct Builder {
        message: Option<String>,
    }
    impl Builder {
        pub fn message(mut self, inp: impl Into<String>) -> Self {
            self.message = Some(inp.into());
            self
        }
        /// Consumes the builder and constructs a [`DuplicateItemError`](crate::error::DuplicateItemError)
        pub fn build(self) -> DuplicateItemError {
            DuplicateItemError {
                message: self.message,
            }
        }
    }
}

/// <p>The specified export was not found.</p>
#[non_exhaustive]
#[derive(
    ::serde::Deserialize,
    ::serde::Serialize,
    ::std::clone::Clone,
    ::std::cmp::PartialEq,
    ::std::fmt::Debug,
)]
pub struct ExportNotFoundError {
    #[serde(rename = "message")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub message: Option<String>,
}
impl ExportNotFoundError {
    /// Creates a new builder-style object to manufacture [`ExportNotFoundError`](crate::error::ExportNotFoundError)
    pub fn builder() -> crate::error::export_not_found_error::Builder {
        crate::error::export_not_found_error::Builder::default()
    }
}
impl ExportNotFoundError {
    // TODO: create shared runtime crate
    // fn at_fault(&self) -> ErrorCause { ErrorCause::Client }
    pub fn retryable(&self) -> bool {
        false
    }
    pub fn throttling(&self) -> bool {
        false
    }
}
impl ::std::fmt::Display for ExportNotFoundError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "ExportNotFoundError")?;
        if let Some(inner_25) = &self.message {
            write!(f, ": {}", inner_25)?;
        }
        Ok(())
    }
}
impl ::std::error::Error for ExportNotFoundError {}
/// See [`ExportNotFoundError`](crate::error::ExportNotFoundError)
pub mod export_not_found_error {

    use crate::error::ExportNotFoundError;
    /// A builder for [`ExportNotFoundError`](crate::error::ExportNotFoundError)
    #[non_exhaustive]
    #[derive(Debug, Clone, Default)]
    pub struct Builder {
        message: Option<String>,
    }
    impl Builder {
        pub fn message(mut self, inp: impl Into<String>) -> Self {
            self.message = Some(inp.into());
            self
        }
        /// Consumes the builder and constructs a [`ExportNotFoundError`](crate::error::ExportNotFoundError)
        pub fn build(self) -> ExportNotFoundError {
            ExportNotFoundError {
                message: self.message,
            }
        }
    }
}

/// <p>The specified global table already exists.</p>
#[non_exhaustive]
#[derive(
    ::serde::Deserialize,
    ::serde::Serialize,
    ::std::clone::Clone,
    ::std::cmp::PartialEq,
    ::std::fmt::Debug,
)]
pub struct GlobalTableAlreadyExistsError {
    #[serde(rename = "message")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub message: Option<String>,
}
impl GlobalTableAlreadyExistsError {
    /// Creates a new builder-style object to manufacture [`GlobalTableAlreadyExistsError`](crate::error::GlobalTableAlreadyExistsError)
    pub fn builder() -> crate::error::global_table_already_exists_error::Builder {
        crate::error::global_table_already_exists_error::Builder::default()
    }
}
impl GlobalTableAlreadyExistsError {
    // TODO: create shared runtime crate
    // fn at_fault(&self) -> ErrorCause { ErrorCause::Client }
    pub fn retryable(&self) -> bool {
        false
    }
    pub fn throttling(&self) -> bool {
        false
    }
}
impl ::std::fmt::Display for GlobalTableAlreadyExistsError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "GlobalTableAlreadyExistsError")?;
        if let Some(inner_26) = &self.message {
            write!(f, ": {}", inner_26)?;
        }
        Ok(())
    }
}
impl ::std::error::Error for GlobalTableAlreadyExistsError {}
/// See [`GlobalTableAlreadyExistsError`](crate::error::GlobalTableAlreadyExistsError)
pub mod global_table_already_exists_error {

    use crate::error::GlobalTableAlreadyExistsError;
    /// A builder for [`GlobalTableAlreadyExistsError`](crate::error::GlobalTableAlreadyExistsError)
    #[non_exhaustive]
    #[derive(Debug, Clone, Default)]
    pub struct Builder {
        message: Option<String>,
    }
    impl Builder {
        pub fn message(mut self, inp: impl Into<String>) -> Self {
            self.message = Some(inp.into());
            self
        }
        /// Consumes the builder and constructs a [`GlobalTableAlreadyExistsError`](crate::error::GlobalTableAlreadyExistsError)
        pub fn build(self) -> GlobalTableAlreadyExistsError {
            GlobalTableAlreadyExistsError {
                message: self.message,
            }
        }
    }
}
