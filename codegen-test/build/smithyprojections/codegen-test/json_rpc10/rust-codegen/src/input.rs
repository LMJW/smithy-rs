// Code generated by software.amazon.smithy.rust.codegen.smithy-rs. DO NOT EDIT.
use crate::model::MyUnion;
use crate::serializer::JsonUnionsInputBody;
/// See [`EmptyInputAndEmptyOutputInput`](crate::input::EmptyInputAndEmptyOutputInput)
pub mod empty_input_and_empty_output_input {

    use crate::input::EmptyInputAndEmptyOutputInput;
    use crate::operation::EmptyInputAndEmptyOutput;
    /// A builder for [`EmptyInputAndEmptyOutputInput`](crate::input::EmptyInputAndEmptyOutputInput)
    #[non_exhaustive]
    #[derive(Debug, Clone, Default)]
    pub struct Builder {}
    impl Builder {
        /// Consumes the builder and constructs an Operation<[`EmptyInputAndEmptyOutput`](crate::operation::EmptyInputAndEmptyOutput)>
        pub fn build(
            self,
            _config: &crate::config::Config,
        ) -> ::smithy_http::operation::Operation<EmptyInputAndEmptyOutput, ()> {
            let op = EmptyInputAndEmptyOutput::new(EmptyInputAndEmptyOutputInput {});

            #[allow(unused_mut)]
            let mut request = ::smithy_http::operation::Request::new(
                op.build_http_request()
                    .map(::smithy_http::body::SdkBody::from),
            );

            ::smithy_http::operation::Operation::new(request, op)
        }
    }
}
impl EmptyInputAndEmptyOutputInput {
    pub fn request_builder_base(&self) -> ::http::request::Builder {
        let builder = ::http::request::Builder::new();

        builder
            .method("POST")
            .header("Content-Type", "application/x-amz-json-1.0")
            .header("X-Amz-Target", "JsonRpc10.EmptyInputAndEmptyOutput")
    }
    pub fn build_body(&self) -> ::std::vec::Vec<u8> {
        vec![]
    }
    pub fn assemble(
        builder: ::http::request::Builder,
        body: ::std::vec::Vec<u8>,
    ) -> ::http::request::Request<::std::vec::Vec<u8>> {
        builder
            .header(::http::header::CONTENT_LENGTH, body.len())
            .body(body)
            .expect("http request should be valid")
    }
    /// Creates a new builder-style object to manufacture [`EmptyInputAndEmptyOutputInput`](crate::input::EmptyInputAndEmptyOutputInput)
    pub fn builder() -> crate::input::empty_input_and_empty_output_input::Builder {
        crate::input::empty_input_and_empty_output_input::Builder::default()
    }
}

/// See [`GreetingWithErrorsInput`](crate::input::GreetingWithErrorsInput)
pub mod greeting_with_errors_input {

    use crate::input::GreetingWithErrorsInput;
    use crate::operation::GreetingWithErrors;
    /// A builder for [`GreetingWithErrorsInput`](crate::input::GreetingWithErrorsInput)
    #[non_exhaustive]
    #[derive(Debug, Clone, Default)]
    pub struct Builder {}
    impl Builder {
        /// Consumes the builder and constructs an Operation<[`GreetingWithErrors`](crate::operation::GreetingWithErrors)>
        pub fn build(
            self,
            _config: &crate::config::Config,
        ) -> ::smithy_http::operation::Operation<GreetingWithErrors, ()> {
            let op = GreetingWithErrors::new(GreetingWithErrorsInput {});

            #[allow(unused_mut)]
            let mut request = ::smithy_http::operation::Request::new(
                op.build_http_request()
                    .map(::smithy_http::body::SdkBody::from),
            );

            ::smithy_http::operation::Operation::new(request, op)
        }
    }
}
impl GreetingWithErrorsInput {
    pub fn request_builder_base(&self) -> ::http::request::Builder {
        let builder = ::http::request::Builder::new();

        builder
            .method("POST")
            .header("Content-Type", "application/x-amz-json-1.0")
            .header("X-Amz-Target", "JsonRpc10.GreetingWithErrors")
    }
    pub fn build_body(&self) -> ::std::vec::Vec<u8> {
        vec![]
    }
    pub fn assemble(
        builder: ::http::request::Builder,
        body: ::std::vec::Vec<u8>,
    ) -> ::http::request::Request<::std::vec::Vec<u8>> {
        builder
            .header(::http::header::CONTENT_LENGTH, body.len())
            .body(body)
            .expect("http request should be valid")
    }
    /// Creates a new builder-style object to manufacture [`GreetingWithErrorsInput`](crate::input::GreetingWithErrorsInput)
    pub fn builder() -> crate::input::greeting_with_errors_input::Builder {
        crate::input::greeting_with_errors_input::Builder::default()
    }
}

/// See [`JsonUnionsInput`](crate::input::JsonUnionsInput)
pub mod json_unions_input {

    use crate::input::JsonUnionsInput;
    use crate::model::MyUnion;
    use crate::operation::JsonUnions;
    /// A builder for [`JsonUnionsInput`](crate::input::JsonUnionsInput)
    #[non_exhaustive]
    #[derive(Debug, Clone, Default)]
    pub struct Builder {
        contents: ::std::option::Option<MyUnion>,
    }
    impl Builder {
        /// A union with a representative set of types for members.
        pub fn contents(mut self, inp: MyUnion) -> Self {
            self.contents = Some(inp);
            self
        }
        /// Consumes the builder and constructs an Operation<[`JsonUnions`](crate::operation::JsonUnions)>
        pub fn build(
            self,
            _config: &crate::config::Config,
        ) -> ::smithy_http::operation::Operation<JsonUnions, ()> {
            let op = JsonUnions::new(JsonUnionsInput {
                contents: self.contents,
            });

            #[allow(unused_mut)]
            let mut request = ::smithy_http::operation::Request::new(
                op.build_http_request()
                    .map(::smithy_http::body::SdkBody::from),
            );

            ::smithy_http::operation::Operation::new(request, op)
        }
    }
}
impl JsonUnionsInput {
    pub fn request_builder_base(&self) -> ::http::request::Builder {
        let builder = ::http::request::Builder::new();

        builder
            .method("POST")
            .header("Content-Type", "application/x-amz-json-1.0")
            .header("X-Amz-Target", "JsonRpc10.JsonUnions")
    }
    fn body(&self) -> JsonUnionsInputBody {
        JsonUnionsInputBody {
            contents: &self.contents,
        }
    }
    pub fn build_body(&self) -> ::std::vec::Vec<u8> {
        ::serde_json::to_vec(&self.body()).expect("serialization should succeed")
    }
    pub fn assemble(
        builder: ::http::request::Builder,
        body: ::std::vec::Vec<u8>,
    ) -> ::http::request::Request<::std::vec::Vec<u8>> {
        builder
            .header(::http::header::CONTENT_LENGTH, body.len())
            .body(body)
            .expect("http request should be valid")
    }
    /// Creates a new builder-style object to manufacture [`JsonUnionsInput`](crate::input::JsonUnionsInput)
    pub fn builder() -> crate::input::json_unions_input::Builder {
        crate::input::json_unions_input::Builder::default()
    }
}

/// See [`NoInputAndNoOutputInput`](crate::input::NoInputAndNoOutputInput)
pub mod no_input_and_no_output_input {

    use crate::input::NoInputAndNoOutputInput;
    use crate::operation::NoInputAndNoOutput;
    /// A builder for [`NoInputAndNoOutputInput`](crate::input::NoInputAndNoOutputInput)
    #[non_exhaustive]
    #[derive(Debug, Clone, Default)]
    pub struct Builder {}
    impl Builder {
        /// Consumes the builder and constructs an Operation<[`NoInputAndNoOutput`](crate::operation::NoInputAndNoOutput)>
        pub fn build(
            self,
            _config: &crate::config::Config,
        ) -> ::smithy_http::operation::Operation<NoInputAndNoOutput, ()> {
            let op = NoInputAndNoOutput::new(NoInputAndNoOutputInput {});

            #[allow(unused_mut)]
            let mut request = ::smithy_http::operation::Request::new(
                op.build_http_request()
                    .map(::smithy_http::body::SdkBody::from),
            );

            ::smithy_http::operation::Operation::new(request, op)
        }
    }
}
impl NoInputAndNoOutputInput {
    pub fn request_builder_base(&self) -> ::http::request::Builder {
        let builder = ::http::request::Builder::new();

        builder
            .method("POST")
            .header("Content-Type", "application/x-amz-json-1.0")
            .header("X-Amz-Target", "JsonRpc10.NoInputAndNoOutput")
    }
    pub fn build_body(&self) -> ::std::vec::Vec<u8> {
        vec![]
    }
    pub fn assemble(
        builder: ::http::request::Builder,
        body: ::std::vec::Vec<u8>,
    ) -> ::http::request::Request<::std::vec::Vec<u8>> {
        builder
            .header(::http::header::CONTENT_LENGTH, body.len())
            .body(body)
            .expect("http request should be valid")
    }
    /// Creates a new builder-style object to manufacture [`NoInputAndNoOutputInput`](crate::input::NoInputAndNoOutputInput)
    pub fn builder() -> crate::input::no_input_and_no_output_input::Builder {
        crate::input::no_input_and_no_output_input::Builder::default()
    }
}

/// See [`NoInputAndOutputInput`](crate::input::NoInputAndOutputInput)
pub mod no_input_and_output_input {

    use crate::input::NoInputAndOutputInput;
    use crate::operation::NoInputAndOutput;
    /// A builder for [`NoInputAndOutputInput`](crate::input::NoInputAndOutputInput)
    #[non_exhaustive]
    #[derive(Debug, Clone, Default)]
    pub struct Builder {}
    impl Builder {
        /// Consumes the builder and constructs an Operation<[`NoInputAndOutput`](crate::operation::NoInputAndOutput)>
        pub fn build(
            self,
            _config: &crate::config::Config,
        ) -> ::smithy_http::operation::Operation<NoInputAndOutput, ()> {
            let op = NoInputAndOutput::new(NoInputAndOutputInput {});

            #[allow(unused_mut)]
            let mut request = ::smithy_http::operation::Request::new(
                op.build_http_request()
                    .map(::smithy_http::body::SdkBody::from),
            );

            ::smithy_http::operation::Operation::new(request, op)
        }
    }
}
impl NoInputAndOutputInput {
    pub fn request_builder_base(&self) -> ::http::request::Builder {
        let builder = ::http::request::Builder::new();

        builder
            .method("POST")
            .header("Content-Type", "application/x-amz-json-1.0")
            .header("X-Amz-Target", "JsonRpc10.NoInputAndOutput")
    }
    pub fn build_body(&self) -> ::std::vec::Vec<u8> {
        vec![]
    }
    pub fn assemble(
        builder: ::http::request::Builder,
        body: ::std::vec::Vec<u8>,
    ) -> ::http::request::Request<::std::vec::Vec<u8>> {
        builder
            .header(::http::header::CONTENT_LENGTH, body.len())
            .body(body)
            .expect("http request should be valid")
    }
    /// Creates a new builder-style object to manufacture [`NoInputAndOutputInput`](crate::input::NoInputAndOutputInput)
    pub fn builder() -> crate::input::no_input_and_output_input::Builder {
        crate::input::no_input_and_output_input::Builder::default()
    }
}

/// A shared structure that contains a single union member.
#[non_exhaustive]
#[derive(::std::clone::Clone, ::std::cmp::PartialEq, ::std::fmt::Debug)]
pub struct JsonUnionsInput {
    /// A union with a representative set of types for members.
    pub contents: ::std::option::Option<MyUnion>,
}

#[non_exhaustive]
#[derive(::std::clone::Clone, ::std::cmp::PartialEq, ::std::fmt::Debug)]
pub struct GreetingWithErrorsInput {}

#[non_exhaustive]
#[derive(::std::clone::Clone, ::std::cmp::PartialEq, ::std::fmt::Debug)]
pub struct EmptyInputAndEmptyOutputInput {}

#[non_exhaustive]
#[derive(::std::clone::Clone, ::std::cmp::PartialEq, ::std::fmt::Debug)]
pub struct NoInputAndOutputInput {}

#[non_exhaustive]
#[derive(::std::clone::Clone, ::std::cmp::PartialEq, ::std::fmt::Debug)]
pub struct NoInputAndNoOutputInput {}
