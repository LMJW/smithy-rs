// Code generated by software.amazon.smithy.rust.codegen.smithy-rs. DO NOT EDIT.
use crate::input::EmptyInputAndEmptyOutputInput;
use crate::input::GreetingWithErrorsInput;
use crate::input::JsonUnionsInput;
use crate::input::NoInputAndNoOutputInput;
use crate::input::NoInputAndOutputInput;
use crate::output::EmptyInputAndEmptyOutputOutput;
use crate::output::GreetingWithErrorsOutput;
use crate::output::JsonUnionsOutput;
use crate::output::NoInputAndNoOutputOutput;
use crate::output::NoInputAndOutputOutput;
use crate::serializer::GreetingWithErrorsOutputBody;
use crate::serializer::JsonUnionsOutputBody;
/// The example tests how requests and responses are serialized when there's
/// no request or response payload because the operation has an empty input
/// and empty output structure that reuses the same shape. While this should
/// be rare, code generators must support this.
pub struct EmptyInputAndEmptyOutput {
    input: EmptyInputAndEmptyOutputInput,
}
impl EmptyInputAndEmptyOutput {
    /// Creates a new builder-style object to manufacture [`EmptyInputAndEmptyOutputInput`](crate::input::EmptyInputAndEmptyOutputInput)
    pub fn builder() -> crate::input::empty_input_and_empty_output_input::Builder {
        crate::input::empty_input_and_empty_output_input::Builder::default()
    }
    pub fn build_http_request(&self) -> ::http::request::Request<Vec<u8>> {
        EmptyInputAndEmptyOutputInput::assemble(
            self.input.request_builder_base(),
            self.input.build_body(),
        )
    }
    fn from_response(
        response: ::http::response::Response<impl AsRef<[u8]>>,
    ) -> Result<EmptyInputAndEmptyOutputOutput, crate::error::EmptyInputAndEmptyOutputError> {
        if crate::error_code::is_error(&response) {
            let body: ::serde_json::Value = ::serde_json::from_slice(response.body().as_ref())
                .unwrap_or_else(|_| ::serde_json::json!({}));
            let error_code = crate::error_code::error_type_from_header(&response)
                .map_err(crate::error::EmptyInputAndEmptyOutputError::unhandled)?;
            let error_code = error_code.or_else(|| crate::error_code::error_type_from_body(&body));
            let error_code = error_code.ok_or_else(|| {
                crate::error::EmptyInputAndEmptyOutputError::unhandled("no error code".to_string())
            })?;
            let error_code = crate::error_code::sanitize_error_code(error_code);

            return Err(crate::error::EmptyInputAndEmptyOutputError::unhandled(
                error_code,
            ));
        }
        Ok(EmptyInputAndEmptyOutputOutput {})
    }
    pub fn parse_response(
        &self,
        response: ::http::response::Response<impl AsRef<[u8]>>,
    ) -> Result<EmptyInputAndEmptyOutputOutput, crate::error::EmptyInputAndEmptyOutputError> {
        Self::from_response(response)
    }
    pub fn new(input: EmptyInputAndEmptyOutputInput) -> Self {
        Self { input }
    }
}
#[cfg(test)]
#[allow(unreachable_code, unused_variables)]
mod empty_input_and_empty_output_request_test {

    use crate::input::EmptyInputAndEmptyOutputInput;
    use crate::operation::EmptyInputAndEmptyOutput;
    use crate::output::EmptyInputAndEmptyOutputOutput;
    /// Empty input serializes no payload
    /// Test ID: AwsJson10EmptyInputAndEmptyOutput
    #[test]
    fn aws_json10_empty_input_and_empty_output_request() {
        let input = EmptyInputAndEmptyOutputInput::builder().build();
        let http_request = input.build_http_request();

        assert_eq!(http_request.method(), "POST");
        assert_eq!(http_request.uri().path(), "/");

        let expected_headers = &[
            ("Content-Type", "application/x-amz-json-1.0"),
            ("X-Amz-Target", "JsonRpc10.EmptyInputAndEmptyOutput"),
        ];
        ::protocol_test_helpers::assert_ok(::protocol_test_helpers::validate_headers(
            &http_request,
            expected_headers,
        ));
        // No body
        assert!(&http_request.body().is_empty());
    }
    /// Empty output serializes no payload
    /// Test ID: AwsJson10EmptyInputAndEmptyOutput
    #[test]
    fn aws_json10_empty_input_and_empty_output_response() {
        let expected_output = EmptyInputAndEmptyOutputOutput::builder().build();
        let http_response = ::http::response::Builder::new()
            .header("Content-Type", "application/x-amz-json-1.0")
            .status(200)
            .body("")
            .unwrap();

        let parsed = EmptyInputAndEmptyOutput::from_response(http_response);
        assert_eq!(parsed.unwrap(), expected_output);
    }
    /// Empty output serializes no payload
    /// Test ID: AwsJson10EmptyInputAndEmptyJsonObjectOutput
    #[test]
    fn aws_json10_empty_input_and_empty_json_object_output_response() {
        let expected_output = EmptyInputAndEmptyOutputOutput::builder().build();
        let http_response = ::http::response::Builder::new()
            .header("Content-Type", "application/x-amz-json-1.0")
            .status(200)
            .body("{}")
            .unwrap();

        let parsed = EmptyInputAndEmptyOutput::from_response(http_response);
        assert_eq!(parsed.unwrap(), expected_output);
    }
}

/// This operation has three possible return values:
/// 1. A successful response in the form of GreetingWithErrorsOutput
/// 2. An InvalidGreeting error.
/// 3. A ComplexError error.
/// Implementations must be able to successfully take a response and
/// properly deserialize successful and error responses.
pub struct GreetingWithErrors {
    input: GreetingWithErrorsInput,
}
impl GreetingWithErrors {
    /// Creates a new builder-style object to manufacture [`GreetingWithErrorsInput`](crate::input::GreetingWithErrorsInput)
    pub fn builder() -> crate::input::greeting_with_errors_input::Builder {
        crate::input::greeting_with_errors_input::Builder::default()
    }
    pub fn build_http_request(&self) -> ::http::request::Request<Vec<u8>> {
        GreetingWithErrorsInput::assemble(
            self.input.request_builder_base(),
            self.input.build_body(),
        )
    }
    fn from_response(
        response: ::http::response::Response<impl AsRef<[u8]>>,
    ) -> Result<GreetingWithErrorsOutput, crate::error::GreetingWithErrorsError> {
        if crate::error_code::is_error(&response) {
            let body: ::serde_json::Value = ::serde_json::from_slice(response.body().as_ref())
                .unwrap_or_else(|_| ::serde_json::json!({}));
            let error_code = crate::error_code::error_type_from_header(&response)
                .map_err(crate::error::GreetingWithErrorsError::unhandled)?;
            let error_code = error_code.or_else(|| crate::error_code::error_type_from_body(&body));
            let error_code = error_code.ok_or_else(|| {
                crate::error::GreetingWithErrorsError::unhandled("no error code".to_string())
            })?;
            let error_code = crate::error_code::sanitize_error_code(error_code);

            return Err(match error_code {
                "InvalidGreeting" => match ::serde_json::from_value(body) {
                    Ok(body) => crate::error::GreetingWithErrorsError::InvalidGreeting(body),
                    Err(e) => crate::error::GreetingWithErrorsError::unhandled(e),
                },
                "ComplexError" => match ::serde_json::from_value(body) {
                    Ok(body) => crate::error::GreetingWithErrorsError::ComplexError(body),
                    Err(e) => crate::error::GreetingWithErrorsError::unhandled(e),
                },
                "FooError" => match ::serde_json::from_value(body) {
                    Ok(body) => crate::error::GreetingWithErrorsError::FooError(body),
                    Err(e) => crate::error::GreetingWithErrorsError::unhandled(e),
                },
                unknown => crate::error::GreetingWithErrorsError::unhandled(unknown),
            });
        }
        let body: GreetingWithErrorsOutputBody = ::serde_json::from_slice(response.body().as_ref())
            .map_err(crate::error::GreetingWithErrorsError::unhandled)?;
        Ok(GreetingWithErrorsOutput {
            greeting: body.greeting,
        })
    }
    pub fn parse_response(
        &self,
        response: ::http::response::Response<impl AsRef<[u8]>>,
    ) -> Result<GreetingWithErrorsOutput, crate::error::GreetingWithErrorsError> {
        Self::from_response(response)
    }
    pub fn new(input: GreetingWithErrorsInput) -> Self {
        Self { input }
    }
}
#[cfg(test)]
#[allow(unreachable_code, unused_variables)]
mod greeting_with_errors_request_test {

    use crate::error::ComplexError;
    use crate::error::FooError;
    use crate::error::InvalidGreeting;
    use crate::model::ComplexNestedErrorData;
    use crate::operation::GreetingWithErrors;
    /// Parses simple JSON errors
    /// Test ID: AwsJson10InvalidGreetingError
    #[test]
    fn aws_json10_invalid_greeting_error_response() {
        let expected_output = InvalidGreeting::builder().message("Hi".to_string()).build();
        let http_response = ::http::response::Builder::new()
            .header("Content-Type", "application/x-amz-json-1.0")
            .status(400)
            .body(
                "{
            \"__type\": \"aws.protocoltests.json10#InvalidGreeting\",
            \"Message\": \"Hi\"
        }",
            )
            .unwrap();

        let parsed = GreetingWithErrors::from_response(http_response);
        if let Err(crate::error::GreetingWithErrorsError::InvalidGreeting(actual_error)) = parsed {
            assert_eq!(expected_output, actual_error);
        } else {
            panic!("wrong variant: {:?}", parsed);
        }
    }
    /// Parses a complex error with no message member
    /// Test ID: AwsJson10ComplexError
    #[test]
    fn aws_json10_complex_error_response() {
        let expected_output = ComplexError::builder()
            .top_level("Top level".to_string())
            .nested(
                ComplexNestedErrorData::builder()
                    .foo("bar".to_string())
                    .build(),
            )
            .build();
        let http_response = ::http::response::Builder::new()
            .header("Content-Type", "application/x-amz-json-1.0")
            .status(400)
            .body(
                "{
            \"__type\": \"aws.protocoltests.json10#ComplexError\",
            \"TopLevel\": \"Top level\",
            \"Nested\": {
                \"Fooooo\": \"bar\"
            }
        }",
            )
            .unwrap();

        let parsed = GreetingWithErrors::from_response(http_response);
        if let Err(crate::error::GreetingWithErrorsError::ComplexError(actual_error)) = parsed {
            assert_eq!(expected_output, actual_error);
        } else {
            panic!("wrong variant: {:?}", parsed);
        }
    }
    /// Parses a complex error with an empty body
    /// Test ID: AwsJson10EmptyComplexError
    #[test]
    fn aws_json10_empty_complex_error_response() {
        let expected_output = ComplexError::builder().build();
        let http_response = ::http::response::Builder::new()
            .header("Content-Type", "application/x-amz-json-1.0")
            .status(400)
            .body(
                "{
            \"__type\": \"aws.protocoltests.json10#ComplexError\"
        }",
            )
            .unwrap();

        let parsed = GreetingWithErrors::from_response(http_response);
        if let Err(crate::error::GreetingWithErrorsError::ComplexError(actual_error)) = parsed {
            assert_eq!(expected_output, actual_error);
        } else {
            panic!("wrong variant: {:?}", parsed);
        }
    }
    /// Serializes the X-Amzn-ErrorType header. For an example service, see Amazon EKS.
    /// Test ID: AwsJson10FooErrorUsingXAmznErrorType
    #[test]
    fn aws_json10_foo_error_using_x_amzn_error_type_response() {
        let expected_output = FooError::builder().build();
        let http_response = ::http::response::Builder::new()
            .header("X-Amzn-Errortype", "FooError")
            .status(500)
            .body(vec![])
            .unwrap();

        let parsed = GreetingWithErrors::from_response(http_response);
        if let Err(crate::error::GreetingWithErrorsError::FooError(actual_error)) = parsed {
            assert_eq!(expected_output, actual_error);
        } else {
            panic!("wrong variant: {:?}", parsed);
        }
    }
    /// Some X-Amzn-Errortype headers contain URLs. Clients need to split the URL on ':' and take only the first half of the string. For example, 'ValidationException:http://internal.amazon.com/coral/com.amazon.coral.validate/'
    /// is to be interpreted as 'ValidationException'.
    ///
    /// For an example service see Amazon Polly.
    /// Test ID: AwsJson10FooErrorUsingXAmznErrorTypeWithUri
    #[test]
    fn aws_json10_foo_error_using_x_amzn_error_type_with_uri_response() {
        let expected_output = FooError::builder().build();
        let http_response = ::http::response::Builder::new()
            .header(
                "X-Amzn-Errortype",
                "FooError:http://internal.amazon.com/coral/com.amazon.coral.validate/",
            )
            .status(500)
            .body(vec![])
            .unwrap();

        let parsed = GreetingWithErrors::from_response(http_response);
        if let Err(crate::error::GreetingWithErrorsError::FooError(actual_error)) = parsed {
            assert_eq!(expected_output, actual_error);
        } else {
            panic!("wrong variant: {:?}", parsed);
        }
    }
    /// X-Amzn-Errortype might contain a URL and a namespace. Client should extract only the shape name. This is a pathalogical case that might not actually happen in any deployed AWS service.
    /// Test ID: AwsJson10FooErrorUsingXAmznErrorTypeWithUriAndNamespace
    #[test]
    fn aws_json10_foo_error_using_x_amzn_error_type_with_uri_and_namespace_response() {
        let expected_output = FooError::builder().build();
        let http_response = ::http::response::Builder::new()
        .header("X-Amzn-Errortype", "aws.protocoltests.json10#FooError:http://internal.amazon.com/coral/com.amazon.coral.validate/")
        
                        .status(500)
                        .body(vec![])
                        .unwrap();

        let parsed = GreetingWithErrors::from_response(http_response);
        if let Err(crate::error::GreetingWithErrorsError::FooError(actual_error)) = parsed {
            assert_eq!(expected_output, actual_error);
        } else {
            panic!("wrong variant: {:?}", parsed);
        }
    }
    /// This example uses the 'code' property in the output rather than X-Amzn-Errortype. Some services do this though it's preferable to send the X-Amzn-Errortype. Client implementations must first check for the X-Amzn-Errortype and then check for a top-level 'code' property.
    ///
    /// For example service see Amazon S3 Glacier.
    /// Test ID: AwsJson10FooErrorUsingCode
    #[test]
    fn aws_json10_foo_error_using_code_response() {
        let expected_output = FooError::builder().build();
        let http_response = ::http::response::Builder::new()
            .header("Content-Type", "application/x-amz-json-1.0")
            .status(500)
            .body(
                "{
            \"code\": \"FooError\"
        }",
            )
            .unwrap();

        let parsed = GreetingWithErrors::from_response(http_response);
        if let Err(crate::error::GreetingWithErrorsError::FooError(actual_error)) = parsed {
            assert_eq!(expected_output, actual_error);
        } else {
            panic!("wrong variant: {:?}", parsed);
        }
    }
    /// Some services serialize errors using code, and it might contain a namespace. Clients should just take the last part of the string after '#'.
    /// Test ID: AwsJson10FooErrorUsingCodeAndNamespace
    #[test]
    fn aws_json10_foo_error_using_code_and_namespace_response() {
        let expected_output = FooError::builder().build();
        let http_response = ::http::response::Builder::new()
            .header("Content-Type", "application/x-amz-json-1.0")
            .status(500)
            .body(
                "{
            \"code\": \"aws.protocoltests.json10#FooError\"
        }",
            )
            .unwrap();

        let parsed = GreetingWithErrors::from_response(http_response);
        if let Err(crate::error::GreetingWithErrorsError::FooError(actual_error)) = parsed {
            assert_eq!(expected_output, actual_error);
        } else {
            panic!("wrong variant: {:?}", parsed);
        }
    }
    /// Some services serialize errors using code, and it might contain a namespace. It also might contain a URI. Clients should just take the last part of the string after '#' and before ":". This is a pathalogical case that might not occur in any deployed AWS service.
    /// Test ID: AwsJson10FooErrorUsingCodeUriAndNamespace
    #[test]
    fn aws_json10_foo_error_using_code_uri_and_namespace_response() {
        let expected_output = FooError::builder().build();
        let http_response = ::http::response::Builder::new()
        .header("Content-Type", "application/x-amz-json-1.0")
        
                        .status(500)
                        .body("{
            \"code\": \"aws.protocoltests.json10#FooError:http://internal.amazon.com/coral/com.amazon.coral.validate/\"
        }")
                        .unwrap();

        let parsed = GreetingWithErrors::from_response(http_response);
        if let Err(crate::error::GreetingWithErrorsError::FooError(actual_error)) = parsed {
            assert_eq!(expected_output, actual_error);
        } else {
            panic!("wrong variant: {:?}", parsed);
        }
    }
    /// Some services serialize errors using __type.
    /// Test ID: AwsJson10FooErrorWithDunderType
    #[test]
    fn aws_json10_foo_error_with_dunder_type_response() {
        let expected_output = FooError::builder().build();
        let http_response = ::http::response::Builder::new()
            .header("Content-Type", "application/x-amz-json-1.0")
            .status(500)
            .body(
                "{
            \"__type\": \"FooError\"
        }",
            )
            .unwrap();

        let parsed = GreetingWithErrors::from_response(http_response);
        if let Err(crate::error::GreetingWithErrorsError::FooError(actual_error)) = parsed {
            assert_eq!(expected_output, actual_error);
        } else {
            panic!("wrong variant: {:?}", parsed);
        }
    }
    /// Some services serialize errors using __type, and it might contain a namespace. Clients should just take the last part of the string after '#'.
    /// Test ID: AwsJson10FooErrorWithDunderTypeAndNamespace
    #[test]
    fn aws_json10_foo_error_with_dunder_type_and_namespace_response() {
        let expected_output = FooError::builder().build();
        let http_response = ::http::response::Builder::new()
            .header("Content-Type", "application/x-amz-json-1.0")
            .status(500)
            .body(
                "{
            \"__type\": \"aws.protocoltests.json10#FooError\"
        }",
            )
            .unwrap();

        let parsed = GreetingWithErrors::from_response(http_response);
        if let Err(crate::error::GreetingWithErrorsError::FooError(actual_error)) = parsed {
            assert_eq!(expected_output, actual_error);
        } else {
            panic!("wrong variant: {:?}", parsed);
        }
    }
    /// Some services serialize errors using __type, and it might contain a namespace. It also might contain a URI. Clients should just take the last part of the string after '#' and before ":". This is a pathalogical case that might not occur in any deployed AWS service.
    /// Test ID: AwsJson10FooErrorWithDunderTypeUriAndNamespace
    #[test]
    fn aws_json10_foo_error_with_dunder_type_uri_and_namespace_response() {
        let expected_output = FooError::builder().build();
        let http_response = ::http::response::Builder::new()
        .header("Content-Type", "application/x-amz-json-1.0")
        
                        .status(500)
                        .body("{
            \"__type\": \"aws.protocoltests.json10#FooError:http://internal.amazon.com/coral/com.amazon.coral.validate/\"
        }")
                        .unwrap();

        let parsed = GreetingWithErrors::from_response(http_response);
        if let Err(crate::error::GreetingWithErrorsError::FooError(actual_error)) = parsed {
            assert_eq!(expected_output, actual_error);
        } else {
            panic!("wrong variant: {:?}", parsed);
        }
    }
}

/// This operation uses unions for inputs and outputs.
pub struct JsonUnions {
    input: JsonUnionsInput,
}
impl JsonUnions {
    /// Creates a new builder-style object to manufacture [`JsonUnionsInput`](crate::input::JsonUnionsInput)
    pub fn builder() -> crate::input::json_unions_input::Builder {
        crate::input::json_unions_input::Builder::default()
    }
    pub fn build_http_request(&self) -> ::http::request::Request<Vec<u8>> {
        JsonUnionsInput::assemble(self.input.request_builder_base(), self.input.build_body())
    }
    fn from_response(
        response: ::http::response::Response<impl AsRef<[u8]>>,
    ) -> Result<JsonUnionsOutput, crate::error::JsonUnionsError> {
        if crate::error_code::is_error(&response) {
            let body: ::serde_json::Value = ::serde_json::from_slice(response.body().as_ref())
                .unwrap_or_else(|_| ::serde_json::json!({}));
            let error_code = crate::error_code::error_type_from_header(&response)
                .map_err(crate::error::JsonUnionsError::unhandled)?;
            let error_code = error_code.or_else(|| crate::error_code::error_type_from_body(&body));
            let error_code = error_code.ok_or_else(|| {
                crate::error::JsonUnionsError::unhandled("no error code".to_string())
            })?;
            let error_code = crate::error_code::sanitize_error_code(error_code);

            return Err(crate::error::JsonUnionsError::unhandled(error_code));
        }
        let body: JsonUnionsOutputBody = ::serde_json::from_slice(response.body().as_ref())
            .map_err(crate::error::JsonUnionsError::unhandled)?;
        Ok(JsonUnionsOutput {
            contents: body.contents,
        })
    }
    pub fn parse_response(
        &self,
        response: ::http::response::Response<impl AsRef<[u8]>>,
    ) -> Result<JsonUnionsOutput, crate::error::JsonUnionsError> {
        Self::from_response(response)
    }
    pub fn new(input: JsonUnionsInput) -> Self {
        Self { input }
    }
}
#[cfg(test)]
#[allow(unreachable_code, unused_variables)]
mod json_unions_request_test {

    use crate::input::JsonUnionsInput;
    use crate::model::FooEnum;
    use crate::model::GreetingStruct;
    use crate::model::MyUnion;
    use crate::operation::JsonUnions;
    use crate::output::JsonUnionsOutput;
    /// Serializes a string union value
    /// Test ID: AwsJson10SerializeStringUnionValue
    #[test]
    fn aws_json10_serialize_string_union_value_request() {
        let input = JsonUnionsInput::builder()
            .contents(MyUnion::StringValue("foo".to_string()))
            .build();
        let http_request = input.build_http_request();

        assert_eq!(http_request.method(), "POST");
        assert_eq!(http_request.uri().path(), "/");

        let expected_headers = &[
            ("Content-Type", "application/x-amz-json-1.0"),
            ("X-Amz-Target", "JsonRpc10.JsonUnions"),
        ];
        ::protocol_test_helpers::assert_ok(::protocol_test_helpers::validate_headers(
            &http_request,
            expected_headers,
        ));
        ::protocol_test_helpers::assert_ok(::protocol_test_helpers::validate_body(
            &http_request.body(),
            "{
            \"contents\": {
                \"stringValue\": \"foo\"
            }
        }",
            ::protocol_test_helpers::MediaType::from("application/json"),
        ));
    }
    /// Serializes a boolean union value
    /// Test ID: AwsJson10SerializeBooleanUnionValue
    #[test]
    fn aws_json10_serialize_boolean_union_value_request() {
        let input = JsonUnionsInput::builder()
            .contents(MyUnion::BooleanValue(true))
            .build();
        let http_request = input.build_http_request();

        assert_eq!(http_request.method(), "POST");
        assert_eq!(http_request.uri().path(), "/");

        let expected_headers = &[
            ("Content-Type", "application/x-amz-json-1.0"),
            ("X-Amz-Target", "JsonRpc10.JsonUnions"),
        ];
        ::protocol_test_helpers::assert_ok(::protocol_test_helpers::validate_headers(
            &http_request,
            expected_headers,
        ));
        ::protocol_test_helpers::assert_ok(::protocol_test_helpers::validate_body(
            &http_request.body(),
            "{
            \"contents\": {
                \"booleanValue\": true
            }
        }",
            ::protocol_test_helpers::MediaType::from("application/json"),
        ));
    }
    /// Serializes a number union value
    /// Test ID: AwsJson10SerializeNumberUnionValue
    #[test]
    fn aws_json10_serialize_number_union_value_request() {
        let input = JsonUnionsInput::builder()
            .contents(MyUnion::NumberValue(1))
            .build();
        let http_request = input.build_http_request();

        assert_eq!(http_request.method(), "POST");
        assert_eq!(http_request.uri().path(), "/");

        let expected_headers = &[
            ("Content-Type", "application/x-amz-json-1.0"),
            ("X-Amz-Target", "JsonRpc10.JsonUnions"),
        ];
        ::protocol_test_helpers::assert_ok(::protocol_test_helpers::validate_headers(
            &http_request,
            expected_headers,
        ));
        ::protocol_test_helpers::assert_ok(::protocol_test_helpers::validate_body(
            &http_request.body(),
            "{
            \"contents\": {
                \"numberValue\": 1
            }
        }",
            ::protocol_test_helpers::MediaType::from("application/json"),
        ));
    }
    /// Serializes a blob union value
    /// Test ID: AwsJson10SerializeBlobUnionValue
    #[test]
    fn aws_json10_serialize_blob_union_value_request() {
        let input = JsonUnionsInput::builder()
            .contents(MyUnion::BlobValue(::smithy_types::Blob::new("foo")))
            .build();
        let http_request = input.build_http_request();

        assert_eq!(http_request.method(), "POST");
        assert_eq!(http_request.uri().path(), "/");

        let expected_headers = &[
            ("Content-Type", "application/x-amz-json-1.0"),
            ("X-Amz-Target", "JsonRpc10.JsonUnions"),
        ];
        ::protocol_test_helpers::assert_ok(::protocol_test_helpers::validate_headers(
            &http_request,
            expected_headers,
        ));
        ::protocol_test_helpers::assert_ok(::protocol_test_helpers::validate_body(
            &http_request.body(),
            "{
            \"contents\": {
                \"blobValue\": \"Zm9v\"
            }
        }",
            ::protocol_test_helpers::MediaType::from("application/json"),
        ));
    }
    /// Serializes a timestamp union value
    /// Test ID: AwsJson10SerializeTimestampUnionValue
    #[test]
    fn aws_json10_serialize_timestamp_union_value_request() {
        let input = JsonUnionsInput::builder()
            .contents(MyUnion::TimestampValue(
                ::smithy_types::Instant::from_epoch_seconds(1398796238),
            ))
            .build();
        let http_request = input.build_http_request();

        assert_eq!(http_request.method(), "POST");
        assert_eq!(http_request.uri().path(), "/");

        let expected_headers = &[
            ("Content-Type", "application/x-amz-json-1.0"),
            ("X-Amz-Target", "JsonRpc10.JsonUnions"),
        ];
        ::protocol_test_helpers::assert_ok(::protocol_test_helpers::validate_headers(
            &http_request,
            expected_headers,
        ));
        ::protocol_test_helpers::assert_ok(::protocol_test_helpers::validate_body(
            &http_request.body(),
            "{
            \"contents\": {
                \"timestampValue\": 1398796238
            }
        }",
            ::protocol_test_helpers::MediaType::from("application/json"),
        ));
    }
    /// Serializes an enum union value
    /// Test ID: AwsJson10SerializeEnumUnionValue
    #[test]
    fn aws_json10_serialize_enum_union_value_request() {
        let input = JsonUnionsInput::builder()
            .contents(MyUnion::EnumValue(FooEnum::from("Foo")))
            .build();
        let http_request = input.build_http_request();

        assert_eq!(http_request.method(), "POST");
        assert_eq!(http_request.uri().path(), "/");

        let expected_headers = &[
            ("Content-Type", "application/x-amz-json-1.0"),
            ("X-Amz-Target", "JsonRpc10.JsonUnions"),
        ];
        ::protocol_test_helpers::assert_ok(::protocol_test_helpers::validate_headers(
            &http_request,
            expected_headers,
        ));
        ::protocol_test_helpers::assert_ok(::protocol_test_helpers::validate_body(
            &http_request.body(),
            "{
            \"contents\": {
                \"enumValue\": \"Foo\"
            }
        }",
            ::protocol_test_helpers::MediaType::from("application/json"),
        ));
    }
    /// Serializes a list union value
    /// Test ID: AwsJson10SerializeListUnionValue
    #[test]
    fn aws_json10_serialize_list_union_value_request() {
        let input = JsonUnionsInput::builder()
            .contents(MyUnion::ListValue(vec![
                "foo".to_string(),
                "bar".to_string(),
            ]))
            .build();
        let http_request = input.build_http_request();

        assert_eq!(http_request.method(), "POST");
        assert_eq!(http_request.uri().path(), "/");

        let expected_headers = &[
            ("Content-Type", "application/x-amz-json-1.0"),
            ("X-Amz-Target", "JsonRpc10.JsonUnions"),
        ];
        ::protocol_test_helpers::assert_ok(::protocol_test_helpers::validate_headers(
            &http_request,
            expected_headers,
        ));
        ::protocol_test_helpers::assert_ok(::protocol_test_helpers::validate_body(
            &http_request.body(),
            "{
            \"contents\": {
                \"listValue\": [\"foo\", \"bar\"]
            }
        }",
            ::protocol_test_helpers::MediaType::from("application/json"),
        ));
    }
    /// Serializes a map union value
    /// Test ID: AwsJson10SerializeMapUnionValue
    #[test]
    fn aws_json10_serialize_map_union_value_request() {
        let input = JsonUnionsInput::builder()
            .contents(MyUnion::MapValue({
                let mut ret = ::std::collections::HashMap::new();
                ret.insert("foo".to_string(), "bar".to_string());
                ret.insert("spam".to_string(), "eggs".to_string());
                ret
            }))
            .build();
        let http_request = input.build_http_request();

        assert_eq!(http_request.method(), "POST");
        assert_eq!(http_request.uri().path(), "/");

        let expected_headers = &[
            ("Content-Type", "application/x-amz-json-1.0"),
            ("X-Amz-Target", "JsonRpc10.JsonUnions"),
        ];
        ::protocol_test_helpers::assert_ok(::protocol_test_helpers::validate_headers(
            &http_request,
            expected_headers,
        ));
        ::protocol_test_helpers::assert_ok(::protocol_test_helpers::validate_body(
            &http_request.body(),
            "{
            \"contents\": {
                \"mapValue\": {
                    \"foo\": \"bar\",
                    \"spam\": \"eggs\"
                }
            }
        }",
            ::protocol_test_helpers::MediaType::from("application/json"),
        ));
    }
    /// Serializes a structure union value
    /// Test ID: AwsJson10SerializeStructureUnionValue
    #[test]
    fn aws_json10_serialize_structure_union_value_request() {
        let input = JsonUnionsInput::builder()
            .contents(MyUnion::StructureValue(
                GreetingStruct::builder().hi("hello".to_string()).build(),
            ))
            .build();
        let http_request = input.build_http_request();

        assert_eq!(http_request.method(), "POST");
        assert_eq!(http_request.uri().path(), "/");

        let expected_headers = &[
            ("Content-Type", "application/x-amz-json-1.0"),
            ("X-Amz-Target", "JsonRpc10.JsonUnions"),
        ];
        ::protocol_test_helpers::assert_ok(::protocol_test_helpers::validate_headers(
            &http_request,
            expected_headers,
        ));
        ::protocol_test_helpers::assert_ok(::protocol_test_helpers::validate_body(
            &http_request.body(),
            "{
            \"contents\": {
                \"structureValue\": {
                    \"hi\": \"hello\"
                }
            }
        }",
            ::protocol_test_helpers::MediaType::from("application/json"),
        ));
    }
    /// Deserializes a string union value
    /// Test ID: AwsJson10DeserializeStringUnionValue
    #[test]
    fn aws_json10_deserialize_string_union_value_response() {
        let expected_output = JsonUnionsOutput::builder()
            .contents(MyUnion::StringValue("foo".to_string()))
            .build();
        let http_response = ::http::response::Builder::new()
            .header("Content-Type", "application/x-amz-json-1.0")
            .status(200)
            .body(
                "{
            \"contents\": {
                \"stringValue\": \"foo\"
            }
        }",
            )
            .unwrap();

        let parsed = JsonUnions::from_response(http_response);
        assert_eq!(parsed.unwrap(), expected_output);
    }
    /// Deserializes a boolean union value
    /// Test ID: AwsJson10DeserializeBooleanUnionValue
    #[test]
    fn aws_json10_deserialize_boolean_union_value_response() {
        let expected_output = JsonUnionsOutput::builder()
            .contents(MyUnion::BooleanValue(true))
            .build();
        let http_response = ::http::response::Builder::new()
            .header("Content-Type", "application/x-amz-json-1.0")
            .status(200)
            .body(
                "{
            \"contents\": {
                \"booleanValue\": true
            }
        }",
            )
            .unwrap();

        let parsed = JsonUnions::from_response(http_response);
        assert_eq!(parsed.unwrap(), expected_output);
    }
    /// Deserializes a number union value
    /// Test ID: AwsJson10DeserializeNumberUnionValue
    #[test]
    fn aws_json10_deserialize_number_union_value_response() {
        let expected_output = JsonUnionsOutput::builder()
            .contents(MyUnion::NumberValue(1))
            .build();
        let http_response = ::http::response::Builder::new()
            .header("Content-Type", "application/x-amz-json-1.0")
            .status(200)
            .body(
                "{
            \"contents\": {
                \"numberValue\": 1
            }
        }",
            )
            .unwrap();

        let parsed = JsonUnions::from_response(http_response);
        assert_eq!(parsed.unwrap(), expected_output);
    }
    /// Deserializes a blob union value
    /// Test ID: AwsJson10DeserializeBlobUnionValue
    #[test]
    fn aws_json10_deserialize_blob_union_value_response() {
        let expected_output = JsonUnionsOutput::builder()
            .contents(MyUnion::BlobValue(::smithy_types::Blob::new("foo")))
            .build();
        let http_response = ::http::response::Builder::new()
            .header("Content-Type", "application/x-amz-json-1.0")
            .status(200)
            .body(
                "{
            \"contents\": {
                \"blobValue\": \"Zm9v\"
            }
        }",
            )
            .unwrap();

        let parsed = JsonUnions::from_response(http_response);
        assert_eq!(parsed.unwrap(), expected_output);
    }
    /// Deserializes a timestamp union value
    /// Test ID: AwsJson10DeserializeTimestampUnionValue
    #[test]
    fn aws_json10_deserialize_timestamp_union_value_response() {
        let expected_output = JsonUnionsOutput::builder()
            .contents(MyUnion::TimestampValue(
                ::smithy_types::Instant::from_epoch_seconds(1398796238),
            ))
            .build();
        let http_response = ::http::response::Builder::new()
            .header("Content-Type", "application/x-amz-json-1.0")
            .status(200)
            .body(
                "{
            \"contents\": {
                \"timestampValue\": 1398796238
            }
        }",
            )
            .unwrap();

        let parsed = JsonUnions::from_response(http_response);
        assert_eq!(parsed.unwrap(), expected_output);
    }
    /// Deserializes an enum union value
    /// Test ID: AwsJson10DeserializeEnumUnionValue
    #[test]
    fn aws_json10_deserialize_enum_union_value_response() {
        let expected_output = JsonUnionsOutput::builder()
            .contents(MyUnion::EnumValue(FooEnum::from("Foo")))
            .build();
        let http_response = ::http::response::Builder::new()
            .header("Content-Type", "application/x-amz-json-1.0")
            .status(200)
            .body(
                "{
            \"contents\": {
                \"enumValue\": \"Foo\"
            }
        }",
            )
            .unwrap();

        let parsed = JsonUnions::from_response(http_response);
        assert_eq!(parsed.unwrap(), expected_output);
    }
    /// Deserializes a list union value
    /// Test ID: AwsJson10DeserializeListUnionValue
    #[test]
    fn aws_json10_deserialize_list_union_value_response() {
        let expected_output = JsonUnionsOutput::builder()
            .contents(MyUnion::ListValue(vec![
                "foo".to_string(),
                "bar".to_string(),
            ]))
            .build();
        let http_response = ::http::response::Builder::new()
            .header("Content-Type", "application/x-amz-json-1.0")
            .status(200)
            .body(
                "{
            \"contents\": {
                \"listValue\": [\"foo\", \"bar\"]
            }
        }",
            )
            .unwrap();

        let parsed = JsonUnions::from_response(http_response);
        assert_eq!(parsed.unwrap(), expected_output);
    }
    /// Deserializes a map union value
    /// Test ID: AwsJson10DeserializeMapUnionValue
    #[test]
    fn aws_json10_deserialize_map_union_value_response() {
        let expected_output = JsonUnionsOutput::builder()
            .contents(MyUnion::MapValue({
                let mut ret = ::std::collections::HashMap::new();
                ret.insert("foo".to_string(), "bar".to_string());
                ret.insert("spam".to_string(), "eggs".to_string());
                ret
            }))
            .build();
        let http_response = ::http::response::Builder::new()
            .header("Content-Type", "application/x-amz-json-1.0")
            .status(200)
            .body(
                "{
            \"contents\": {
                \"mapValue\": {
                    \"foo\": \"bar\",
                    \"spam\": \"eggs\"
                }
            }
        }",
            )
            .unwrap();

        let parsed = JsonUnions::from_response(http_response);
        assert_eq!(parsed.unwrap(), expected_output);
    }
    /// Deserializes a structure union value
    /// Test ID: AwsJson10DeserializeStructureUnionValue
    #[test]
    fn aws_json10_deserialize_structure_union_value_response() {
        let expected_output = JsonUnionsOutput::builder()
            .contents(MyUnion::StructureValue(
                GreetingStruct::builder().hi("hello".to_string()).build(),
            ))
            .build();
        let http_response = ::http::response::Builder::new()
            .header("Content-Type", "application/x-amz-json-1.0")
            .status(200)
            .body(
                "{
            \"contents\": {
                \"structureValue\": {
                    \"hi\": \"hello\"
                }
            }
        }",
            )
            .unwrap();

        let parsed = JsonUnions::from_response(http_response);
        assert_eq!(parsed.unwrap(), expected_output);
    }
}

/// The example tests how requests and responses are serialized when there's
/// no request or response payload because the operation has no input or output.
/// While this should be rare, code generators must support this.
pub struct NoInputAndNoOutput {
    input: NoInputAndNoOutputInput,
}
impl NoInputAndNoOutput {
    /// Creates a new builder-style object to manufacture [`NoInputAndNoOutputInput`](crate::input::NoInputAndNoOutputInput)
    pub fn builder() -> crate::input::no_input_and_no_output_input::Builder {
        crate::input::no_input_and_no_output_input::Builder::default()
    }
    pub fn build_http_request(&self) -> ::http::request::Request<Vec<u8>> {
        NoInputAndNoOutputInput::assemble(
            self.input.request_builder_base(),
            self.input.build_body(),
        )
    }
    fn from_response(
        response: ::http::response::Response<impl AsRef<[u8]>>,
    ) -> Result<NoInputAndNoOutputOutput, crate::error::NoInputAndNoOutputError> {
        if crate::error_code::is_error(&response) {
            let body: ::serde_json::Value = ::serde_json::from_slice(response.body().as_ref())
                .unwrap_or_else(|_| ::serde_json::json!({}));
            let error_code = crate::error_code::error_type_from_header(&response)
                .map_err(crate::error::NoInputAndNoOutputError::unhandled)?;
            let error_code = error_code.or_else(|| crate::error_code::error_type_from_body(&body));
            let error_code = error_code.ok_or_else(|| {
                crate::error::NoInputAndNoOutputError::unhandled("no error code".to_string())
            })?;
            let error_code = crate::error_code::sanitize_error_code(error_code);

            return Err(crate::error::NoInputAndNoOutputError::unhandled(error_code));
        }
        Ok(NoInputAndNoOutputOutput {})
    }
    pub fn parse_response(
        &self,
        response: ::http::response::Response<impl AsRef<[u8]>>,
    ) -> Result<NoInputAndNoOutputOutput, crate::error::NoInputAndNoOutputError> {
        Self::from_response(response)
    }
    pub fn new(input: NoInputAndNoOutputInput) -> Self {
        Self { input }
    }
}
#[cfg(test)]
#[allow(unreachable_code, unused_variables)]
mod no_input_and_no_output_request_test {

    use crate::input::NoInputAndNoOutputInput;
    use crate::operation::NoInputAndNoOutput;
    use crate::output::NoInputAndNoOutputOutput;
    /// No input serializes no payload
    /// Test ID: AwsJson10NoInputAndNoOutput
    #[test]
    fn aws_json10_no_input_and_no_output_request() {
        let input = NoInputAndNoOutputInput::builder().build();
        let http_request = input.build_http_request();

        assert_eq!(http_request.method(), "POST");
        assert_eq!(http_request.uri().path(), "/");

        let expected_headers = &[
            ("Content-Type", "application/x-amz-json-1.0"),
            ("X-Amz-Target", "JsonRpc10.NoInputAndNoOutput"),
        ];
        ::protocol_test_helpers::assert_ok(::protocol_test_helpers::validate_headers(
            &http_request,
            expected_headers,
        ));
        // No body
        assert!(&http_request.body().is_empty());
    }
    /// No output serializes no payload
    /// Test ID: AwsJson10NoInputAndNoOutput
    #[test]
    fn aws_json10_no_input_and_no_output_response() {
        let expected_output = NoInputAndNoOutputOutput::builder().build();
        let http_response = ::http::response::Builder::new()
            .header("Content-Type", "application/x-amz-json-1.0")
            .status(200)
            .body(vec![])
            .unwrap();

        let parsed = NoInputAndNoOutput::from_response(http_response);
        assert_eq!(parsed.unwrap(), expected_output);
    }
}

/// The example tests how requests and responses are serialized when there's
/// no request or response payload because the operation has no input and the
/// output is empty. While this should be rare, code generators must support
/// this.
pub struct NoInputAndOutput {
    input: NoInputAndOutputInput,
}
impl NoInputAndOutput {
    /// Creates a new builder-style object to manufacture [`NoInputAndOutputInput`](crate::input::NoInputAndOutputInput)
    pub fn builder() -> crate::input::no_input_and_output_input::Builder {
        crate::input::no_input_and_output_input::Builder::default()
    }
    pub fn build_http_request(&self) -> ::http::request::Request<Vec<u8>> {
        NoInputAndOutputInput::assemble(self.input.request_builder_base(), self.input.build_body())
    }
    fn from_response(
        response: ::http::response::Response<impl AsRef<[u8]>>,
    ) -> Result<NoInputAndOutputOutput, crate::error::NoInputAndOutputError> {
        if crate::error_code::is_error(&response) {
            let body: ::serde_json::Value = ::serde_json::from_slice(response.body().as_ref())
                .unwrap_or_else(|_| ::serde_json::json!({}));
            let error_code = crate::error_code::error_type_from_header(&response)
                .map_err(crate::error::NoInputAndOutputError::unhandled)?;
            let error_code = error_code.or_else(|| crate::error_code::error_type_from_body(&body));
            let error_code = error_code.ok_or_else(|| {
                crate::error::NoInputAndOutputError::unhandled("no error code".to_string())
            })?;
            let error_code = crate::error_code::sanitize_error_code(error_code);

            return Err(crate::error::NoInputAndOutputError::unhandled(error_code));
        }
        Ok(NoInputAndOutputOutput {})
    }
    pub fn parse_response(
        &self,
        response: ::http::response::Response<impl AsRef<[u8]>>,
    ) -> Result<NoInputAndOutputOutput, crate::error::NoInputAndOutputError> {
        Self::from_response(response)
    }
    pub fn new(input: NoInputAndOutputInput) -> Self {
        Self { input }
    }
}
#[cfg(test)]
#[allow(unreachable_code, unused_variables)]
mod no_input_and_output_request_test {

    use crate::input::NoInputAndOutputInput;
    use crate::operation::NoInputAndOutput;
    use crate::output::NoInputAndOutputOutput;
    /// No input serializes no payload
    /// Test ID: AwsJson10NoInputAndOutput
    #[test]
    fn aws_json10_no_input_and_output_request() {
        let input = NoInputAndOutputInput::builder().build();
        let http_request = input.build_http_request();

        assert_eq!(http_request.method(), "POST");
        assert_eq!(http_request.uri().path(), "/");

        let expected_headers = &[
            ("Content-Type", "application/x-amz-json-1.0"),
            ("X-Amz-Target", "JsonRpc10.NoInputAndOutput"),
        ];
        ::protocol_test_helpers::assert_ok(::protocol_test_helpers::validate_headers(
            &http_request,
            expected_headers,
        ));
        // No body
        assert!(&http_request.body().is_empty());
    }
    /// Empty output serializes no payload
    /// Test ID: AwsJson10NoInputAndOutput
    #[test]
    fn aws_json10_no_input_and_output_response() {
        let expected_output = NoInputAndOutputOutput::builder().build();
        let http_response = ::http::response::Builder::new()
            .header("Content-Type", "application/x-amz-json-1.0")
            .status(200)
            .body(vec![])
            .unwrap();

        let parsed = NoInputAndOutput::from_response(http_response);
        assert_eq!(parsed.unwrap(), expected_output);
    }
}
