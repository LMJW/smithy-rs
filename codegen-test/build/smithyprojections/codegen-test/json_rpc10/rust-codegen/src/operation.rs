// Code generated by software.amazon.smithy.rust.codegen.smithy-rs. DO NOT EDIT.
use crate::model::MyUnion;
use crate::serializer::JsonUnionsInputBody;
impl EmptyInputAndEmptyOutputInput {
    pub fn request_builder_base(&self) -> ::http::request::Builder {
        let builder = ::http::request::Builder::new();
        builder
            .method("POST")
            .header("Content-Type", "application/x-amz-json-1.0")
            .header("X-Amz-Target", "JsonRpc10.EmptyInputAndEmptyOutput")
    }
    pub fn build_body(&self) -> ::std::vec::Vec<u8> {
        vec![]
    }
    pub fn assemble(
        builder: ::http::request::Builder,
        body: ::std::vec::Vec<u8>,
    ) -> ::http::request::Request<::std::vec::Vec<u8>> {
        builder
            .header(::http::header::CONTENT_LENGTH, body.len())
            .body(body)
            .expect("http request should be valid")
    }
}
#[cfg(test)]
#[allow(unreachable_code, unused_variables)]
mod empty_input_and_empty_output_request_test {

    use crate::operation::EmptyInputAndEmptyOutputInput;
    /// Empty input serializes no payload
    /// Test ID: AwsJson10EmptyInputAndEmptyOutput
    #[test]
    fn test_aws_json10_empty_input_and_empty_output_request() {
        let input = EmptyInputAndEmptyOutputInput::builder().build();
        let http_request = EmptyInputAndEmptyOutputInput::assemble(
            input.request_builder_base(),
            input.build_body(),
        );

        assert_eq!(http_request.method(), "POST");
        assert_eq!(http_request.uri().path(), "/");

        let expected_headers = &[
            ("Content-Type", "application/x-amz-json-1.0"),
            ("X-Amz-Target", "JsonRpc10.EmptyInputAndEmptyOutput"),
        ];
        ::protocol_test_helpers::assert_ok(::protocol_test_helpers::validate_headers(
            &http_request,
            expected_headers,
        ));
        // No body
        assert!(input.build_body().is_empty());
    }
    /// Empty output serializes no payload
    /// Test ID: AwsJson10EmptyInputAndEmptyOutput
    #[test]
    fn test_aws_json10_empty_input_and_empty_output_response() {
        /* test case disabled for this protocol (not yet supported) */
    }
    /// Empty output serializes no payload
    /// Test ID: AwsJson10EmptyInputAndEmptyJsonObjectOutput
    #[test]
    fn test_aws_json10_empty_input_and_empty_json_object_output_response() {
        /* test case disabled for this protocol (not yet supported) */
    }
}

impl GreetingWithErrorsInput {
    pub fn request_builder_base(&self) -> ::http::request::Builder {
        let builder = ::http::request::Builder::new();
        builder
            .method("POST")
            .header("Content-Type", "application/x-amz-json-1.0")
            .header("X-Amz-Target", "JsonRpc10.GreetingWithErrors")
    }
    pub fn build_body(&self) -> ::std::vec::Vec<u8> {
        vec![]
    }
    pub fn assemble(
        builder: ::http::request::Builder,
        body: ::std::vec::Vec<u8>,
    ) -> ::http::request::Request<::std::vec::Vec<u8>> {
        builder
            .header(::http::header::CONTENT_LENGTH, body.len())
            .body(body)
            .expect("http request should be valid")
    }
}
#[cfg(test)]
#[allow(unreachable_code, unused_variables)]
mod greeting_with_errors_request_test {

    /// Parses simple JSON errors
    /// Test ID: AwsJson10InvalidGreetingError
    #[test]
    fn test_aws_json10_invalid_greeting_error_response() {
        /* test case disabled for this protocol (not yet supported) */
    }
    /// Parses a complex error with no message member
    /// Test ID: AwsJson10ComplexError
    #[test]
    fn test_aws_json10_complex_error_response() {
        /* test case disabled for this protocol (not yet supported) */
    }
    /// Parses a complex error with an empty body
    /// Test ID: AwsJson10EmptyComplexError
    #[test]
    fn test_aws_json10_empty_complex_error_response() {
        /* test case disabled for this protocol (not yet supported) */
    }
    /// Serializes the X-Amzn-ErrorType header. For an example service, see Amazon EKS.
    /// Test ID: AwsJson10FooErrorUsingXAmznErrorType
    #[test]
    fn test_aws_json10_foo_error_using_x_amzn_error_type_response() {
        /* test case disabled for this protocol (not yet supported) */
    }
    /// Some X-Amzn-Errortype headers contain URLs. Clients need to split the URL on ':' and take only the first half of the string. For example, 'ValidationException:http://internal.amazon.com/coral/com.amazon.coral.validate/'
    /// is to be interpreted as 'ValidationException'.
    ///
    /// For an example service see Amazon Polly.
    /// Test ID: AwsJson10FooErrorUsingXAmznErrorTypeWithUri
    #[test]
    fn test_aws_json10_foo_error_using_x_amzn_error_type_with_uri_response() {
        /* test case disabled for this protocol (not yet supported) */
    }
    /// X-Amzn-Errortype might contain a URL and a namespace. Client should extract only the shape name. This is a pathalogical case that might not actually happen in any deployed AWS service.
    /// Test ID: AwsJson10FooErrorUsingXAmznErrorTypeWithUriAndNamespace
    #[test]
    fn test_aws_json10_foo_error_using_x_amzn_error_type_with_uri_and_namespace_response() {
        /* test case disabled for this protocol (not yet supported) */
    }
    /// This example uses the 'code' property in the output rather than X-Amzn-Errortype. Some services do this though it's preferable to send the X-Amzn-Errortype. Client implementations must first check for the X-Amzn-Errortype and then check for a top-level 'code' property.
    ///
    /// For example service see Amazon S3 Glacier.
    /// Test ID: AwsJson10FooErrorUsingCode
    #[test]
    fn test_aws_json10_foo_error_using_code_response() {
        /* test case disabled for this protocol (not yet supported) */
    }
    /// Some services serialize errors using code, and it might contain a namespace. Clients should just take the last part of the string after '#'.
    /// Test ID: AwsJson10FooErrorUsingCodeAndNamespace
    #[test]
    fn test_aws_json10_foo_error_using_code_and_namespace_response() {
        /* test case disabled for this protocol (not yet supported) */
    }
    /// Some services serialize errors using code, and it might contain a namespace. It also might contain a URI. Clients should just take the last part of the string after '#' and before ":". This is a pathalogical case that might not occur in any deployed AWS service.
    /// Test ID: AwsJson10FooErrorUsingCodeUriAndNamespace
    #[test]
    fn test_aws_json10_foo_error_using_code_uri_and_namespace_response() {
        /* test case disabled for this protocol (not yet supported) */
    }
    /// Some services serialize errors using __type.
    /// Test ID: AwsJson10FooErrorWithDunderType
    #[test]
    fn test_aws_json10_foo_error_with_dunder_type_response() {
        /* test case disabled for this protocol (not yet supported) */
    }
    /// Some services serialize errors using __type, and it might contain a namespace. Clients should just take the last part of the string after '#'.
    /// Test ID: AwsJson10FooErrorWithDunderTypeAndNamespace
    #[test]
    fn test_aws_json10_foo_error_with_dunder_type_and_namespace_response() {
        /* test case disabled for this protocol (not yet supported) */
    }
    /// Some services serialize errors using __type, and it might contain a namespace. It also might contain a URI. Clients should just take the last part of the string after '#' and before ":". This is a pathalogical case that might not occur in any deployed AWS service.
    /// Test ID: AwsJson10FooErrorWithDunderTypeUriAndNamespace
    #[test]
    fn test_aws_json10_foo_error_with_dunder_type_uri_and_namespace_response() {
        /* test case disabled for this protocol (not yet supported) */
    }
}

impl JsonUnionsInput {
    pub fn request_builder_base(&self) -> ::http::request::Builder {
        let builder = ::http::request::Builder::new();
        builder
            .method("POST")
            .header("Content-Type", "application/x-amz-json-1.0")
            .header("X-Amz-Target", "JsonRpc10.JsonUnions")
    }
    fn body(&self) -> JsonUnionsInputBody {
        JsonUnionsInputBody {
            contents: &self.contents,
        }
    }
    pub fn build_body(&self) -> ::std::vec::Vec<u8> {
        ::serde_json::to_vec(&self.body()).expect("serialization should succeed")
    }
    pub fn assemble(
        builder: ::http::request::Builder,
        body: ::std::vec::Vec<u8>,
    ) -> ::http::request::Request<::std::vec::Vec<u8>> {
        builder
            .header(::http::header::CONTENT_LENGTH, body.len())
            .body(body)
            .expect("http request should be valid")
    }
}
#[cfg(test)]
#[allow(unreachable_code, unused_variables)]
mod json_unions_request_test {

    use crate::model::FooEnum;
    use crate::model::GreetingStruct;
    use crate::model::MyUnion;
    use crate::operation::JsonUnionsInput;
    /// Serializes a string union value
    /// Test ID: AwsJson10SerializeStringUnionValue
    #[test]
    fn test_aws_json10_serialize_string_union_value_request() {
        let input = JsonUnionsInput::builder()
            .contents(MyUnion::StringValue("foo".to_string()))
            .build();
        let http_request =
            JsonUnionsInput::assemble(input.request_builder_base(), input.build_body());

        assert_eq!(http_request.method(), "POST");
        assert_eq!(http_request.uri().path(), "/");

        let expected_headers = &[
            ("Content-Type", "application/x-amz-json-1.0"),
            ("X-Amz-Target", "JsonRpc10.JsonUnions"),
        ];
        ::protocol_test_helpers::assert_ok(::protocol_test_helpers::validate_headers(
            &http_request,
            expected_headers,
        ));
        ::protocol_test_helpers::assert_ok(::protocol_test_helpers::validate_body(
            input.build_body(),
            "{
            \"contents\": {
                \"stringValue\": \"foo\"
            }
        }",
            ::protocol_test_helpers::MediaType::from("application/json"),
        ));
    }
    /// Serializes a boolean union value
    /// Test ID: AwsJson10SerializeBooleanUnionValue
    #[test]
    fn test_aws_json10_serialize_boolean_union_value_request() {
        let input = JsonUnionsInput::builder()
            .contents(MyUnion::BooleanValue(true))
            .build();
        let http_request =
            JsonUnionsInput::assemble(input.request_builder_base(), input.build_body());

        assert_eq!(http_request.method(), "POST");
        assert_eq!(http_request.uri().path(), "/");

        let expected_headers = &[
            ("Content-Type", "application/x-amz-json-1.0"),
            ("X-Amz-Target", "JsonRpc10.JsonUnions"),
        ];
        ::protocol_test_helpers::assert_ok(::protocol_test_helpers::validate_headers(
            &http_request,
            expected_headers,
        ));
        ::protocol_test_helpers::assert_ok(::protocol_test_helpers::validate_body(
            input.build_body(),
            "{
            \"contents\": {
                \"booleanValue\": true
            }
        }",
            ::protocol_test_helpers::MediaType::from("application/json"),
        ));
    }
    /// Serializes a number union value
    /// Test ID: AwsJson10SerializeNumberUnionValue
    #[test]
    fn test_aws_json10_serialize_number_union_value_request() {
        let input = JsonUnionsInput::builder()
            .contents(MyUnion::NumberValue(1))
            .build();
        let http_request =
            JsonUnionsInput::assemble(input.request_builder_base(), input.build_body());

        assert_eq!(http_request.method(), "POST");
        assert_eq!(http_request.uri().path(), "/");

        let expected_headers = &[
            ("Content-Type", "application/x-amz-json-1.0"),
            ("X-Amz-Target", "JsonRpc10.JsonUnions"),
        ];
        ::protocol_test_helpers::assert_ok(::protocol_test_helpers::validate_headers(
            &http_request,
            expected_headers,
        ));
        ::protocol_test_helpers::assert_ok(::protocol_test_helpers::validate_body(
            input.build_body(),
            "{
            \"contents\": {
                \"numberValue\": 1
            }
        }",
            ::protocol_test_helpers::MediaType::from("application/json"),
        ));
    }
    /// Serializes a blob union value
    /// Test ID: AwsJson10SerializeBlobUnionValue
    #[test]
    fn test_aws_json10_serialize_blob_union_value_request() {
        let input = JsonUnionsInput::builder()
            .contents(MyUnion::BlobValue(::smithy_types::Blob::new("foo")))
            .build();
        let http_request =
            JsonUnionsInput::assemble(input.request_builder_base(), input.build_body());

        assert_eq!(http_request.method(), "POST");
        assert_eq!(http_request.uri().path(), "/");

        let expected_headers = &[
            ("Content-Type", "application/x-amz-json-1.0"),
            ("X-Amz-Target", "JsonRpc10.JsonUnions"),
        ];
        ::protocol_test_helpers::assert_ok(::protocol_test_helpers::validate_headers(
            &http_request,
            expected_headers,
        ));
        ::protocol_test_helpers::assert_ok(::protocol_test_helpers::validate_body(
            input.build_body(),
            "{
            \"contents\": {
                \"blobValue\": \"Zm9v\"
            }
        }",
            ::protocol_test_helpers::MediaType::from("application/json"),
        ));
    }
    /// Serializes a timestamp union value
    /// Test ID: AwsJson10SerializeTimestampUnionValue
    #[test]
    fn test_aws_json10_serialize_timestamp_union_value_request() {
        let input = JsonUnionsInput::builder()
            .contents(MyUnion::TimestampValue(
                ::smithy_types::Instant::from_epoch_seconds(1398796238),
            ))
            .build();
        let http_request =
            JsonUnionsInput::assemble(input.request_builder_base(), input.build_body());

        assert_eq!(http_request.method(), "POST");
        assert_eq!(http_request.uri().path(), "/");

        let expected_headers = &[
            ("Content-Type", "application/x-amz-json-1.0"),
            ("X-Amz-Target", "JsonRpc10.JsonUnions"),
        ];
        ::protocol_test_helpers::assert_ok(::protocol_test_helpers::validate_headers(
            &http_request,
            expected_headers,
        ));
        ::protocol_test_helpers::assert_ok(::protocol_test_helpers::validate_body(
            input.build_body(),
            "{
            \"contents\": {
                \"timestampValue\": 1398796238
            }
        }",
            ::protocol_test_helpers::MediaType::from("application/json"),
        ));
    }
    /// Serializes an enum union value
    /// Test ID: AwsJson10SerializeEnumUnionValue
    #[test]
    fn test_aws_json10_serialize_enum_union_value_request() {
        let input = JsonUnionsInput::builder()
            .contents(MyUnion::EnumValue(FooEnum::from("Foo")))
            .build();
        let http_request =
            JsonUnionsInput::assemble(input.request_builder_base(), input.build_body());

        assert_eq!(http_request.method(), "POST");
        assert_eq!(http_request.uri().path(), "/");

        let expected_headers = &[
            ("Content-Type", "application/x-amz-json-1.0"),
            ("X-Amz-Target", "JsonRpc10.JsonUnions"),
        ];
        ::protocol_test_helpers::assert_ok(::protocol_test_helpers::validate_headers(
            &http_request,
            expected_headers,
        ));
        ::protocol_test_helpers::assert_ok(::protocol_test_helpers::validate_body(
            input.build_body(),
            "{
            \"contents\": {
                \"enumValue\": \"Foo\"
            }
        }",
            ::protocol_test_helpers::MediaType::from("application/json"),
        ));
    }
    /// Serializes a list union value
    /// Test ID: AwsJson10SerializeListUnionValue
    #[test]
    fn test_aws_json10_serialize_list_union_value_request() {
        let input = JsonUnionsInput::builder()
            .contents(MyUnion::ListValue(vec![
                "foo".to_string(),
                "bar".to_string(),
            ]))
            .build();
        let http_request =
            JsonUnionsInput::assemble(input.request_builder_base(), input.build_body());

        assert_eq!(http_request.method(), "POST");
        assert_eq!(http_request.uri().path(), "/");

        let expected_headers = &[
            ("Content-Type", "application/x-amz-json-1.0"),
            ("X-Amz-Target", "JsonRpc10.JsonUnions"),
        ];
        ::protocol_test_helpers::assert_ok(::protocol_test_helpers::validate_headers(
            &http_request,
            expected_headers,
        ));
        ::protocol_test_helpers::assert_ok(::protocol_test_helpers::validate_body(
            input.build_body(),
            "{
            \"contents\": {
                \"listValue\": [\"foo\", \"bar\"]
            }
        }",
            ::protocol_test_helpers::MediaType::from("application/json"),
        ));
    }
    /// Serializes a map union value
    /// Test ID: AwsJson10SerializeMapUnionValue
    #[test]
    fn test_aws_json10_serialize_map_union_value_request() {
        let input = JsonUnionsInput::builder()
            .contents(MyUnion::MapValue({
                let mut ret = ::std::collections::HashMap::new();
                ret.insert("foo".to_string(), "bar".to_string());
                ret.insert("spam".to_string(), "eggs".to_string());
                ret
            }))
            .build();
        let http_request =
            JsonUnionsInput::assemble(input.request_builder_base(), input.build_body());

        assert_eq!(http_request.method(), "POST");
        assert_eq!(http_request.uri().path(), "/");

        let expected_headers = &[
            ("Content-Type", "application/x-amz-json-1.0"),
            ("X-Amz-Target", "JsonRpc10.JsonUnions"),
        ];
        ::protocol_test_helpers::assert_ok(::protocol_test_helpers::validate_headers(
            &http_request,
            expected_headers,
        ));
        ::protocol_test_helpers::assert_ok(::protocol_test_helpers::validate_body(
            input.build_body(),
            "{
            \"contents\": {
                \"mapValue\": {
                    \"foo\": \"bar\",
                    \"spam\": \"eggs\"
                }
            }
        }",
            ::protocol_test_helpers::MediaType::from("application/json"),
        ));
    }
    /// Serializes a structure union value
    /// Test ID: AwsJson10SerializeStructureUnionValue
    #[test]
    fn test_aws_json10_serialize_structure_union_value_request() {
        let input = JsonUnionsInput::builder()
            .contents(MyUnion::StructureValue(
                GreetingStruct::builder().hi("hello".to_string()).build(),
            ))
            .build();
        let http_request =
            JsonUnionsInput::assemble(input.request_builder_base(), input.build_body());

        assert_eq!(http_request.method(), "POST");
        assert_eq!(http_request.uri().path(), "/");

        let expected_headers = &[
            ("Content-Type", "application/x-amz-json-1.0"),
            ("X-Amz-Target", "JsonRpc10.JsonUnions"),
        ];
        ::protocol_test_helpers::assert_ok(::protocol_test_helpers::validate_headers(
            &http_request,
            expected_headers,
        ));
        ::protocol_test_helpers::assert_ok(::protocol_test_helpers::validate_body(
            input.build_body(),
            "{
            \"contents\": {
                \"structureValue\": {
                    \"hi\": \"hello\"
                }
            }
        }",
            ::protocol_test_helpers::MediaType::from("application/json"),
        ));
    }
    /// Deserializes a string union value
    /// Test ID: AwsJson10DeserializeStringUnionValue
    #[test]
    fn test_aws_json10_deserialize_string_union_value_response() {
        /* test case disabled for this protocol (not yet supported) */
    }
    /// Deserializes a boolean union value
    /// Test ID: AwsJson10DeserializeBooleanUnionValue
    #[test]
    fn test_aws_json10_deserialize_boolean_union_value_response() {
        /* test case disabled for this protocol (not yet supported) */
    }
    /// Deserializes a number union value
    /// Test ID: AwsJson10DeserializeNumberUnionValue
    #[test]
    fn test_aws_json10_deserialize_number_union_value_response() {
        /* test case disabled for this protocol (not yet supported) */
    }
    /// Deserializes a blob union value
    /// Test ID: AwsJson10DeserializeBlobUnionValue
    #[test]
    fn test_aws_json10_deserialize_blob_union_value_response() {
        /* test case disabled for this protocol (not yet supported) */
    }
    /// Deserializes a timestamp union value
    /// Test ID: AwsJson10DeserializeTimestampUnionValue
    #[test]
    fn test_aws_json10_deserialize_timestamp_union_value_response() {
        /* test case disabled for this protocol (not yet supported) */
    }
    /// Deserializes an enum union value
    /// Test ID: AwsJson10DeserializeEnumUnionValue
    #[test]
    fn test_aws_json10_deserialize_enum_union_value_response() {
        /* test case disabled for this protocol (not yet supported) */
    }
    /// Deserializes a list union value
    /// Test ID: AwsJson10DeserializeListUnionValue
    #[test]
    fn test_aws_json10_deserialize_list_union_value_response() {
        /* test case disabled for this protocol (not yet supported) */
    }
    /// Deserializes a map union value
    /// Test ID: AwsJson10DeserializeMapUnionValue
    #[test]
    fn test_aws_json10_deserialize_map_union_value_response() {
        /* test case disabled for this protocol (not yet supported) */
    }
    /// Deserializes a structure union value
    /// Test ID: AwsJson10DeserializeStructureUnionValue
    #[test]
    fn test_aws_json10_deserialize_structure_union_value_response() {
        /* test case disabled for this protocol (not yet supported) */
    }
}

impl NoInputAndNoOutputInput {
    pub fn request_builder_base(&self) -> ::http::request::Builder {
        let builder = ::http::request::Builder::new();
        builder
            .method("POST")
            .header("Content-Type", "application/x-amz-json-1.0")
            .header("X-Amz-Target", "JsonRpc10.NoInputAndNoOutput")
    }
    pub fn build_body(&self) -> ::std::vec::Vec<u8> {
        vec![]
    }
    pub fn assemble(
        builder: ::http::request::Builder,
        body: ::std::vec::Vec<u8>,
    ) -> ::http::request::Request<::std::vec::Vec<u8>> {
        builder
            .header(::http::header::CONTENT_LENGTH, body.len())
            .body(body)
            .expect("http request should be valid")
    }
}
#[cfg(test)]
#[allow(unreachable_code, unused_variables)]
mod no_input_and_no_output_request_test {

    use crate::operation::NoInputAndNoOutputInput;
    /// No input serializes no payload
    /// Test ID: AwsJson10NoInputAndNoOutput
    #[test]
    fn test_aws_json10_no_input_and_no_output_request() {
        let input = NoInputAndNoOutputInput::builder().build();
        let http_request =
            NoInputAndNoOutputInput::assemble(input.request_builder_base(), input.build_body());

        assert_eq!(http_request.method(), "POST");
        assert_eq!(http_request.uri().path(), "/");

        let expected_headers = &[
            ("Content-Type", "application/x-amz-json-1.0"),
            ("X-Amz-Target", "JsonRpc10.NoInputAndNoOutput"),
        ];
        ::protocol_test_helpers::assert_ok(::protocol_test_helpers::validate_headers(
            &http_request,
            expected_headers,
        ));
        // No body
        assert!(input.build_body().is_empty());
    }
    /// No output serializes no payload
    /// Test ID: AwsJson10NoInputAndNoOutput
    #[test]
    fn test_aws_json10_no_input_and_no_output_response() {
        /* test case disabled for this protocol (not yet supported) */
    }
}

impl NoInputAndOutputInput {
    pub fn request_builder_base(&self) -> ::http::request::Builder {
        let builder = ::http::request::Builder::new();
        builder
            .method("POST")
            .header("Content-Type", "application/x-amz-json-1.0")
            .header("X-Amz-Target", "JsonRpc10.NoInputAndOutput")
    }
    pub fn build_body(&self) -> ::std::vec::Vec<u8> {
        vec![]
    }
    pub fn assemble(
        builder: ::http::request::Builder,
        body: ::std::vec::Vec<u8>,
    ) -> ::http::request::Request<::std::vec::Vec<u8>> {
        builder
            .header(::http::header::CONTENT_LENGTH, body.len())
            .body(body)
            .expect("http request should be valid")
    }
}
#[cfg(test)]
#[allow(unreachable_code, unused_variables)]
mod no_input_and_output_request_test {

    use crate::operation::NoInputAndOutputInput;
    /// No input serializes no payload
    /// Test ID: AwsJson10NoInputAndOutput
    #[test]
    fn test_aws_json10_no_input_and_output_request() {
        let input = NoInputAndOutputInput::builder().build();
        let http_request =
            NoInputAndOutputInput::assemble(input.request_builder_base(), input.build_body());

        assert_eq!(http_request.method(), "POST");
        assert_eq!(http_request.uri().path(), "/");

        let expected_headers = &[
            ("Content-Type", "application/x-amz-json-1.0"),
            ("X-Amz-Target", "JsonRpc10.NoInputAndOutput"),
        ];
        ::protocol_test_helpers::assert_ok(::protocol_test_helpers::validate_headers(
            &http_request,
            expected_headers,
        ));
        // No body
        assert!(input.build_body().is_empty());
    }
    /// Empty output serializes no payload
    /// Test ID: AwsJson10NoInputAndOutput
    #[test]
    fn test_aws_json10_no_input_and_output_response() {
        /* test case disabled for this protocol (not yet supported) */
    }
}

/// A shared structure that contains a single union member.
#[non_exhaustive]
#[derive(::std::clone::Clone, ::std::cmp::PartialEq, ::std::fmt::Debug)]
pub struct JsonUnionsOutput {
    /// A union with a representative set of types for members.
    pub contents: ::std::option::Option<MyUnion>,
}
impl JsonUnionsOutput {
    /// Creates a new builder-style object to manufacture [`JsonUnionsOutput`](crate::operation::JsonUnionsOutput)
    pub fn builder() -> crate::operation::json_unions_output::Builder {
        crate::operation::json_unions_output::Builder::default()
    }
}
/// See [`JsonUnionsOutput`](crate::operation::JsonUnionsOutput)
pub mod json_unions_output {

    use crate::model::MyUnion;
    use crate::operation::JsonUnionsOutput;
    /// A builder for [`JsonUnionsOutput`](crate::operation::JsonUnionsOutput)
    #[non_exhaustive]
    #[derive(Debug, Clone, Default)]
    pub struct Builder {
        contents: ::std::option::Option<MyUnion>,
    }
    impl Builder {
        /// A union with a representative set of types for members.
        pub fn contents(mut self, inp: MyUnion) -> Self {
            self.contents = Some(inp);
            self
        }
        /// Consumes the builder and constructs a [`JsonUnionsOutput`](crate::operation::JsonUnionsOutput)
        pub fn build(self) -> JsonUnionsOutput {
            JsonUnionsOutput {
                contents: self.contents,
            }
        }
    }
}

/// A shared structure that contains a single union member.
#[non_exhaustive]
#[derive(::std::clone::Clone, ::std::cmp::PartialEq, ::std::fmt::Debug)]
pub struct JsonUnionsInput {
    /// A union with a representative set of types for members.
    pub contents: ::std::option::Option<MyUnion>,
}
impl JsonUnionsInput {
    /// Creates a new builder-style object to manufacture [`JsonUnionsInput`](crate::operation::JsonUnionsInput)
    pub fn builder() -> crate::operation::json_unions_input::Builder {
        crate::operation::json_unions_input::Builder::default()
    }
}
/// See [`JsonUnionsInput`](crate::operation::JsonUnionsInput)
pub mod json_unions_input {

    use crate::model::MyUnion;
    use crate::operation::JsonUnionsInput;
    /// A builder for [`JsonUnionsInput`](crate::operation::JsonUnionsInput)
    #[non_exhaustive]
    #[derive(Debug, Clone, Default)]
    pub struct Builder {
        contents: ::std::option::Option<MyUnion>,
    }
    impl Builder {
        /// A union with a representative set of types for members.
        pub fn contents(mut self, inp: MyUnion) -> Self {
            self.contents = Some(inp);
            self
        }
        /// Consumes the builder and constructs a [`JsonUnionsInput`](crate::operation::JsonUnionsInput)
        pub fn build(self) -> JsonUnionsInput {
            JsonUnionsInput {
                contents: self.contents,
            }
        }
    }
}

#[non_exhaustive]
#[derive(::std::clone::Clone, ::std::cmp::PartialEq, ::std::fmt::Debug)]
pub struct GreetingWithErrorsOutput {
    pub greeting: ::std::option::Option<::std::string::String>,
}
impl GreetingWithErrorsOutput {
    /// Creates a new builder-style object to manufacture [`GreetingWithErrorsOutput`](crate::operation::GreetingWithErrorsOutput)
    pub fn builder() -> crate::operation::greeting_with_errors_output::Builder {
        crate::operation::greeting_with_errors_output::Builder::default()
    }
}
/// See [`GreetingWithErrorsOutput`](crate::operation::GreetingWithErrorsOutput)
pub mod greeting_with_errors_output {

    use crate::operation::GreetingWithErrorsOutput;
    /// A builder for [`GreetingWithErrorsOutput`](crate::operation::GreetingWithErrorsOutput)
    #[non_exhaustive]
    #[derive(Debug, Clone, Default)]
    pub struct Builder {
        greeting: ::std::option::Option<::std::string::String>,
    }
    impl Builder {
        pub fn greeting(mut self, inp: impl Into<::std::string::String>) -> Self {
            self.greeting = Some(inp.into());
            self
        }
        /// Consumes the builder and constructs a [`GreetingWithErrorsOutput`](crate::operation::GreetingWithErrorsOutput)
        pub fn build(self) -> GreetingWithErrorsOutput {
            GreetingWithErrorsOutput {
                greeting: self.greeting,
            }
        }
    }
}

#[non_exhaustive]
#[derive(::std::clone::Clone, ::std::cmp::PartialEq, ::std::fmt::Debug)]
pub struct GreetingWithErrorsInput {}
impl GreetingWithErrorsInput {
    /// Creates a new builder-style object to manufacture [`GreetingWithErrorsInput`](crate::operation::GreetingWithErrorsInput)
    pub fn builder() -> crate::operation::greeting_with_errors_input::Builder {
        crate::operation::greeting_with_errors_input::Builder::default()
    }
}
/// See [`GreetingWithErrorsInput`](crate::operation::GreetingWithErrorsInput)
pub mod greeting_with_errors_input {

    use crate::operation::GreetingWithErrorsInput;
    /// A builder for [`GreetingWithErrorsInput`](crate::operation::GreetingWithErrorsInput)
    #[non_exhaustive]
    #[derive(Debug, Clone, Default)]
    pub struct Builder {}
    impl Builder {
        /// Consumes the builder and constructs a [`GreetingWithErrorsInput`](crate::operation::GreetingWithErrorsInput)
        pub fn build(self) -> GreetingWithErrorsInput {
            GreetingWithErrorsInput {}
        }
    }
}

#[non_exhaustive]
#[derive(::std::clone::Clone, ::std::cmp::PartialEq, ::std::fmt::Debug)]
pub struct EmptyInputAndEmptyOutputOutput {}
impl EmptyInputAndEmptyOutputOutput {
    /// Creates a new builder-style object to manufacture [`EmptyInputAndEmptyOutputOutput`](crate::operation::EmptyInputAndEmptyOutputOutput)
    pub fn builder() -> crate::operation::empty_input_and_empty_output_output::Builder {
        crate::operation::empty_input_and_empty_output_output::Builder::default()
    }
}
/// See [`EmptyInputAndEmptyOutputOutput`](crate::operation::EmptyInputAndEmptyOutputOutput)
pub mod empty_input_and_empty_output_output {

    use crate::operation::EmptyInputAndEmptyOutputOutput;
    /// A builder for [`EmptyInputAndEmptyOutputOutput`](crate::operation::EmptyInputAndEmptyOutputOutput)
    #[non_exhaustive]
    #[derive(Debug, Clone, Default)]
    pub struct Builder {}
    impl Builder {
        /// Consumes the builder and constructs a [`EmptyInputAndEmptyOutputOutput`](crate::operation::EmptyInputAndEmptyOutputOutput)
        pub fn build(self) -> EmptyInputAndEmptyOutputOutput {
            EmptyInputAndEmptyOutputOutput {}
        }
    }
}

#[non_exhaustive]
#[derive(::std::clone::Clone, ::std::cmp::PartialEq, ::std::fmt::Debug)]
pub struct EmptyInputAndEmptyOutputInput {}
impl EmptyInputAndEmptyOutputInput {
    /// Creates a new builder-style object to manufacture [`EmptyInputAndEmptyOutputInput`](crate::operation::EmptyInputAndEmptyOutputInput)
    pub fn builder() -> crate::operation::empty_input_and_empty_output_input::Builder {
        crate::operation::empty_input_and_empty_output_input::Builder::default()
    }
}
/// See [`EmptyInputAndEmptyOutputInput`](crate::operation::EmptyInputAndEmptyOutputInput)
pub mod empty_input_and_empty_output_input {

    use crate::operation::EmptyInputAndEmptyOutputInput;
    /// A builder for [`EmptyInputAndEmptyOutputInput`](crate::operation::EmptyInputAndEmptyOutputInput)
    #[non_exhaustive]
    #[derive(Debug, Clone, Default)]
    pub struct Builder {}
    impl Builder {
        /// Consumes the builder and constructs a [`EmptyInputAndEmptyOutputInput`](crate::operation::EmptyInputAndEmptyOutputInput)
        pub fn build(self) -> EmptyInputAndEmptyOutputInput {
            EmptyInputAndEmptyOutputInput {}
        }
    }
}

#[non_exhaustive]
#[derive(::std::clone::Clone, ::std::cmp::PartialEq, ::std::fmt::Debug)]
pub struct NoInputAndOutputOutput {}
impl NoInputAndOutputOutput {
    /// Creates a new builder-style object to manufacture [`NoInputAndOutputOutput`](crate::operation::NoInputAndOutputOutput)
    pub fn builder() -> crate::operation::no_input_and_output_output::Builder {
        crate::operation::no_input_and_output_output::Builder::default()
    }
}
/// See [`NoInputAndOutputOutput`](crate::operation::NoInputAndOutputOutput)
pub mod no_input_and_output_output {

    use crate::operation::NoInputAndOutputOutput;
    /// A builder for [`NoInputAndOutputOutput`](crate::operation::NoInputAndOutputOutput)
    #[non_exhaustive]
    #[derive(Debug, Clone, Default)]
    pub struct Builder {}
    impl Builder {
        /// Consumes the builder and constructs a [`NoInputAndOutputOutput`](crate::operation::NoInputAndOutputOutput)
        pub fn build(self) -> NoInputAndOutputOutput {
            NoInputAndOutputOutput {}
        }
    }
}

#[non_exhaustive]
#[derive(::std::clone::Clone, ::std::cmp::PartialEq, ::std::fmt::Debug)]
pub struct NoInputAndOutputInput {}
impl NoInputAndOutputInput {
    /// Creates a new builder-style object to manufacture [`NoInputAndOutputInput`](crate::operation::NoInputAndOutputInput)
    pub fn builder() -> crate::operation::no_input_and_output_input::Builder {
        crate::operation::no_input_and_output_input::Builder::default()
    }
}
/// See [`NoInputAndOutputInput`](crate::operation::NoInputAndOutputInput)
pub mod no_input_and_output_input {

    use crate::operation::NoInputAndOutputInput;
    /// A builder for [`NoInputAndOutputInput`](crate::operation::NoInputAndOutputInput)
    #[non_exhaustive]
    #[derive(Debug, Clone, Default)]
    pub struct Builder {}
    impl Builder {
        /// Consumes the builder and constructs a [`NoInputAndOutputInput`](crate::operation::NoInputAndOutputInput)
        pub fn build(self) -> NoInputAndOutputInput {
            NoInputAndOutputInput {}
        }
    }
}

#[non_exhaustive]
#[derive(::std::clone::Clone, ::std::cmp::PartialEq, ::std::fmt::Debug)]
pub struct NoInputAndNoOutputOutput {}
impl NoInputAndNoOutputOutput {
    /// Creates a new builder-style object to manufacture [`NoInputAndNoOutputOutput`](crate::operation::NoInputAndNoOutputOutput)
    pub fn builder() -> crate::operation::no_input_and_no_output_output::Builder {
        crate::operation::no_input_and_no_output_output::Builder::default()
    }
}
/// See [`NoInputAndNoOutputOutput`](crate::operation::NoInputAndNoOutputOutput)
pub mod no_input_and_no_output_output {

    use crate::operation::NoInputAndNoOutputOutput;
    /// A builder for [`NoInputAndNoOutputOutput`](crate::operation::NoInputAndNoOutputOutput)
    #[non_exhaustive]
    #[derive(Debug, Clone, Default)]
    pub struct Builder {}
    impl Builder {
        /// Consumes the builder and constructs a [`NoInputAndNoOutputOutput`](crate::operation::NoInputAndNoOutputOutput)
        pub fn build(self) -> NoInputAndNoOutputOutput {
            NoInputAndNoOutputOutput {}
        }
    }
}

#[non_exhaustive]
#[derive(::std::clone::Clone, ::std::cmp::PartialEq, ::std::fmt::Debug)]
pub struct NoInputAndNoOutputInput {}
impl NoInputAndNoOutputInput {
    /// Creates a new builder-style object to manufacture [`NoInputAndNoOutputInput`](crate::operation::NoInputAndNoOutputInput)
    pub fn builder() -> crate::operation::no_input_and_no_output_input::Builder {
        crate::operation::no_input_and_no_output_input::Builder::default()
    }
}
/// See [`NoInputAndNoOutputInput`](crate::operation::NoInputAndNoOutputInput)
pub mod no_input_and_no_output_input {

    use crate::operation::NoInputAndNoOutputInput;
    /// A builder for [`NoInputAndNoOutputInput`](crate::operation::NoInputAndNoOutputInput)
    #[non_exhaustive]
    #[derive(Debug, Clone, Default)]
    pub struct Builder {}
    impl Builder {
        /// Consumes the builder and constructs a [`NoInputAndNoOutputInput`](crate::operation::NoInputAndNoOutputInput)
        pub fn build(self) -> NoInputAndNoOutputInput {
            NoInputAndNoOutputInput {}
        }
    }
}
