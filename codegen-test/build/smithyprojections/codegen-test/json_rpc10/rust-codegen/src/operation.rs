// Code generated by software.amazon.smithy.rust.codegen.smithy-rs. DO NOT EDIT.
use crate::input::EmptyInputAndEmptyOutputInput;
use crate::input::GreetingWithErrorsInput;
use crate::input::JsonUnionsInput;
use crate::input::NoInputAndNoOutputInput;
use crate::input::NoInputAndOutputInput;
/// The example tests how requests and responses are serialized when there's
/// no request or response payload because the operation has an empty input
/// and empty output structure that reuses the same shape. While this should
/// be rare, code generators must support this.
pub struct EmptyInputAndEmptyOutput {
    input: EmptyInputAndEmptyOutputInput,
}
impl EmptyInputAndEmptyOutput {
    /// Creates a new builder-style object to manufacture [`EmptyInputAndEmptyOutputInput`](crate::input::EmptyInputAndEmptyOutputInput)
    pub fn builder() -> crate::input::empty_input_and_empty_output_input::Builder {
        crate::input::empty_input_and_empty_output_input::Builder::default()
    }
    pub fn build_http_request(&self) -> ::http::request::Request<Vec<u8>> {
        EmptyInputAndEmptyOutputInput::assemble(
            self.input.request_builder_base(),
            self.input.build_body(),
        )
    }
    pub fn new(input: EmptyInputAndEmptyOutputInput) -> Self {
        Self { input }
    }
}
#[cfg(test)]
#[allow(unreachable_code, unused_variables)]
mod empty_input_and_empty_output_request_test {

    use crate::input::EmptyInputAndEmptyOutputInput;
    /// Empty input serializes no payload
    /// Test ID: AwsJson10EmptyInputAndEmptyOutput
    #[test]
    fn test_aws_json10_empty_input_and_empty_output_request() {
        let input = EmptyInputAndEmptyOutputInput::builder().build();
        let http_request = input.build_http_request();

        assert_eq!(http_request.method(), "POST");
        assert_eq!(http_request.uri().path(), "/");

        let expected_headers = &[
            ("Content-Type", "application/x-amz-json-1.0"),
            ("X-Amz-Target", "JsonRpc10.EmptyInputAndEmptyOutput"),
        ];
        ::protocol_test_helpers::assert_ok(::protocol_test_helpers::validate_headers(
            &http_request,
            expected_headers,
        ));
        // No body
        assert!(&http_request.body().is_empty());
    }
    /// Empty output serializes no payload
    /// Test ID: AwsJson10EmptyInputAndEmptyOutput
    #[test]
    fn test_aws_json10_empty_input_and_empty_output_response() {
        /* test case disabled for this protocol (not yet supported) */
    }
    /// Empty output serializes no payload
    /// Test ID: AwsJson10EmptyInputAndEmptyJsonObjectOutput
    #[test]
    fn test_aws_json10_empty_input_and_empty_json_object_output_response() {
        /* test case disabled for this protocol (not yet supported) */
    }
}

/// This operation has three possible return values:
/// 1. A successful response in the form of GreetingWithErrorsOutput
/// 2. An InvalidGreeting error.
/// 3. A ComplexError error.
/// Implementations must be able to successfully take a response and
/// properly deserialize successful and error responses.
pub struct GreetingWithErrors {
    input: GreetingWithErrorsInput,
}
impl GreetingWithErrors {
    /// Creates a new builder-style object to manufacture [`GreetingWithErrorsInput`](crate::input::GreetingWithErrorsInput)
    pub fn builder() -> crate::input::greeting_with_errors_input::Builder {
        crate::input::greeting_with_errors_input::Builder::default()
    }
    pub fn build_http_request(&self) -> ::http::request::Request<Vec<u8>> {
        GreetingWithErrorsInput::assemble(
            self.input.request_builder_base(),
            self.input.build_body(),
        )
    }
    pub fn new(input: GreetingWithErrorsInput) -> Self {
        Self { input }
    }
}
#[cfg(test)]
#[allow(unreachable_code, unused_variables)]
mod greeting_with_errors_request_test {

    /// Parses simple JSON errors
    /// Test ID: AwsJson10InvalidGreetingError
    #[test]
    fn test_aws_json10_invalid_greeting_error_response() {
        /* test case disabled for this protocol (not yet supported) */
    }
    /// Parses a complex error with no message member
    /// Test ID: AwsJson10ComplexError
    #[test]
    fn test_aws_json10_complex_error_response() {
        /* test case disabled for this protocol (not yet supported) */
    }
    /// Parses a complex error with an empty body
    /// Test ID: AwsJson10EmptyComplexError
    #[test]
    fn test_aws_json10_empty_complex_error_response() {
        /* test case disabled for this protocol (not yet supported) */
    }
    /// Serializes the X-Amzn-ErrorType header. For an example service, see Amazon EKS.
    /// Test ID: AwsJson10FooErrorUsingXAmznErrorType
    #[test]
    fn test_aws_json10_foo_error_using_x_amzn_error_type_response() {
        /* test case disabled for this protocol (not yet supported) */
    }
    /// Some X-Amzn-Errortype headers contain URLs. Clients need to split the URL on ':' and take only the first half of the string. For example, 'ValidationException:http://internal.amazon.com/coral/com.amazon.coral.validate/'
    /// is to be interpreted as 'ValidationException'.
    ///
    /// For an example service see Amazon Polly.
    /// Test ID: AwsJson10FooErrorUsingXAmznErrorTypeWithUri
    #[test]
    fn test_aws_json10_foo_error_using_x_amzn_error_type_with_uri_response() {
        /* test case disabled for this protocol (not yet supported) */
    }
    /// X-Amzn-Errortype might contain a URL and a namespace. Client should extract only the shape name. This is a pathalogical case that might not actually happen in any deployed AWS service.
    /// Test ID: AwsJson10FooErrorUsingXAmznErrorTypeWithUriAndNamespace
    #[test]
    fn test_aws_json10_foo_error_using_x_amzn_error_type_with_uri_and_namespace_response() {
        /* test case disabled for this protocol (not yet supported) */
    }
    /// This example uses the 'code' property in the output rather than X-Amzn-Errortype. Some services do this though it's preferable to send the X-Amzn-Errortype. Client implementations must first check for the X-Amzn-Errortype and then check for a top-level 'code' property.
    ///
    /// For example service see Amazon S3 Glacier.
    /// Test ID: AwsJson10FooErrorUsingCode
    #[test]
    fn test_aws_json10_foo_error_using_code_response() {
        /* test case disabled for this protocol (not yet supported) */
    }
    /// Some services serialize errors using code, and it might contain a namespace. Clients should just take the last part of the string after '#'.
    /// Test ID: AwsJson10FooErrorUsingCodeAndNamespace
    #[test]
    fn test_aws_json10_foo_error_using_code_and_namespace_response() {
        /* test case disabled for this protocol (not yet supported) */
    }
    /// Some services serialize errors using code, and it might contain a namespace. It also might contain a URI. Clients should just take the last part of the string after '#' and before ":". This is a pathalogical case that might not occur in any deployed AWS service.
    /// Test ID: AwsJson10FooErrorUsingCodeUriAndNamespace
    #[test]
    fn test_aws_json10_foo_error_using_code_uri_and_namespace_response() {
        /* test case disabled for this protocol (not yet supported) */
    }
    /// Some services serialize errors using __type.
    /// Test ID: AwsJson10FooErrorWithDunderType
    #[test]
    fn test_aws_json10_foo_error_with_dunder_type_response() {
        /* test case disabled for this protocol (not yet supported) */
    }
    /// Some services serialize errors using __type, and it might contain a namespace. Clients should just take the last part of the string after '#'.
    /// Test ID: AwsJson10FooErrorWithDunderTypeAndNamespace
    #[test]
    fn test_aws_json10_foo_error_with_dunder_type_and_namespace_response() {
        /* test case disabled for this protocol (not yet supported) */
    }
    /// Some services serialize errors using __type, and it might contain a namespace. It also might contain a URI. Clients should just take the last part of the string after '#' and before ":". This is a pathalogical case that might not occur in any deployed AWS service.
    /// Test ID: AwsJson10FooErrorWithDunderTypeUriAndNamespace
    #[test]
    fn test_aws_json10_foo_error_with_dunder_type_uri_and_namespace_response() {
        /* test case disabled for this protocol (not yet supported) */
    }
}

/// This operation uses unions for inputs and outputs.
pub struct JsonUnions {
    input: JsonUnionsInput,
}
impl JsonUnions {
    /// Creates a new builder-style object to manufacture [`JsonUnionsInput`](crate::input::JsonUnionsInput)
    pub fn builder() -> crate::input::json_unions_input::Builder {
        crate::input::json_unions_input::Builder::default()
    }
    pub fn build_http_request(&self) -> ::http::request::Request<Vec<u8>> {
        JsonUnionsInput::assemble(self.input.request_builder_base(), self.input.build_body())
    }
    pub fn new(input: JsonUnionsInput) -> Self {
        Self { input }
    }
}
#[cfg(test)]
#[allow(unreachable_code, unused_variables)]
mod json_unions_request_test {

    use crate::input::JsonUnionsInput;
    use crate::model::FooEnum;
    use crate::model::GreetingStruct;
    use crate::model::MyUnion;
    /// Serializes a string union value
    /// Test ID: AwsJson10SerializeStringUnionValue
    #[test]
    fn test_aws_json10_serialize_string_union_value_request() {
        let input = JsonUnionsInput::builder()
            .contents(MyUnion::StringValue("foo".to_string()))
            .build();
        let http_request = input.build_http_request();

        assert_eq!(http_request.method(), "POST");
        assert_eq!(http_request.uri().path(), "/");

        let expected_headers = &[
            ("Content-Type", "application/x-amz-json-1.0"),
            ("X-Amz-Target", "JsonRpc10.JsonUnions"),
        ];
        ::protocol_test_helpers::assert_ok(::protocol_test_helpers::validate_headers(
            &http_request,
            expected_headers,
        ));
        ::protocol_test_helpers::assert_ok(::protocol_test_helpers::validate_body(
            &http_request.body(),
            "{
            \"contents\": {
                \"stringValue\": \"foo\"
            }
        }",
            ::protocol_test_helpers::MediaType::from("application/json"),
        ));
    }
    /// Serializes a boolean union value
    /// Test ID: AwsJson10SerializeBooleanUnionValue
    #[test]
    fn test_aws_json10_serialize_boolean_union_value_request() {
        let input = JsonUnionsInput::builder()
            .contents(MyUnion::BooleanValue(true))
            .build();
        let http_request = input.build_http_request();

        assert_eq!(http_request.method(), "POST");
        assert_eq!(http_request.uri().path(), "/");

        let expected_headers = &[
            ("Content-Type", "application/x-amz-json-1.0"),
            ("X-Amz-Target", "JsonRpc10.JsonUnions"),
        ];
        ::protocol_test_helpers::assert_ok(::protocol_test_helpers::validate_headers(
            &http_request,
            expected_headers,
        ));
        ::protocol_test_helpers::assert_ok(::protocol_test_helpers::validate_body(
            &http_request.body(),
            "{
            \"contents\": {
                \"booleanValue\": true
            }
        }",
            ::protocol_test_helpers::MediaType::from("application/json"),
        ));
    }
    /// Serializes a number union value
    /// Test ID: AwsJson10SerializeNumberUnionValue
    #[test]
    fn test_aws_json10_serialize_number_union_value_request() {
        let input = JsonUnionsInput::builder()
            .contents(MyUnion::NumberValue(1))
            .build();
        let http_request = input.build_http_request();

        assert_eq!(http_request.method(), "POST");
        assert_eq!(http_request.uri().path(), "/");

        let expected_headers = &[
            ("Content-Type", "application/x-amz-json-1.0"),
            ("X-Amz-Target", "JsonRpc10.JsonUnions"),
        ];
        ::protocol_test_helpers::assert_ok(::protocol_test_helpers::validate_headers(
            &http_request,
            expected_headers,
        ));
        ::protocol_test_helpers::assert_ok(::protocol_test_helpers::validate_body(
            &http_request.body(),
            "{
            \"contents\": {
                \"numberValue\": 1
            }
        }",
            ::protocol_test_helpers::MediaType::from("application/json"),
        ));
    }
    /// Serializes a blob union value
    /// Test ID: AwsJson10SerializeBlobUnionValue
    #[test]
    fn test_aws_json10_serialize_blob_union_value_request() {
        let input = JsonUnionsInput::builder()
            .contents(MyUnion::BlobValue(::smithy_types::Blob::new("foo")))
            .build();
        let http_request = input.build_http_request();

        assert_eq!(http_request.method(), "POST");
        assert_eq!(http_request.uri().path(), "/");

        let expected_headers = &[
            ("Content-Type", "application/x-amz-json-1.0"),
            ("X-Amz-Target", "JsonRpc10.JsonUnions"),
        ];
        ::protocol_test_helpers::assert_ok(::protocol_test_helpers::validate_headers(
            &http_request,
            expected_headers,
        ));
        ::protocol_test_helpers::assert_ok(::protocol_test_helpers::validate_body(
            &http_request.body(),
            "{
            \"contents\": {
                \"blobValue\": \"Zm9v\"
            }
        }",
            ::protocol_test_helpers::MediaType::from("application/json"),
        ));
    }
    /// Serializes a timestamp union value
    /// Test ID: AwsJson10SerializeTimestampUnionValue
    #[test]
    fn test_aws_json10_serialize_timestamp_union_value_request() {
        let input = JsonUnionsInput::builder()
            .contents(MyUnion::TimestampValue(
                ::smithy_types::Instant::from_epoch_seconds(1398796238),
            ))
            .build();
        let http_request = input.build_http_request();

        assert_eq!(http_request.method(), "POST");
        assert_eq!(http_request.uri().path(), "/");

        let expected_headers = &[
            ("Content-Type", "application/x-amz-json-1.0"),
            ("X-Amz-Target", "JsonRpc10.JsonUnions"),
        ];
        ::protocol_test_helpers::assert_ok(::protocol_test_helpers::validate_headers(
            &http_request,
            expected_headers,
        ));
        ::protocol_test_helpers::assert_ok(::protocol_test_helpers::validate_body(
            &http_request.body(),
            "{
            \"contents\": {
                \"timestampValue\": 1398796238
            }
        }",
            ::protocol_test_helpers::MediaType::from("application/json"),
        ));
    }
    /// Serializes an enum union value
    /// Test ID: AwsJson10SerializeEnumUnionValue
    #[test]
    fn test_aws_json10_serialize_enum_union_value_request() {
        let input = JsonUnionsInput::builder()
            .contents(MyUnion::EnumValue(FooEnum::from("Foo")))
            .build();
        let http_request = input.build_http_request();

        assert_eq!(http_request.method(), "POST");
        assert_eq!(http_request.uri().path(), "/");

        let expected_headers = &[
            ("Content-Type", "application/x-amz-json-1.0"),
            ("X-Amz-Target", "JsonRpc10.JsonUnions"),
        ];
        ::protocol_test_helpers::assert_ok(::protocol_test_helpers::validate_headers(
            &http_request,
            expected_headers,
        ));
        ::protocol_test_helpers::assert_ok(::protocol_test_helpers::validate_body(
            &http_request.body(),
            "{
            \"contents\": {
                \"enumValue\": \"Foo\"
            }
        }",
            ::protocol_test_helpers::MediaType::from("application/json"),
        ));
    }
    /// Serializes a list union value
    /// Test ID: AwsJson10SerializeListUnionValue
    #[test]
    fn test_aws_json10_serialize_list_union_value_request() {
        let input = JsonUnionsInput::builder()
            .contents(MyUnion::ListValue(vec![
                "foo".to_string(),
                "bar".to_string(),
            ]))
            .build();
        let http_request = input.build_http_request();

        assert_eq!(http_request.method(), "POST");
        assert_eq!(http_request.uri().path(), "/");

        let expected_headers = &[
            ("Content-Type", "application/x-amz-json-1.0"),
            ("X-Amz-Target", "JsonRpc10.JsonUnions"),
        ];
        ::protocol_test_helpers::assert_ok(::protocol_test_helpers::validate_headers(
            &http_request,
            expected_headers,
        ));
        ::protocol_test_helpers::assert_ok(::protocol_test_helpers::validate_body(
            &http_request.body(),
            "{
            \"contents\": {
                \"listValue\": [\"foo\", \"bar\"]
            }
        }",
            ::protocol_test_helpers::MediaType::from("application/json"),
        ));
    }
    /// Serializes a map union value
    /// Test ID: AwsJson10SerializeMapUnionValue
    #[test]
    fn test_aws_json10_serialize_map_union_value_request() {
        let input = JsonUnionsInput::builder()
            .contents(MyUnion::MapValue({
                let mut ret = ::std::collections::HashMap::new();
                ret.insert("foo".to_string(), "bar".to_string());
                ret.insert("spam".to_string(), "eggs".to_string());
                ret
            }))
            .build();
        let http_request = input.build_http_request();

        assert_eq!(http_request.method(), "POST");
        assert_eq!(http_request.uri().path(), "/");

        let expected_headers = &[
            ("Content-Type", "application/x-amz-json-1.0"),
            ("X-Amz-Target", "JsonRpc10.JsonUnions"),
        ];
        ::protocol_test_helpers::assert_ok(::protocol_test_helpers::validate_headers(
            &http_request,
            expected_headers,
        ));
        ::protocol_test_helpers::assert_ok(::protocol_test_helpers::validate_body(
            &http_request.body(),
            "{
            \"contents\": {
                \"mapValue\": {
                    \"foo\": \"bar\",
                    \"spam\": \"eggs\"
                }
            }
        }",
            ::protocol_test_helpers::MediaType::from("application/json"),
        ));
    }
    /// Serializes a structure union value
    /// Test ID: AwsJson10SerializeStructureUnionValue
    #[test]
    fn test_aws_json10_serialize_structure_union_value_request() {
        let input = JsonUnionsInput::builder()
            .contents(MyUnion::StructureValue(
                GreetingStruct::builder().hi("hello".to_string()).build(),
            ))
            .build();
        let http_request = input.build_http_request();

        assert_eq!(http_request.method(), "POST");
        assert_eq!(http_request.uri().path(), "/");

        let expected_headers = &[
            ("Content-Type", "application/x-amz-json-1.0"),
            ("X-Amz-Target", "JsonRpc10.JsonUnions"),
        ];
        ::protocol_test_helpers::assert_ok(::protocol_test_helpers::validate_headers(
            &http_request,
            expected_headers,
        ));
        ::protocol_test_helpers::assert_ok(::protocol_test_helpers::validate_body(
            &http_request.body(),
            "{
            \"contents\": {
                \"structureValue\": {
                    \"hi\": \"hello\"
                }
            }
        }",
            ::protocol_test_helpers::MediaType::from("application/json"),
        ));
    }
    /// Deserializes a string union value
    /// Test ID: AwsJson10DeserializeStringUnionValue
    #[test]
    fn test_aws_json10_deserialize_string_union_value_response() {
        /* test case disabled for this protocol (not yet supported) */
    }
    /// Deserializes a boolean union value
    /// Test ID: AwsJson10DeserializeBooleanUnionValue
    #[test]
    fn test_aws_json10_deserialize_boolean_union_value_response() {
        /* test case disabled for this protocol (not yet supported) */
    }
    /// Deserializes a number union value
    /// Test ID: AwsJson10DeserializeNumberUnionValue
    #[test]
    fn test_aws_json10_deserialize_number_union_value_response() {
        /* test case disabled for this protocol (not yet supported) */
    }
    /// Deserializes a blob union value
    /// Test ID: AwsJson10DeserializeBlobUnionValue
    #[test]
    fn test_aws_json10_deserialize_blob_union_value_response() {
        /* test case disabled for this protocol (not yet supported) */
    }
    /// Deserializes a timestamp union value
    /// Test ID: AwsJson10DeserializeTimestampUnionValue
    #[test]
    fn test_aws_json10_deserialize_timestamp_union_value_response() {
        /* test case disabled for this protocol (not yet supported) */
    }
    /// Deserializes an enum union value
    /// Test ID: AwsJson10DeserializeEnumUnionValue
    #[test]
    fn test_aws_json10_deserialize_enum_union_value_response() {
        /* test case disabled for this protocol (not yet supported) */
    }
    /// Deserializes a list union value
    /// Test ID: AwsJson10DeserializeListUnionValue
    #[test]
    fn test_aws_json10_deserialize_list_union_value_response() {
        /* test case disabled for this protocol (not yet supported) */
    }
    /// Deserializes a map union value
    /// Test ID: AwsJson10DeserializeMapUnionValue
    #[test]
    fn test_aws_json10_deserialize_map_union_value_response() {
        /* test case disabled for this protocol (not yet supported) */
    }
    /// Deserializes a structure union value
    /// Test ID: AwsJson10DeserializeStructureUnionValue
    #[test]
    fn test_aws_json10_deserialize_structure_union_value_response() {
        /* test case disabled for this protocol (not yet supported) */
    }
}

/// The example tests how requests and responses are serialized when there's
/// no request or response payload because the operation has no input or output.
/// While this should be rare, code generators must support this.
pub struct NoInputAndNoOutput {
    input: NoInputAndNoOutputInput,
}
impl NoInputAndNoOutput {
    /// Creates a new builder-style object to manufacture [`NoInputAndNoOutputInput`](crate::input::NoInputAndNoOutputInput)
    pub fn builder() -> crate::input::no_input_and_no_output_input::Builder {
        crate::input::no_input_and_no_output_input::Builder::default()
    }
    pub fn build_http_request(&self) -> ::http::request::Request<Vec<u8>> {
        NoInputAndNoOutputInput::assemble(
            self.input.request_builder_base(),
            self.input.build_body(),
        )
    }
    pub fn new(input: NoInputAndNoOutputInput) -> Self {
        Self { input }
    }
}
#[cfg(test)]
#[allow(unreachable_code, unused_variables)]
mod no_input_and_no_output_request_test {

    use crate::input::NoInputAndNoOutputInput;
    /// No input serializes no payload
    /// Test ID: AwsJson10NoInputAndNoOutput
    #[test]
    fn test_aws_json10_no_input_and_no_output_request() {
        let input = NoInputAndNoOutputInput::builder().build();
        let http_request = input.build_http_request();

        assert_eq!(http_request.method(), "POST");
        assert_eq!(http_request.uri().path(), "/");

        let expected_headers = &[
            ("Content-Type", "application/x-amz-json-1.0"),
            ("X-Amz-Target", "JsonRpc10.NoInputAndNoOutput"),
        ];
        ::protocol_test_helpers::assert_ok(::protocol_test_helpers::validate_headers(
            &http_request,
            expected_headers,
        ));
        // No body
        assert!(&http_request.body().is_empty());
    }
    /// No output serializes no payload
    /// Test ID: AwsJson10NoInputAndNoOutput
    #[test]
    fn test_aws_json10_no_input_and_no_output_response() {
        /* test case disabled for this protocol (not yet supported) */
    }
}

/// The example tests how requests and responses are serialized when there's
/// no request or response payload because the operation has no input and the
/// output is empty. While this should be rare, code generators must support
/// this.
pub struct NoInputAndOutput {
    input: NoInputAndOutputInput,
}
impl NoInputAndOutput {
    /// Creates a new builder-style object to manufacture [`NoInputAndOutputInput`](crate::input::NoInputAndOutputInput)
    pub fn builder() -> crate::input::no_input_and_output_input::Builder {
        crate::input::no_input_and_output_input::Builder::default()
    }
    pub fn build_http_request(&self) -> ::http::request::Request<Vec<u8>> {
        NoInputAndOutputInput::assemble(self.input.request_builder_base(), self.input.build_body())
    }
    pub fn new(input: NoInputAndOutputInput) -> Self {
        Self { input }
    }
}
#[cfg(test)]
#[allow(unreachable_code, unused_variables)]
mod no_input_and_output_request_test {

    use crate::input::NoInputAndOutputInput;
    /// No input serializes no payload
    /// Test ID: AwsJson10NoInputAndOutput
    #[test]
    fn test_aws_json10_no_input_and_output_request() {
        let input = NoInputAndOutputInput::builder().build();
        let http_request = input.build_http_request();

        assert_eq!(http_request.method(), "POST");
        assert_eq!(http_request.uri().path(), "/");

        let expected_headers = &[
            ("Content-Type", "application/x-amz-json-1.0"),
            ("X-Amz-Target", "JsonRpc10.NoInputAndOutput"),
        ];
        ::protocol_test_helpers::assert_ok(::protocol_test_helpers::validate_headers(
            &http_request,
            expected_headers,
        ));
        // No body
        assert!(&http_request.body().is_empty());
    }
    /// Empty output serializes no payload
    /// Test ID: AwsJson10NoInputAndOutput
    #[test]
    fn test_aws_json10_no_input_and_output_response() {
        /* test case disabled for this protocol (not yet supported) */
    }
}
