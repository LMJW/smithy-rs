// Code generated by software.amazon.smithy.rust.codegen.smithy-rs. DO NOT EDIT.
/// <p>Ends a given Amazon QLDB journal stream. Before a stream can be canceled, its current
/// status must be <code>ACTIVE</code>.</p>
/// <p>You can't restart a stream after you cancel it. Canceled QLDB stream resources are
/// subject to a 7-day retention period, so they are automatically deleted after this limit
/// expires.</p>
#[derive(std::clone::Clone)]
pub struct CancelJournalKinesisStream {
    _private: (),
}
impl CancelJournalKinesisStream {
    /// Creates a new builder-style object to manufacture [`CancelJournalKinesisStreamInput`](crate::input::CancelJournalKinesisStreamInput)
    pub fn builder() -> crate::input::cancel_journal_kinesis_stream_input::Builder {
        crate::input::cancel_journal_kinesis_stream_input::Builder::default()
    }
    #[allow(clippy::unnecessary_wraps)]
    fn from_response(
        response: &http::response::Response<impl AsRef<[u8]>>,
    ) -> Result<
        crate::output::CancelJournalKinesisStreamOutput,
        crate::error::CancelJournalKinesisStreamError,
    > {
        if crate::aws_json_errors::is_error(&response) && response.status().as_u16() != 200 {
            let body = serde_json::from_slice(response.body().as_ref())
                .unwrap_or_else(|_| serde_json::json!({}));
            let generic = crate::aws_json_errors::parse_generic_error(&response, &body);

            let error_code = match generic.code() {
                Some(code) => code,
                None => {
                    return Err(crate::error::CancelJournalKinesisStreamError::unhandled(
                        generic,
                    ))
                }
            };
            return Err(match error_code {
                "InvalidParameterException" => crate::error::CancelJournalKinesisStreamError { meta: generic, kind: crate::error::CancelJournalKinesisStreamErrorKind::InvalidParameterError({
                    #[allow(unused_mut)]let mut output = crate::error::invalid_parameter_error::Builder::default();
                    let _ = response;
                    
                                        let body_slice = response.body().as_ref();
                    
                                        let parsed_body: crate::error::InvalidParameterError = if body_slice.is_empty() {
                                            // To enable JSON parsing to succeed, replace an empty body
                                            // with an empty JSON body. If a member was required, it will fail slightly later
                                            // during the operation construction phase.
                                            serde_json::from_slice(b"{}").map_err(crate::error::CancelJournalKinesisStreamError::unhandled)?
                                        } else {
                                            serde_json::from_slice(response.body().as_ref()).map_err(crate::error::CancelJournalKinesisStreamError::unhandled)?
                                        };
                                    
                    output = output.set_message(
                        parsed_body.message
                    );
                    output = output.set_parameter_name(
                        parsed_body.parameter_name
                    );
                    output.build()
                })},
                "ResourceNotFoundException" => crate::error::CancelJournalKinesisStreamError { meta: generic, kind: crate::error::CancelJournalKinesisStreamErrorKind::ResourceNotFoundError({
                    #[allow(unused_mut)]let mut output = crate::error::resource_not_found_error::Builder::default();
                    let _ = response;
                    
                                        let body_slice = response.body().as_ref();
                    
                                        let parsed_body: crate::error::ResourceNotFoundError = if body_slice.is_empty() {
                                            // To enable JSON parsing to succeed, replace an empty body
                                            // with an empty JSON body. If a member was required, it will fail slightly later
                                            // during the operation construction phase.
                                            serde_json::from_slice(b"{}").map_err(crate::error::CancelJournalKinesisStreamError::unhandled)?
                                        } else {
                                            serde_json::from_slice(response.body().as_ref()).map_err(crate::error::CancelJournalKinesisStreamError::unhandled)?
                                        };
                                    
                    output = output.set_message(
                        parsed_body.message
                    );
                    output = output.set_resource_type(
                        parsed_body.resource_type
                    );
                    output = output.set_resource_name(
                        parsed_body.resource_name
                    );
                    output.build()
                })},
                "ResourcePreconditionNotMetException" => crate::error::CancelJournalKinesisStreamError { meta: generic, kind: crate::error::CancelJournalKinesisStreamErrorKind::ResourcePreconditionNotMetError({
                    #[allow(unused_mut)]let mut output = crate::error::resource_precondition_not_met_error::Builder::default();
                    let _ = response;
                    
                                        let body_slice = response.body().as_ref();
                    
                                        let parsed_body: crate::error::ResourcePreconditionNotMetError = if body_slice.is_empty() {
                                            // To enable JSON parsing to succeed, replace an empty body
                                            // with an empty JSON body. If a member was required, it will fail slightly later
                                            // during the operation construction phase.
                                            serde_json::from_slice(b"{}").map_err(crate::error::CancelJournalKinesisStreamError::unhandled)?
                                        } else {
                                            serde_json::from_slice(response.body().as_ref()).map_err(crate::error::CancelJournalKinesisStreamError::unhandled)?
                                        };
                                    
                    output = output.set_message(
                        parsed_body.message
                    );
                    output = output.set_resource_type(
                        parsed_body.resource_type
                    );
                    output = output.set_resource_name(
                        parsed_body.resource_name
                    );
                    output.build()
                })},
                _ => crate::error::CancelJournalKinesisStreamError::generic(generic)
            });
        }
        Ok({
            #[allow(unused_mut)]
            let mut output =
                crate::output::cancel_journal_kinesis_stream_output::Builder::default();
            let _ = response;

            let body_slice = response.body().as_ref();

            let parsed_body: crate::serializer::CancelJournalKinesisStreamOutputBody =
                if body_slice.is_empty() {
                    // To enable JSON parsing to succeed, replace an empty body
                    // with an empty JSON body. If a member was required, it will fail slightly later
                    // during the operation construction phase.
                    serde_json::from_slice(b"{}")
                        .map_err(crate::error::CancelJournalKinesisStreamError::unhandled)?
                } else {
                    serde_json::from_slice(response.body().as_ref())
                        .map_err(crate::error::CancelJournalKinesisStreamError::unhandled)?
                };

            output = output.set_stream_id(parsed_body.stream_id);
            output.build()
        })
    }
    pub fn parse_response(
        &self,
        response: &http::response::Response<impl AsRef<[u8]>>,
    ) -> Result<
        crate::output::CancelJournalKinesisStreamOutput,
        crate::error::CancelJournalKinesisStreamError,
    > {
        Self::from_response(&response)
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}

impl smithy_http::response::ParseStrictResponse for CancelJournalKinesisStream {
    type Output = Result<
        crate::output::CancelJournalKinesisStreamOutput,
        crate::error::CancelJournalKinesisStreamError,
    >;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        self.parse_response(response)
    }
}

/// <p>Creates a new ledger in your AWS account.</p>
#[derive(std::clone::Clone)]
pub struct CreateLedger {
    _private: (),
}
impl CreateLedger {
    /// Creates a new builder-style object to manufacture [`CreateLedgerInput`](crate::input::CreateLedgerInput)
    pub fn builder() -> crate::input::create_ledger_input::Builder {
        crate::input::create_ledger_input::Builder::default()
    }
    #[allow(clippy::unnecessary_wraps)]
    fn from_response(
        response: &http::response::Response<impl AsRef<[u8]>>,
    ) -> Result<crate::output::CreateLedgerOutput, crate::error::CreateLedgerError> {
        if crate::aws_json_errors::is_error(&response) && response.status().as_u16() != 200 {
            let body = serde_json::from_slice(response.body().as_ref())
                .unwrap_or_else(|_| serde_json::json!({}));
            let generic = crate::aws_json_errors::parse_generic_error(&response, &body);

            let error_code = match generic.code() {
                Some(code) => code,
                None => return Err(crate::error::CreateLedgerError::unhandled(generic)),
            };
            return Err(match error_code {
                "InvalidParameterException" => crate::error::CreateLedgerError {
                    meta: generic,
                    kind: crate::error::CreateLedgerErrorKind::InvalidParameterError({
                        #[allow(unused_mut)]
                        let mut output = crate::error::invalid_parameter_error::Builder::default();
                        let _ = response;

                        let body_slice = response.body().as_ref();

                        let parsed_body: crate::error::InvalidParameterError =
                            if body_slice.is_empty() {
                                // To enable JSON parsing to succeed, replace an empty body
                                // with an empty JSON body. If a member was required, it will fail slightly later
                                // during the operation construction phase.
                                serde_json::from_slice(b"{}")
                                    .map_err(crate::error::CreateLedgerError::unhandled)?
                            } else {
                                serde_json::from_slice(response.body().as_ref())
                                    .map_err(crate::error::CreateLedgerError::unhandled)?
                            };

                        output = output.set_message(parsed_body.message);
                        output = output.set_parameter_name(parsed_body.parameter_name);
                        output.build()
                    }),
                },
                "LimitExceededException" => crate::error::CreateLedgerError {
                    meta: generic,
                    kind: crate::error::CreateLedgerErrorKind::LimitExceededError({
                        #[allow(unused_mut)]
                        let mut output = crate::error::limit_exceeded_error::Builder::default();
                        let _ = response;

                        let body_slice = response.body().as_ref();

                        let parsed_body: crate::error::LimitExceededError = if body_slice.is_empty()
                        {
                            // To enable JSON parsing to succeed, replace an empty body
                            // with an empty JSON body. If a member was required, it will fail slightly later
                            // during the operation construction phase.
                            serde_json::from_slice(b"{}")
                                .map_err(crate::error::CreateLedgerError::unhandled)?
                        } else {
                            serde_json::from_slice(response.body().as_ref())
                                .map_err(crate::error::CreateLedgerError::unhandled)?
                        };

                        output = output.set_message(parsed_body.message);
                        output = output.set_resource_type(parsed_body.resource_type);
                        output.build()
                    }),
                },
                "ResourceAlreadyExistsException" => crate::error::CreateLedgerError {
                    meta: generic,
                    kind: crate::error::CreateLedgerErrorKind::ResourceAlreadyExistsError({
                        #[allow(unused_mut)]
                        let mut output =
                            crate::error::resource_already_exists_error::Builder::default();
                        let _ = response;

                        let body_slice = response.body().as_ref();

                        let parsed_body: crate::error::ResourceAlreadyExistsError =
                            if body_slice.is_empty() {
                                // To enable JSON parsing to succeed, replace an empty body
                                // with an empty JSON body. If a member was required, it will fail slightly later
                                // during the operation construction phase.
                                serde_json::from_slice(b"{}")
                                    .map_err(crate::error::CreateLedgerError::unhandled)?
                            } else {
                                serde_json::from_slice(response.body().as_ref())
                                    .map_err(crate::error::CreateLedgerError::unhandled)?
                            };

                        output = output.set_message(parsed_body.message);
                        output = output.set_resource_type(parsed_body.resource_type);
                        output = output.set_resource_name(parsed_body.resource_name);
                        output.build()
                    }),
                },
                "ResourceInUseException" => crate::error::CreateLedgerError {
                    meta: generic,
                    kind: crate::error::CreateLedgerErrorKind::ResourceInUseError({
                        #[allow(unused_mut)]
                        let mut output = crate::error::resource_in_use_error::Builder::default();
                        let _ = response;

                        let body_slice = response.body().as_ref();

                        let parsed_body: crate::error::ResourceInUseError = if body_slice.is_empty()
                        {
                            // To enable JSON parsing to succeed, replace an empty body
                            // with an empty JSON body. If a member was required, it will fail slightly later
                            // during the operation construction phase.
                            serde_json::from_slice(b"{}")
                                .map_err(crate::error::CreateLedgerError::unhandled)?
                        } else {
                            serde_json::from_slice(response.body().as_ref())
                                .map_err(crate::error::CreateLedgerError::unhandled)?
                        };

                        output = output.set_message(parsed_body.message);
                        output = output.set_resource_type(parsed_body.resource_type);
                        output = output.set_resource_name(parsed_body.resource_name);
                        output.build()
                    }),
                },
                _ => crate::error::CreateLedgerError::generic(generic),
            });
        }
        Ok({
            #[allow(unused_mut)]
            let mut output = crate::output::create_ledger_output::Builder::default();
            let _ = response;

            let body_slice = response.body().as_ref();

            let parsed_body: crate::serializer::CreateLedgerOutputBody = if body_slice.is_empty() {
                // To enable JSON parsing to succeed, replace an empty body
                // with an empty JSON body. If a member was required, it will fail slightly later
                // during the operation construction phase.
                serde_json::from_slice(b"{}").map_err(crate::error::CreateLedgerError::unhandled)?
            } else {
                serde_json::from_slice(response.body().as_ref())
                    .map_err(crate::error::CreateLedgerError::unhandled)?
            };

            output = output.set_name(parsed_body.name);
            output = output.set_arn(parsed_body.arn);
            output = output.set_state(parsed_body.state);
            output = output.set_creation_date_time(parsed_body.creation_date_time);
            output = output.set_deletion_protection(parsed_body.deletion_protection);
            output.build()
        })
    }
    pub fn parse_response(
        &self,
        response: &http::response::Response<impl AsRef<[u8]>>,
    ) -> Result<crate::output::CreateLedgerOutput, crate::error::CreateLedgerError> {
        Self::from_response(&response)
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}

impl smithy_http::response::ParseStrictResponse for CreateLedger {
    type Output = Result<crate::output::CreateLedgerOutput, crate::error::CreateLedgerError>;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        self.parse_response(response)
    }
}

/// <p>Deletes a ledger and all of its contents. This action is irreversible.</p>
/// <p>If deletion protection is enabled, you must first disable it before you can delete the
/// ledger using the QLDB API or the AWS Command Line Interface (AWS CLI). You can disable it by calling the
/// <code>UpdateLedger</code> operation to set the flag to <code>false</code>. The QLDB
/// console disables deletion protection for you when you use it to delete a ledger.</p>
#[derive(std::clone::Clone)]
pub struct DeleteLedger {
    _private: (),
}
impl DeleteLedger {
    /// Creates a new builder-style object to manufacture [`DeleteLedgerInput`](crate::input::DeleteLedgerInput)
    pub fn builder() -> crate::input::delete_ledger_input::Builder {
        crate::input::delete_ledger_input::Builder::default()
    }
    #[allow(clippy::unnecessary_wraps)]
    fn from_response(
        response: &http::response::Response<impl AsRef<[u8]>>,
    ) -> Result<crate::output::DeleteLedgerOutput, crate::error::DeleteLedgerError> {
        if crate::aws_json_errors::is_error(&response) && response.status().as_u16() != 200 {
            let body = serde_json::from_slice(response.body().as_ref())
                .unwrap_or_else(|_| serde_json::json!({}));
            let generic = crate::aws_json_errors::parse_generic_error(&response, &body);

            let error_code = match generic.code() {
                Some(code) => code,
                None => return Err(crate::error::DeleteLedgerError::unhandled(generic)),
            };
            return Err(match error_code {
                "InvalidParameterException" => crate::error::DeleteLedgerError {
                    meta: generic,
                    kind: crate::error::DeleteLedgerErrorKind::InvalidParameterError({
                        #[allow(unused_mut)]
                        let mut output = crate::error::invalid_parameter_error::Builder::default();
                        let _ = response;

                        let body_slice = response.body().as_ref();

                        let parsed_body: crate::error::InvalidParameterError =
                            if body_slice.is_empty() {
                                // To enable JSON parsing to succeed, replace an empty body
                                // with an empty JSON body. If a member was required, it will fail slightly later
                                // during the operation construction phase.
                                serde_json::from_slice(b"{}")
                                    .map_err(crate::error::DeleteLedgerError::unhandled)?
                            } else {
                                serde_json::from_slice(response.body().as_ref())
                                    .map_err(crate::error::DeleteLedgerError::unhandled)?
                            };

                        output = output.set_message(parsed_body.message);
                        output = output.set_parameter_name(parsed_body.parameter_name);
                        output.build()
                    }),
                },
                "ResourceInUseException" => crate::error::DeleteLedgerError {
                    meta: generic,
                    kind: crate::error::DeleteLedgerErrorKind::ResourceInUseError({
                        #[allow(unused_mut)]
                        let mut output = crate::error::resource_in_use_error::Builder::default();
                        let _ = response;

                        let body_slice = response.body().as_ref();

                        let parsed_body: crate::error::ResourceInUseError = if body_slice.is_empty()
                        {
                            // To enable JSON parsing to succeed, replace an empty body
                            // with an empty JSON body. If a member was required, it will fail slightly later
                            // during the operation construction phase.
                            serde_json::from_slice(b"{}")
                                .map_err(crate::error::DeleteLedgerError::unhandled)?
                        } else {
                            serde_json::from_slice(response.body().as_ref())
                                .map_err(crate::error::DeleteLedgerError::unhandled)?
                        };

                        output = output.set_message(parsed_body.message);
                        output = output.set_resource_type(parsed_body.resource_type);
                        output = output.set_resource_name(parsed_body.resource_name);
                        output.build()
                    }),
                },
                "ResourceNotFoundException" => crate::error::DeleteLedgerError {
                    meta: generic,
                    kind: crate::error::DeleteLedgerErrorKind::ResourceNotFoundError({
                        #[allow(unused_mut)]
                        let mut output = crate::error::resource_not_found_error::Builder::default();
                        let _ = response;

                        let body_slice = response.body().as_ref();

                        let parsed_body: crate::error::ResourceNotFoundError =
                            if body_slice.is_empty() {
                                // To enable JSON parsing to succeed, replace an empty body
                                // with an empty JSON body. If a member was required, it will fail slightly later
                                // during the operation construction phase.
                                serde_json::from_slice(b"{}")
                                    .map_err(crate::error::DeleteLedgerError::unhandled)?
                            } else {
                                serde_json::from_slice(response.body().as_ref())
                                    .map_err(crate::error::DeleteLedgerError::unhandled)?
                            };

                        output = output.set_message(parsed_body.message);
                        output = output.set_resource_type(parsed_body.resource_type);
                        output = output.set_resource_name(parsed_body.resource_name);
                        output.build()
                    }),
                },
                "ResourcePreconditionNotMetException" => crate::error::DeleteLedgerError {
                    meta: generic,
                    kind: crate::error::DeleteLedgerErrorKind::ResourcePreconditionNotMetError({
                        #[allow(unused_mut)]
                        let mut output =
                            crate::error::resource_precondition_not_met_error::Builder::default();
                        let _ = response;

                        let body_slice = response.body().as_ref();

                        let parsed_body: crate::error::ResourcePreconditionNotMetError =
                            if body_slice.is_empty() {
                                // To enable JSON parsing to succeed, replace an empty body
                                // with an empty JSON body. If a member was required, it will fail slightly later
                                // during the operation construction phase.
                                serde_json::from_slice(b"{}")
                                    .map_err(crate::error::DeleteLedgerError::unhandled)?
                            } else {
                                serde_json::from_slice(response.body().as_ref())
                                    .map_err(crate::error::DeleteLedgerError::unhandled)?
                            };

                        output = output.set_message(parsed_body.message);
                        output = output.set_resource_type(parsed_body.resource_type);
                        output = output.set_resource_name(parsed_body.resource_name);
                        output.build()
                    }),
                },
                _ => crate::error::DeleteLedgerError::generic(generic),
            });
        }
        Ok({
            #[allow(unused_mut)]
            let mut output = crate::output::delete_ledger_output::Builder::default();
            let _ = response;
            output.build()
        })
    }
    pub fn parse_response(
        &self,
        response: &http::response::Response<impl AsRef<[u8]>>,
    ) -> Result<crate::output::DeleteLedgerOutput, crate::error::DeleteLedgerError> {
        Self::from_response(&response)
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}

impl smithy_http::response::ParseStrictResponse for DeleteLedger {
    type Output = Result<crate::output::DeleteLedgerOutput, crate::error::DeleteLedgerError>;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        self.parse_response(response)
    }
}

/// <p>Returns detailed information about a given Amazon QLDB journal stream. The output
/// includes the Amazon Resource Name (ARN), stream name, current status, creation time, and
/// the parameters of your original stream creation request.</p>
#[derive(std::clone::Clone)]
pub struct DescribeJournalKinesisStream {
    _private: (),
}
impl DescribeJournalKinesisStream {
    /// Creates a new builder-style object to manufacture [`DescribeJournalKinesisStreamInput`](crate::input::DescribeJournalKinesisStreamInput)
    pub fn builder() -> crate::input::describe_journal_kinesis_stream_input::Builder {
        crate::input::describe_journal_kinesis_stream_input::Builder::default()
    }
    #[allow(clippy::unnecessary_wraps)]
    fn from_response(
        response: &http::response::Response<impl AsRef<[u8]>>,
    ) -> Result<
        crate::output::DescribeJournalKinesisStreamOutput,
        crate::error::DescribeJournalKinesisStreamError,
    > {
        if crate::aws_json_errors::is_error(&response) && response.status().as_u16() != 200 {
            let body = serde_json::from_slice(response.body().as_ref())
                .unwrap_or_else(|_| serde_json::json!({}));
            let generic = crate::aws_json_errors::parse_generic_error(&response, &body);

            let error_code = match generic.code() {
                Some(code) => code,
                None => {
                    return Err(crate::error::DescribeJournalKinesisStreamError::unhandled(
                        generic,
                    ))
                }
            };
            return Err(match error_code {
                "InvalidParameterException" => crate::error::DescribeJournalKinesisStreamError { meta: generic, kind: crate::error::DescribeJournalKinesisStreamErrorKind::InvalidParameterError({
                    #[allow(unused_mut)]let mut output = crate::error::invalid_parameter_error::Builder::default();
                    let _ = response;
                    
                                        let body_slice = response.body().as_ref();
                    
                                        let parsed_body: crate::error::InvalidParameterError = if body_slice.is_empty() {
                                            // To enable JSON parsing to succeed, replace an empty body
                                            // with an empty JSON body. If a member was required, it will fail slightly later
                                            // during the operation construction phase.
                                            serde_json::from_slice(b"{}").map_err(crate::error::DescribeJournalKinesisStreamError::unhandled)?
                                        } else {
                                            serde_json::from_slice(response.body().as_ref()).map_err(crate::error::DescribeJournalKinesisStreamError::unhandled)?
                                        };
                                    
                    output = output.set_message(
                        parsed_body.message
                    );
                    output = output.set_parameter_name(
                        parsed_body.parameter_name
                    );
                    output.build()
                })},
                "ResourceNotFoundException" => crate::error::DescribeJournalKinesisStreamError { meta: generic, kind: crate::error::DescribeJournalKinesisStreamErrorKind::ResourceNotFoundError({
                    #[allow(unused_mut)]let mut output = crate::error::resource_not_found_error::Builder::default();
                    let _ = response;
                    
                                        let body_slice = response.body().as_ref();
                    
                                        let parsed_body: crate::error::ResourceNotFoundError = if body_slice.is_empty() {
                                            // To enable JSON parsing to succeed, replace an empty body
                                            // with an empty JSON body. If a member was required, it will fail slightly later
                                            // during the operation construction phase.
                                            serde_json::from_slice(b"{}").map_err(crate::error::DescribeJournalKinesisStreamError::unhandled)?
                                        } else {
                                            serde_json::from_slice(response.body().as_ref()).map_err(crate::error::DescribeJournalKinesisStreamError::unhandled)?
                                        };
                                    
                    output = output.set_message(
                        parsed_body.message
                    );
                    output = output.set_resource_type(
                        parsed_body.resource_type
                    );
                    output = output.set_resource_name(
                        parsed_body.resource_name
                    );
                    output.build()
                })},
                "ResourcePreconditionNotMetException" => crate::error::DescribeJournalKinesisStreamError { meta: generic, kind: crate::error::DescribeJournalKinesisStreamErrorKind::ResourcePreconditionNotMetError({
                    #[allow(unused_mut)]let mut output = crate::error::resource_precondition_not_met_error::Builder::default();
                    let _ = response;
                    
                                        let body_slice = response.body().as_ref();
                    
                                        let parsed_body: crate::error::ResourcePreconditionNotMetError = if body_slice.is_empty() {
                                            // To enable JSON parsing to succeed, replace an empty body
                                            // with an empty JSON body. If a member was required, it will fail slightly later
                                            // during the operation construction phase.
                                            serde_json::from_slice(b"{}").map_err(crate::error::DescribeJournalKinesisStreamError::unhandled)?
                                        } else {
                                            serde_json::from_slice(response.body().as_ref()).map_err(crate::error::DescribeJournalKinesisStreamError::unhandled)?
                                        };
                                    
                    output = output.set_message(
                        parsed_body.message
                    );
                    output = output.set_resource_type(
                        parsed_body.resource_type
                    );
                    output = output.set_resource_name(
                        parsed_body.resource_name
                    );
                    output.build()
                })},
                _ => crate::error::DescribeJournalKinesisStreamError::generic(generic)
            });
        }
        Ok({
            #[allow(unused_mut)]
            let mut output =
                crate::output::describe_journal_kinesis_stream_output::Builder::default();
            let _ = response;

            let body_slice = response.body().as_ref();

            let parsed_body: crate::serializer::DescribeJournalKinesisStreamOutputBody =
                if body_slice.is_empty() {
                    // To enable JSON parsing to succeed, replace an empty body
                    // with an empty JSON body. If a member was required, it will fail slightly later
                    // during the operation construction phase.
                    serde_json::from_slice(b"{}")
                        .map_err(crate::error::DescribeJournalKinesisStreamError::unhandled)?
                } else {
                    serde_json::from_slice(response.body().as_ref())
                        .map_err(crate::error::DescribeJournalKinesisStreamError::unhandled)?
                };

            output = output.set_stream(parsed_body.stream);
            output.build()
        })
    }
    pub fn parse_response(
        &self,
        response: &http::response::Response<impl AsRef<[u8]>>,
    ) -> Result<
        crate::output::DescribeJournalKinesisStreamOutput,
        crate::error::DescribeJournalKinesisStreamError,
    > {
        Self::from_response(&response)
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}

impl smithy_http::response::ParseStrictResponse for DescribeJournalKinesisStream {
    type Output = Result<
        crate::output::DescribeJournalKinesisStreamOutput,
        crate::error::DescribeJournalKinesisStreamError,
    >;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        self.parse_response(response)
    }
}

/// <p>Returns information about a journal export job, including the ledger name, export ID,
/// when it was created, current status, and its start and end time export parameters.</p>
/// <p>This action does not return any expired export jobs. For more information, see <a href="https://docs.aws.amazon.com/qldb/latest/developerguide/export-journal.request.html#export-journal.request.expiration">Export Job Expiration</a> in the <i>Amazon QLDB Developer
/// Guide</i>.</p>
/// <p>If the export job with the given <code>ExportId</code> doesn't exist, then throws
/// <code>ResourceNotFoundException</code>.</p>
/// <p>If the ledger with the given <code>Name</code> doesn't exist, then throws
/// <code>ResourceNotFoundException</code>.</p>
#[derive(std::clone::Clone)]
pub struct DescribeJournalS3Export {
    _private: (),
}
impl DescribeJournalS3Export {
    /// Creates a new builder-style object to manufacture [`DescribeJournalS3ExportInput`](crate::input::DescribeJournalS3ExportInput)
    pub fn builder() -> crate::input::describe_journal_s3_export_input::Builder {
        crate::input::describe_journal_s3_export_input::Builder::default()
    }
    #[allow(clippy::unnecessary_wraps)]
    fn from_response(
        response: &http::response::Response<impl AsRef<[u8]>>,
    ) -> Result<
        crate::output::DescribeJournalS3ExportOutput,
        crate::error::DescribeJournalS3ExportError,
    > {
        if crate::aws_json_errors::is_error(&response) && response.status().as_u16() != 200 {
            let body = serde_json::from_slice(response.body().as_ref())
                .unwrap_or_else(|_| serde_json::json!({}));
            let generic = crate::aws_json_errors::parse_generic_error(&response, &body);

            let error_code = match generic.code() {
                Some(code) => code,
                None => {
                    return Err(crate::error::DescribeJournalS3ExportError::unhandled(
                        generic,
                    ))
                }
            };
            return Err(match error_code {
                "ResourceNotFoundException" => crate::error::DescribeJournalS3ExportError {
                    meta: generic,
                    kind: crate::error::DescribeJournalS3ExportErrorKind::ResourceNotFoundError({
                        #[allow(unused_mut)]
                        let mut output = crate::error::resource_not_found_error::Builder::default();
                        let _ = response;

                        let body_slice = response.body().as_ref();

                        let parsed_body: crate::error::ResourceNotFoundError = if body_slice
                            .is_empty()
                        {
                            // To enable JSON parsing to succeed, replace an empty body
                            // with an empty JSON body. If a member was required, it will fail slightly later
                            // during the operation construction phase.
                            serde_json::from_slice(b"{}")
                                .map_err(crate::error::DescribeJournalS3ExportError::unhandled)?
                        } else {
                            serde_json::from_slice(response.body().as_ref())
                                .map_err(crate::error::DescribeJournalS3ExportError::unhandled)?
                        };

                        output = output.set_message(parsed_body.message);
                        output = output.set_resource_type(parsed_body.resource_type);
                        output = output.set_resource_name(parsed_body.resource_name);
                        output.build()
                    }),
                },
                _ => crate::error::DescribeJournalS3ExportError::generic(generic),
            });
        }
        Ok({
            #[allow(unused_mut)]
            let mut output = crate::output::describe_journal_s3_export_output::Builder::default();
            let _ = response;

            let body_slice = response.body().as_ref();

            let parsed_body: crate::serializer::DescribeJournalS3ExportOutputBody =
                if body_slice.is_empty() {
                    // To enable JSON parsing to succeed, replace an empty body
                    // with an empty JSON body. If a member was required, it will fail slightly later
                    // during the operation construction phase.
                    serde_json::from_slice(b"{}")
                        .map_err(crate::error::DescribeJournalS3ExportError::unhandled)?
                } else {
                    serde_json::from_slice(response.body().as_ref())
                        .map_err(crate::error::DescribeJournalS3ExportError::unhandled)?
                };

            output = output.set_export_description(parsed_body.export_description);
            output.build()
        })
    }
    pub fn parse_response(
        &self,
        response: &http::response::Response<impl AsRef<[u8]>>,
    ) -> Result<
        crate::output::DescribeJournalS3ExportOutput,
        crate::error::DescribeJournalS3ExportError,
    > {
        Self::from_response(&response)
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}

impl smithy_http::response::ParseStrictResponse for DescribeJournalS3Export {
    type Output = Result<
        crate::output::DescribeJournalS3ExportOutput,
        crate::error::DescribeJournalS3ExportError,
    >;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        self.parse_response(response)
    }
}

/// <p>Returns information about a ledger, including its state and when it was created.</p>
#[derive(std::clone::Clone)]
pub struct DescribeLedger {
    _private: (),
}
impl DescribeLedger {
    /// Creates a new builder-style object to manufacture [`DescribeLedgerInput`](crate::input::DescribeLedgerInput)
    pub fn builder() -> crate::input::describe_ledger_input::Builder {
        crate::input::describe_ledger_input::Builder::default()
    }
    #[allow(clippy::unnecessary_wraps)]
    fn from_response(
        response: &http::response::Response<impl AsRef<[u8]>>,
    ) -> Result<crate::output::DescribeLedgerOutput, crate::error::DescribeLedgerError> {
        if crate::aws_json_errors::is_error(&response) && response.status().as_u16() != 200 {
            let body = serde_json::from_slice(response.body().as_ref())
                .unwrap_or_else(|_| serde_json::json!({}));
            let generic = crate::aws_json_errors::parse_generic_error(&response, &body);

            let error_code = match generic.code() {
                Some(code) => code,
                None => return Err(crate::error::DescribeLedgerError::unhandled(generic)),
            };
            return Err(match error_code {
                "InvalidParameterException" => crate::error::DescribeLedgerError {
                    meta: generic,
                    kind: crate::error::DescribeLedgerErrorKind::InvalidParameterError({
                        #[allow(unused_mut)]
                        let mut output = crate::error::invalid_parameter_error::Builder::default();
                        let _ = response;

                        let body_slice = response.body().as_ref();

                        let parsed_body: crate::error::InvalidParameterError =
                            if body_slice.is_empty() {
                                // To enable JSON parsing to succeed, replace an empty body
                                // with an empty JSON body. If a member was required, it will fail slightly later
                                // during the operation construction phase.
                                serde_json::from_slice(b"{}")
                                    .map_err(crate::error::DescribeLedgerError::unhandled)?
                            } else {
                                serde_json::from_slice(response.body().as_ref())
                                    .map_err(crate::error::DescribeLedgerError::unhandled)?
                            };

                        output = output.set_message(parsed_body.message);
                        output = output.set_parameter_name(parsed_body.parameter_name);
                        output.build()
                    }),
                },
                "ResourceNotFoundException" => crate::error::DescribeLedgerError {
                    meta: generic,
                    kind: crate::error::DescribeLedgerErrorKind::ResourceNotFoundError({
                        #[allow(unused_mut)]
                        let mut output = crate::error::resource_not_found_error::Builder::default();
                        let _ = response;

                        let body_slice = response.body().as_ref();

                        let parsed_body: crate::error::ResourceNotFoundError =
                            if body_slice.is_empty() {
                                // To enable JSON parsing to succeed, replace an empty body
                                // with an empty JSON body. If a member was required, it will fail slightly later
                                // during the operation construction phase.
                                serde_json::from_slice(b"{}")
                                    .map_err(crate::error::DescribeLedgerError::unhandled)?
                            } else {
                                serde_json::from_slice(response.body().as_ref())
                                    .map_err(crate::error::DescribeLedgerError::unhandled)?
                            };

                        output = output.set_message(parsed_body.message);
                        output = output.set_resource_type(parsed_body.resource_type);
                        output = output.set_resource_name(parsed_body.resource_name);
                        output.build()
                    }),
                },
                _ => crate::error::DescribeLedgerError::generic(generic),
            });
        }
        Ok({
            #[allow(unused_mut)]
            let mut output = crate::output::describe_ledger_output::Builder::default();
            let _ = response;

            let body_slice = response.body().as_ref();

            let parsed_body: crate::serializer::DescribeLedgerOutputBody = if body_slice.is_empty()
            {
                // To enable JSON parsing to succeed, replace an empty body
                // with an empty JSON body. If a member was required, it will fail slightly later
                // during the operation construction phase.
                serde_json::from_slice(b"{}")
                    .map_err(crate::error::DescribeLedgerError::unhandled)?
            } else {
                serde_json::from_slice(response.body().as_ref())
                    .map_err(crate::error::DescribeLedgerError::unhandled)?
            };

            output = output.set_name(parsed_body.name);
            output = output.set_arn(parsed_body.arn);
            output = output.set_state(parsed_body.state);
            output = output.set_creation_date_time(parsed_body.creation_date_time);
            output = output.set_deletion_protection(parsed_body.deletion_protection);
            output.build()
        })
    }
    pub fn parse_response(
        &self,
        response: &http::response::Response<impl AsRef<[u8]>>,
    ) -> Result<crate::output::DescribeLedgerOutput, crate::error::DescribeLedgerError> {
        Self::from_response(&response)
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}

impl smithy_http::response::ParseStrictResponse for DescribeLedger {
    type Output = Result<crate::output::DescribeLedgerOutput, crate::error::DescribeLedgerError>;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        self.parse_response(response)
    }
}

/// <p>Exports journal contents within a date and time range from a ledger into a specified
/// Amazon Simple Storage Service (Amazon S3) bucket. The data is written as files in Amazon Ion format.</p>
/// <p>If the ledger with the given <code>Name</code> doesn't exist, then throws
/// <code>ResourceNotFoundException</code>.</p>
/// <p>If the ledger with the given <code>Name</code> is in <code>CREATING</code> status, then
/// throws <code>ResourcePreconditionNotMetException</code>.</p>
/// <p>You can initiate up to two concurrent journal export requests for each ledger. Beyond
/// this limit, journal export requests throw <code>LimitExceededException</code>.</p>
#[derive(std::clone::Clone)]
pub struct ExportJournalToS3 {
    _private: (),
}
impl ExportJournalToS3 {
    /// Creates a new builder-style object to manufacture [`ExportJournalToS3Input`](crate::input::ExportJournalToS3Input)
    pub fn builder() -> crate::input::export_journal_to_s3_input::Builder {
        crate::input::export_journal_to_s3_input::Builder::default()
    }
    #[allow(clippy::unnecessary_wraps)]
    fn from_response(
        response: &http::response::Response<impl AsRef<[u8]>>,
    ) -> Result<crate::output::ExportJournalToS3Output, crate::error::ExportJournalToS3Error> {
        if crate::aws_json_errors::is_error(&response) && response.status().as_u16() != 200 {
            let body = serde_json::from_slice(response.body().as_ref())
                .unwrap_or_else(|_| serde_json::json!({}));
            let generic = crate::aws_json_errors::parse_generic_error(&response, &body);

            let error_code = match generic.code() {
                Some(code) => code,
                None => return Err(crate::error::ExportJournalToS3Error::unhandled(generic)),
            };
            return Err(match error_code {
                "ResourceNotFoundException" => crate::error::ExportJournalToS3Error {
                    meta: generic,
                    kind: crate::error::ExportJournalToS3ErrorKind::ResourceNotFoundError({
                        #[allow(unused_mut)]
                        let mut output = crate::error::resource_not_found_error::Builder::default();
                        let _ = response;

                        let body_slice = response.body().as_ref();

                        let parsed_body: crate::error::ResourceNotFoundError =
                            if body_slice.is_empty() {
                                // To enable JSON parsing to succeed, replace an empty body
                                // with an empty JSON body. If a member was required, it will fail slightly later
                                // during the operation construction phase.
                                serde_json::from_slice(b"{}")
                                    .map_err(crate::error::ExportJournalToS3Error::unhandled)?
                            } else {
                                serde_json::from_slice(response.body().as_ref())
                                    .map_err(crate::error::ExportJournalToS3Error::unhandled)?
                            };

                        output = output.set_message(parsed_body.message);
                        output = output.set_resource_type(parsed_body.resource_type);
                        output = output.set_resource_name(parsed_body.resource_name);
                        output.build()
                    }),
                },
                "ResourcePreconditionNotMetException" => crate::error::ExportJournalToS3Error {
                    meta: generic,
                    kind: crate::error::ExportJournalToS3ErrorKind::ResourcePreconditionNotMetError(
                        {
                            #[allow(unused_mut)]
                            let mut output =
                                crate::error::resource_precondition_not_met_error::Builder::default(
                                );
                            let _ = response;

                            let body_slice = response.body().as_ref();

                            let parsed_body: crate::error::ResourcePreconditionNotMetError =
                                if body_slice.is_empty() {
                                    // To enable JSON parsing to succeed, replace an empty body
                                    // with an empty JSON body. If a member was required, it will fail slightly later
                                    // during the operation construction phase.
                                    serde_json::from_slice(b"{}")
                                        .map_err(crate::error::ExportJournalToS3Error::unhandled)?
                                } else {
                                    serde_json::from_slice(response.body().as_ref())
                                        .map_err(crate::error::ExportJournalToS3Error::unhandled)?
                                };

                            output = output.set_message(parsed_body.message);
                            output = output.set_resource_type(parsed_body.resource_type);
                            output = output.set_resource_name(parsed_body.resource_name);
                            output.build()
                        },
                    ),
                },
                _ => crate::error::ExportJournalToS3Error::generic(generic),
            });
        }
        Ok({
            #[allow(unused_mut)]
            let mut output = crate::output::export_journal_to_s3_output::Builder::default();
            let _ = response;

            let body_slice = response.body().as_ref();

            let parsed_body: crate::serializer::ExportJournalToS3OutputBody =
                if body_slice.is_empty() {
                    // To enable JSON parsing to succeed, replace an empty body
                    // with an empty JSON body. If a member was required, it will fail slightly later
                    // during the operation construction phase.
                    serde_json::from_slice(b"{}")
                        .map_err(crate::error::ExportJournalToS3Error::unhandled)?
                } else {
                    serde_json::from_slice(response.body().as_ref())
                        .map_err(crate::error::ExportJournalToS3Error::unhandled)?
                };

            output = output.set_export_id(parsed_body.export_id);
            output.build()
        })
    }
    pub fn parse_response(
        &self,
        response: &http::response::Response<impl AsRef<[u8]>>,
    ) -> Result<crate::output::ExportJournalToS3Output, crate::error::ExportJournalToS3Error> {
        Self::from_response(&response)
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}

impl smithy_http::response::ParseStrictResponse for ExportJournalToS3 {
    type Output =
        Result<crate::output::ExportJournalToS3Output, crate::error::ExportJournalToS3Error>;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        self.parse_response(response)
    }
}

/// <p>Returns a block object at a specified address in a journal. Also returns a proof of the
/// specified block for verification if <code>DigestTipAddress</code> is provided.</p>
/// <p>For information about the data contents in a block, see <a href="https://docs.aws.amazon.com/qldb/latest/developerguide/journal-contents.html">Journal contents</a> in the
/// <i>Amazon QLDB Developer Guide</i>.</p>
/// <p>If the specified ledger doesn't exist or is in <code>DELETING</code> status, then throws
/// <code>ResourceNotFoundException</code>.</p>
/// <p>If the specified ledger is in <code>CREATING</code> status, then throws
/// <code>ResourcePreconditionNotMetException</code>.</p>
/// <p>If no block exists with the specified address, then throws
/// <code>InvalidParameterException</code>.</p>
#[derive(std::clone::Clone)]
pub struct GetBlock {
    _private: (),
}
impl GetBlock {
    /// Creates a new builder-style object to manufacture [`GetBlockInput`](crate::input::GetBlockInput)
    pub fn builder() -> crate::input::get_block_input::Builder {
        crate::input::get_block_input::Builder::default()
    }
    #[allow(clippy::unnecessary_wraps)]
    fn from_response(
        response: &http::response::Response<impl AsRef<[u8]>>,
    ) -> Result<crate::output::GetBlockOutput, crate::error::GetBlockError> {
        if crate::aws_json_errors::is_error(&response) && response.status().as_u16() != 200 {
            let body = serde_json::from_slice(response.body().as_ref())
                .unwrap_or_else(|_| serde_json::json!({}));
            let generic = crate::aws_json_errors::parse_generic_error(&response, &body);

            let error_code = match generic.code() {
                Some(code) => code,
                None => return Err(crate::error::GetBlockError::unhandled(generic)),
            };
            return Err(match error_code {
                "InvalidParameterException" => crate::error::GetBlockError {
                    meta: generic,
                    kind: crate::error::GetBlockErrorKind::InvalidParameterError({
                        #[allow(unused_mut)]
                        let mut output = crate::error::invalid_parameter_error::Builder::default();
                        let _ = response;

                        let body_slice = response.body().as_ref();

                        let parsed_body: crate::error::InvalidParameterError =
                            if body_slice.is_empty() {
                                // To enable JSON parsing to succeed, replace an empty body
                                // with an empty JSON body. If a member was required, it will fail slightly later
                                // during the operation construction phase.
                                serde_json::from_slice(b"{}")
                                    .map_err(crate::error::GetBlockError::unhandled)?
                            } else {
                                serde_json::from_slice(response.body().as_ref())
                                    .map_err(crate::error::GetBlockError::unhandled)?
                            };

                        output = output.set_message(parsed_body.message);
                        output = output.set_parameter_name(parsed_body.parameter_name);
                        output.build()
                    }),
                },
                "ResourceNotFoundException" => crate::error::GetBlockError {
                    meta: generic,
                    kind: crate::error::GetBlockErrorKind::ResourceNotFoundError({
                        #[allow(unused_mut)]
                        let mut output = crate::error::resource_not_found_error::Builder::default();
                        let _ = response;

                        let body_slice = response.body().as_ref();

                        let parsed_body: crate::error::ResourceNotFoundError =
                            if body_slice.is_empty() {
                                // To enable JSON parsing to succeed, replace an empty body
                                // with an empty JSON body. If a member was required, it will fail slightly later
                                // during the operation construction phase.
                                serde_json::from_slice(b"{}")
                                    .map_err(crate::error::GetBlockError::unhandled)?
                            } else {
                                serde_json::from_slice(response.body().as_ref())
                                    .map_err(crate::error::GetBlockError::unhandled)?
                            };

                        output = output.set_message(parsed_body.message);
                        output = output.set_resource_type(parsed_body.resource_type);
                        output = output.set_resource_name(parsed_body.resource_name);
                        output.build()
                    }),
                },
                "ResourcePreconditionNotMetException" => crate::error::GetBlockError {
                    meta: generic,
                    kind: crate::error::GetBlockErrorKind::ResourcePreconditionNotMetError({
                        #[allow(unused_mut)]
                        let mut output =
                            crate::error::resource_precondition_not_met_error::Builder::default();
                        let _ = response;

                        let body_slice = response.body().as_ref();

                        let parsed_body: crate::error::ResourcePreconditionNotMetError =
                            if body_slice.is_empty() {
                                // To enable JSON parsing to succeed, replace an empty body
                                // with an empty JSON body. If a member was required, it will fail slightly later
                                // during the operation construction phase.
                                serde_json::from_slice(b"{}")
                                    .map_err(crate::error::GetBlockError::unhandled)?
                            } else {
                                serde_json::from_slice(response.body().as_ref())
                                    .map_err(crate::error::GetBlockError::unhandled)?
                            };

                        output = output.set_message(parsed_body.message);
                        output = output.set_resource_type(parsed_body.resource_type);
                        output = output.set_resource_name(parsed_body.resource_name);
                        output.build()
                    }),
                },
                _ => crate::error::GetBlockError::generic(generic),
            });
        }
        Ok({
            #[allow(unused_mut)]
            let mut output = crate::output::get_block_output::Builder::default();
            let _ = response;

            let body_slice = response.body().as_ref();

            let parsed_body: crate::serializer::GetBlockOutputBody = if body_slice.is_empty() {
                // To enable JSON parsing to succeed, replace an empty body
                // with an empty JSON body. If a member was required, it will fail slightly later
                // during the operation construction phase.
                serde_json::from_slice(b"{}").map_err(crate::error::GetBlockError::unhandled)?
            } else {
                serde_json::from_slice(response.body().as_ref())
                    .map_err(crate::error::GetBlockError::unhandled)?
            };

            output = output.set_block(parsed_body.block);
            output = output.set_proof(parsed_body.proof);
            output.build()
        })
    }
    pub fn parse_response(
        &self,
        response: &http::response::Response<impl AsRef<[u8]>>,
    ) -> Result<crate::output::GetBlockOutput, crate::error::GetBlockError> {
        Self::from_response(&response)
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}

impl smithy_http::response::ParseStrictResponse for GetBlock {
    type Output = Result<crate::output::GetBlockOutput, crate::error::GetBlockError>;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        self.parse_response(response)
    }
}

/// <p>Returns the digest of a ledger at the latest committed block in the journal. The
/// response includes a 256-bit hash value and a block address.</p>
#[derive(std::clone::Clone)]
pub struct GetDigest {
    _private: (),
}
impl GetDigest {
    /// Creates a new builder-style object to manufacture [`GetDigestInput`](crate::input::GetDigestInput)
    pub fn builder() -> crate::input::get_digest_input::Builder {
        crate::input::get_digest_input::Builder::default()
    }
    #[allow(clippy::unnecessary_wraps)]
    fn from_response(
        response: &http::response::Response<impl AsRef<[u8]>>,
    ) -> Result<crate::output::GetDigestOutput, crate::error::GetDigestError> {
        if crate::aws_json_errors::is_error(&response) && response.status().as_u16() != 200 {
            let body = serde_json::from_slice(response.body().as_ref())
                .unwrap_or_else(|_| serde_json::json!({}));
            let generic = crate::aws_json_errors::parse_generic_error(&response, &body);

            let error_code = match generic.code() {
                Some(code) => code,
                None => return Err(crate::error::GetDigestError::unhandled(generic)),
            };
            return Err(match error_code {
                "InvalidParameterException" => crate::error::GetDigestError {
                    meta: generic,
                    kind: crate::error::GetDigestErrorKind::InvalidParameterError({
                        #[allow(unused_mut)]
                        let mut output = crate::error::invalid_parameter_error::Builder::default();
                        let _ = response;

                        let body_slice = response.body().as_ref();

                        let parsed_body: crate::error::InvalidParameterError =
                            if body_slice.is_empty() {
                                // To enable JSON parsing to succeed, replace an empty body
                                // with an empty JSON body. If a member was required, it will fail slightly later
                                // during the operation construction phase.
                                serde_json::from_slice(b"{}")
                                    .map_err(crate::error::GetDigestError::unhandled)?
                            } else {
                                serde_json::from_slice(response.body().as_ref())
                                    .map_err(crate::error::GetDigestError::unhandled)?
                            };

                        output = output.set_message(parsed_body.message);
                        output = output.set_parameter_name(parsed_body.parameter_name);
                        output.build()
                    }),
                },
                "ResourceNotFoundException" => crate::error::GetDigestError {
                    meta: generic,
                    kind: crate::error::GetDigestErrorKind::ResourceNotFoundError({
                        #[allow(unused_mut)]
                        let mut output = crate::error::resource_not_found_error::Builder::default();
                        let _ = response;

                        let body_slice = response.body().as_ref();

                        let parsed_body: crate::error::ResourceNotFoundError =
                            if body_slice.is_empty() {
                                // To enable JSON parsing to succeed, replace an empty body
                                // with an empty JSON body. If a member was required, it will fail slightly later
                                // during the operation construction phase.
                                serde_json::from_slice(b"{}")
                                    .map_err(crate::error::GetDigestError::unhandled)?
                            } else {
                                serde_json::from_slice(response.body().as_ref())
                                    .map_err(crate::error::GetDigestError::unhandled)?
                            };

                        output = output.set_message(parsed_body.message);
                        output = output.set_resource_type(parsed_body.resource_type);
                        output = output.set_resource_name(parsed_body.resource_name);
                        output.build()
                    }),
                },
                "ResourcePreconditionNotMetException" => crate::error::GetDigestError {
                    meta: generic,
                    kind: crate::error::GetDigestErrorKind::ResourcePreconditionNotMetError({
                        #[allow(unused_mut)]
                        let mut output =
                            crate::error::resource_precondition_not_met_error::Builder::default();
                        let _ = response;

                        let body_slice = response.body().as_ref();

                        let parsed_body: crate::error::ResourcePreconditionNotMetError =
                            if body_slice.is_empty() {
                                // To enable JSON parsing to succeed, replace an empty body
                                // with an empty JSON body. If a member was required, it will fail slightly later
                                // during the operation construction phase.
                                serde_json::from_slice(b"{}")
                                    .map_err(crate::error::GetDigestError::unhandled)?
                            } else {
                                serde_json::from_slice(response.body().as_ref())
                                    .map_err(crate::error::GetDigestError::unhandled)?
                            };

                        output = output.set_message(parsed_body.message);
                        output = output.set_resource_type(parsed_body.resource_type);
                        output = output.set_resource_name(parsed_body.resource_name);
                        output.build()
                    }),
                },
                _ => crate::error::GetDigestError::generic(generic),
            });
        }
        Ok({
            #[allow(unused_mut)]
            let mut output = crate::output::get_digest_output::Builder::default();
            let _ = response;

            let body_slice = response.body().as_ref();

            let parsed_body: crate::serializer::GetDigestOutputBody = if body_slice.is_empty() {
                // To enable JSON parsing to succeed, replace an empty body
                // with an empty JSON body. If a member was required, it will fail slightly later
                // during the operation construction phase.
                serde_json::from_slice(b"{}").map_err(crate::error::GetDigestError::unhandled)?
            } else {
                serde_json::from_slice(response.body().as_ref())
                    .map_err(crate::error::GetDigestError::unhandled)?
            };

            output = output.set_digest(parsed_body.digest);
            output = output.set_digest_tip_address(parsed_body.digest_tip_address);
            output.build()
        })
    }
    pub fn parse_response(
        &self,
        response: &http::response::Response<impl AsRef<[u8]>>,
    ) -> Result<crate::output::GetDigestOutput, crate::error::GetDigestError> {
        Self::from_response(&response)
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}

impl smithy_http::response::ParseStrictResponse for GetDigest {
    type Output = Result<crate::output::GetDigestOutput, crate::error::GetDigestError>;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        self.parse_response(response)
    }
}

/// <p>Returns a revision data object for a specified document ID and block address. Also
/// returns a proof of the specified revision for verification if <code>DigestTipAddress</code>
/// is provided.</p>
#[derive(std::clone::Clone)]
pub struct GetRevision {
    _private: (),
}
impl GetRevision {
    /// Creates a new builder-style object to manufacture [`GetRevisionInput`](crate::input::GetRevisionInput)
    pub fn builder() -> crate::input::get_revision_input::Builder {
        crate::input::get_revision_input::Builder::default()
    }
    #[allow(clippy::unnecessary_wraps)]
    fn from_response(
        response: &http::response::Response<impl AsRef<[u8]>>,
    ) -> Result<crate::output::GetRevisionOutput, crate::error::GetRevisionError> {
        if crate::aws_json_errors::is_error(&response) && response.status().as_u16() != 200 {
            let body = serde_json::from_slice(response.body().as_ref())
                .unwrap_or_else(|_| serde_json::json!({}));
            let generic = crate::aws_json_errors::parse_generic_error(&response, &body);

            let error_code = match generic.code() {
                Some(code) => code,
                None => return Err(crate::error::GetRevisionError::unhandled(generic)),
            };
            return Err(match error_code {
                "InvalidParameterException" => crate::error::GetRevisionError {
                    meta: generic,
                    kind: crate::error::GetRevisionErrorKind::InvalidParameterError({
                        #[allow(unused_mut)]
                        let mut output = crate::error::invalid_parameter_error::Builder::default();
                        let _ = response;

                        let body_slice = response.body().as_ref();

                        let parsed_body: crate::error::InvalidParameterError =
                            if body_slice.is_empty() {
                                // To enable JSON parsing to succeed, replace an empty body
                                // with an empty JSON body. If a member was required, it will fail slightly later
                                // during the operation construction phase.
                                serde_json::from_slice(b"{}")
                                    .map_err(crate::error::GetRevisionError::unhandled)?
                            } else {
                                serde_json::from_slice(response.body().as_ref())
                                    .map_err(crate::error::GetRevisionError::unhandled)?
                            };

                        output = output.set_message(parsed_body.message);
                        output = output.set_parameter_name(parsed_body.parameter_name);
                        output.build()
                    }),
                },
                "ResourceNotFoundException" => crate::error::GetRevisionError {
                    meta: generic,
                    kind: crate::error::GetRevisionErrorKind::ResourceNotFoundError({
                        #[allow(unused_mut)]
                        let mut output = crate::error::resource_not_found_error::Builder::default();
                        let _ = response;

                        let body_slice = response.body().as_ref();

                        let parsed_body: crate::error::ResourceNotFoundError =
                            if body_slice.is_empty() {
                                // To enable JSON parsing to succeed, replace an empty body
                                // with an empty JSON body. If a member was required, it will fail slightly later
                                // during the operation construction phase.
                                serde_json::from_slice(b"{}")
                                    .map_err(crate::error::GetRevisionError::unhandled)?
                            } else {
                                serde_json::from_slice(response.body().as_ref())
                                    .map_err(crate::error::GetRevisionError::unhandled)?
                            };

                        output = output.set_message(parsed_body.message);
                        output = output.set_resource_type(parsed_body.resource_type);
                        output = output.set_resource_name(parsed_body.resource_name);
                        output.build()
                    }),
                },
                "ResourcePreconditionNotMetException" => crate::error::GetRevisionError {
                    meta: generic,
                    kind: crate::error::GetRevisionErrorKind::ResourcePreconditionNotMetError({
                        #[allow(unused_mut)]
                        let mut output =
                            crate::error::resource_precondition_not_met_error::Builder::default();
                        let _ = response;

                        let body_slice = response.body().as_ref();

                        let parsed_body: crate::error::ResourcePreconditionNotMetError =
                            if body_slice.is_empty() {
                                // To enable JSON parsing to succeed, replace an empty body
                                // with an empty JSON body. If a member was required, it will fail slightly later
                                // during the operation construction phase.
                                serde_json::from_slice(b"{}")
                                    .map_err(crate::error::GetRevisionError::unhandled)?
                            } else {
                                serde_json::from_slice(response.body().as_ref())
                                    .map_err(crate::error::GetRevisionError::unhandled)?
                            };

                        output = output.set_message(parsed_body.message);
                        output = output.set_resource_type(parsed_body.resource_type);
                        output = output.set_resource_name(parsed_body.resource_name);
                        output.build()
                    }),
                },
                _ => crate::error::GetRevisionError::generic(generic),
            });
        }
        Ok({
            #[allow(unused_mut)]
            let mut output = crate::output::get_revision_output::Builder::default();
            let _ = response;

            let body_slice = response.body().as_ref();

            let parsed_body: crate::serializer::GetRevisionOutputBody = if body_slice.is_empty() {
                // To enable JSON parsing to succeed, replace an empty body
                // with an empty JSON body. If a member was required, it will fail slightly later
                // during the operation construction phase.
                serde_json::from_slice(b"{}").map_err(crate::error::GetRevisionError::unhandled)?
            } else {
                serde_json::from_slice(response.body().as_ref())
                    .map_err(crate::error::GetRevisionError::unhandled)?
            };

            output = output.set_proof(parsed_body.proof);
            output = output.set_revision(parsed_body.revision);
            output.build()
        })
    }
    pub fn parse_response(
        &self,
        response: &http::response::Response<impl AsRef<[u8]>>,
    ) -> Result<crate::output::GetRevisionOutput, crate::error::GetRevisionError> {
        Self::from_response(&response)
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}

impl smithy_http::response::ParseStrictResponse for GetRevision {
    type Output = Result<crate::output::GetRevisionOutput, crate::error::GetRevisionError>;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        self.parse_response(response)
    }
}

/// <p>Returns an array of all Amazon QLDB journal stream descriptors for a given ledger. The
/// output of each stream descriptor includes the same details that are returned by
/// <code>DescribeJournalKinesisStream</code>.</p>
/// <p>This action returns a maximum of <code>MaxResults</code> items. It is paginated so that
/// you can retrieve all the items by calling <code>ListJournalKinesisStreamsForLedger</code>
/// multiple times.</p>
#[derive(std::clone::Clone)]
pub struct ListJournalKinesisStreamsForLedger {
    _private: (),
}
impl ListJournalKinesisStreamsForLedger {
    /// Creates a new builder-style object to manufacture [`ListJournalKinesisStreamsForLedgerInput`](crate::input::ListJournalKinesisStreamsForLedgerInput)
    pub fn builder() -> crate::input::list_journal_kinesis_streams_for_ledger_input::Builder {
        crate::input::list_journal_kinesis_streams_for_ledger_input::Builder::default()
    }
    #[allow(clippy::unnecessary_wraps)]
    fn from_response(
        response: &http::response::Response<impl AsRef<[u8]>>,
    ) -> Result<
        crate::output::ListJournalKinesisStreamsForLedgerOutput,
        crate::error::ListJournalKinesisStreamsForLedgerError,
    > {
        if crate::aws_json_errors::is_error(&response) && response.status().as_u16() != 200 {
            let body = serde_json::from_slice(response.body().as_ref())
                .unwrap_or_else(|_| serde_json::json!({}));
            let generic = crate::aws_json_errors::parse_generic_error(&response, &body);

            let error_code = match generic.code() {
                Some(code) => code,
                None => {
                    return Err(
                        crate::error::ListJournalKinesisStreamsForLedgerError::unhandled(generic),
                    )
                }
            };
            return Err(match error_code {
                "InvalidParameterException" => crate::error::ListJournalKinesisStreamsForLedgerError { meta: generic, kind: crate::error::ListJournalKinesisStreamsForLedgerErrorKind::InvalidParameterError({
                    #[allow(unused_mut)]let mut output = crate::error::invalid_parameter_error::Builder::default();
                    let _ = response;
                    
                                        let body_slice = response.body().as_ref();
                    
                                        let parsed_body: crate::error::InvalidParameterError = if body_slice.is_empty() {
                                            // To enable JSON parsing to succeed, replace an empty body
                                            // with an empty JSON body. If a member was required, it will fail slightly later
                                            // during the operation construction phase.
                                            serde_json::from_slice(b"{}").map_err(crate::error::ListJournalKinesisStreamsForLedgerError::unhandled)?
                                        } else {
                                            serde_json::from_slice(response.body().as_ref()).map_err(crate::error::ListJournalKinesisStreamsForLedgerError::unhandled)?
                                        };
                                    
                    output = output.set_message(
                        parsed_body.message
                    );
                    output = output.set_parameter_name(
                        parsed_body.parameter_name
                    );
                    output.build()
                })},
                "ResourceNotFoundException" => crate::error::ListJournalKinesisStreamsForLedgerError { meta: generic, kind: crate::error::ListJournalKinesisStreamsForLedgerErrorKind::ResourceNotFoundError({
                    #[allow(unused_mut)]let mut output = crate::error::resource_not_found_error::Builder::default();
                    let _ = response;
                    
                                        let body_slice = response.body().as_ref();
                    
                                        let parsed_body: crate::error::ResourceNotFoundError = if body_slice.is_empty() {
                                            // To enable JSON parsing to succeed, replace an empty body
                                            // with an empty JSON body. If a member was required, it will fail slightly later
                                            // during the operation construction phase.
                                            serde_json::from_slice(b"{}").map_err(crate::error::ListJournalKinesisStreamsForLedgerError::unhandled)?
                                        } else {
                                            serde_json::from_slice(response.body().as_ref()).map_err(crate::error::ListJournalKinesisStreamsForLedgerError::unhandled)?
                                        };
                                    
                    output = output.set_message(
                        parsed_body.message
                    );
                    output = output.set_resource_type(
                        parsed_body.resource_type
                    );
                    output = output.set_resource_name(
                        parsed_body.resource_name
                    );
                    output.build()
                })},
                "ResourcePreconditionNotMetException" => crate::error::ListJournalKinesisStreamsForLedgerError { meta: generic, kind: crate::error::ListJournalKinesisStreamsForLedgerErrorKind::ResourcePreconditionNotMetError({
                    #[allow(unused_mut)]let mut output = crate::error::resource_precondition_not_met_error::Builder::default();
                    let _ = response;
                    
                                        let body_slice = response.body().as_ref();
                    
                                        let parsed_body: crate::error::ResourcePreconditionNotMetError = if body_slice.is_empty() {
                                            // To enable JSON parsing to succeed, replace an empty body
                                            // with an empty JSON body. If a member was required, it will fail slightly later
                                            // during the operation construction phase.
                                            serde_json::from_slice(b"{}").map_err(crate::error::ListJournalKinesisStreamsForLedgerError::unhandled)?
                                        } else {
                                            serde_json::from_slice(response.body().as_ref()).map_err(crate::error::ListJournalKinesisStreamsForLedgerError::unhandled)?
                                        };
                                    
                    output = output.set_message(
                        parsed_body.message
                    );
                    output = output.set_resource_type(
                        parsed_body.resource_type
                    );
                    output = output.set_resource_name(
                        parsed_body.resource_name
                    );
                    output.build()
                })},
                _ => crate::error::ListJournalKinesisStreamsForLedgerError::generic(generic)
            });
        }
        Ok({
            #[allow(unused_mut)]
            let mut output =
                crate::output::list_journal_kinesis_streams_for_ledger_output::Builder::default();
            let _ = response;

            let body_slice = response.body().as_ref();

            let parsed_body: crate::serializer::ListJournalKinesisStreamsForLedgerOutputBody =
                if body_slice.is_empty() {
                    // To enable JSON parsing to succeed, replace an empty body
                    // with an empty JSON body. If a member was required, it will fail slightly later
                    // during the operation construction phase.
                    serde_json::from_slice(b"{}")
                        .map_err(crate::error::ListJournalKinesisStreamsForLedgerError::unhandled)?
                } else {
                    serde_json::from_slice(response.body().as_ref())
                        .map_err(crate::error::ListJournalKinesisStreamsForLedgerError::unhandled)?
                };

            output = output.set_streams(parsed_body.streams);
            output = output.set_next_token(parsed_body.next_token);
            output.build()
        })
    }
    pub fn parse_response(
        &self,
        response: &http::response::Response<impl AsRef<[u8]>>,
    ) -> Result<
        crate::output::ListJournalKinesisStreamsForLedgerOutput,
        crate::error::ListJournalKinesisStreamsForLedgerError,
    > {
        Self::from_response(&response)
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}

impl smithy_http::response::ParseStrictResponse for ListJournalKinesisStreamsForLedger {
    type Output = Result<
        crate::output::ListJournalKinesisStreamsForLedgerOutput,
        crate::error::ListJournalKinesisStreamsForLedgerError,
    >;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        self.parse_response(response)
    }
}

/// <p>Returns an array of journal export job descriptions for all ledgers that are associated
/// with the current AWS account and Region.</p>
/// <p>This action returns a maximum of <code>MaxResults</code> items, and is paginated so that
/// you can retrieve all the items by calling <code>ListJournalS3Exports</code> multiple
/// times.</p>
/// <p>This action does not return any expired export jobs. For more information, see <a href="https://docs.aws.amazon.com/qldb/latest/developerguide/export-journal.request.html#export-journal.request.expiration">Export Job Expiration</a> in the <i>Amazon QLDB Developer
/// Guide</i>.</p>
#[derive(std::clone::Clone)]
pub struct ListJournalS3Exports {
    _private: (),
}
impl ListJournalS3Exports {
    /// Creates a new builder-style object to manufacture [`ListJournalS3ExportsInput`](crate::input::ListJournalS3ExportsInput)
    pub fn builder() -> crate::input::list_journal_s3_exports_input::Builder {
        crate::input::list_journal_s3_exports_input::Builder::default()
    }
    #[allow(clippy::unnecessary_wraps)]
    fn from_response(
        response: &http::response::Response<impl AsRef<[u8]>>,
    ) -> Result<crate::output::ListJournalS3ExportsOutput, crate::error::ListJournalS3ExportsError>
    {
        if crate::aws_json_errors::is_error(&response) && response.status().as_u16() != 200 {
            let body = serde_json::from_slice(response.body().as_ref())
                .unwrap_or_else(|_| serde_json::json!({}));
            let generic = crate::aws_json_errors::parse_generic_error(&response, &body);

            return Err(crate::error::ListJournalS3ExportsError::generic(generic));
        }
        Ok({
            #[allow(unused_mut)]
            let mut output = crate::output::list_journal_s3_exports_output::Builder::default();
            let _ = response;

            let body_slice = response.body().as_ref();

            let parsed_body: crate::serializer::ListJournalS3ExportsOutputBody =
                if body_slice.is_empty() {
                    // To enable JSON parsing to succeed, replace an empty body
                    // with an empty JSON body. If a member was required, it will fail slightly later
                    // during the operation construction phase.
                    serde_json::from_slice(b"{}")
                        .map_err(crate::error::ListJournalS3ExportsError::unhandled)?
                } else {
                    serde_json::from_slice(response.body().as_ref())
                        .map_err(crate::error::ListJournalS3ExportsError::unhandled)?
                };

            output = output.set_journal_s3_exports(parsed_body.journal_s3_exports);
            output = output.set_next_token(parsed_body.next_token);
            output.build()
        })
    }
    pub fn parse_response(
        &self,
        response: &http::response::Response<impl AsRef<[u8]>>,
    ) -> Result<crate::output::ListJournalS3ExportsOutput, crate::error::ListJournalS3ExportsError>
    {
        Self::from_response(&response)
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}

impl smithy_http::response::ParseStrictResponse for ListJournalS3Exports {
    type Output =
        Result<crate::output::ListJournalS3ExportsOutput, crate::error::ListJournalS3ExportsError>;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        self.parse_response(response)
    }
}

/// <p>Returns an array of journal export job descriptions for a specified ledger.</p>
/// <p>This action returns a maximum of <code>MaxResults</code> items, and is paginated so that
/// you can retrieve all the items by calling <code>ListJournalS3ExportsForLedger</code>
/// multiple times.</p>
/// <p>This action does not return any expired export jobs. For more information, see <a href="https://docs.aws.amazon.com/qldb/latest/developerguide/export-journal.request.html#export-journal.request.expiration">Export Job Expiration</a> in the <i>Amazon QLDB Developer
/// Guide</i>.</p>
#[derive(std::clone::Clone)]
pub struct ListJournalS3ExportsForLedger {
    _private: (),
}
impl ListJournalS3ExportsForLedger {
    /// Creates a new builder-style object to manufacture [`ListJournalS3ExportsForLedgerInput`](crate::input::ListJournalS3ExportsForLedgerInput)
    pub fn builder() -> crate::input::list_journal_s3_exports_for_ledger_input::Builder {
        crate::input::list_journal_s3_exports_for_ledger_input::Builder::default()
    }
    #[allow(clippy::unnecessary_wraps)]
    fn from_response(
        response: &http::response::Response<impl AsRef<[u8]>>,
    ) -> Result<
        crate::output::ListJournalS3ExportsForLedgerOutput,
        crate::error::ListJournalS3ExportsForLedgerError,
    > {
        if crate::aws_json_errors::is_error(&response) && response.status().as_u16() != 200 {
            let body = serde_json::from_slice(response.body().as_ref())
                .unwrap_or_else(|_| serde_json::json!({}));
            let generic = crate::aws_json_errors::parse_generic_error(&response, &body);

            return Err(crate::error::ListJournalS3ExportsForLedgerError::generic(
                generic,
            ));
        }
        Ok({
            #[allow(unused_mut)]
            let mut output =
                crate::output::list_journal_s3_exports_for_ledger_output::Builder::default();
            let _ = response;

            let body_slice = response.body().as_ref();

            let parsed_body: crate::serializer::ListJournalS3ExportsForLedgerOutputBody =
                if body_slice.is_empty() {
                    // To enable JSON parsing to succeed, replace an empty body
                    // with an empty JSON body. If a member was required, it will fail slightly later
                    // during the operation construction phase.
                    serde_json::from_slice(b"{}")
                        .map_err(crate::error::ListJournalS3ExportsForLedgerError::unhandled)?
                } else {
                    serde_json::from_slice(response.body().as_ref())
                        .map_err(crate::error::ListJournalS3ExportsForLedgerError::unhandled)?
                };

            output = output.set_journal_s3_exports(parsed_body.journal_s3_exports);
            output = output.set_next_token(parsed_body.next_token);
            output.build()
        })
    }
    pub fn parse_response(
        &self,
        response: &http::response::Response<impl AsRef<[u8]>>,
    ) -> Result<
        crate::output::ListJournalS3ExportsForLedgerOutput,
        crate::error::ListJournalS3ExportsForLedgerError,
    > {
        Self::from_response(&response)
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}

impl smithy_http::response::ParseStrictResponse for ListJournalS3ExportsForLedger {
    type Output = Result<
        crate::output::ListJournalS3ExportsForLedgerOutput,
        crate::error::ListJournalS3ExportsForLedgerError,
    >;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        self.parse_response(response)
    }
}

/// <p>Returns an array of ledger summaries that are associated with the current AWS account
/// and Region.</p>
/// <p>This action returns a maximum of 100 items and is paginated so that you can
/// retrieve all the items by calling <code>ListLedgers</code> multiple times.</p>
#[derive(std::clone::Clone)]
pub struct ListLedgers {
    _private: (),
}
impl ListLedgers {
    /// Creates a new builder-style object to manufacture [`ListLedgersInput`](crate::input::ListLedgersInput)
    pub fn builder() -> crate::input::list_ledgers_input::Builder {
        crate::input::list_ledgers_input::Builder::default()
    }
    #[allow(clippy::unnecessary_wraps)]
    fn from_response(
        response: &http::response::Response<impl AsRef<[u8]>>,
    ) -> Result<crate::output::ListLedgersOutput, crate::error::ListLedgersError> {
        if crate::aws_json_errors::is_error(&response) && response.status().as_u16() != 200 {
            let body = serde_json::from_slice(response.body().as_ref())
                .unwrap_or_else(|_| serde_json::json!({}));
            let generic = crate::aws_json_errors::parse_generic_error(&response, &body);

            return Err(crate::error::ListLedgersError::generic(generic));
        }
        Ok({
            #[allow(unused_mut)]
            let mut output = crate::output::list_ledgers_output::Builder::default();
            let _ = response;

            let body_slice = response.body().as_ref();

            let parsed_body: crate::serializer::ListLedgersOutputBody = if body_slice.is_empty() {
                // To enable JSON parsing to succeed, replace an empty body
                // with an empty JSON body. If a member was required, it will fail slightly later
                // during the operation construction phase.
                serde_json::from_slice(b"{}").map_err(crate::error::ListLedgersError::unhandled)?
            } else {
                serde_json::from_slice(response.body().as_ref())
                    .map_err(crate::error::ListLedgersError::unhandled)?
            };

            output = output.set_ledgers(parsed_body.ledgers);
            output = output.set_next_token(parsed_body.next_token);
            output.build()
        })
    }
    pub fn parse_response(
        &self,
        response: &http::response::Response<impl AsRef<[u8]>>,
    ) -> Result<crate::output::ListLedgersOutput, crate::error::ListLedgersError> {
        Self::from_response(&response)
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}

impl smithy_http::response::ParseStrictResponse for ListLedgers {
    type Output = Result<crate::output::ListLedgersOutput, crate::error::ListLedgersError>;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        self.parse_response(response)
    }
}

/// <p>Returns all tags for a specified Amazon QLDB resource.</p>
#[derive(std::clone::Clone)]
pub struct ListTagsForResource {
    _private: (),
}
impl ListTagsForResource {
    /// Creates a new builder-style object to manufacture [`ListTagsForResourceInput`](crate::input::ListTagsForResourceInput)
    pub fn builder() -> crate::input::list_tags_for_resource_input::Builder {
        crate::input::list_tags_for_resource_input::Builder::default()
    }
    #[allow(clippy::unnecessary_wraps)]
    fn from_response(
        response: &http::response::Response<impl AsRef<[u8]>>,
    ) -> Result<crate::output::ListTagsForResourceOutput, crate::error::ListTagsForResourceError>
    {
        if crate::aws_json_errors::is_error(&response) && response.status().as_u16() != 200 {
            let body = serde_json::from_slice(response.body().as_ref())
                .unwrap_or_else(|_| serde_json::json!({}));
            let generic = crate::aws_json_errors::parse_generic_error(&response, &body);

            let error_code = match generic.code() {
                Some(code) => code,
                None => return Err(crate::error::ListTagsForResourceError::unhandled(generic)),
            };
            return Err(match error_code {
                "InvalidParameterException" => crate::error::ListTagsForResourceError {
                    meta: generic,
                    kind: crate::error::ListTagsForResourceErrorKind::InvalidParameterError({
                        #[allow(unused_mut)]
                        let mut output = crate::error::invalid_parameter_error::Builder::default();
                        let _ = response;

                        let body_slice = response.body().as_ref();

                        let parsed_body: crate::error::InvalidParameterError =
                            if body_slice.is_empty() {
                                // To enable JSON parsing to succeed, replace an empty body
                                // with an empty JSON body. If a member was required, it will fail slightly later
                                // during the operation construction phase.
                                serde_json::from_slice(b"{}")
                                    .map_err(crate::error::ListTagsForResourceError::unhandled)?
                            } else {
                                serde_json::from_slice(response.body().as_ref())
                                    .map_err(crate::error::ListTagsForResourceError::unhandled)?
                            };

                        output = output.set_message(parsed_body.message);
                        output = output.set_parameter_name(parsed_body.parameter_name);
                        output.build()
                    }),
                },
                "ResourceNotFoundException" => crate::error::ListTagsForResourceError {
                    meta: generic,
                    kind: crate::error::ListTagsForResourceErrorKind::ResourceNotFoundError({
                        #[allow(unused_mut)]
                        let mut output = crate::error::resource_not_found_error::Builder::default();
                        let _ = response;

                        let body_slice = response.body().as_ref();

                        let parsed_body: crate::error::ResourceNotFoundError =
                            if body_slice.is_empty() {
                                // To enable JSON parsing to succeed, replace an empty body
                                // with an empty JSON body. If a member was required, it will fail slightly later
                                // during the operation construction phase.
                                serde_json::from_slice(b"{}")
                                    .map_err(crate::error::ListTagsForResourceError::unhandled)?
                            } else {
                                serde_json::from_slice(response.body().as_ref())
                                    .map_err(crate::error::ListTagsForResourceError::unhandled)?
                            };

                        output = output.set_message(parsed_body.message);
                        output = output.set_resource_type(parsed_body.resource_type);
                        output = output.set_resource_name(parsed_body.resource_name);
                        output.build()
                    }),
                },
                _ => crate::error::ListTagsForResourceError::generic(generic),
            });
        }
        Ok({
            #[allow(unused_mut)]
            let mut output = crate::output::list_tags_for_resource_output::Builder::default();
            let _ = response;

            let body_slice = response.body().as_ref();

            let parsed_body: crate::serializer::ListTagsForResourceOutputBody =
                if body_slice.is_empty() {
                    // To enable JSON parsing to succeed, replace an empty body
                    // with an empty JSON body. If a member was required, it will fail slightly later
                    // during the operation construction phase.
                    serde_json::from_slice(b"{}")
                        .map_err(crate::error::ListTagsForResourceError::unhandled)?
                } else {
                    serde_json::from_slice(response.body().as_ref())
                        .map_err(crate::error::ListTagsForResourceError::unhandled)?
                };

            output = output.set_tags(parsed_body.tags);
            output.build()
        })
    }
    pub fn parse_response(
        &self,
        response: &http::response::Response<impl AsRef<[u8]>>,
    ) -> Result<crate::output::ListTagsForResourceOutput, crate::error::ListTagsForResourceError>
    {
        Self::from_response(&response)
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}

impl smithy_http::response::ParseStrictResponse for ListTagsForResource {
    type Output =
        Result<crate::output::ListTagsForResourceOutput, crate::error::ListTagsForResourceError>;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        self.parse_response(response)
    }
}

/// <p>Creates a journal stream for a given Amazon QLDB ledger. The stream captures every
/// document revision that is committed to the ledger's journal and delivers the data to a
/// specified Amazon Kinesis Data Streams resource.</p>
#[derive(std::clone::Clone)]
pub struct StreamJournalToKinesis {
    _private: (),
}
impl StreamJournalToKinesis {
    /// Creates a new builder-style object to manufacture [`StreamJournalToKinesisInput`](crate::input::StreamJournalToKinesisInput)
    pub fn builder() -> crate::input::stream_journal_to_kinesis_input::Builder {
        crate::input::stream_journal_to_kinesis_input::Builder::default()
    }
    #[allow(clippy::unnecessary_wraps)]
    fn from_response(
        response: &http::response::Response<impl AsRef<[u8]>>,
    ) -> Result<
        crate::output::StreamJournalToKinesisOutput,
        crate::error::StreamJournalToKinesisError,
    > {
        if crate::aws_json_errors::is_error(&response) && response.status().as_u16() != 200 {
            let body = serde_json::from_slice(response.body().as_ref())
                .unwrap_or_else(|_| serde_json::json!({}));
            let generic = crate::aws_json_errors::parse_generic_error(&response, &body);

            let error_code = match generic.code() {
                Some(code) => code,
                None => {
                    return Err(crate::error::StreamJournalToKinesisError::unhandled(
                        generic,
                    ))
                }
            };
            return Err(match error_code {
                "InvalidParameterException" => crate::error::StreamJournalToKinesisError { meta: generic, kind: crate::error::StreamJournalToKinesisErrorKind::InvalidParameterError({
                    #[allow(unused_mut)]let mut output = crate::error::invalid_parameter_error::Builder::default();
                    let _ = response;
                    
                                        let body_slice = response.body().as_ref();
                    
                                        let parsed_body: crate::error::InvalidParameterError = if body_slice.is_empty() {
                                            // To enable JSON parsing to succeed, replace an empty body
                                            // with an empty JSON body. If a member was required, it will fail slightly later
                                            // during the operation construction phase.
                                            serde_json::from_slice(b"{}").map_err(crate::error::StreamJournalToKinesisError::unhandled)?
                                        } else {
                                            serde_json::from_slice(response.body().as_ref()).map_err(crate::error::StreamJournalToKinesisError::unhandled)?
                                        };
                                    
                    output = output.set_message(
                        parsed_body.message
                    );
                    output = output.set_parameter_name(
                        parsed_body.parameter_name
                    );
                    output.build()
                })},
                "ResourceNotFoundException" => crate::error::StreamJournalToKinesisError { meta: generic, kind: crate::error::StreamJournalToKinesisErrorKind::ResourceNotFoundError({
                    #[allow(unused_mut)]let mut output = crate::error::resource_not_found_error::Builder::default();
                    let _ = response;
                    
                                        let body_slice = response.body().as_ref();
                    
                                        let parsed_body: crate::error::ResourceNotFoundError = if body_slice.is_empty() {
                                            // To enable JSON parsing to succeed, replace an empty body
                                            // with an empty JSON body. If a member was required, it will fail slightly later
                                            // during the operation construction phase.
                                            serde_json::from_slice(b"{}").map_err(crate::error::StreamJournalToKinesisError::unhandled)?
                                        } else {
                                            serde_json::from_slice(response.body().as_ref()).map_err(crate::error::StreamJournalToKinesisError::unhandled)?
                                        };
                                    
                    output = output.set_message(
                        parsed_body.message
                    );
                    output = output.set_resource_type(
                        parsed_body.resource_type
                    );
                    output = output.set_resource_name(
                        parsed_body.resource_name
                    );
                    output.build()
                })},
                "ResourcePreconditionNotMetException" => crate::error::StreamJournalToKinesisError { meta: generic, kind: crate::error::StreamJournalToKinesisErrorKind::ResourcePreconditionNotMetError({
                    #[allow(unused_mut)]let mut output = crate::error::resource_precondition_not_met_error::Builder::default();
                    let _ = response;
                    
                                        let body_slice = response.body().as_ref();
                    
                                        let parsed_body: crate::error::ResourcePreconditionNotMetError = if body_slice.is_empty() {
                                            // To enable JSON parsing to succeed, replace an empty body
                                            // with an empty JSON body. If a member was required, it will fail slightly later
                                            // during the operation construction phase.
                                            serde_json::from_slice(b"{}").map_err(crate::error::StreamJournalToKinesisError::unhandled)?
                                        } else {
                                            serde_json::from_slice(response.body().as_ref()).map_err(crate::error::StreamJournalToKinesisError::unhandled)?
                                        };
                                    
                    output = output.set_message(
                        parsed_body.message
                    );
                    output = output.set_resource_type(
                        parsed_body.resource_type
                    );
                    output = output.set_resource_name(
                        parsed_body.resource_name
                    );
                    output.build()
                })},
                _ => crate::error::StreamJournalToKinesisError::generic(generic)
            });
        }
        Ok({
            #[allow(unused_mut)]
            let mut output = crate::output::stream_journal_to_kinesis_output::Builder::default();
            let _ = response;

            let body_slice = response.body().as_ref();

            let parsed_body: crate::serializer::StreamJournalToKinesisOutputBody =
                if body_slice.is_empty() {
                    // To enable JSON parsing to succeed, replace an empty body
                    // with an empty JSON body. If a member was required, it will fail slightly later
                    // during the operation construction phase.
                    serde_json::from_slice(b"{}")
                        .map_err(crate::error::StreamJournalToKinesisError::unhandled)?
                } else {
                    serde_json::from_slice(response.body().as_ref())
                        .map_err(crate::error::StreamJournalToKinesisError::unhandled)?
                };

            output = output.set_stream_id(parsed_body.stream_id);
            output.build()
        })
    }
    pub fn parse_response(
        &self,
        response: &http::response::Response<impl AsRef<[u8]>>,
    ) -> Result<
        crate::output::StreamJournalToKinesisOutput,
        crate::error::StreamJournalToKinesisError,
    > {
        Self::from_response(&response)
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}

impl smithy_http::response::ParseStrictResponse for StreamJournalToKinesis {
    type Output = Result<
        crate::output::StreamJournalToKinesisOutput,
        crate::error::StreamJournalToKinesisError,
    >;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        self.parse_response(response)
    }
}

/// <p>Adds one or more tags to a specified Amazon QLDB resource.</p>
/// <p>A resource can have up to 50 tags. If you try to create more than 50 tags for a
/// resource, your request fails and returns an error.</p>
#[derive(std::clone::Clone)]
pub struct TagResource {
    _private: (),
}
impl TagResource {
    /// Creates a new builder-style object to manufacture [`TagResourceInput`](crate::input::TagResourceInput)
    pub fn builder() -> crate::input::tag_resource_input::Builder {
        crate::input::tag_resource_input::Builder::default()
    }
    #[allow(clippy::unnecessary_wraps)]
    fn from_response(
        response: &http::response::Response<impl AsRef<[u8]>>,
    ) -> Result<crate::output::TagResourceOutput, crate::error::TagResourceError> {
        if crate::aws_json_errors::is_error(&response) && response.status().as_u16() != 200 {
            let body = serde_json::from_slice(response.body().as_ref())
                .unwrap_or_else(|_| serde_json::json!({}));
            let generic = crate::aws_json_errors::parse_generic_error(&response, &body);

            let error_code = match generic.code() {
                Some(code) => code,
                None => return Err(crate::error::TagResourceError::unhandled(generic)),
            };
            return Err(match error_code {
                "InvalidParameterException" => crate::error::TagResourceError {
                    meta: generic,
                    kind: crate::error::TagResourceErrorKind::InvalidParameterError({
                        #[allow(unused_mut)]
                        let mut output = crate::error::invalid_parameter_error::Builder::default();
                        let _ = response;

                        let body_slice = response.body().as_ref();

                        let parsed_body: crate::error::InvalidParameterError =
                            if body_slice.is_empty() {
                                // To enable JSON parsing to succeed, replace an empty body
                                // with an empty JSON body. If a member was required, it will fail slightly later
                                // during the operation construction phase.
                                serde_json::from_slice(b"{}")
                                    .map_err(crate::error::TagResourceError::unhandled)?
                            } else {
                                serde_json::from_slice(response.body().as_ref())
                                    .map_err(crate::error::TagResourceError::unhandled)?
                            };

                        output = output.set_message(parsed_body.message);
                        output = output.set_parameter_name(parsed_body.parameter_name);
                        output.build()
                    }),
                },
                "ResourceNotFoundException" => crate::error::TagResourceError {
                    meta: generic,
                    kind: crate::error::TagResourceErrorKind::ResourceNotFoundError({
                        #[allow(unused_mut)]
                        let mut output = crate::error::resource_not_found_error::Builder::default();
                        let _ = response;

                        let body_slice = response.body().as_ref();

                        let parsed_body: crate::error::ResourceNotFoundError =
                            if body_slice.is_empty() {
                                // To enable JSON parsing to succeed, replace an empty body
                                // with an empty JSON body. If a member was required, it will fail slightly later
                                // during the operation construction phase.
                                serde_json::from_slice(b"{}")
                                    .map_err(crate::error::TagResourceError::unhandled)?
                            } else {
                                serde_json::from_slice(response.body().as_ref())
                                    .map_err(crate::error::TagResourceError::unhandled)?
                            };

                        output = output.set_message(parsed_body.message);
                        output = output.set_resource_type(parsed_body.resource_type);
                        output = output.set_resource_name(parsed_body.resource_name);
                        output.build()
                    }),
                },
                _ => crate::error::TagResourceError::generic(generic),
            });
        }
        Ok({
            #[allow(unused_mut)]
            let mut output = crate::output::tag_resource_output::Builder::default();
            let _ = response;
            output.build()
        })
    }
    pub fn parse_response(
        &self,
        response: &http::response::Response<impl AsRef<[u8]>>,
    ) -> Result<crate::output::TagResourceOutput, crate::error::TagResourceError> {
        Self::from_response(&response)
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}

impl smithy_http::response::ParseStrictResponse for TagResource {
    type Output = Result<crate::output::TagResourceOutput, crate::error::TagResourceError>;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        self.parse_response(response)
    }
}

/// <p>Removes one or more tags from a specified Amazon QLDB resource. You can specify up to 50
/// tag keys to remove.</p>
#[derive(std::clone::Clone)]
pub struct UntagResource {
    _private: (),
}
impl UntagResource {
    /// Creates a new builder-style object to manufacture [`UntagResourceInput`](crate::input::UntagResourceInput)
    pub fn builder() -> crate::input::untag_resource_input::Builder {
        crate::input::untag_resource_input::Builder::default()
    }
    #[allow(clippy::unnecessary_wraps)]
    fn from_response(
        response: &http::response::Response<impl AsRef<[u8]>>,
    ) -> Result<crate::output::UntagResourceOutput, crate::error::UntagResourceError> {
        if crate::aws_json_errors::is_error(&response) && response.status().as_u16() != 200 {
            let body = serde_json::from_slice(response.body().as_ref())
                .unwrap_or_else(|_| serde_json::json!({}));
            let generic = crate::aws_json_errors::parse_generic_error(&response, &body);

            let error_code = match generic.code() {
                Some(code) => code,
                None => return Err(crate::error::UntagResourceError::unhandled(generic)),
            };
            return Err(match error_code {
                "InvalidParameterException" => crate::error::UntagResourceError {
                    meta: generic,
                    kind: crate::error::UntagResourceErrorKind::InvalidParameterError({
                        #[allow(unused_mut)]
                        let mut output = crate::error::invalid_parameter_error::Builder::default();
                        let _ = response;

                        let body_slice = response.body().as_ref();

                        let parsed_body: crate::error::InvalidParameterError =
                            if body_slice.is_empty() {
                                // To enable JSON parsing to succeed, replace an empty body
                                // with an empty JSON body. If a member was required, it will fail slightly later
                                // during the operation construction phase.
                                serde_json::from_slice(b"{}")
                                    .map_err(crate::error::UntagResourceError::unhandled)?
                            } else {
                                serde_json::from_slice(response.body().as_ref())
                                    .map_err(crate::error::UntagResourceError::unhandled)?
                            };

                        output = output.set_message(parsed_body.message);
                        output = output.set_parameter_name(parsed_body.parameter_name);
                        output.build()
                    }),
                },
                "ResourceNotFoundException" => crate::error::UntagResourceError {
                    meta: generic,
                    kind: crate::error::UntagResourceErrorKind::ResourceNotFoundError({
                        #[allow(unused_mut)]
                        let mut output = crate::error::resource_not_found_error::Builder::default();
                        let _ = response;

                        let body_slice = response.body().as_ref();

                        let parsed_body: crate::error::ResourceNotFoundError =
                            if body_slice.is_empty() {
                                // To enable JSON parsing to succeed, replace an empty body
                                // with an empty JSON body. If a member was required, it will fail slightly later
                                // during the operation construction phase.
                                serde_json::from_slice(b"{}")
                                    .map_err(crate::error::UntagResourceError::unhandled)?
                            } else {
                                serde_json::from_slice(response.body().as_ref())
                                    .map_err(crate::error::UntagResourceError::unhandled)?
                            };

                        output = output.set_message(parsed_body.message);
                        output = output.set_resource_type(parsed_body.resource_type);
                        output = output.set_resource_name(parsed_body.resource_name);
                        output.build()
                    }),
                },
                _ => crate::error::UntagResourceError::generic(generic),
            });
        }
        Ok({
            #[allow(unused_mut)]
            let mut output = crate::output::untag_resource_output::Builder::default();
            let _ = response;
            output.build()
        })
    }
    pub fn parse_response(
        &self,
        response: &http::response::Response<impl AsRef<[u8]>>,
    ) -> Result<crate::output::UntagResourceOutput, crate::error::UntagResourceError> {
        Self::from_response(&response)
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}

impl smithy_http::response::ParseStrictResponse for UntagResource {
    type Output = Result<crate::output::UntagResourceOutput, crate::error::UntagResourceError>;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        self.parse_response(response)
    }
}

/// <p>Updates properties on a ledger.</p>
#[derive(std::clone::Clone)]
pub struct UpdateLedger {
    _private: (),
}
impl UpdateLedger {
    /// Creates a new builder-style object to manufacture [`UpdateLedgerInput`](crate::input::UpdateLedgerInput)
    pub fn builder() -> crate::input::update_ledger_input::Builder {
        crate::input::update_ledger_input::Builder::default()
    }
    #[allow(clippy::unnecessary_wraps)]
    fn from_response(
        response: &http::response::Response<impl AsRef<[u8]>>,
    ) -> Result<crate::output::UpdateLedgerOutput, crate::error::UpdateLedgerError> {
        if crate::aws_json_errors::is_error(&response) && response.status().as_u16() != 200 {
            let body = serde_json::from_slice(response.body().as_ref())
                .unwrap_or_else(|_| serde_json::json!({}));
            let generic = crate::aws_json_errors::parse_generic_error(&response, &body);

            let error_code = match generic.code() {
                Some(code) => code,
                None => return Err(crate::error::UpdateLedgerError::unhandled(generic)),
            };
            return Err(match error_code {
                "InvalidParameterException" => crate::error::UpdateLedgerError {
                    meta: generic,
                    kind: crate::error::UpdateLedgerErrorKind::InvalidParameterError({
                        #[allow(unused_mut)]
                        let mut output = crate::error::invalid_parameter_error::Builder::default();
                        let _ = response;

                        let body_slice = response.body().as_ref();

                        let parsed_body: crate::error::InvalidParameterError =
                            if body_slice.is_empty() {
                                // To enable JSON parsing to succeed, replace an empty body
                                // with an empty JSON body. If a member was required, it will fail slightly later
                                // during the operation construction phase.
                                serde_json::from_slice(b"{}")
                                    .map_err(crate::error::UpdateLedgerError::unhandled)?
                            } else {
                                serde_json::from_slice(response.body().as_ref())
                                    .map_err(crate::error::UpdateLedgerError::unhandled)?
                            };

                        output = output.set_message(parsed_body.message);
                        output = output.set_parameter_name(parsed_body.parameter_name);
                        output.build()
                    }),
                },
                "ResourceNotFoundException" => crate::error::UpdateLedgerError {
                    meta: generic,
                    kind: crate::error::UpdateLedgerErrorKind::ResourceNotFoundError({
                        #[allow(unused_mut)]
                        let mut output = crate::error::resource_not_found_error::Builder::default();
                        let _ = response;

                        let body_slice = response.body().as_ref();

                        let parsed_body: crate::error::ResourceNotFoundError =
                            if body_slice.is_empty() {
                                // To enable JSON parsing to succeed, replace an empty body
                                // with an empty JSON body. If a member was required, it will fail slightly later
                                // during the operation construction phase.
                                serde_json::from_slice(b"{}")
                                    .map_err(crate::error::UpdateLedgerError::unhandled)?
                            } else {
                                serde_json::from_slice(response.body().as_ref())
                                    .map_err(crate::error::UpdateLedgerError::unhandled)?
                            };

                        output = output.set_message(parsed_body.message);
                        output = output.set_resource_type(parsed_body.resource_type);
                        output = output.set_resource_name(parsed_body.resource_name);
                        output.build()
                    }),
                },
                _ => crate::error::UpdateLedgerError::generic(generic),
            });
        }
        Ok({
            #[allow(unused_mut)]
            let mut output = crate::output::update_ledger_output::Builder::default();
            let _ = response;

            let body_slice = response.body().as_ref();

            let parsed_body: crate::serializer::UpdateLedgerOutputBody = if body_slice.is_empty() {
                // To enable JSON parsing to succeed, replace an empty body
                // with an empty JSON body. If a member was required, it will fail slightly later
                // during the operation construction phase.
                serde_json::from_slice(b"{}").map_err(crate::error::UpdateLedgerError::unhandled)?
            } else {
                serde_json::from_slice(response.body().as_ref())
                    .map_err(crate::error::UpdateLedgerError::unhandled)?
            };

            output = output.set_name(parsed_body.name);
            output = output.set_arn(parsed_body.arn);
            output = output.set_state(parsed_body.state);
            output = output.set_creation_date_time(parsed_body.creation_date_time);
            output = output.set_deletion_protection(parsed_body.deletion_protection);
            output.build()
        })
    }
    pub fn parse_response(
        &self,
        response: &http::response::Response<impl AsRef<[u8]>>,
    ) -> Result<crate::output::UpdateLedgerOutput, crate::error::UpdateLedgerError> {
        Self::from_response(&response)
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}

impl smithy_http::response::ParseStrictResponse for UpdateLedger {
    type Output = Result<crate::output::UpdateLedgerOutput, crate::error::UpdateLedgerError>;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        self.parse_response(response)
    }
}
