// Code generated by software.amazon.smithy.rust.codegen.smithy-rs. DO NOT EDIT.

#[non_exhaustive]
#[derive(::std::fmt::Debug)]
pub enum CancelKeyDeletionError {
    DependencyTimeoutError(DependencyTimeoutError),
    InvalidArnError(InvalidArnError),
    KMSInternalError(KMSInternalError),
    KMSInvalidStateError(KMSInvalidStateError),
    NotFoundError(NotFoundError),

    /// An unexpected error, eg. invalid JSON returned by the service
    Unhandled(Box<dyn ::std::error::Error>),
}
impl ::std::fmt::Display for CancelKeyDeletionError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match self {
            CancelKeyDeletionError::DependencyTimeoutError(_inner) => _inner.fmt(f),
            CancelKeyDeletionError::InvalidArnError(_inner) => _inner.fmt(f),
            CancelKeyDeletionError::KMSInternalError(_inner) => _inner.fmt(f),
            CancelKeyDeletionError::KMSInvalidStateError(_inner) => _inner.fmt(f),
            CancelKeyDeletionError::NotFoundError(_inner) => _inner.fmt(f),
            CancelKeyDeletionError::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl ::smithy_types::retry::ProvideErrorKind for CancelKeyDeletionError {
    fn code(&self) -> Option<&str> {
        CancelKeyDeletionError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<::smithy_types::retry::ErrorKind> {
        match self {
            CancelKeyDeletionError::DependencyTimeoutError(_inner) => None,
            CancelKeyDeletionError::InvalidArnError(_inner) => None,
            CancelKeyDeletionError::KMSInternalError(_inner) => None,
            CancelKeyDeletionError::KMSInvalidStateError(_inner) => None,
            CancelKeyDeletionError::NotFoundError(_inner) => None,
            CancelKeyDeletionError::Unhandled(_inner) => {
                match _inner.downcast_ref::<::smithy_types::Error>() {
                    Some(_inner) => _inner.retryable_error_kind(),
                    None => None,
                }
            }
        }
    }
}
impl CancelKeyDeletionError {
    pub fn unhandled<E: Into<Box<dyn ::std::error::Error>>>(err: E) -> Self {
        CancelKeyDeletionError::Unhandled(err.into())
    }
    pub fn message(&self) -> Option<&str> {
        match self {
            CancelKeyDeletionError::DependencyTimeoutError(_inner) => _inner.message(),
            CancelKeyDeletionError::InvalidArnError(_inner) => _inner.message(),
            CancelKeyDeletionError::KMSInternalError(_inner) => _inner.message(),
            CancelKeyDeletionError::KMSInvalidStateError(_inner) => _inner.message(),
            CancelKeyDeletionError::NotFoundError(_inner) => _inner.message(),
            CancelKeyDeletionError::Unhandled(_inner) => {
                match _inner.downcast_ref::<::smithy_types::Error>() {
                    Some(_inner) => _inner.message(),
                    None => None,
                }
            }
        }
    }
    pub fn code(&self) -> Option<&str> {
        match self {
            CancelKeyDeletionError::DependencyTimeoutError(_inner) => Some(_inner.code()),
            CancelKeyDeletionError::InvalidArnError(_inner) => Some(_inner.code()),
            CancelKeyDeletionError::KMSInternalError(_inner) => Some(_inner.code()),
            CancelKeyDeletionError::KMSInvalidStateError(_inner) => Some(_inner.code()),
            CancelKeyDeletionError::NotFoundError(_inner) => Some(_inner.code()),
            CancelKeyDeletionError::Unhandled(_inner) => {
                match _inner.downcast_ref::<::smithy_types::Error>() {
                    Some(_inner) => _inner.code(),
                    None => None,
                }
            }
        }
    }
}
impl ::std::error::Error for CancelKeyDeletionError {
    fn source(&self) -> Option<&(dyn ::std::error::Error + 'static)> {
        match self {
            CancelKeyDeletionError::DependencyTimeoutError(_inner) => Some(_inner),
            CancelKeyDeletionError::InvalidArnError(_inner) => Some(_inner),
            CancelKeyDeletionError::KMSInternalError(_inner) => Some(_inner),
            CancelKeyDeletionError::KMSInvalidStateError(_inner) => Some(_inner),
            CancelKeyDeletionError::NotFoundError(_inner) => Some(_inner),
            CancelKeyDeletionError::Unhandled(_inner) => {
                match _inner.downcast_ref::<::smithy_types::Error>() {
                    Some(_inner) => Some(_inner),
                    None => Some(_inner.as_ref()),
                }
            }
        }
    }
}

#[non_exhaustive]
#[derive(::std::fmt::Debug)]
pub enum ConnectCustomKeyStoreError {
    CloudHsmClusterInvalidConfigurationError(CloudHsmClusterInvalidConfigurationError),
    CloudHsmClusterNotActiveError(CloudHsmClusterNotActiveError),
    CustomKeyStoreInvalidStateError(CustomKeyStoreInvalidStateError),
    CustomKeyStoreNotFoundError(CustomKeyStoreNotFoundError),
    KMSInternalError(KMSInternalError),

    /// An unexpected error, eg. invalid JSON returned by the service
    Unhandled(Box<dyn ::std::error::Error>),
}
impl ::std::fmt::Display for ConnectCustomKeyStoreError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match self {
            ConnectCustomKeyStoreError::CloudHsmClusterInvalidConfigurationError(_inner) => {
                _inner.fmt(f)
            }
            ConnectCustomKeyStoreError::CloudHsmClusterNotActiveError(_inner) => _inner.fmt(f),
            ConnectCustomKeyStoreError::CustomKeyStoreInvalidStateError(_inner) => _inner.fmt(f),
            ConnectCustomKeyStoreError::CustomKeyStoreNotFoundError(_inner) => _inner.fmt(f),
            ConnectCustomKeyStoreError::KMSInternalError(_inner) => _inner.fmt(f),
            ConnectCustomKeyStoreError::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl ::smithy_types::retry::ProvideErrorKind for ConnectCustomKeyStoreError {
    fn code(&self) -> Option<&str> {
        ConnectCustomKeyStoreError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<::smithy_types::retry::ErrorKind> {
        match self {
            ConnectCustomKeyStoreError::CloudHsmClusterInvalidConfigurationError(_inner) => None,
            ConnectCustomKeyStoreError::CloudHsmClusterNotActiveError(_inner) => None,
            ConnectCustomKeyStoreError::CustomKeyStoreInvalidStateError(_inner) => None,
            ConnectCustomKeyStoreError::CustomKeyStoreNotFoundError(_inner) => None,
            ConnectCustomKeyStoreError::KMSInternalError(_inner) => None,
            ConnectCustomKeyStoreError::Unhandled(_inner) => {
                match _inner.downcast_ref::<::smithy_types::Error>() {
                    Some(_inner) => _inner.retryable_error_kind(),
                    None => None,
                }
            }
        }
    }
}
impl ConnectCustomKeyStoreError {
    pub fn unhandled<E: Into<Box<dyn ::std::error::Error>>>(err: E) -> Self {
        ConnectCustomKeyStoreError::Unhandled(err.into())
    }
    pub fn message(&self) -> Option<&str> {
        match self {
            ConnectCustomKeyStoreError::CloudHsmClusterInvalidConfigurationError(_inner) => {
                _inner.message()
            }
            ConnectCustomKeyStoreError::CloudHsmClusterNotActiveError(_inner) => _inner.message(),
            ConnectCustomKeyStoreError::CustomKeyStoreInvalidStateError(_inner) => _inner.message(),
            ConnectCustomKeyStoreError::CustomKeyStoreNotFoundError(_inner) => _inner.message(),
            ConnectCustomKeyStoreError::KMSInternalError(_inner) => _inner.message(),
            ConnectCustomKeyStoreError::Unhandled(_inner) => {
                match _inner.downcast_ref::<::smithy_types::Error>() {
                    Some(_inner) => _inner.message(),
                    None => None,
                }
            }
        }
    }
    pub fn code(&self) -> Option<&str> {
        match self {
            ConnectCustomKeyStoreError::CloudHsmClusterInvalidConfigurationError(_inner) => {
                Some(_inner.code())
            }
            ConnectCustomKeyStoreError::CloudHsmClusterNotActiveError(_inner) => {
                Some(_inner.code())
            }
            ConnectCustomKeyStoreError::CustomKeyStoreInvalidStateError(_inner) => {
                Some(_inner.code())
            }
            ConnectCustomKeyStoreError::CustomKeyStoreNotFoundError(_inner) => Some(_inner.code()),
            ConnectCustomKeyStoreError::KMSInternalError(_inner) => Some(_inner.code()),
            ConnectCustomKeyStoreError::Unhandled(_inner) => {
                match _inner.downcast_ref::<::smithy_types::Error>() {
                    Some(_inner) => _inner.code(),
                    None => None,
                }
            }
        }
    }
}
impl ::std::error::Error for ConnectCustomKeyStoreError {
    fn source(&self) -> Option<&(dyn ::std::error::Error + 'static)> {
        match self {
            ConnectCustomKeyStoreError::CloudHsmClusterInvalidConfigurationError(_inner) => {
                Some(_inner)
            }
            ConnectCustomKeyStoreError::CloudHsmClusterNotActiveError(_inner) => Some(_inner),
            ConnectCustomKeyStoreError::CustomKeyStoreInvalidStateError(_inner) => Some(_inner),
            ConnectCustomKeyStoreError::CustomKeyStoreNotFoundError(_inner) => Some(_inner),
            ConnectCustomKeyStoreError::KMSInternalError(_inner) => Some(_inner),
            ConnectCustomKeyStoreError::Unhandled(_inner) => {
                match _inner.downcast_ref::<::smithy_types::Error>() {
                    Some(_inner) => Some(_inner),
                    None => Some(_inner.as_ref()),
                }
            }
        }
    }
}

#[non_exhaustive]
#[derive(::std::fmt::Debug)]
pub enum CreateAliasError {
    AlreadyExistsError(AlreadyExistsError),
    DependencyTimeoutError(DependencyTimeoutError),
    InvalidAliasNameError(InvalidAliasNameError),
    KMSInternalError(KMSInternalError),
    KMSInvalidStateError(KMSInvalidStateError),
    LimitExceededError(LimitExceededError),
    NotFoundError(NotFoundError),

    /// An unexpected error, eg. invalid JSON returned by the service
    Unhandled(Box<dyn ::std::error::Error>),
}
impl ::std::fmt::Display for CreateAliasError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match self {
            CreateAliasError::AlreadyExistsError(_inner) => _inner.fmt(f),
            CreateAliasError::DependencyTimeoutError(_inner) => _inner.fmt(f),
            CreateAliasError::InvalidAliasNameError(_inner) => _inner.fmt(f),
            CreateAliasError::KMSInternalError(_inner) => _inner.fmt(f),
            CreateAliasError::KMSInvalidStateError(_inner) => _inner.fmt(f),
            CreateAliasError::LimitExceededError(_inner) => _inner.fmt(f),
            CreateAliasError::NotFoundError(_inner) => _inner.fmt(f),
            CreateAliasError::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl ::smithy_types::retry::ProvideErrorKind for CreateAliasError {
    fn code(&self) -> Option<&str> {
        CreateAliasError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<::smithy_types::retry::ErrorKind> {
        match self {
            CreateAliasError::AlreadyExistsError(_inner) => None,
            CreateAliasError::DependencyTimeoutError(_inner) => None,
            CreateAliasError::InvalidAliasNameError(_inner) => None,
            CreateAliasError::KMSInternalError(_inner) => None,
            CreateAliasError::KMSInvalidStateError(_inner) => None,
            CreateAliasError::LimitExceededError(_inner) => None,
            CreateAliasError::NotFoundError(_inner) => None,
            CreateAliasError::Unhandled(_inner) => {
                match _inner.downcast_ref::<::smithy_types::Error>() {
                    Some(_inner) => _inner.retryable_error_kind(),
                    None => None,
                }
            }
        }
    }
}
impl CreateAliasError {
    pub fn unhandled<E: Into<Box<dyn ::std::error::Error>>>(err: E) -> Self {
        CreateAliasError::Unhandled(err.into())
    }
    pub fn message(&self) -> Option<&str> {
        match self {
            CreateAliasError::AlreadyExistsError(_inner) => _inner.message(),
            CreateAliasError::DependencyTimeoutError(_inner) => _inner.message(),
            CreateAliasError::InvalidAliasNameError(_inner) => _inner.message(),
            CreateAliasError::KMSInternalError(_inner) => _inner.message(),
            CreateAliasError::KMSInvalidStateError(_inner) => _inner.message(),
            CreateAliasError::LimitExceededError(_inner) => _inner.message(),
            CreateAliasError::NotFoundError(_inner) => _inner.message(),
            CreateAliasError::Unhandled(_inner) => {
                match _inner.downcast_ref::<::smithy_types::Error>() {
                    Some(_inner) => _inner.message(),
                    None => None,
                }
            }
        }
    }
    pub fn code(&self) -> Option<&str> {
        match self {
            CreateAliasError::AlreadyExistsError(_inner) => Some(_inner.code()),
            CreateAliasError::DependencyTimeoutError(_inner) => Some(_inner.code()),
            CreateAliasError::InvalidAliasNameError(_inner) => Some(_inner.code()),
            CreateAliasError::KMSInternalError(_inner) => Some(_inner.code()),
            CreateAliasError::KMSInvalidStateError(_inner) => Some(_inner.code()),
            CreateAliasError::LimitExceededError(_inner) => Some(_inner.code()),
            CreateAliasError::NotFoundError(_inner) => Some(_inner.code()),
            CreateAliasError::Unhandled(_inner) => {
                match _inner.downcast_ref::<::smithy_types::Error>() {
                    Some(_inner) => _inner.code(),
                    None => None,
                }
            }
        }
    }
}
impl ::std::error::Error for CreateAliasError {
    fn source(&self) -> Option<&(dyn ::std::error::Error + 'static)> {
        match self {
            CreateAliasError::AlreadyExistsError(_inner) => Some(_inner),
            CreateAliasError::DependencyTimeoutError(_inner) => Some(_inner),
            CreateAliasError::InvalidAliasNameError(_inner) => Some(_inner),
            CreateAliasError::KMSInternalError(_inner) => Some(_inner),
            CreateAliasError::KMSInvalidStateError(_inner) => Some(_inner),
            CreateAliasError::LimitExceededError(_inner) => Some(_inner),
            CreateAliasError::NotFoundError(_inner) => Some(_inner),
            CreateAliasError::Unhandled(_inner) => {
                match _inner.downcast_ref::<::smithy_types::Error>() {
                    Some(_inner) => Some(_inner),
                    None => Some(_inner.as_ref()),
                }
            }
        }
    }
}

#[non_exhaustive]
#[derive(::std::fmt::Debug)]
pub enum CreateCustomKeyStoreError {
    CloudHsmClusterInUseError(CloudHsmClusterInUseError),
    CloudHsmClusterInvalidConfigurationError(CloudHsmClusterInvalidConfigurationError),
    CloudHsmClusterNotActiveError(CloudHsmClusterNotActiveError),
    CloudHsmClusterNotFoundError(CloudHsmClusterNotFoundError),
    CustomKeyStoreNameInUseError(CustomKeyStoreNameInUseError),
    IncorrectTrustAnchorError(IncorrectTrustAnchorError),
    KMSInternalError(KMSInternalError),

    /// An unexpected error, eg. invalid JSON returned by the service
    Unhandled(Box<dyn ::std::error::Error>),
}
impl ::std::fmt::Display for CreateCustomKeyStoreError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match self {
            CreateCustomKeyStoreError::CloudHsmClusterInUseError(_inner) => _inner.fmt(f),
            CreateCustomKeyStoreError::CloudHsmClusterInvalidConfigurationError(_inner) => {
                _inner.fmt(f)
            }
            CreateCustomKeyStoreError::CloudHsmClusterNotActiveError(_inner) => _inner.fmt(f),
            CreateCustomKeyStoreError::CloudHsmClusterNotFoundError(_inner) => _inner.fmt(f),
            CreateCustomKeyStoreError::CustomKeyStoreNameInUseError(_inner) => _inner.fmt(f),
            CreateCustomKeyStoreError::IncorrectTrustAnchorError(_inner) => _inner.fmt(f),
            CreateCustomKeyStoreError::KMSInternalError(_inner) => _inner.fmt(f),
            CreateCustomKeyStoreError::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl ::smithy_types::retry::ProvideErrorKind for CreateCustomKeyStoreError {
    fn code(&self) -> Option<&str> {
        CreateCustomKeyStoreError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<::smithy_types::retry::ErrorKind> {
        match self {
            CreateCustomKeyStoreError::CloudHsmClusterInUseError(_inner) => None,
            CreateCustomKeyStoreError::CloudHsmClusterInvalidConfigurationError(_inner) => None,
            CreateCustomKeyStoreError::CloudHsmClusterNotActiveError(_inner) => None,
            CreateCustomKeyStoreError::CloudHsmClusterNotFoundError(_inner) => None,
            CreateCustomKeyStoreError::CustomKeyStoreNameInUseError(_inner) => None,
            CreateCustomKeyStoreError::IncorrectTrustAnchorError(_inner) => None,
            CreateCustomKeyStoreError::KMSInternalError(_inner) => None,
            CreateCustomKeyStoreError::Unhandled(_inner) => {
                match _inner.downcast_ref::<::smithy_types::Error>() {
                    Some(_inner) => _inner.retryable_error_kind(),
                    None => None,
                }
            }
        }
    }
}
impl CreateCustomKeyStoreError {
    pub fn unhandled<E: Into<Box<dyn ::std::error::Error>>>(err: E) -> Self {
        CreateCustomKeyStoreError::Unhandled(err.into())
    }
    pub fn message(&self) -> Option<&str> {
        match self {
            CreateCustomKeyStoreError::CloudHsmClusterInUseError(_inner) => _inner.message(),
            CreateCustomKeyStoreError::CloudHsmClusterInvalidConfigurationError(_inner) => {
                _inner.message()
            }
            CreateCustomKeyStoreError::CloudHsmClusterNotActiveError(_inner) => _inner.message(),
            CreateCustomKeyStoreError::CloudHsmClusterNotFoundError(_inner) => _inner.message(),
            CreateCustomKeyStoreError::CustomKeyStoreNameInUseError(_inner) => _inner.message(),
            CreateCustomKeyStoreError::IncorrectTrustAnchorError(_inner) => _inner.message(),
            CreateCustomKeyStoreError::KMSInternalError(_inner) => _inner.message(),
            CreateCustomKeyStoreError::Unhandled(_inner) => {
                match _inner.downcast_ref::<::smithy_types::Error>() {
                    Some(_inner) => _inner.message(),
                    None => None,
                }
            }
        }
    }
    pub fn code(&self) -> Option<&str> {
        match self {
            CreateCustomKeyStoreError::CloudHsmClusterInUseError(_inner) => Some(_inner.code()),
            CreateCustomKeyStoreError::CloudHsmClusterInvalidConfigurationError(_inner) => {
                Some(_inner.code())
            }
            CreateCustomKeyStoreError::CloudHsmClusterNotActiveError(_inner) => Some(_inner.code()),
            CreateCustomKeyStoreError::CloudHsmClusterNotFoundError(_inner) => Some(_inner.code()),
            CreateCustomKeyStoreError::CustomKeyStoreNameInUseError(_inner) => Some(_inner.code()),
            CreateCustomKeyStoreError::IncorrectTrustAnchorError(_inner) => Some(_inner.code()),
            CreateCustomKeyStoreError::KMSInternalError(_inner) => Some(_inner.code()),
            CreateCustomKeyStoreError::Unhandled(_inner) => {
                match _inner.downcast_ref::<::smithy_types::Error>() {
                    Some(_inner) => _inner.code(),
                    None => None,
                }
            }
        }
    }
}
impl ::std::error::Error for CreateCustomKeyStoreError {
    fn source(&self) -> Option<&(dyn ::std::error::Error + 'static)> {
        match self {
            CreateCustomKeyStoreError::CloudHsmClusterInUseError(_inner) => Some(_inner),
            CreateCustomKeyStoreError::CloudHsmClusterInvalidConfigurationError(_inner) => {
                Some(_inner)
            }
            CreateCustomKeyStoreError::CloudHsmClusterNotActiveError(_inner) => Some(_inner),
            CreateCustomKeyStoreError::CloudHsmClusterNotFoundError(_inner) => Some(_inner),
            CreateCustomKeyStoreError::CustomKeyStoreNameInUseError(_inner) => Some(_inner),
            CreateCustomKeyStoreError::IncorrectTrustAnchorError(_inner) => Some(_inner),
            CreateCustomKeyStoreError::KMSInternalError(_inner) => Some(_inner),
            CreateCustomKeyStoreError::Unhandled(_inner) => {
                match _inner.downcast_ref::<::smithy_types::Error>() {
                    Some(_inner) => Some(_inner),
                    None => Some(_inner.as_ref()),
                }
            }
        }
    }
}

#[non_exhaustive]
#[derive(::std::fmt::Debug)]
pub enum CreateGrantError {
    DependencyTimeoutError(DependencyTimeoutError),
    DisabledError(DisabledError),
    InvalidArnError(InvalidArnError),
    InvalidGrantTokenError(InvalidGrantTokenError),
    KMSInternalError(KMSInternalError),
    KMSInvalidStateError(KMSInvalidStateError),
    LimitExceededError(LimitExceededError),
    NotFoundError(NotFoundError),

    /// An unexpected error, eg. invalid JSON returned by the service
    Unhandled(Box<dyn ::std::error::Error>),
}
impl ::std::fmt::Display for CreateGrantError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match self {
            CreateGrantError::DependencyTimeoutError(_inner) => _inner.fmt(f),
            CreateGrantError::DisabledError(_inner) => _inner.fmt(f),
            CreateGrantError::InvalidArnError(_inner) => _inner.fmt(f),
            CreateGrantError::InvalidGrantTokenError(_inner) => _inner.fmt(f),
            CreateGrantError::KMSInternalError(_inner) => _inner.fmt(f),
            CreateGrantError::KMSInvalidStateError(_inner) => _inner.fmt(f),
            CreateGrantError::LimitExceededError(_inner) => _inner.fmt(f),
            CreateGrantError::NotFoundError(_inner) => _inner.fmt(f),
            CreateGrantError::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl ::smithy_types::retry::ProvideErrorKind for CreateGrantError {
    fn code(&self) -> Option<&str> {
        CreateGrantError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<::smithy_types::retry::ErrorKind> {
        match self {
            CreateGrantError::DependencyTimeoutError(_inner) => None,
            CreateGrantError::DisabledError(_inner) => None,
            CreateGrantError::InvalidArnError(_inner) => None,
            CreateGrantError::InvalidGrantTokenError(_inner) => None,
            CreateGrantError::KMSInternalError(_inner) => None,
            CreateGrantError::KMSInvalidStateError(_inner) => None,
            CreateGrantError::LimitExceededError(_inner) => None,
            CreateGrantError::NotFoundError(_inner) => None,
            CreateGrantError::Unhandled(_inner) => {
                match _inner.downcast_ref::<::smithy_types::Error>() {
                    Some(_inner) => _inner.retryable_error_kind(),
                    None => None,
                }
            }
        }
    }
}
impl CreateGrantError {
    pub fn unhandled<E: Into<Box<dyn ::std::error::Error>>>(err: E) -> Self {
        CreateGrantError::Unhandled(err.into())
    }
    pub fn message(&self) -> Option<&str> {
        match self {
            CreateGrantError::DependencyTimeoutError(_inner) => _inner.message(),
            CreateGrantError::DisabledError(_inner) => _inner.message(),
            CreateGrantError::InvalidArnError(_inner) => _inner.message(),
            CreateGrantError::InvalidGrantTokenError(_inner) => _inner.message(),
            CreateGrantError::KMSInternalError(_inner) => _inner.message(),
            CreateGrantError::KMSInvalidStateError(_inner) => _inner.message(),
            CreateGrantError::LimitExceededError(_inner) => _inner.message(),
            CreateGrantError::NotFoundError(_inner) => _inner.message(),
            CreateGrantError::Unhandled(_inner) => {
                match _inner.downcast_ref::<::smithy_types::Error>() {
                    Some(_inner) => _inner.message(),
                    None => None,
                }
            }
        }
    }
    pub fn code(&self) -> Option<&str> {
        match self {
            CreateGrantError::DependencyTimeoutError(_inner) => Some(_inner.code()),
            CreateGrantError::DisabledError(_inner) => Some(_inner.code()),
            CreateGrantError::InvalidArnError(_inner) => Some(_inner.code()),
            CreateGrantError::InvalidGrantTokenError(_inner) => Some(_inner.code()),
            CreateGrantError::KMSInternalError(_inner) => Some(_inner.code()),
            CreateGrantError::KMSInvalidStateError(_inner) => Some(_inner.code()),
            CreateGrantError::LimitExceededError(_inner) => Some(_inner.code()),
            CreateGrantError::NotFoundError(_inner) => Some(_inner.code()),
            CreateGrantError::Unhandled(_inner) => {
                match _inner.downcast_ref::<::smithy_types::Error>() {
                    Some(_inner) => _inner.code(),
                    None => None,
                }
            }
        }
    }
}
impl ::std::error::Error for CreateGrantError {
    fn source(&self) -> Option<&(dyn ::std::error::Error + 'static)> {
        match self {
            CreateGrantError::DependencyTimeoutError(_inner) => Some(_inner),
            CreateGrantError::DisabledError(_inner) => Some(_inner),
            CreateGrantError::InvalidArnError(_inner) => Some(_inner),
            CreateGrantError::InvalidGrantTokenError(_inner) => Some(_inner),
            CreateGrantError::KMSInternalError(_inner) => Some(_inner),
            CreateGrantError::KMSInvalidStateError(_inner) => Some(_inner),
            CreateGrantError::LimitExceededError(_inner) => Some(_inner),
            CreateGrantError::NotFoundError(_inner) => Some(_inner),
            CreateGrantError::Unhandled(_inner) => {
                match _inner.downcast_ref::<::smithy_types::Error>() {
                    Some(_inner) => Some(_inner),
                    None => Some(_inner.as_ref()),
                }
            }
        }
    }
}

#[non_exhaustive]
#[derive(::std::fmt::Debug)]
pub enum CreateKeyError {
    CloudHsmClusterInvalidConfigurationError(CloudHsmClusterInvalidConfigurationError),
    CustomKeyStoreInvalidStateError(CustomKeyStoreInvalidStateError),
    CustomKeyStoreNotFoundError(CustomKeyStoreNotFoundError),
    DependencyTimeoutError(DependencyTimeoutError),
    InvalidArnError(InvalidArnError),
    KMSInternalError(KMSInternalError),
    LimitExceededError(LimitExceededError),
    MalformedPolicyDocumentError(MalformedPolicyDocumentError),
    TagError(TagError),
    UnsupportedOperationError(UnsupportedOperationError),

    /// An unexpected error, eg. invalid JSON returned by the service
    Unhandled(Box<dyn ::std::error::Error>),
}
impl ::std::fmt::Display for CreateKeyError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match self {
            CreateKeyError::CloudHsmClusterInvalidConfigurationError(_inner) => _inner.fmt(f),
            CreateKeyError::CustomKeyStoreInvalidStateError(_inner) => _inner.fmt(f),
            CreateKeyError::CustomKeyStoreNotFoundError(_inner) => _inner.fmt(f),
            CreateKeyError::DependencyTimeoutError(_inner) => _inner.fmt(f),
            CreateKeyError::InvalidArnError(_inner) => _inner.fmt(f),
            CreateKeyError::KMSInternalError(_inner) => _inner.fmt(f),
            CreateKeyError::LimitExceededError(_inner) => _inner.fmt(f),
            CreateKeyError::MalformedPolicyDocumentError(_inner) => _inner.fmt(f),
            CreateKeyError::TagError(_inner) => _inner.fmt(f),
            CreateKeyError::UnsupportedOperationError(_inner) => _inner.fmt(f),
            CreateKeyError::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl ::smithy_types::retry::ProvideErrorKind for CreateKeyError {
    fn code(&self) -> Option<&str> {
        CreateKeyError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<::smithy_types::retry::ErrorKind> {
        match self {
            CreateKeyError::CloudHsmClusterInvalidConfigurationError(_inner) => None,
            CreateKeyError::CustomKeyStoreInvalidStateError(_inner) => None,
            CreateKeyError::CustomKeyStoreNotFoundError(_inner) => None,
            CreateKeyError::DependencyTimeoutError(_inner) => None,
            CreateKeyError::InvalidArnError(_inner) => None,
            CreateKeyError::KMSInternalError(_inner) => None,
            CreateKeyError::LimitExceededError(_inner) => None,
            CreateKeyError::MalformedPolicyDocumentError(_inner) => None,
            CreateKeyError::TagError(_inner) => None,
            CreateKeyError::UnsupportedOperationError(_inner) => None,
            CreateKeyError::Unhandled(_inner) => {
                match _inner.downcast_ref::<::smithy_types::Error>() {
                    Some(_inner) => _inner.retryable_error_kind(),
                    None => None,
                }
            }
        }
    }
}
impl CreateKeyError {
    pub fn unhandled<E: Into<Box<dyn ::std::error::Error>>>(err: E) -> Self {
        CreateKeyError::Unhandled(err.into())
    }
    pub fn message(&self) -> Option<&str> {
        match self {
            CreateKeyError::CloudHsmClusterInvalidConfigurationError(_inner) => _inner.message(),
            CreateKeyError::CustomKeyStoreInvalidStateError(_inner) => _inner.message(),
            CreateKeyError::CustomKeyStoreNotFoundError(_inner) => _inner.message(),
            CreateKeyError::DependencyTimeoutError(_inner) => _inner.message(),
            CreateKeyError::InvalidArnError(_inner) => _inner.message(),
            CreateKeyError::KMSInternalError(_inner) => _inner.message(),
            CreateKeyError::LimitExceededError(_inner) => _inner.message(),
            CreateKeyError::MalformedPolicyDocumentError(_inner) => _inner.message(),
            CreateKeyError::TagError(_inner) => _inner.message(),
            CreateKeyError::UnsupportedOperationError(_inner) => _inner.message(),
            CreateKeyError::Unhandled(_inner) => {
                match _inner.downcast_ref::<::smithy_types::Error>() {
                    Some(_inner) => _inner.message(),
                    None => None,
                }
            }
        }
    }
    pub fn code(&self) -> Option<&str> {
        match self {
            CreateKeyError::CloudHsmClusterInvalidConfigurationError(_inner) => Some(_inner.code()),
            CreateKeyError::CustomKeyStoreInvalidStateError(_inner) => Some(_inner.code()),
            CreateKeyError::CustomKeyStoreNotFoundError(_inner) => Some(_inner.code()),
            CreateKeyError::DependencyTimeoutError(_inner) => Some(_inner.code()),
            CreateKeyError::InvalidArnError(_inner) => Some(_inner.code()),
            CreateKeyError::KMSInternalError(_inner) => Some(_inner.code()),
            CreateKeyError::LimitExceededError(_inner) => Some(_inner.code()),
            CreateKeyError::MalformedPolicyDocumentError(_inner) => Some(_inner.code()),
            CreateKeyError::TagError(_inner) => Some(_inner.code()),
            CreateKeyError::UnsupportedOperationError(_inner) => Some(_inner.code()),
            CreateKeyError::Unhandled(_inner) => {
                match _inner.downcast_ref::<::smithy_types::Error>() {
                    Some(_inner) => _inner.code(),
                    None => None,
                }
            }
        }
    }
}
impl ::std::error::Error for CreateKeyError {
    fn source(&self) -> Option<&(dyn ::std::error::Error + 'static)> {
        match self {
            CreateKeyError::CloudHsmClusterInvalidConfigurationError(_inner) => Some(_inner),
            CreateKeyError::CustomKeyStoreInvalidStateError(_inner) => Some(_inner),
            CreateKeyError::CustomKeyStoreNotFoundError(_inner) => Some(_inner),
            CreateKeyError::DependencyTimeoutError(_inner) => Some(_inner),
            CreateKeyError::InvalidArnError(_inner) => Some(_inner),
            CreateKeyError::KMSInternalError(_inner) => Some(_inner),
            CreateKeyError::LimitExceededError(_inner) => Some(_inner),
            CreateKeyError::MalformedPolicyDocumentError(_inner) => Some(_inner),
            CreateKeyError::TagError(_inner) => Some(_inner),
            CreateKeyError::UnsupportedOperationError(_inner) => Some(_inner),
            CreateKeyError::Unhandled(_inner) => {
                match _inner.downcast_ref::<::smithy_types::Error>() {
                    Some(_inner) => Some(_inner),
                    None => Some(_inner.as_ref()),
                }
            }
        }
    }
}

#[non_exhaustive]
#[derive(::std::fmt::Debug)]
pub enum DecryptError {
    DependencyTimeoutError(DependencyTimeoutError),
    DisabledError(DisabledError),
    IncorrectKeyError(IncorrectKeyError),
    InvalidCiphertextError(InvalidCiphertextError),
    InvalidGrantTokenError(InvalidGrantTokenError),
    InvalidKeyUsageError(InvalidKeyUsageError),
    KeyUnavailableError(KeyUnavailableError),
    KMSInternalError(KMSInternalError),
    KMSInvalidStateError(KMSInvalidStateError),
    NotFoundError(NotFoundError),

    /// An unexpected error, eg. invalid JSON returned by the service
    Unhandled(Box<dyn ::std::error::Error>),
}
impl ::std::fmt::Display for DecryptError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match self {
            DecryptError::DependencyTimeoutError(_inner) => _inner.fmt(f),
            DecryptError::DisabledError(_inner) => _inner.fmt(f),
            DecryptError::IncorrectKeyError(_inner) => _inner.fmt(f),
            DecryptError::InvalidCiphertextError(_inner) => _inner.fmt(f),
            DecryptError::InvalidGrantTokenError(_inner) => _inner.fmt(f),
            DecryptError::InvalidKeyUsageError(_inner) => _inner.fmt(f),
            DecryptError::KeyUnavailableError(_inner) => _inner.fmt(f),
            DecryptError::KMSInternalError(_inner) => _inner.fmt(f),
            DecryptError::KMSInvalidStateError(_inner) => _inner.fmt(f),
            DecryptError::NotFoundError(_inner) => _inner.fmt(f),
            DecryptError::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl ::smithy_types::retry::ProvideErrorKind for DecryptError {
    fn code(&self) -> Option<&str> {
        DecryptError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<::smithy_types::retry::ErrorKind> {
        match self {
            DecryptError::DependencyTimeoutError(_inner) => None,
            DecryptError::DisabledError(_inner) => None,
            DecryptError::IncorrectKeyError(_inner) => None,
            DecryptError::InvalidCiphertextError(_inner) => None,
            DecryptError::InvalidGrantTokenError(_inner) => None,
            DecryptError::InvalidKeyUsageError(_inner) => None,
            DecryptError::KeyUnavailableError(_inner) => None,
            DecryptError::KMSInternalError(_inner) => None,
            DecryptError::KMSInvalidStateError(_inner) => None,
            DecryptError::NotFoundError(_inner) => None,
            DecryptError::Unhandled(_inner) => {
                match _inner.downcast_ref::<::smithy_types::Error>() {
                    Some(_inner) => _inner.retryable_error_kind(),
                    None => None,
                }
            }
        }
    }
}
impl DecryptError {
    pub fn unhandled<E: Into<Box<dyn ::std::error::Error>>>(err: E) -> Self {
        DecryptError::Unhandled(err.into())
    }
    pub fn message(&self) -> Option<&str> {
        match self {
            DecryptError::DependencyTimeoutError(_inner) => _inner.message(),
            DecryptError::DisabledError(_inner) => _inner.message(),
            DecryptError::IncorrectKeyError(_inner) => _inner.message(),
            DecryptError::InvalidCiphertextError(_inner) => _inner.message(),
            DecryptError::InvalidGrantTokenError(_inner) => _inner.message(),
            DecryptError::InvalidKeyUsageError(_inner) => _inner.message(),
            DecryptError::KeyUnavailableError(_inner) => _inner.message(),
            DecryptError::KMSInternalError(_inner) => _inner.message(),
            DecryptError::KMSInvalidStateError(_inner) => _inner.message(),
            DecryptError::NotFoundError(_inner) => _inner.message(),
            DecryptError::Unhandled(_inner) => {
                match _inner.downcast_ref::<::smithy_types::Error>() {
                    Some(_inner) => _inner.message(),
                    None => None,
                }
            }
        }
    }
    pub fn code(&self) -> Option<&str> {
        match self {
            DecryptError::DependencyTimeoutError(_inner) => Some(_inner.code()),
            DecryptError::DisabledError(_inner) => Some(_inner.code()),
            DecryptError::IncorrectKeyError(_inner) => Some(_inner.code()),
            DecryptError::InvalidCiphertextError(_inner) => Some(_inner.code()),
            DecryptError::InvalidGrantTokenError(_inner) => Some(_inner.code()),
            DecryptError::InvalidKeyUsageError(_inner) => Some(_inner.code()),
            DecryptError::KeyUnavailableError(_inner) => Some(_inner.code()),
            DecryptError::KMSInternalError(_inner) => Some(_inner.code()),
            DecryptError::KMSInvalidStateError(_inner) => Some(_inner.code()),
            DecryptError::NotFoundError(_inner) => Some(_inner.code()),
            DecryptError::Unhandled(_inner) => {
                match _inner.downcast_ref::<::smithy_types::Error>() {
                    Some(_inner) => _inner.code(),
                    None => None,
                }
            }
        }
    }
}
impl ::std::error::Error for DecryptError {
    fn source(&self) -> Option<&(dyn ::std::error::Error + 'static)> {
        match self {
            DecryptError::DependencyTimeoutError(_inner) => Some(_inner),
            DecryptError::DisabledError(_inner) => Some(_inner),
            DecryptError::IncorrectKeyError(_inner) => Some(_inner),
            DecryptError::InvalidCiphertextError(_inner) => Some(_inner),
            DecryptError::InvalidGrantTokenError(_inner) => Some(_inner),
            DecryptError::InvalidKeyUsageError(_inner) => Some(_inner),
            DecryptError::KeyUnavailableError(_inner) => Some(_inner),
            DecryptError::KMSInternalError(_inner) => Some(_inner),
            DecryptError::KMSInvalidStateError(_inner) => Some(_inner),
            DecryptError::NotFoundError(_inner) => Some(_inner),
            DecryptError::Unhandled(_inner) => {
                match _inner.downcast_ref::<::smithy_types::Error>() {
                    Some(_inner) => Some(_inner),
                    None => Some(_inner.as_ref()),
                }
            }
        }
    }
}

#[non_exhaustive]
#[derive(::std::fmt::Debug)]
pub enum DeleteAliasError {
    DependencyTimeoutError(DependencyTimeoutError),
    KMSInternalError(KMSInternalError),
    KMSInvalidStateError(KMSInvalidStateError),
    NotFoundError(NotFoundError),

    /// An unexpected error, eg. invalid JSON returned by the service
    Unhandled(Box<dyn ::std::error::Error>),
}
impl ::std::fmt::Display for DeleteAliasError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match self {
            DeleteAliasError::DependencyTimeoutError(_inner) => _inner.fmt(f),
            DeleteAliasError::KMSInternalError(_inner) => _inner.fmt(f),
            DeleteAliasError::KMSInvalidStateError(_inner) => _inner.fmt(f),
            DeleteAliasError::NotFoundError(_inner) => _inner.fmt(f),
            DeleteAliasError::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl ::smithy_types::retry::ProvideErrorKind for DeleteAliasError {
    fn code(&self) -> Option<&str> {
        DeleteAliasError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<::smithy_types::retry::ErrorKind> {
        match self {
            DeleteAliasError::DependencyTimeoutError(_inner) => None,
            DeleteAliasError::KMSInternalError(_inner) => None,
            DeleteAliasError::KMSInvalidStateError(_inner) => None,
            DeleteAliasError::NotFoundError(_inner) => None,
            DeleteAliasError::Unhandled(_inner) => {
                match _inner.downcast_ref::<::smithy_types::Error>() {
                    Some(_inner) => _inner.retryable_error_kind(),
                    None => None,
                }
            }
        }
    }
}
impl DeleteAliasError {
    pub fn unhandled<E: Into<Box<dyn ::std::error::Error>>>(err: E) -> Self {
        DeleteAliasError::Unhandled(err.into())
    }
    pub fn message(&self) -> Option<&str> {
        match self {
            DeleteAliasError::DependencyTimeoutError(_inner) => _inner.message(),
            DeleteAliasError::KMSInternalError(_inner) => _inner.message(),
            DeleteAliasError::KMSInvalidStateError(_inner) => _inner.message(),
            DeleteAliasError::NotFoundError(_inner) => _inner.message(),
            DeleteAliasError::Unhandled(_inner) => {
                match _inner.downcast_ref::<::smithy_types::Error>() {
                    Some(_inner) => _inner.message(),
                    None => None,
                }
            }
        }
    }
    pub fn code(&self) -> Option<&str> {
        match self {
            DeleteAliasError::DependencyTimeoutError(_inner) => Some(_inner.code()),
            DeleteAliasError::KMSInternalError(_inner) => Some(_inner.code()),
            DeleteAliasError::KMSInvalidStateError(_inner) => Some(_inner.code()),
            DeleteAliasError::NotFoundError(_inner) => Some(_inner.code()),
            DeleteAliasError::Unhandled(_inner) => {
                match _inner.downcast_ref::<::smithy_types::Error>() {
                    Some(_inner) => _inner.code(),
                    None => None,
                }
            }
        }
    }
}
impl ::std::error::Error for DeleteAliasError {
    fn source(&self) -> Option<&(dyn ::std::error::Error + 'static)> {
        match self {
            DeleteAliasError::DependencyTimeoutError(_inner) => Some(_inner),
            DeleteAliasError::KMSInternalError(_inner) => Some(_inner),
            DeleteAliasError::KMSInvalidStateError(_inner) => Some(_inner),
            DeleteAliasError::NotFoundError(_inner) => Some(_inner),
            DeleteAliasError::Unhandled(_inner) => {
                match _inner.downcast_ref::<::smithy_types::Error>() {
                    Some(_inner) => Some(_inner),
                    None => Some(_inner.as_ref()),
                }
            }
        }
    }
}

#[non_exhaustive]
#[derive(::std::fmt::Debug)]
pub enum DeleteCustomKeyStoreError {
    CustomKeyStoreHasCMKsError(CustomKeyStoreHasCMKsError),
    CustomKeyStoreInvalidStateError(CustomKeyStoreInvalidStateError),
    CustomKeyStoreNotFoundError(CustomKeyStoreNotFoundError),
    KMSInternalError(KMSInternalError),

    /// An unexpected error, eg. invalid JSON returned by the service
    Unhandled(Box<dyn ::std::error::Error>),
}
impl ::std::fmt::Display for DeleteCustomKeyStoreError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match self {
            DeleteCustomKeyStoreError::CustomKeyStoreHasCMKsError(_inner) => _inner.fmt(f),
            DeleteCustomKeyStoreError::CustomKeyStoreInvalidStateError(_inner) => _inner.fmt(f),
            DeleteCustomKeyStoreError::CustomKeyStoreNotFoundError(_inner) => _inner.fmt(f),
            DeleteCustomKeyStoreError::KMSInternalError(_inner) => _inner.fmt(f),
            DeleteCustomKeyStoreError::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl ::smithy_types::retry::ProvideErrorKind for DeleteCustomKeyStoreError {
    fn code(&self) -> Option<&str> {
        DeleteCustomKeyStoreError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<::smithy_types::retry::ErrorKind> {
        match self {
            DeleteCustomKeyStoreError::CustomKeyStoreHasCMKsError(_inner) => None,
            DeleteCustomKeyStoreError::CustomKeyStoreInvalidStateError(_inner) => None,
            DeleteCustomKeyStoreError::CustomKeyStoreNotFoundError(_inner) => None,
            DeleteCustomKeyStoreError::KMSInternalError(_inner) => None,
            DeleteCustomKeyStoreError::Unhandled(_inner) => {
                match _inner.downcast_ref::<::smithy_types::Error>() {
                    Some(_inner) => _inner.retryable_error_kind(),
                    None => None,
                }
            }
        }
    }
}
impl DeleteCustomKeyStoreError {
    pub fn unhandled<E: Into<Box<dyn ::std::error::Error>>>(err: E) -> Self {
        DeleteCustomKeyStoreError::Unhandled(err.into())
    }
    pub fn message(&self) -> Option<&str> {
        match self {
            DeleteCustomKeyStoreError::CustomKeyStoreHasCMKsError(_inner) => _inner.message(),
            DeleteCustomKeyStoreError::CustomKeyStoreInvalidStateError(_inner) => _inner.message(),
            DeleteCustomKeyStoreError::CustomKeyStoreNotFoundError(_inner) => _inner.message(),
            DeleteCustomKeyStoreError::KMSInternalError(_inner) => _inner.message(),
            DeleteCustomKeyStoreError::Unhandled(_inner) => {
                match _inner.downcast_ref::<::smithy_types::Error>() {
                    Some(_inner) => _inner.message(),
                    None => None,
                }
            }
        }
    }
    pub fn code(&self) -> Option<&str> {
        match self {
            DeleteCustomKeyStoreError::CustomKeyStoreHasCMKsError(_inner) => Some(_inner.code()),
            DeleteCustomKeyStoreError::CustomKeyStoreInvalidStateError(_inner) => {
                Some(_inner.code())
            }
            DeleteCustomKeyStoreError::CustomKeyStoreNotFoundError(_inner) => Some(_inner.code()),
            DeleteCustomKeyStoreError::KMSInternalError(_inner) => Some(_inner.code()),
            DeleteCustomKeyStoreError::Unhandled(_inner) => {
                match _inner.downcast_ref::<::smithy_types::Error>() {
                    Some(_inner) => _inner.code(),
                    None => None,
                }
            }
        }
    }
}
impl ::std::error::Error for DeleteCustomKeyStoreError {
    fn source(&self) -> Option<&(dyn ::std::error::Error + 'static)> {
        match self {
            DeleteCustomKeyStoreError::CustomKeyStoreHasCMKsError(_inner) => Some(_inner),
            DeleteCustomKeyStoreError::CustomKeyStoreInvalidStateError(_inner) => Some(_inner),
            DeleteCustomKeyStoreError::CustomKeyStoreNotFoundError(_inner) => Some(_inner),
            DeleteCustomKeyStoreError::KMSInternalError(_inner) => Some(_inner),
            DeleteCustomKeyStoreError::Unhandled(_inner) => {
                match _inner.downcast_ref::<::smithy_types::Error>() {
                    Some(_inner) => Some(_inner),
                    None => Some(_inner.as_ref()),
                }
            }
        }
    }
}

#[non_exhaustive]
#[derive(::std::fmt::Debug)]
pub enum DeleteImportedKeyMaterialError {
    DependencyTimeoutError(DependencyTimeoutError),
    InvalidArnError(InvalidArnError),
    KMSInternalError(KMSInternalError),
    KMSInvalidStateError(KMSInvalidStateError),
    NotFoundError(NotFoundError),
    UnsupportedOperationError(UnsupportedOperationError),

    /// An unexpected error, eg. invalid JSON returned by the service
    Unhandled(Box<dyn ::std::error::Error>),
}
impl ::std::fmt::Display for DeleteImportedKeyMaterialError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match self {
            DeleteImportedKeyMaterialError::DependencyTimeoutError(_inner) => _inner.fmt(f),
            DeleteImportedKeyMaterialError::InvalidArnError(_inner) => _inner.fmt(f),
            DeleteImportedKeyMaterialError::KMSInternalError(_inner) => _inner.fmt(f),
            DeleteImportedKeyMaterialError::KMSInvalidStateError(_inner) => _inner.fmt(f),
            DeleteImportedKeyMaterialError::NotFoundError(_inner) => _inner.fmt(f),
            DeleteImportedKeyMaterialError::UnsupportedOperationError(_inner) => _inner.fmt(f),
            DeleteImportedKeyMaterialError::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl ::smithy_types::retry::ProvideErrorKind for DeleteImportedKeyMaterialError {
    fn code(&self) -> Option<&str> {
        DeleteImportedKeyMaterialError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<::smithy_types::retry::ErrorKind> {
        match self {
            DeleteImportedKeyMaterialError::DependencyTimeoutError(_inner) => None,
            DeleteImportedKeyMaterialError::InvalidArnError(_inner) => None,
            DeleteImportedKeyMaterialError::KMSInternalError(_inner) => None,
            DeleteImportedKeyMaterialError::KMSInvalidStateError(_inner) => None,
            DeleteImportedKeyMaterialError::NotFoundError(_inner) => None,
            DeleteImportedKeyMaterialError::UnsupportedOperationError(_inner) => None,
            DeleteImportedKeyMaterialError::Unhandled(_inner) => {
                match _inner.downcast_ref::<::smithy_types::Error>() {
                    Some(_inner) => _inner.retryable_error_kind(),
                    None => None,
                }
            }
        }
    }
}
impl DeleteImportedKeyMaterialError {
    pub fn unhandled<E: Into<Box<dyn ::std::error::Error>>>(err: E) -> Self {
        DeleteImportedKeyMaterialError::Unhandled(err.into())
    }
    pub fn message(&self) -> Option<&str> {
        match self {
            DeleteImportedKeyMaterialError::DependencyTimeoutError(_inner) => _inner.message(),
            DeleteImportedKeyMaterialError::InvalidArnError(_inner) => _inner.message(),
            DeleteImportedKeyMaterialError::KMSInternalError(_inner) => _inner.message(),
            DeleteImportedKeyMaterialError::KMSInvalidStateError(_inner) => _inner.message(),
            DeleteImportedKeyMaterialError::NotFoundError(_inner) => _inner.message(),
            DeleteImportedKeyMaterialError::UnsupportedOperationError(_inner) => _inner.message(),
            DeleteImportedKeyMaterialError::Unhandled(_inner) => {
                match _inner.downcast_ref::<::smithy_types::Error>() {
                    Some(_inner) => _inner.message(),
                    None => None,
                }
            }
        }
    }
    pub fn code(&self) -> Option<&str> {
        match self {
            DeleteImportedKeyMaterialError::DependencyTimeoutError(_inner) => Some(_inner.code()),
            DeleteImportedKeyMaterialError::InvalidArnError(_inner) => Some(_inner.code()),
            DeleteImportedKeyMaterialError::KMSInternalError(_inner) => Some(_inner.code()),
            DeleteImportedKeyMaterialError::KMSInvalidStateError(_inner) => Some(_inner.code()),
            DeleteImportedKeyMaterialError::NotFoundError(_inner) => Some(_inner.code()),
            DeleteImportedKeyMaterialError::UnsupportedOperationError(_inner) => {
                Some(_inner.code())
            }
            DeleteImportedKeyMaterialError::Unhandled(_inner) => {
                match _inner.downcast_ref::<::smithy_types::Error>() {
                    Some(_inner) => _inner.code(),
                    None => None,
                }
            }
        }
    }
}
impl ::std::error::Error for DeleteImportedKeyMaterialError {
    fn source(&self) -> Option<&(dyn ::std::error::Error + 'static)> {
        match self {
            DeleteImportedKeyMaterialError::DependencyTimeoutError(_inner) => Some(_inner),
            DeleteImportedKeyMaterialError::InvalidArnError(_inner) => Some(_inner),
            DeleteImportedKeyMaterialError::KMSInternalError(_inner) => Some(_inner),
            DeleteImportedKeyMaterialError::KMSInvalidStateError(_inner) => Some(_inner),
            DeleteImportedKeyMaterialError::NotFoundError(_inner) => Some(_inner),
            DeleteImportedKeyMaterialError::UnsupportedOperationError(_inner) => Some(_inner),
            DeleteImportedKeyMaterialError::Unhandled(_inner) => {
                match _inner.downcast_ref::<::smithy_types::Error>() {
                    Some(_inner) => Some(_inner),
                    None => Some(_inner.as_ref()),
                }
            }
        }
    }
}

#[non_exhaustive]
#[derive(::std::fmt::Debug)]
pub enum DescribeCustomKeyStoresError {
    CustomKeyStoreNotFoundError(CustomKeyStoreNotFoundError),
    KMSInternalError(KMSInternalError),

    /// An unexpected error, eg. invalid JSON returned by the service
    Unhandled(Box<dyn ::std::error::Error>),
}
impl ::std::fmt::Display for DescribeCustomKeyStoresError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match self {
            DescribeCustomKeyStoresError::CustomKeyStoreNotFoundError(_inner) => _inner.fmt(f),
            DescribeCustomKeyStoresError::KMSInternalError(_inner) => _inner.fmt(f),
            DescribeCustomKeyStoresError::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl ::smithy_types::retry::ProvideErrorKind for DescribeCustomKeyStoresError {
    fn code(&self) -> Option<&str> {
        DescribeCustomKeyStoresError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<::smithy_types::retry::ErrorKind> {
        match self {
            DescribeCustomKeyStoresError::CustomKeyStoreNotFoundError(_inner) => None,
            DescribeCustomKeyStoresError::KMSInternalError(_inner) => None,
            DescribeCustomKeyStoresError::Unhandled(_inner) => {
                match _inner.downcast_ref::<::smithy_types::Error>() {
                    Some(_inner) => _inner.retryable_error_kind(),
                    None => None,
                }
            }
        }
    }
}
impl DescribeCustomKeyStoresError {
    pub fn unhandled<E: Into<Box<dyn ::std::error::Error>>>(err: E) -> Self {
        DescribeCustomKeyStoresError::Unhandled(err.into())
    }
    pub fn message(&self) -> Option<&str> {
        match self {
            DescribeCustomKeyStoresError::CustomKeyStoreNotFoundError(_inner) => _inner.message(),
            DescribeCustomKeyStoresError::KMSInternalError(_inner) => _inner.message(),
            DescribeCustomKeyStoresError::Unhandled(_inner) => {
                match _inner.downcast_ref::<::smithy_types::Error>() {
                    Some(_inner) => _inner.message(),
                    None => None,
                }
            }
        }
    }
    pub fn code(&self) -> Option<&str> {
        match self {
            DescribeCustomKeyStoresError::CustomKeyStoreNotFoundError(_inner) => {
                Some(_inner.code())
            }
            DescribeCustomKeyStoresError::KMSInternalError(_inner) => Some(_inner.code()),
            DescribeCustomKeyStoresError::Unhandled(_inner) => {
                match _inner.downcast_ref::<::smithy_types::Error>() {
                    Some(_inner) => _inner.code(),
                    None => None,
                }
            }
        }
    }
}
impl ::std::error::Error for DescribeCustomKeyStoresError {
    fn source(&self) -> Option<&(dyn ::std::error::Error + 'static)> {
        match self {
            DescribeCustomKeyStoresError::CustomKeyStoreNotFoundError(_inner) => Some(_inner),
            DescribeCustomKeyStoresError::KMSInternalError(_inner) => Some(_inner),
            DescribeCustomKeyStoresError::Unhandled(_inner) => {
                match _inner.downcast_ref::<::smithy_types::Error>() {
                    Some(_inner) => Some(_inner),
                    None => Some(_inner.as_ref()),
                }
            }
        }
    }
}

#[non_exhaustive]
#[derive(::std::fmt::Debug)]
pub enum DescribeKeyError {
    DependencyTimeoutError(DependencyTimeoutError),
    InvalidArnError(InvalidArnError),
    KMSInternalError(KMSInternalError),
    NotFoundError(NotFoundError),

    /// An unexpected error, eg. invalid JSON returned by the service
    Unhandled(Box<dyn ::std::error::Error>),
}
impl ::std::fmt::Display for DescribeKeyError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match self {
            DescribeKeyError::DependencyTimeoutError(_inner) => _inner.fmt(f),
            DescribeKeyError::InvalidArnError(_inner) => _inner.fmt(f),
            DescribeKeyError::KMSInternalError(_inner) => _inner.fmt(f),
            DescribeKeyError::NotFoundError(_inner) => _inner.fmt(f),
            DescribeKeyError::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl ::smithy_types::retry::ProvideErrorKind for DescribeKeyError {
    fn code(&self) -> Option<&str> {
        DescribeKeyError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<::smithy_types::retry::ErrorKind> {
        match self {
            DescribeKeyError::DependencyTimeoutError(_inner) => None,
            DescribeKeyError::InvalidArnError(_inner) => None,
            DescribeKeyError::KMSInternalError(_inner) => None,
            DescribeKeyError::NotFoundError(_inner) => None,
            DescribeKeyError::Unhandled(_inner) => {
                match _inner.downcast_ref::<::smithy_types::Error>() {
                    Some(_inner) => _inner.retryable_error_kind(),
                    None => None,
                }
            }
        }
    }
}
impl DescribeKeyError {
    pub fn unhandled<E: Into<Box<dyn ::std::error::Error>>>(err: E) -> Self {
        DescribeKeyError::Unhandled(err.into())
    }
    pub fn message(&self) -> Option<&str> {
        match self {
            DescribeKeyError::DependencyTimeoutError(_inner) => _inner.message(),
            DescribeKeyError::InvalidArnError(_inner) => _inner.message(),
            DescribeKeyError::KMSInternalError(_inner) => _inner.message(),
            DescribeKeyError::NotFoundError(_inner) => _inner.message(),
            DescribeKeyError::Unhandled(_inner) => {
                match _inner.downcast_ref::<::smithy_types::Error>() {
                    Some(_inner) => _inner.message(),
                    None => None,
                }
            }
        }
    }
    pub fn code(&self) -> Option<&str> {
        match self {
            DescribeKeyError::DependencyTimeoutError(_inner) => Some(_inner.code()),
            DescribeKeyError::InvalidArnError(_inner) => Some(_inner.code()),
            DescribeKeyError::KMSInternalError(_inner) => Some(_inner.code()),
            DescribeKeyError::NotFoundError(_inner) => Some(_inner.code()),
            DescribeKeyError::Unhandled(_inner) => {
                match _inner.downcast_ref::<::smithy_types::Error>() {
                    Some(_inner) => _inner.code(),
                    None => None,
                }
            }
        }
    }
}
impl ::std::error::Error for DescribeKeyError {
    fn source(&self) -> Option<&(dyn ::std::error::Error + 'static)> {
        match self {
            DescribeKeyError::DependencyTimeoutError(_inner) => Some(_inner),
            DescribeKeyError::InvalidArnError(_inner) => Some(_inner),
            DescribeKeyError::KMSInternalError(_inner) => Some(_inner),
            DescribeKeyError::NotFoundError(_inner) => Some(_inner),
            DescribeKeyError::Unhandled(_inner) => {
                match _inner.downcast_ref::<::smithy_types::Error>() {
                    Some(_inner) => Some(_inner),
                    None => Some(_inner.as_ref()),
                }
            }
        }
    }
}

#[non_exhaustive]
#[derive(::std::fmt::Debug)]
pub enum DisableKeyError {
    DependencyTimeoutError(DependencyTimeoutError),
    InvalidArnError(InvalidArnError),
    KMSInternalError(KMSInternalError),
    KMSInvalidStateError(KMSInvalidStateError),
    NotFoundError(NotFoundError),

    /// An unexpected error, eg. invalid JSON returned by the service
    Unhandled(Box<dyn ::std::error::Error>),
}
impl ::std::fmt::Display for DisableKeyError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match self {
            DisableKeyError::DependencyTimeoutError(_inner) => _inner.fmt(f),
            DisableKeyError::InvalidArnError(_inner) => _inner.fmt(f),
            DisableKeyError::KMSInternalError(_inner) => _inner.fmt(f),
            DisableKeyError::KMSInvalidStateError(_inner) => _inner.fmt(f),
            DisableKeyError::NotFoundError(_inner) => _inner.fmt(f),
            DisableKeyError::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl ::smithy_types::retry::ProvideErrorKind for DisableKeyError {
    fn code(&self) -> Option<&str> {
        DisableKeyError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<::smithy_types::retry::ErrorKind> {
        match self {
            DisableKeyError::DependencyTimeoutError(_inner) => None,
            DisableKeyError::InvalidArnError(_inner) => None,
            DisableKeyError::KMSInternalError(_inner) => None,
            DisableKeyError::KMSInvalidStateError(_inner) => None,
            DisableKeyError::NotFoundError(_inner) => None,
            DisableKeyError::Unhandled(_inner) => {
                match _inner.downcast_ref::<::smithy_types::Error>() {
                    Some(_inner) => _inner.retryable_error_kind(),
                    None => None,
                }
            }
        }
    }
}
impl DisableKeyError {
    pub fn unhandled<E: Into<Box<dyn ::std::error::Error>>>(err: E) -> Self {
        DisableKeyError::Unhandled(err.into())
    }
    pub fn message(&self) -> Option<&str> {
        match self {
            DisableKeyError::DependencyTimeoutError(_inner) => _inner.message(),
            DisableKeyError::InvalidArnError(_inner) => _inner.message(),
            DisableKeyError::KMSInternalError(_inner) => _inner.message(),
            DisableKeyError::KMSInvalidStateError(_inner) => _inner.message(),
            DisableKeyError::NotFoundError(_inner) => _inner.message(),
            DisableKeyError::Unhandled(_inner) => {
                match _inner.downcast_ref::<::smithy_types::Error>() {
                    Some(_inner) => _inner.message(),
                    None => None,
                }
            }
        }
    }
    pub fn code(&self) -> Option<&str> {
        match self {
            DisableKeyError::DependencyTimeoutError(_inner) => Some(_inner.code()),
            DisableKeyError::InvalidArnError(_inner) => Some(_inner.code()),
            DisableKeyError::KMSInternalError(_inner) => Some(_inner.code()),
            DisableKeyError::KMSInvalidStateError(_inner) => Some(_inner.code()),
            DisableKeyError::NotFoundError(_inner) => Some(_inner.code()),
            DisableKeyError::Unhandled(_inner) => {
                match _inner.downcast_ref::<::smithy_types::Error>() {
                    Some(_inner) => _inner.code(),
                    None => None,
                }
            }
        }
    }
}
impl ::std::error::Error for DisableKeyError {
    fn source(&self) -> Option<&(dyn ::std::error::Error + 'static)> {
        match self {
            DisableKeyError::DependencyTimeoutError(_inner) => Some(_inner),
            DisableKeyError::InvalidArnError(_inner) => Some(_inner),
            DisableKeyError::KMSInternalError(_inner) => Some(_inner),
            DisableKeyError::KMSInvalidStateError(_inner) => Some(_inner),
            DisableKeyError::NotFoundError(_inner) => Some(_inner),
            DisableKeyError::Unhandled(_inner) => {
                match _inner.downcast_ref::<::smithy_types::Error>() {
                    Some(_inner) => Some(_inner),
                    None => Some(_inner.as_ref()),
                }
            }
        }
    }
}

#[non_exhaustive]
#[derive(::std::fmt::Debug)]
pub enum DisableKeyRotationError {
    DependencyTimeoutError(DependencyTimeoutError),
    DisabledError(DisabledError),
    InvalidArnError(InvalidArnError),
    KMSInternalError(KMSInternalError),
    KMSInvalidStateError(KMSInvalidStateError),
    NotFoundError(NotFoundError),
    UnsupportedOperationError(UnsupportedOperationError),

    /// An unexpected error, eg. invalid JSON returned by the service
    Unhandled(Box<dyn ::std::error::Error>),
}
impl ::std::fmt::Display for DisableKeyRotationError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match self {
            DisableKeyRotationError::DependencyTimeoutError(_inner) => _inner.fmt(f),
            DisableKeyRotationError::DisabledError(_inner) => _inner.fmt(f),
            DisableKeyRotationError::InvalidArnError(_inner) => _inner.fmt(f),
            DisableKeyRotationError::KMSInternalError(_inner) => _inner.fmt(f),
            DisableKeyRotationError::KMSInvalidStateError(_inner) => _inner.fmt(f),
            DisableKeyRotationError::NotFoundError(_inner) => _inner.fmt(f),
            DisableKeyRotationError::UnsupportedOperationError(_inner) => _inner.fmt(f),
            DisableKeyRotationError::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl ::smithy_types::retry::ProvideErrorKind for DisableKeyRotationError {
    fn code(&self) -> Option<&str> {
        DisableKeyRotationError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<::smithy_types::retry::ErrorKind> {
        match self {
            DisableKeyRotationError::DependencyTimeoutError(_inner) => None,
            DisableKeyRotationError::DisabledError(_inner) => None,
            DisableKeyRotationError::InvalidArnError(_inner) => None,
            DisableKeyRotationError::KMSInternalError(_inner) => None,
            DisableKeyRotationError::KMSInvalidStateError(_inner) => None,
            DisableKeyRotationError::NotFoundError(_inner) => None,
            DisableKeyRotationError::UnsupportedOperationError(_inner) => None,
            DisableKeyRotationError::Unhandled(_inner) => {
                match _inner.downcast_ref::<::smithy_types::Error>() {
                    Some(_inner) => _inner.retryable_error_kind(),
                    None => None,
                }
            }
        }
    }
}
impl DisableKeyRotationError {
    pub fn unhandled<E: Into<Box<dyn ::std::error::Error>>>(err: E) -> Self {
        DisableKeyRotationError::Unhandled(err.into())
    }
    pub fn message(&self) -> Option<&str> {
        match self {
            DisableKeyRotationError::DependencyTimeoutError(_inner) => _inner.message(),
            DisableKeyRotationError::DisabledError(_inner) => _inner.message(),
            DisableKeyRotationError::InvalidArnError(_inner) => _inner.message(),
            DisableKeyRotationError::KMSInternalError(_inner) => _inner.message(),
            DisableKeyRotationError::KMSInvalidStateError(_inner) => _inner.message(),
            DisableKeyRotationError::NotFoundError(_inner) => _inner.message(),
            DisableKeyRotationError::UnsupportedOperationError(_inner) => _inner.message(),
            DisableKeyRotationError::Unhandled(_inner) => {
                match _inner.downcast_ref::<::smithy_types::Error>() {
                    Some(_inner) => _inner.message(),
                    None => None,
                }
            }
        }
    }
    pub fn code(&self) -> Option<&str> {
        match self {
            DisableKeyRotationError::DependencyTimeoutError(_inner) => Some(_inner.code()),
            DisableKeyRotationError::DisabledError(_inner) => Some(_inner.code()),
            DisableKeyRotationError::InvalidArnError(_inner) => Some(_inner.code()),
            DisableKeyRotationError::KMSInternalError(_inner) => Some(_inner.code()),
            DisableKeyRotationError::KMSInvalidStateError(_inner) => Some(_inner.code()),
            DisableKeyRotationError::NotFoundError(_inner) => Some(_inner.code()),
            DisableKeyRotationError::UnsupportedOperationError(_inner) => Some(_inner.code()),
            DisableKeyRotationError::Unhandled(_inner) => {
                match _inner.downcast_ref::<::smithy_types::Error>() {
                    Some(_inner) => _inner.code(),
                    None => None,
                }
            }
        }
    }
}
impl ::std::error::Error for DisableKeyRotationError {
    fn source(&self) -> Option<&(dyn ::std::error::Error + 'static)> {
        match self {
            DisableKeyRotationError::DependencyTimeoutError(_inner) => Some(_inner),
            DisableKeyRotationError::DisabledError(_inner) => Some(_inner),
            DisableKeyRotationError::InvalidArnError(_inner) => Some(_inner),
            DisableKeyRotationError::KMSInternalError(_inner) => Some(_inner),
            DisableKeyRotationError::KMSInvalidStateError(_inner) => Some(_inner),
            DisableKeyRotationError::NotFoundError(_inner) => Some(_inner),
            DisableKeyRotationError::UnsupportedOperationError(_inner) => Some(_inner),
            DisableKeyRotationError::Unhandled(_inner) => {
                match _inner.downcast_ref::<::smithy_types::Error>() {
                    Some(_inner) => Some(_inner),
                    None => Some(_inner.as_ref()),
                }
            }
        }
    }
}

#[non_exhaustive]
#[derive(::std::fmt::Debug)]
pub enum DisconnectCustomKeyStoreError {
    CustomKeyStoreInvalidStateError(CustomKeyStoreInvalidStateError),
    CustomKeyStoreNotFoundError(CustomKeyStoreNotFoundError),
    KMSInternalError(KMSInternalError),

    /// An unexpected error, eg. invalid JSON returned by the service
    Unhandled(Box<dyn ::std::error::Error>),
}
impl ::std::fmt::Display for DisconnectCustomKeyStoreError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match self {
            DisconnectCustomKeyStoreError::CustomKeyStoreInvalidStateError(_inner) => _inner.fmt(f),
            DisconnectCustomKeyStoreError::CustomKeyStoreNotFoundError(_inner) => _inner.fmt(f),
            DisconnectCustomKeyStoreError::KMSInternalError(_inner) => _inner.fmt(f),
            DisconnectCustomKeyStoreError::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl ::smithy_types::retry::ProvideErrorKind for DisconnectCustomKeyStoreError {
    fn code(&self) -> Option<&str> {
        DisconnectCustomKeyStoreError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<::smithy_types::retry::ErrorKind> {
        match self {
            DisconnectCustomKeyStoreError::CustomKeyStoreInvalidStateError(_inner) => None,
            DisconnectCustomKeyStoreError::CustomKeyStoreNotFoundError(_inner) => None,
            DisconnectCustomKeyStoreError::KMSInternalError(_inner) => None,
            DisconnectCustomKeyStoreError::Unhandled(_inner) => {
                match _inner.downcast_ref::<::smithy_types::Error>() {
                    Some(_inner) => _inner.retryable_error_kind(),
                    None => None,
                }
            }
        }
    }
}
impl DisconnectCustomKeyStoreError {
    pub fn unhandled<E: Into<Box<dyn ::std::error::Error>>>(err: E) -> Self {
        DisconnectCustomKeyStoreError::Unhandled(err.into())
    }
    pub fn message(&self) -> Option<&str> {
        match self {
            DisconnectCustomKeyStoreError::CustomKeyStoreInvalidStateError(_inner) => {
                _inner.message()
            }
            DisconnectCustomKeyStoreError::CustomKeyStoreNotFoundError(_inner) => _inner.message(),
            DisconnectCustomKeyStoreError::KMSInternalError(_inner) => _inner.message(),
            DisconnectCustomKeyStoreError::Unhandled(_inner) => {
                match _inner.downcast_ref::<::smithy_types::Error>() {
                    Some(_inner) => _inner.message(),
                    None => None,
                }
            }
        }
    }
    pub fn code(&self) -> Option<&str> {
        match self {
            DisconnectCustomKeyStoreError::CustomKeyStoreInvalidStateError(_inner) => {
                Some(_inner.code())
            }
            DisconnectCustomKeyStoreError::CustomKeyStoreNotFoundError(_inner) => {
                Some(_inner.code())
            }
            DisconnectCustomKeyStoreError::KMSInternalError(_inner) => Some(_inner.code()),
            DisconnectCustomKeyStoreError::Unhandled(_inner) => {
                match _inner.downcast_ref::<::smithy_types::Error>() {
                    Some(_inner) => _inner.code(),
                    None => None,
                }
            }
        }
    }
}
impl ::std::error::Error for DisconnectCustomKeyStoreError {
    fn source(&self) -> Option<&(dyn ::std::error::Error + 'static)> {
        match self {
            DisconnectCustomKeyStoreError::CustomKeyStoreInvalidStateError(_inner) => Some(_inner),
            DisconnectCustomKeyStoreError::CustomKeyStoreNotFoundError(_inner) => Some(_inner),
            DisconnectCustomKeyStoreError::KMSInternalError(_inner) => Some(_inner),
            DisconnectCustomKeyStoreError::Unhandled(_inner) => {
                match _inner.downcast_ref::<::smithy_types::Error>() {
                    Some(_inner) => Some(_inner),
                    None => Some(_inner.as_ref()),
                }
            }
        }
    }
}

#[non_exhaustive]
#[derive(::std::fmt::Debug)]
pub enum EnableKeyError {
    DependencyTimeoutError(DependencyTimeoutError),
    InvalidArnError(InvalidArnError),
    KMSInternalError(KMSInternalError),
    KMSInvalidStateError(KMSInvalidStateError),
    LimitExceededError(LimitExceededError),
    NotFoundError(NotFoundError),

    /// An unexpected error, eg. invalid JSON returned by the service
    Unhandled(Box<dyn ::std::error::Error>),
}
impl ::std::fmt::Display for EnableKeyError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match self {
            EnableKeyError::DependencyTimeoutError(_inner) => _inner.fmt(f),
            EnableKeyError::InvalidArnError(_inner) => _inner.fmt(f),
            EnableKeyError::KMSInternalError(_inner) => _inner.fmt(f),
            EnableKeyError::KMSInvalidStateError(_inner) => _inner.fmt(f),
            EnableKeyError::LimitExceededError(_inner) => _inner.fmt(f),
            EnableKeyError::NotFoundError(_inner) => _inner.fmt(f),
            EnableKeyError::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl ::smithy_types::retry::ProvideErrorKind for EnableKeyError {
    fn code(&self) -> Option<&str> {
        EnableKeyError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<::smithy_types::retry::ErrorKind> {
        match self {
            EnableKeyError::DependencyTimeoutError(_inner) => None,
            EnableKeyError::InvalidArnError(_inner) => None,
            EnableKeyError::KMSInternalError(_inner) => None,
            EnableKeyError::KMSInvalidStateError(_inner) => None,
            EnableKeyError::LimitExceededError(_inner) => None,
            EnableKeyError::NotFoundError(_inner) => None,
            EnableKeyError::Unhandled(_inner) => {
                match _inner.downcast_ref::<::smithy_types::Error>() {
                    Some(_inner) => _inner.retryable_error_kind(),
                    None => None,
                }
            }
        }
    }
}
impl EnableKeyError {
    pub fn unhandled<E: Into<Box<dyn ::std::error::Error>>>(err: E) -> Self {
        EnableKeyError::Unhandled(err.into())
    }
    pub fn message(&self) -> Option<&str> {
        match self {
            EnableKeyError::DependencyTimeoutError(_inner) => _inner.message(),
            EnableKeyError::InvalidArnError(_inner) => _inner.message(),
            EnableKeyError::KMSInternalError(_inner) => _inner.message(),
            EnableKeyError::KMSInvalidStateError(_inner) => _inner.message(),
            EnableKeyError::LimitExceededError(_inner) => _inner.message(),
            EnableKeyError::NotFoundError(_inner) => _inner.message(),
            EnableKeyError::Unhandled(_inner) => {
                match _inner.downcast_ref::<::smithy_types::Error>() {
                    Some(_inner) => _inner.message(),
                    None => None,
                }
            }
        }
    }
    pub fn code(&self) -> Option<&str> {
        match self {
            EnableKeyError::DependencyTimeoutError(_inner) => Some(_inner.code()),
            EnableKeyError::InvalidArnError(_inner) => Some(_inner.code()),
            EnableKeyError::KMSInternalError(_inner) => Some(_inner.code()),
            EnableKeyError::KMSInvalidStateError(_inner) => Some(_inner.code()),
            EnableKeyError::LimitExceededError(_inner) => Some(_inner.code()),
            EnableKeyError::NotFoundError(_inner) => Some(_inner.code()),
            EnableKeyError::Unhandled(_inner) => {
                match _inner.downcast_ref::<::smithy_types::Error>() {
                    Some(_inner) => _inner.code(),
                    None => None,
                }
            }
        }
    }
}
impl ::std::error::Error for EnableKeyError {
    fn source(&self) -> Option<&(dyn ::std::error::Error + 'static)> {
        match self {
            EnableKeyError::DependencyTimeoutError(_inner) => Some(_inner),
            EnableKeyError::InvalidArnError(_inner) => Some(_inner),
            EnableKeyError::KMSInternalError(_inner) => Some(_inner),
            EnableKeyError::KMSInvalidStateError(_inner) => Some(_inner),
            EnableKeyError::LimitExceededError(_inner) => Some(_inner),
            EnableKeyError::NotFoundError(_inner) => Some(_inner),
            EnableKeyError::Unhandled(_inner) => {
                match _inner.downcast_ref::<::smithy_types::Error>() {
                    Some(_inner) => Some(_inner),
                    None => Some(_inner.as_ref()),
                }
            }
        }
    }
}

#[non_exhaustive]
#[derive(::std::fmt::Debug)]
pub enum EnableKeyRotationError {
    DependencyTimeoutError(DependencyTimeoutError),
    DisabledError(DisabledError),
    InvalidArnError(InvalidArnError),
    KMSInternalError(KMSInternalError),
    KMSInvalidStateError(KMSInvalidStateError),
    NotFoundError(NotFoundError),
    UnsupportedOperationError(UnsupportedOperationError),

    /// An unexpected error, eg. invalid JSON returned by the service
    Unhandled(Box<dyn ::std::error::Error>),
}
impl ::std::fmt::Display for EnableKeyRotationError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match self {
            EnableKeyRotationError::DependencyTimeoutError(_inner) => _inner.fmt(f),
            EnableKeyRotationError::DisabledError(_inner) => _inner.fmt(f),
            EnableKeyRotationError::InvalidArnError(_inner) => _inner.fmt(f),
            EnableKeyRotationError::KMSInternalError(_inner) => _inner.fmt(f),
            EnableKeyRotationError::KMSInvalidStateError(_inner) => _inner.fmt(f),
            EnableKeyRotationError::NotFoundError(_inner) => _inner.fmt(f),
            EnableKeyRotationError::UnsupportedOperationError(_inner) => _inner.fmt(f),
            EnableKeyRotationError::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl ::smithy_types::retry::ProvideErrorKind for EnableKeyRotationError {
    fn code(&self) -> Option<&str> {
        EnableKeyRotationError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<::smithy_types::retry::ErrorKind> {
        match self {
            EnableKeyRotationError::DependencyTimeoutError(_inner) => None,
            EnableKeyRotationError::DisabledError(_inner) => None,
            EnableKeyRotationError::InvalidArnError(_inner) => None,
            EnableKeyRotationError::KMSInternalError(_inner) => None,
            EnableKeyRotationError::KMSInvalidStateError(_inner) => None,
            EnableKeyRotationError::NotFoundError(_inner) => None,
            EnableKeyRotationError::UnsupportedOperationError(_inner) => None,
            EnableKeyRotationError::Unhandled(_inner) => {
                match _inner.downcast_ref::<::smithy_types::Error>() {
                    Some(_inner) => _inner.retryable_error_kind(),
                    None => None,
                }
            }
        }
    }
}
impl EnableKeyRotationError {
    pub fn unhandled<E: Into<Box<dyn ::std::error::Error>>>(err: E) -> Self {
        EnableKeyRotationError::Unhandled(err.into())
    }
    pub fn message(&self) -> Option<&str> {
        match self {
            EnableKeyRotationError::DependencyTimeoutError(_inner) => _inner.message(),
            EnableKeyRotationError::DisabledError(_inner) => _inner.message(),
            EnableKeyRotationError::InvalidArnError(_inner) => _inner.message(),
            EnableKeyRotationError::KMSInternalError(_inner) => _inner.message(),
            EnableKeyRotationError::KMSInvalidStateError(_inner) => _inner.message(),
            EnableKeyRotationError::NotFoundError(_inner) => _inner.message(),
            EnableKeyRotationError::UnsupportedOperationError(_inner) => _inner.message(),
            EnableKeyRotationError::Unhandled(_inner) => {
                match _inner.downcast_ref::<::smithy_types::Error>() {
                    Some(_inner) => _inner.message(),
                    None => None,
                }
            }
        }
    }
    pub fn code(&self) -> Option<&str> {
        match self {
            EnableKeyRotationError::DependencyTimeoutError(_inner) => Some(_inner.code()),
            EnableKeyRotationError::DisabledError(_inner) => Some(_inner.code()),
            EnableKeyRotationError::InvalidArnError(_inner) => Some(_inner.code()),
            EnableKeyRotationError::KMSInternalError(_inner) => Some(_inner.code()),
            EnableKeyRotationError::KMSInvalidStateError(_inner) => Some(_inner.code()),
            EnableKeyRotationError::NotFoundError(_inner) => Some(_inner.code()),
            EnableKeyRotationError::UnsupportedOperationError(_inner) => Some(_inner.code()),
            EnableKeyRotationError::Unhandled(_inner) => {
                match _inner.downcast_ref::<::smithy_types::Error>() {
                    Some(_inner) => _inner.code(),
                    None => None,
                }
            }
        }
    }
}
impl ::std::error::Error for EnableKeyRotationError {
    fn source(&self) -> Option<&(dyn ::std::error::Error + 'static)> {
        match self {
            EnableKeyRotationError::DependencyTimeoutError(_inner) => Some(_inner),
            EnableKeyRotationError::DisabledError(_inner) => Some(_inner),
            EnableKeyRotationError::InvalidArnError(_inner) => Some(_inner),
            EnableKeyRotationError::KMSInternalError(_inner) => Some(_inner),
            EnableKeyRotationError::KMSInvalidStateError(_inner) => Some(_inner),
            EnableKeyRotationError::NotFoundError(_inner) => Some(_inner),
            EnableKeyRotationError::UnsupportedOperationError(_inner) => Some(_inner),
            EnableKeyRotationError::Unhandled(_inner) => {
                match _inner.downcast_ref::<::smithy_types::Error>() {
                    Some(_inner) => Some(_inner),
                    None => Some(_inner.as_ref()),
                }
            }
        }
    }
}

#[non_exhaustive]
#[derive(::std::fmt::Debug)]
pub enum EncryptError {
    DependencyTimeoutError(DependencyTimeoutError),
    DisabledError(DisabledError),
    InvalidGrantTokenError(InvalidGrantTokenError),
    InvalidKeyUsageError(InvalidKeyUsageError),
    KeyUnavailableError(KeyUnavailableError),
    KMSInternalError(KMSInternalError),
    KMSInvalidStateError(KMSInvalidStateError),
    NotFoundError(NotFoundError),

    /// An unexpected error, eg. invalid JSON returned by the service
    Unhandled(Box<dyn ::std::error::Error>),
}
impl ::std::fmt::Display for EncryptError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match self {
            EncryptError::DependencyTimeoutError(_inner) => _inner.fmt(f),
            EncryptError::DisabledError(_inner) => _inner.fmt(f),
            EncryptError::InvalidGrantTokenError(_inner) => _inner.fmt(f),
            EncryptError::InvalidKeyUsageError(_inner) => _inner.fmt(f),
            EncryptError::KeyUnavailableError(_inner) => _inner.fmt(f),
            EncryptError::KMSInternalError(_inner) => _inner.fmt(f),
            EncryptError::KMSInvalidStateError(_inner) => _inner.fmt(f),
            EncryptError::NotFoundError(_inner) => _inner.fmt(f),
            EncryptError::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl ::smithy_types::retry::ProvideErrorKind for EncryptError {
    fn code(&self) -> Option<&str> {
        EncryptError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<::smithy_types::retry::ErrorKind> {
        match self {
            EncryptError::DependencyTimeoutError(_inner) => None,
            EncryptError::DisabledError(_inner) => None,
            EncryptError::InvalidGrantTokenError(_inner) => None,
            EncryptError::InvalidKeyUsageError(_inner) => None,
            EncryptError::KeyUnavailableError(_inner) => None,
            EncryptError::KMSInternalError(_inner) => None,
            EncryptError::KMSInvalidStateError(_inner) => None,
            EncryptError::NotFoundError(_inner) => None,
            EncryptError::Unhandled(_inner) => {
                match _inner.downcast_ref::<::smithy_types::Error>() {
                    Some(_inner) => _inner.retryable_error_kind(),
                    None => None,
                }
            }
        }
    }
}
impl EncryptError {
    pub fn unhandled<E: Into<Box<dyn ::std::error::Error>>>(err: E) -> Self {
        EncryptError::Unhandled(err.into())
    }
    pub fn message(&self) -> Option<&str> {
        match self {
            EncryptError::DependencyTimeoutError(_inner) => _inner.message(),
            EncryptError::DisabledError(_inner) => _inner.message(),
            EncryptError::InvalidGrantTokenError(_inner) => _inner.message(),
            EncryptError::InvalidKeyUsageError(_inner) => _inner.message(),
            EncryptError::KeyUnavailableError(_inner) => _inner.message(),
            EncryptError::KMSInternalError(_inner) => _inner.message(),
            EncryptError::KMSInvalidStateError(_inner) => _inner.message(),
            EncryptError::NotFoundError(_inner) => _inner.message(),
            EncryptError::Unhandled(_inner) => {
                match _inner.downcast_ref::<::smithy_types::Error>() {
                    Some(_inner) => _inner.message(),
                    None => None,
                }
            }
        }
    }
    pub fn code(&self) -> Option<&str> {
        match self {
            EncryptError::DependencyTimeoutError(_inner) => Some(_inner.code()),
            EncryptError::DisabledError(_inner) => Some(_inner.code()),
            EncryptError::InvalidGrantTokenError(_inner) => Some(_inner.code()),
            EncryptError::InvalidKeyUsageError(_inner) => Some(_inner.code()),
            EncryptError::KeyUnavailableError(_inner) => Some(_inner.code()),
            EncryptError::KMSInternalError(_inner) => Some(_inner.code()),
            EncryptError::KMSInvalidStateError(_inner) => Some(_inner.code()),
            EncryptError::NotFoundError(_inner) => Some(_inner.code()),
            EncryptError::Unhandled(_inner) => {
                match _inner.downcast_ref::<::smithy_types::Error>() {
                    Some(_inner) => _inner.code(),
                    None => None,
                }
            }
        }
    }
}
impl ::std::error::Error for EncryptError {
    fn source(&self) -> Option<&(dyn ::std::error::Error + 'static)> {
        match self {
            EncryptError::DependencyTimeoutError(_inner) => Some(_inner),
            EncryptError::DisabledError(_inner) => Some(_inner),
            EncryptError::InvalidGrantTokenError(_inner) => Some(_inner),
            EncryptError::InvalidKeyUsageError(_inner) => Some(_inner),
            EncryptError::KeyUnavailableError(_inner) => Some(_inner),
            EncryptError::KMSInternalError(_inner) => Some(_inner),
            EncryptError::KMSInvalidStateError(_inner) => Some(_inner),
            EncryptError::NotFoundError(_inner) => Some(_inner),
            EncryptError::Unhandled(_inner) => {
                match _inner.downcast_ref::<::smithy_types::Error>() {
                    Some(_inner) => Some(_inner),
                    None => Some(_inner.as_ref()),
                }
            }
        }
    }
}

#[non_exhaustive]
#[derive(::std::fmt::Debug)]
pub enum GenerateDataKeyError {
    DependencyTimeoutError(DependencyTimeoutError),
    DisabledError(DisabledError),
    InvalidGrantTokenError(InvalidGrantTokenError),
    InvalidKeyUsageError(InvalidKeyUsageError),
    KeyUnavailableError(KeyUnavailableError),
    KMSInternalError(KMSInternalError),
    KMSInvalidStateError(KMSInvalidStateError),
    NotFoundError(NotFoundError),

    /// An unexpected error, eg. invalid JSON returned by the service
    Unhandled(Box<dyn ::std::error::Error>),
}
impl ::std::fmt::Display for GenerateDataKeyError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match self {
            GenerateDataKeyError::DependencyTimeoutError(_inner) => _inner.fmt(f),
            GenerateDataKeyError::DisabledError(_inner) => _inner.fmt(f),
            GenerateDataKeyError::InvalidGrantTokenError(_inner) => _inner.fmt(f),
            GenerateDataKeyError::InvalidKeyUsageError(_inner) => _inner.fmt(f),
            GenerateDataKeyError::KeyUnavailableError(_inner) => _inner.fmt(f),
            GenerateDataKeyError::KMSInternalError(_inner) => _inner.fmt(f),
            GenerateDataKeyError::KMSInvalidStateError(_inner) => _inner.fmt(f),
            GenerateDataKeyError::NotFoundError(_inner) => _inner.fmt(f),
            GenerateDataKeyError::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl ::smithy_types::retry::ProvideErrorKind for GenerateDataKeyError {
    fn code(&self) -> Option<&str> {
        GenerateDataKeyError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<::smithy_types::retry::ErrorKind> {
        match self {
            GenerateDataKeyError::DependencyTimeoutError(_inner) => None,
            GenerateDataKeyError::DisabledError(_inner) => None,
            GenerateDataKeyError::InvalidGrantTokenError(_inner) => None,
            GenerateDataKeyError::InvalidKeyUsageError(_inner) => None,
            GenerateDataKeyError::KeyUnavailableError(_inner) => None,
            GenerateDataKeyError::KMSInternalError(_inner) => None,
            GenerateDataKeyError::KMSInvalidStateError(_inner) => None,
            GenerateDataKeyError::NotFoundError(_inner) => None,
            GenerateDataKeyError::Unhandled(_inner) => {
                match _inner.downcast_ref::<::smithy_types::Error>() {
                    Some(_inner) => _inner.retryable_error_kind(),
                    None => None,
                }
            }
        }
    }
}
impl GenerateDataKeyError {
    pub fn unhandled<E: Into<Box<dyn ::std::error::Error>>>(err: E) -> Self {
        GenerateDataKeyError::Unhandled(err.into())
    }
    pub fn message(&self) -> Option<&str> {
        match self {
            GenerateDataKeyError::DependencyTimeoutError(_inner) => _inner.message(),
            GenerateDataKeyError::DisabledError(_inner) => _inner.message(),
            GenerateDataKeyError::InvalidGrantTokenError(_inner) => _inner.message(),
            GenerateDataKeyError::InvalidKeyUsageError(_inner) => _inner.message(),
            GenerateDataKeyError::KeyUnavailableError(_inner) => _inner.message(),
            GenerateDataKeyError::KMSInternalError(_inner) => _inner.message(),
            GenerateDataKeyError::KMSInvalidStateError(_inner) => _inner.message(),
            GenerateDataKeyError::NotFoundError(_inner) => _inner.message(),
            GenerateDataKeyError::Unhandled(_inner) => {
                match _inner.downcast_ref::<::smithy_types::Error>() {
                    Some(_inner) => _inner.message(),
                    None => None,
                }
            }
        }
    }
    pub fn code(&self) -> Option<&str> {
        match self {
            GenerateDataKeyError::DependencyTimeoutError(_inner) => Some(_inner.code()),
            GenerateDataKeyError::DisabledError(_inner) => Some(_inner.code()),
            GenerateDataKeyError::InvalidGrantTokenError(_inner) => Some(_inner.code()),
            GenerateDataKeyError::InvalidKeyUsageError(_inner) => Some(_inner.code()),
            GenerateDataKeyError::KeyUnavailableError(_inner) => Some(_inner.code()),
            GenerateDataKeyError::KMSInternalError(_inner) => Some(_inner.code()),
            GenerateDataKeyError::KMSInvalidStateError(_inner) => Some(_inner.code()),
            GenerateDataKeyError::NotFoundError(_inner) => Some(_inner.code()),
            GenerateDataKeyError::Unhandled(_inner) => {
                match _inner.downcast_ref::<::smithy_types::Error>() {
                    Some(_inner) => _inner.code(),
                    None => None,
                }
            }
        }
    }
}
impl ::std::error::Error for GenerateDataKeyError {
    fn source(&self) -> Option<&(dyn ::std::error::Error + 'static)> {
        match self {
            GenerateDataKeyError::DependencyTimeoutError(_inner) => Some(_inner),
            GenerateDataKeyError::DisabledError(_inner) => Some(_inner),
            GenerateDataKeyError::InvalidGrantTokenError(_inner) => Some(_inner),
            GenerateDataKeyError::InvalidKeyUsageError(_inner) => Some(_inner),
            GenerateDataKeyError::KeyUnavailableError(_inner) => Some(_inner),
            GenerateDataKeyError::KMSInternalError(_inner) => Some(_inner),
            GenerateDataKeyError::KMSInvalidStateError(_inner) => Some(_inner),
            GenerateDataKeyError::NotFoundError(_inner) => Some(_inner),
            GenerateDataKeyError::Unhandled(_inner) => {
                match _inner.downcast_ref::<::smithy_types::Error>() {
                    Some(_inner) => Some(_inner),
                    None => Some(_inner.as_ref()),
                }
            }
        }
    }
}

#[non_exhaustive]
#[derive(::std::fmt::Debug)]
pub enum GenerateDataKeyPairError {
    DependencyTimeoutError(DependencyTimeoutError),
    DisabledError(DisabledError),
    InvalidGrantTokenError(InvalidGrantTokenError),
    InvalidKeyUsageError(InvalidKeyUsageError),
    KeyUnavailableError(KeyUnavailableError),
    KMSInternalError(KMSInternalError),
    KMSInvalidStateError(KMSInvalidStateError),
    NotFoundError(NotFoundError),
    UnsupportedOperationError(UnsupportedOperationError),

    /// An unexpected error, eg. invalid JSON returned by the service
    Unhandled(Box<dyn ::std::error::Error>),
}
impl ::std::fmt::Display for GenerateDataKeyPairError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match self {
            GenerateDataKeyPairError::DependencyTimeoutError(_inner) => _inner.fmt(f),
            GenerateDataKeyPairError::DisabledError(_inner) => _inner.fmt(f),
            GenerateDataKeyPairError::InvalidGrantTokenError(_inner) => _inner.fmt(f),
            GenerateDataKeyPairError::InvalidKeyUsageError(_inner) => _inner.fmt(f),
            GenerateDataKeyPairError::KeyUnavailableError(_inner) => _inner.fmt(f),
            GenerateDataKeyPairError::KMSInternalError(_inner) => _inner.fmt(f),
            GenerateDataKeyPairError::KMSInvalidStateError(_inner) => _inner.fmt(f),
            GenerateDataKeyPairError::NotFoundError(_inner) => _inner.fmt(f),
            GenerateDataKeyPairError::UnsupportedOperationError(_inner) => _inner.fmt(f),
            GenerateDataKeyPairError::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl ::smithy_types::retry::ProvideErrorKind for GenerateDataKeyPairError {
    fn code(&self) -> Option<&str> {
        GenerateDataKeyPairError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<::smithy_types::retry::ErrorKind> {
        match self {
            GenerateDataKeyPairError::DependencyTimeoutError(_inner) => None,
            GenerateDataKeyPairError::DisabledError(_inner) => None,
            GenerateDataKeyPairError::InvalidGrantTokenError(_inner) => None,
            GenerateDataKeyPairError::InvalidKeyUsageError(_inner) => None,
            GenerateDataKeyPairError::KeyUnavailableError(_inner) => None,
            GenerateDataKeyPairError::KMSInternalError(_inner) => None,
            GenerateDataKeyPairError::KMSInvalidStateError(_inner) => None,
            GenerateDataKeyPairError::NotFoundError(_inner) => None,
            GenerateDataKeyPairError::UnsupportedOperationError(_inner) => None,
            GenerateDataKeyPairError::Unhandled(_inner) => {
                match _inner.downcast_ref::<::smithy_types::Error>() {
                    Some(_inner) => _inner.retryable_error_kind(),
                    None => None,
                }
            }
        }
    }
}
impl GenerateDataKeyPairError {
    pub fn unhandled<E: Into<Box<dyn ::std::error::Error>>>(err: E) -> Self {
        GenerateDataKeyPairError::Unhandled(err.into())
    }
    pub fn message(&self) -> Option<&str> {
        match self {
            GenerateDataKeyPairError::DependencyTimeoutError(_inner) => _inner.message(),
            GenerateDataKeyPairError::DisabledError(_inner) => _inner.message(),
            GenerateDataKeyPairError::InvalidGrantTokenError(_inner) => _inner.message(),
            GenerateDataKeyPairError::InvalidKeyUsageError(_inner) => _inner.message(),
            GenerateDataKeyPairError::KeyUnavailableError(_inner) => _inner.message(),
            GenerateDataKeyPairError::KMSInternalError(_inner) => _inner.message(),
            GenerateDataKeyPairError::KMSInvalidStateError(_inner) => _inner.message(),
            GenerateDataKeyPairError::NotFoundError(_inner) => _inner.message(),
            GenerateDataKeyPairError::UnsupportedOperationError(_inner) => _inner.message(),
            GenerateDataKeyPairError::Unhandled(_inner) => {
                match _inner.downcast_ref::<::smithy_types::Error>() {
                    Some(_inner) => _inner.message(),
                    None => None,
                }
            }
        }
    }
    pub fn code(&self) -> Option<&str> {
        match self {
            GenerateDataKeyPairError::DependencyTimeoutError(_inner) => Some(_inner.code()),
            GenerateDataKeyPairError::DisabledError(_inner) => Some(_inner.code()),
            GenerateDataKeyPairError::InvalidGrantTokenError(_inner) => Some(_inner.code()),
            GenerateDataKeyPairError::InvalidKeyUsageError(_inner) => Some(_inner.code()),
            GenerateDataKeyPairError::KeyUnavailableError(_inner) => Some(_inner.code()),
            GenerateDataKeyPairError::KMSInternalError(_inner) => Some(_inner.code()),
            GenerateDataKeyPairError::KMSInvalidStateError(_inner) => Some(_inner.code()),
            GenerateDataKeyPairError::NotFoundError(_inner) => Some(_inner.code()),
            GenerateDataKeyPairError::UnsupportedOperationError(_inner) => Some(_inner.code()),
            GenerateDataKeyPairError::Unhandled(_inner) => {
                match _inner.downcast_ref::<::smithy_types::Error>() {
                    Some(_inner) => _inner.code(),
                    None => None,
                }
            }
        }
    }
}
impl ::std::error::Error for GenerateDataKeyPairError {
    fn source(&self) -> Option<&(dyn ::std::error::Error + 'static)> {
        match self {
            GenerateDataKeyPairError::DependencyTimeoutError(_inner) => Some(_inner),
            GenerateDataKeyPairError::DisabledError(_inner) => Some(_inner),
            GenerateDataKeyPairError::InvalidGrantTokenError(_inner) => Some(_inner),
            GenerateDataKeyPairError::InvalidKeyUsageError(_inner) => Some(_inner),
            GenerateDataKeyPairError::KeyUnavailableError(_inner) => Some(_inner),
            GenerateDataKeyPairError::KMSInternalError(_inner) => Some(_inner),
            GenerateDataKeyPairError::KMSInvalidStateError(_inner) => Some(_inner),
            GenerateDataKeyPairError::NotFoundError(_inner) => Some(_inner),
            GenerateDataKeyPairError::UnsupportedOperationError(_inner) => Some(_inner),
            GenerateDataKeyPairError::Unhandled(_inner) => {
                match _inner.downcast_ref::<::smithy_types::Error>() {
                    Some(_inner) => Some(_inner),
                    None => Some(_inner.as_ref()),
                }
            }
        }
    }
}

#[non_exhaustive]
#[derive(::std::fmt::Debug)]
pub enum GenerateDataKeyPairWithoutPlaintextError {
    DependencyTimeoutError(DependencyTimeoutError),
    DisabledError(DisabledError),
    InvalidGrantTokenError(InvalidGrantTokenError),
    InvalidKeyUsageError(InvalidKeyUsageError),
    KeyUnavailableError(KeyUnavailableError),
    KMSInternalError(KMSInternalError),
    KMSInvalidStateError(KMSInvalidStateError),
    NotFoundError(NotFoundError),
    UnsupportedOperationError(UnsupportedOperationError),

    /// An unexpected error, eg. invalid JSON returned by the service
    Unhandled(Box<dyn ::std::error::Error>),
}
impl ::std::fmt::Display for GenerateDataKeyPairWithoutPlaintextError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match self {
            GenerateDataKeyPairWithoutPlaintextError::DependencyTimeoutError(_inner) => {
                _inner.fmt(f)
            }
            GenerateDataKeyPairWithoutPlaintextError::DisabledError(_inner) => _inner.fmt(f),
            GenerateDataKeyPairWithoutPlaintextError::InvalidGrantTokenError(_inner) => {
                _inner.fmt(f)
            }
            GenerateDataKeyPairWithoutPlaintextError::InvalidKeyUsageError(_inner) => _inner.fmt(f),
            GenerateDataKeyPairWithoutPlaintextError::KeyUnavailableError(_inner) => _inner.fmt(f),
            GenerateDataKeyPairWithoutPlaintextError::KMSInternalError(_inner) => _inner.fmt(f),
            GenerateDataKeyPairWithoutPlaintextError::KMSInvalidStateError(_inner) => _inner.fmt(f),
            GenerateDataKeyPairWithoutPlaintextError::NotFoundError(_inner) => _inner.fmt(f),
            GenerateDataKeyPairWithoutPlaintextError::UnsupportedOperationError(_inner) => {
                _inner.fmt(f)
            }
            GenerateDataKeyPairWithoutPlaintextError::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl ::smithy_types::retry::ProvideErrorKind for GenerateDataKeyPairWithoutPlaintextError {
    fn code(&self) -> Option<&str> {
        GenerateDataKeyPairWithoutPlaintextError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<::smithy_types::retry::ErrorKind> {
        match self {
            GenerateDataKeyPairWithoutPlaintextError::DependencyTimeoutError(_inner) => None,
            GenerateDataKeyPairWithoutPlaintextError::DisabledError(_inner) => None,
            GenerateDataKeyPairWithoutPlaintextError::InvalidGrantTokenError(_inner) => None,
            GenerateDataKeyPairWithoutPlaintextError::InvalidKeyUsageError(_inner) => None,
            GenerateDataKeyPairWithoutPlaintextError::KeyUnavailableError(_inner) => None,
            GenerateDataKeyPairWithoutPlaintextError::KMSInternalError(_inner) => None,
            GenerateDataKeyPairWithoutPlaintextError::KMSInvalidStateError(_inner) => None,
            GenerateDataKeyPairWithoutPlaintextError::NotFoundError(_inner) => None,
            GenerateDataKeyPairWithoutPlaintextError::UnsupportedOperationError(_inner) => None,
            GenerateDataKeyPairWithoutPlaintextError::Unhandled(_inner) => {
                match _inner.downcast_ref::<::smithy_types::Error>() {
                    Some(_inner) => _inner.retryable_error_kind(),
                    None => None,
                }
            }
        }
    }
}
impl GenerateDataKeyPairWithoutPlaintextError {
    pub fn unhandled<E: Into<Box<dyn ::std::error::Error>>>(err: E) -> Self {
        GenerateDataKeyPairWithoutPlaintextError::Unhandled(err.into())
    }
    pub fn message(&self) -> Option<&str> {
        match self {
            GenerateDataKeyPairWithoutPlaintextError::DependencyTimeoutError(_inner) => {
                _inner.message()
            }
            GenerateDataKeyPairWithoutPlaintextError::DisabledError(_inner) => _inner.message(),
            GenerateDataKeyPairWithoutPlaintextError::InvalidGrantTokenError(_inner) => {
                _inner.message()
            }
            GenerateDataKeyPairWithoutPlaintextError::InvalidKeyUsageError(_inner) => {
                _inner.message()
            }
            GenerateDataKeyPairWithoutPlaintextError::KeyUnavailableError(_inner) => {
                _inner.message()
            }
            GenerateDataKeyPairWithoutPlaintextError::KMSInternalError(_inner) => _inner.message(),
            GenerateDataKeyPairWithoutPlaintextError::KMSInvalidStateError(_inner) => {
                _inner.message()
            }
            GenerateDataKeyPairWithoutPlaintextError::NotFoundError(_inner) => _inner.message(),
            GenerateDataKeyPairWithoutPlaintextError::UnsupportedOperationError(_inner) => {
                _inner.message()
            }
            GenerateDataKeyPairWithoutPlaintextError::Unhandled(_inner) => {
                match _inner.downcast_ref::<::smithy_types::Error>() {
                    Some(_inner) => _inner.message(),
                    None => None,
                }
            }
        }
    }
    pub fn code(&self) -> Option<&str> {
        match self {
            GenerateDataKeyPairWithoutPlaintextError::DependencyTimeoutError(_inner) => {
                Some(_inner.code())
            }
            GenerateDataKeyPairWithoutPlaintextError::DisabledError(_inner) => Some(_inner.code()),
            GenerateDataKeyPairWithoutPlaintextError::InvalidGrantTokenError(_inner) => {
                Some(_inner.code())
            }
            GenerateDataKeyPairWithoutPlaintextError::InvalidKeyUsageError(_inner) => {
                Some(_inner.code())
            }
            GenerateDataKeyPairWithoutPlaintextError::KeyUnavailableError(_inner) => {
                Some(_inner.code())
            }
            GenerateDataKeyPairWithoutPlaintextError::KMSInternalError(_inner) => {
                Some(_inner.code())
            }
            GenerateDataKeyPairWithoutPlaintextError::KMSInvalidStateError(_inner) => {
                Some(_inner.code())
            }
            GenerateDataKeyPairWithoutPlaintextError::NotFoundError(_inner) => Some(_inner.code()),
            GenerateDataKeyPairWithoutPlaintextError::UnsupportedOperationError(_inner) => {
                Some(_inner.code())
            }
            GenerateDataKeyPairWithoutPlaintextError::Unhandled(_inner) => {
                match _inner.downcast_ref::<::smithy_types::Error>() {
                    Some(_inner) => _inner.code(),
                    None => None,
                }
            }
        }
    }
}
impl ::std::error::Error for GenerateDataKeyPairWithoutPlaintextError {
    fn source(&self) -> Option<&(dyn ::std::error::Error + 'static)> {
        match self {
            GenerateDataKeyPairWithoutPlaintextError::DependencyTimeoutError(_inner) => {
                Some(_inner)
            }
            GenerateDataKeyPairWithoutPlaintextError::DisabledError(_inner) => Some(_inner),
            GenerateDataKeyPairWithoutPlaintextError::InvalidGrantTokenError(_inner) => {
                Some(_inner)
            }
            GenerateDataKeyPairWithoutPlaintextError::InvalidKeyUsageError(_inner) => Some(_inner),
            GenerateDataKeyPairWithoutPlaintextError::KeyUnavailableError(_inner) => Some(_inner),
            GenerateDataKeyPairWithoutPlaintextError::KMSInternalError(_inner) => Some(_inner),
            GenerateDataKeyPairWithoutPlaintextError::KMSInvalidStateError(_inner) => Some(_inner),
            GenerateDataKeyPairWithoutPlaintextError::NotFoundError(_inner) => Some(_inner),
            GenerateDataKeyPairWithoutPlaintextError::UnsupportedOperationError(_inner) => {
                Some(_inner)
            }
            GenerateDataKeyPairWithoutPlaintextError::Unhandled(_inner) => {
                match _inner.downcast_ref::<::smithy_types::Error>() {
                    Some(_inner) => Some(_inner),
                    None => Some(_inner.as_ref()),
                }
            }
        }
    }
}

#[non_exhaustive]
#[derive(::std::fmt::Debug)]
pub enum GenerateDataKeyWithoutPlaintextError {
    DependencyTimeoutError(DependencyTimeoutError),
    DisabledError(DisabledError),
    InvalidGrantTokenError(InvalidGrantTokenError),
    InvalidKeyUsageError(InvalidKeyUsageError),
    KeyUnavailableError(KeyUnavailableError),
    KMSInternalError(KMSInternalError),
    KMSInvalidStateError(KMSInvalidStateError),
    NotFoundError(NotFoundError),

    /// An unexpected error, eg. invalid JSON returned by the service
    Unhandled(Box<dyn ::std::error::Error>),
}
impl ::std::fmt::Display for GenerateDataKeyWithoutPlaintextError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match self {
            GenerateDataKeyWithoutPlaintextError::DependencyTimeoutError(_inner) => _inner.fmt(f),
            GenerateDataKeyWithoutPlaintextError::DisabledError(_inner) => _inner.fmt(f),
            GenerateDataKeyWithoutPlaintextError::InvalidGrantTokenError(_inner) => _inner.fmt(f),
            GenerateDataKeyWithoutPlaintextError::InvalidKeyUsageError(_inner) => _inner.fmt(f),
            GenerateDataKeyWithoutPlaintextError::KeyUnavailableError(_inner) => _inner.fmt(f),
            GenerateDataKeyWithoutPlaintextError::KMSInternalError(_inner) => _inner.fmt(f),
            GenerateDataKeyWithoutPlaintextError::KMSInvalidStateError(_inner) => _inner.fmt(f),
            GenerateDataKeyWithoutPlaintextError::NotFoundError(_inner) => _inner.fmt(f),
            GenerateDataKeyWithoutPlaintextError::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl ::smithy_types::retry::ProvideErrorKind for GenerateDataKeyWithoutPlaintextError {
    fn code(&self) -> Option<&str> {
        GenerateDataKeyWithoutPlaintextError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<::smithy_types::retry::ErrorKind> {
        match self {
            GenerateDataKeyWithoutPlaintextError::DependencyTimeoutError(_inner) => None,
            GenerateDataKeyWithoutPlaintextError::DisabledError(_inner) => None,
            GenerateDataKeyWithoutPlaintextError::InvalidGrantTokenError(_inner) => None,
            GenerateDataKeyWithoutPlaintextError::InvalidKeyUsageError(_inner) => None,
            GenerateDataKeyWithoutPlaintextError::KeyUnavailableError(_inner) => None,
            GenerateDataKeyWithoutPlaintextError::KMSInternalError(_inner) => None,
            GenerateDataKeyWithoutPlaintextError::KMSInvalidStateError(_inner) => None,
            GenerateDataKeyWithoutPlaintextError::NotFoundError(_inner) => None,
            GenerateDataKeyWithoutPlaintextError::Unhandled(_inner) => {
                match _inner.downcast_ref::<::smithy_types::Error>() {
                    Some(_inner) => _inner.retryable_error_kind(),
                    None => None,
                }
            }
        }
    }
}
impl GenerateDataKeyWithoutPlaintextError {
    pub fn unhandled<E: Into<Box<dyn ::std::error::Error>>>(err: E) -> Self {
        GenerateDataKeyWithoutPlaintextError::Unhandled(err.into())
    }
    pub fn message(&self) -> Option<&str> {
        match self {
            GenerateDataKeyWithoutPlaintextError::DependencyTimeoutError(_inner) => {
                _inner.message()
            }
            GenerateDataKeyWithoutPlaintextError::DisabledError(_inner) => _inner.message(),
            GenerateDataKeyWithoutPlaintextError::InvalidGrantTokenError(_inner) => {
                _inner.message()
            }
            GenerateDataKeyWithoutPlaintextError::InvalidKeyUsageError(_inner) => _inner.message(),
            GenerateDataKeyWithoutPlaintextError::KeyUnavailableError(_inner) => _inner.message(),
            GenerateDataKeyWithoutPlaintextError::KMSInternalError(_inner) => _inner.message(),
            GenerateDataKeyWithoutPlaintextError::KMSInvalidStateError(_inner) => _inner.message(),
            GenerateDataKeyWithoutPlaintextError::NotFoundError(_inner) => _inner.message(),
            GenerateDataKeyWithoutPlaintextError::Unhandled(_inner) => {
                match _inner.downcast_ref::<::smithy_types::Error>() {
                    Some(_inner) => _inner.message(),
                    None => None,
                }
            }
        }
    }
    pub fn code(&self) -> Option<&str> {
        match self {
            GenerateDataKeyWithoutPlaintextError::DependencyTimeoutError(_inner) => {
                Some(_inner.code())
            }
            GenerateDataKeyWithoutPlaintextError::DisabledError(_inner) => Some(_inner.code()),
            GenerateDataKeyWithoutPlaintextError::InvalidGrantTokenError(_inner) => {
                Some(_inner.code())
            }
            GenerateDataKeyWithoutPlaintextError::InvalidKeyUsageError(_inner) => {
                Some(_inner.code())
            }
            GenerateDataKeyWithoutPlaintextError::KeyUnavailableError(_inner) => {
                Some(_inner.code())
            }
            GenerateDataKeyWithoutPlaintextError::KMSInternalError(_inner) => Some(_inner.code()),
            GenerateDataKeyWithoutPlaintextError::KMSInvalidStateError(_inner) => {
                Some(_inner.code())
            }
            GenerateDataKeyWithoutPlaintextError::NotFoundError(_inner) => Some(_inner.code()),
            GenerateDataKeyWithoutPlaintextError::Unhandled(_inner) => {
                match _inner.downcast_ref::<::smithy_types::Error>() {
                    Some(_inner) => _inner.code(),
                    None => None,
                }
            }
        }
    }
}
impl ::std::error::Error for GenerateDataKeyWithoutPlaintextError {
    fn source(&self) -> Option<&(dyn ::std::error::Error + 'static)> {
        match self {
            GenerateDataKeyWithoutPlaintextError::DependencyTimeoutError(_inner) => Some(_inner),
            GenerateDataKeyWithoutPlaintextError::DisabledError(_inner) => Some(_inner),
            GenerateDataKeyWithoutPlaintextError::InvalidGrantTokenError(_inner) => Some(_inner),
            GenerateDataKeyWithoutPlaintextError::InvalidKeyUsageError(_inner) => Some(_inner),
            GenerateDataKeyWithoutPlaintextError::KeyUnavailableError(_inner) => Some(_inner),
            GenerateDataKeyWithoutPlaintextError::KMSInternalError(_inner) => Some(_inner),
            GenerateDataKeyWithoutPlaintextError::KMSInvalidStateError(_inner) => Some(_inner),
            GenerateDataKeyWithoutPlaintextError::NotFoundError(_inner) => Some(_inner),
            GenerateDataKeyWithoutPlaintextError::Unhandled(_inner) => {
                match _inner.downcast_ref::<::smithy_types::Error>() {
                    Some(_inner) => Some(_inner),
                    None => Some(_inner.as_ref()),
                }
            }
        }
    }
}

#[non_exhaustive]
#[derive(::std::fmt::Debug)]
pub enum GenerateRandomError {
    CustomKeyStoreInvalidStateError(CustomKeyStoreInvalidStateError),
    CustomKeyStoreNotFoundError(CustomKeyStoreNotFoundError),
    DependencyTimeoutError(DependencyTimeoutError),
    KMSInternalError(KMSInternalError),

    /// An unexpected error, eg. invalid JSON returned by the service
    Unhandled(Box<dyn ::std::error::Error>),
}
impl ::std::fmt::Display for GenerateRandomError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match self {
            GenerateRandomError::CustomKeyStoreInvalidStateError(_inner) => _inner.fmt(f),
            GenerateRandomError::CustomKeyStoreNotFoundError(_inner) => _inner.fmt(f),
            GenerateRandomError::DependencyTimeoutError(_inner) => _inner.fmt(f),
            GenerateRandomError::KMSInternalError(_inner) => _inner.fmt(f),
            GenerateRandomError::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl ::smithy_types::retry::ProvideErrorKind for GenerateRandomError {
    fn code(&self) -> Option<&str> {
        GenerateRandomError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<::smithy_types::retry::ErrorKind> {
        match self {
            GenerateRandomError::CustomKeyStoreInvalidStateError(_inner) => None,
            GenerateRandomError::CustomKeyStoreNotFoundError(_inner) => None,
            GenerateRandomError::DependencyTimeoutError(_inner) => None,
            GenerateRandomError::KMSInternalError(_inner) => None,
            GenerateRandomError::Unhandled(_inner) => {
                match _inner.downcast_ref::<::smithy_types::Error>() {
                    Some(_inner) => _inner.retryable_error_kind(),
                    None => None,
                }
            }
        }
    }
}
impl GenerateRandomError {
    pub fn unhandled<E: Into<Box<dyn ::std::error::Error>>>(err: E) -> Self {
        GenerateRandomError::Unhandled(err.into())
    }
    pub fn message(&self) -> Option<&str> {
        match self {
            GenerateRandomError::CustomKeyStoreInvalidStateError(_inner) => _inner.message(),
            GenerateRandomError::CustomKeyStoreNotFoundError(_inner) => _inner.message(),
            GenerateRandomError::DependencyTimeoutError(_inner) => _inner.message(),
            GenerateRandomError::KMSInternalError(_inner) => _inner.message(),
            GenerateRandomError::Unhandled(_inner) => {
                match _inner.downcast_ref::<::smithy_types::Error>() {
                    Some(_inner) => _inner.message(),
                    None => None,
                }
            }
        }
    }
    pub fn code(&self) -> Option<&str> {
        match self {
            GenerateRandomError::CustomKeyStoreInvalidStateError(_inner) => Some(_inner.code()),
            GenerateRandomError::CustomKeyStoreNotFoundError(_inner) => Some(_inner.code()),
            GenerateRandomError::DependencyTimeoutError(_inner) => Some(_inner.code()),
            GenerateRandomError::KMSInternalError(_inner) => Some(_inner.code()),
            GenerateRandomError::Unhandled(_inner) => {
                match _inner.downcast_ref::<::smithy_types::Error>() {
                    Some(_inner) => _inner.code(),
                    None => None,
                }
            }
        }
    }
}
impl ::std::error::Error for GenerateRandomError {
    fn source(&self) -> Option<&(dyn ::std::error::Error + 'static)> {
        match self {
            GenerateRandomError::CustomKeyStoreInvalidStateError(_inner) => Some(_inner),
            GenerateRandomError::CustomKeyStoreNotFoundError(_inner) => Some(_inner),
            GenerateRandomError::DependencyTimeoutError(_inner) => Some(_inner),
            GenerateRandomError::KMSInternalError(_inner) => Some(_inner),
            GenerateRandomError::Unhandled(_inner) => {
                match _inner.downcast_ref::<::smithy_types::Error>() {
                    Some(_inner) => Some(_inner),
                    None => Some(_inner.as_ref()),
                }
            }
        }
    }
}

#[non_exhaustive]
#[derive(::std::fmt::Debug)]
pub enum GetKeyPolicyError {
    DependencyTimeoutError(DependencyTimeoutError),
    InvalidArnError(InvalidArnError),
    KMSInternalError(KMSInternalError),
    KMSInvalidStateError(KMSInvalidStateError),
    NotFoundError(NotFoundError),

    /// An unexpected error, eg. invalid JSON returned by the service
    Unhandled(Box<dyn ::std::error::Error>),
}
impl ::std::fmt::Display for GetKeyPolicyError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match self {
            GetKeyPolicyError::DependencyTimeoutError(_inner) => _inner.fmt(f),
            GetKeyPolicyError::InvalidArnError(_inner) => _inner.fmt(f),
            GetKeyPolicyError::KMSInternalError(_inner) => _inner.fmt(f),
            GetKeyPolicyError::KMSInvalidStateError(_inner) => _inner.fmt(f),
            GetKeyPolicyError::NotFoundError(_inner) => _inner.fmt(f),
            GetKeyPolicyError::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl ::smithy_types::retry::ProvideErrorKind for GetKeyPolicyError {
    fn code(&self) -> Option<&str> {
        GetKeyPolicyError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<::smithy_types::retry::ErrorKind> {
        match self {
            GetKeyPolicyError::DependencyTimeoutError(_inner) => None,
            GetKeyPolicyError::InvalidArnError(_inner) => None,
            GetKeyPolicyError::KMSInternalError(_inner) => None,
            GetKeyPolicyError::KMSInvalidStateError(_inner) => None,
            GetKeyPolicyError::NotFoundError(_inner) => None,
            GetKeyPolicyError::Unhandled(_inner) => {
                match _inner.downcast_ref::<::smithy_types::Error>() {
                    Some(_inner) => _inner.retryable_error_kind(),
                    None => None,
                }
            }
        }
    }
}
impl GetKeyPolicyError {
    pub fn unhandled<E: Into<Box<dyn ::std::error::Error>>>(err: E) -> Self {
        GetKeyPolicyError::Unhandled(err.into())
    }
    pub fn message(&self) -> Option<&str> {
        match self {
            GetKeyPolicyError::DependencyTimeoutError(_inner) => _inner.message(),
            GetKeyPolicyError::InvalidArnError(_inner) => _inner.message(),
            GetKeyPolicyError::KMSInternalError(_inner) => _inner.message(),
            GetKeyPolicyError::KMSInvalidStateError(_inner) => _inner.message(),
            GetKeyPolicyError::NotFoundError(_inner) => _inner.message(),
            GetKeyPolicyError::Unhandled(_inner) => {
                match _inner.downcast_ref::<::smithy_types::Error>() {
                    Some(_inner) => _inner.message(),
                    None => None,
                }
            }
        }
    }
    pub fn code(&self) -> Option<&str> {
        match self {
            GetKeyPolicyError::DependencyTimeoutError(_inner) => Some(_inner.code()),
            GetKeyPolicyError::InvalidArnError(_inner) => Some(_inner.code()),
            GetKeyPolicyError::KMSInternalError(_inner) => Some(_inner.code()),
            GetKeyPolicyError::KMSInvalidStateError(_inner) => Some(_inner.code()),
            GetKeyPolicyError::NotFoundError(_inner) => Some(_inner.code()),
            GetKeyPolicyError::Unhandled(_inner) => {
                match _inner.downcast_ref::<::smithy_types::Error>() {
                    Some(_inner) => _inner.code(),
                    None => None,
                }
            }
        }
    }
}
impl ::std::error::Error for GetKeyPolicyError {
    fn source(&self) -> Option<&(dyn ::std::error::Error + 'static)> {
        match self {
            GetKeyPolicyError::DependencyTimeoutError(_inner) => Some(_inner),
            GetKeyPolicyError::InvalidArnError(_inner) => Some(_inner),
            GetKeyPolicyError::KMSInternalError(_inner) => Some(_inner),
            GetKeyPolicyError::KMSInvalidStateError(_inner) => Some(_inner),
            GetKeyPolicyError::NotFoundError(_inner) => Some(_inner),
            GetKeyPolicyError::Unhandled(_inner) => {
                match _inner.downcast_ref::<::smithy_types::Error>() {
                    Some(_inner) => Some(_inner),
                    None => Some(_inner.as_ref()),
                }
            }
        }
    }
}

#[non_exhaustive]
#[derive(::std::fmt::Debug)]
pub enum GetKeyRotationStatusError {
    DependencyTimeoutError(DependencyTimeoutError),
    InvalidArnError(InvalidArnError),
    KMSInternalError(KMSInternalError),
    KMSInvalidStateError(KMSInvalidStateError),
    NotFoundError(NotFoundError),
    UnsupportedOperationError(UnsupportedOperationError),

    /// An unexpected error, eg. invalid JSON returned by the service
    Unhandled(Box<dyn ::std::error::Error>),
}
impl ::std::fmt::Display for GetKeyRotationStatusError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match self {
            GetKeyRotationStatusError::DependencyTimeoutError(_inner) => _inner.fmt(f),
            GetKeyRotationStatusError::InvalidArnError(_inner) => _inner.fmt(f),
            GetKeyRotationStatusError::KMSInternalError(_inner) => _inner.fmt(f),
            GetKeyRotationStatusError::KMSInvalidStateError(_inner) => _inner.fmt(f),
            GetKeyRotationStatusError::NotFoundError(_inner) => _inner.fmt(f),
            GetKeyRotationStatusError::UnsupportedOperationError(_inner) => _inner.fmt(f),
            GetKeyRotationStatusError::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl ::smithy_types::retry::ProvideErrorKind for GetKeyRotationStatusError {
    fn code(&self) -> Option<&str> {
        GetKeyRotationStatusError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<::smithy_types::retry::ErrorKind> {
        match self {
            GetKeyRotationStatusError::DependencyTimeoutError(_inner) => None,
            GetKeyRotationStatusError::InvalidArnError(_inner) => None,
            GetKeyRotationStatusError::KMSInternalError(_inner) => None,
            GetKeyRotationStatusError::KMSInvalidStateError(_inner) => None,
            GetKeyRotationStatusError::NotFoundError(_inner) => None,
            GetKeyRotationStatusError::UnsupportedOperationError(_inner) => None,
            GetKeyRotationStatusError::Unhandled(_inner) => {
                match _inner.downcast_ref::<::smithy_types::Error>() {
                    Some(_inner) => _inner.retryable_error_kind(),
                    None => None,
                }
            }
        }
    }
}
impl GetKeyRotationStatusError {
    pub fn unhandled<E: Into<Box<dyn ::std::error::Error>>>(err: E) -> Self {
        GetKeyRotationStatusError::Unhandled(err.into())
    }
    pub fn message(&self) -> Option<&str> {
        match self {
            GetKeyRotationStatusError::DependencyTimeoutError(_inner) => _inner.message(),
            GetKeyRotationStatusError::InvalidArnError(_inner) => _inner.message(),
            GetKeyRotationStatusError::KMSInternalError(_inner) => _inner.message(),
            GetKeyRotationStatusError::KMSInvalidStateError(_inner) => _inner.message(),
            GetKeyRotationStatusError::NotFoundError(_inner) => _inner.message(),
            GetKeyRotationStatusError::UnsupportedOperationError(_inner) => _inner.message(),
            GetKeyRotationStatusError::Unhandled(_inner) => {
                match _inner.downcast_ref::<::smithy_types::Error>() {
                    Some(_inner) => _inner.message(),
                    None => None,
                }
            }
        }
    }
    pub fn code(&self) -> Option<&str> {
        match self {
            GetKeyRotationStatusError::DependencyTimeoutError(_inner) => Some(_inner.code()),
            GetKeyRotationStatusError::InvalidArnError(_inner) => Some(_inner.code()),
            GetKeyRotationStatusError::KMSInternalError(_inner) => Some(_inner.code()),
            GetKeyRotationStatusError::KMSInvalidStateError(_inner) => Some(_inner.code()),
            GetKeyRotationStatusError::NotFoundError(_inner) => Some(_inner.code()),
            GetKeyRotationStatusError::UnsupportedOperationError(_inner) => Some(_inner.code()),
            GetKeyRotationStatusError::Unhandled(_inner) => {
                match _inner.downcast_ref::<::smithy_types::Error>() {
                    Some(_inner) => _inner.code(),
                    None => None,
                }
            }
        }
    }
}
impl ::std::error::Error for GetKeyRotationStatusError {
    fn source(&self) -> Option<&(dyn ::std::error::Error + 'static)> {
        match self {
            GetKeyRotationStatusError::DependencyTimeoutError(_inner) => Some(_inner),
            GetKeyRotationStatusError::InvalidArnError(_inner) => Some(_inner),
            GetKeyRotationStatusError::KMSInternalError(_inner) => Some(_inner),
            GetKeyRotationStatusError::KMSInvalidStateError(_inner) => Some(_inner),
            GetKeyRotationStatusError::NotFoundError(_inner) => Some(_inner),
            GetKeyRotationStatusError::UnsupportedOperationError(_inner) => Some(_inner),
            GetKeyRotationStatusError::Unhandled(_inner) => {
                match _inner.downcast_ref::<::smithy_types::Error>() {
                    Some(_inner) => Some(_inner),
                    None => Some(_inner.as_ref()),
                }
            }
        }
    }
}

#[non_exhaustive]
#[derive(::std::fmt::Debug)]
pub enum GetParametersForImportError {
    DependencyTimeoutError(DependencyTimeoutError),
    InvalidArnError(InvalidArnError),
    KMSInternalError(KMSInternalError),
    KMSInvalidStateError(KMSInvalidStateError),
    NotFoundError(NotFoundError),
    UnsupportedOperationError(UnsupportedOperationError),

    /// An unexpected error, eg. invalid JSON returned by the service
    Unhandled(Box<dyn ::std::error::Error>),
}
impl ::std::fmt::Display for GetParametersForImportError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match self {
            GetParametersForImportError::DependencyTimeoutError(_inner) => _inner.fmt(f),
            GetParametersForImportError::InvalidArnError(_inner) => _inner.fmt(f),
            GetParametersForImportError::KMSInternalError(_inner) => _inner.fmt(f),
            GetParametersForImportError::KMSInvalidStateError(_inner) => _inner.fmt(f),
            GetParametersForImportError::NotFoundError(_inner) => _inner.fmt(f),
            GetParametersForImportError::UnsupportedOperationError(_inner) => _inner.fmt(f),
            GetParametersForImportError::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl ::smithy_types::retry::ProvideErrorKind for GetParametersForImportError {
    fn code(&self) -> Option<&str> {
        GetParametersForImportError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<::smithy_types::retry::ErrorKind> {
        match self {
            GetParametersForImportError::DependencyTimeoutError(_inner) => None,
            GetParametersForImportError::InvalidArnError(_inner) => None,
            GetParametersForImportError::KMSInternalError(_inner) => None,
            GetParametersForImportError::KMSInvalidStateError(_inner) => None,
            GetParametersForImportError::NotFoundError(_inner) => None,
            GetParametersForImportError::UnsupportedOperationError(_inner) => None,
            GetParametersForImportError::Unhandled(_inner) => {
                match _inner.downcast_ref::<::smithy_types::Error>() {
                    Some(_inner) => _inner.retryable_error_kind(),
                    None => None,
                }
            }
        }
    }
}
impl GetParametersForImportError {
    pub fn unhandled<E: Into<Box<dyn ::std::error::Error>>>(err: E) -> Self {
        GetParametersForImportError::Unhandled(err.into())
    }
    pub fn message(&self) -> Option<&str> {
        match self {
            GetParametersForImportError::DependencyTimeoutError(_inner) => _inner.message(),
            GetParametersForImportError::InvalidArnError(_inner) => _inner.message(),
            GetParametersForImportError::KMSInternalError(_inner) => _inner.message(),
            GetParametersForImportError::KMSInvalidStateError(_inner) => _inner.message(),
            GetParametersForImportError::NotFoundError(_inner) => _inner.message(),
            GetParametersForImportError::UnsupportedOperationError(_inner) => _inner.message(),
            GetParametersForImportError::Unhandled(_inner) => {
                match _inner.downcast_ref::<::smithy_types::Error>() {
                    Some(_inner) => _inner.message(),
                    None => None,
                }
            }
        }
    }
    pub fn code(&self) -> Option<&str> {
        match self {
            GetParametersForImportError::DependencyTimeoutError(_inner) => Some(_inner.code()),
            GetParametersForImportError::InvalidArnError(_inner) => Some(_inner.code()),
            GetParametersForImportError::KMSInternalError(_inner) => Some(_inner.code()),
            GetParametersForImportError::KMSInvalidStateError(_inner) => Some(_inner.code()),
            GetParametersForImportError::NotFoundError(_inner) => Some(_inner.code()),
            GetParametersForImportError::UnsupportedOperationError(_inner) => Some(_inner.code()),
            GetParametersForImportError::Unhandled(_inner) => {
                match _inner.downcast_ref::<::smithy_types::Error>() {
                    Some(_inner) => _inner.code(),
                    None => None,
                }
            }
        }
    }
}
impl ::std::error::Error for GetParametersForImportError {
    fn source(&self) -> Option<&(dyn ::std::error::Error + 'static)> {
        match self {
            GetParametersForImportError::DependencyTimeoutError(_inner) => Some(_inner),
            GetParametersForImportError::InvalidArnError(_inner) => Some(_inner),
            GetParametersForImportError::KMSInternalError(_inner) => Some(_inner),
            GetParametersForImportError::KMSInvalidStateError(_inner) => Some(_inner),
            GetParametersForImportError::NotFoundError(_inner) => Some(_inner),
            GetParametersForImportError::UnsupportedOperationError(_inner) => Some(_inner),
            GetParametersForImportError::Unhandled(_inner) => {
                match _inner.downcast_ref::<::smithy_types::Error>() {
                    Some(_inner) => Some(_inner),
                    None => Some(_inner.as_ref()),
                }
            }
        }
    }
}

#[non_exhaustive]
#[derive(::std::fmt::Debug)]
pub enum GetPublicKeyError {
    DependencyTimeoutError(DependencyTimeoutError),
    DisabledError(DisabledError),
    InvalidArnError(InvalidArnError),
    InvalidGrantTokenError(InvalidGrantTokenError),
    InvalidKeyUsageError(InvalidKeyUsageError),
    KeyUnavailableError(KeyUnavailableError),
    KMSInternalError(KMSInternalError),
    KMSInvalidStateError(KMSInvalidStateError),
    NotFoundError(NotFoundError),
    UnsupportedOperationError(UnsupportedOperationError),

    /// An unexpected error, eg. invalid JSON returned by the service
    Unhandled(Box<dyn ::std::error::Error>),
}
impl ::std::fmt::Display for GetPublicKeyError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match self {
            GetPublicKeyError::DependencyTimeoutError(_inner) => _inner.fmt(f),
            GetPublicKeyError::DisabledError(_inner) => _inner.fmt(f),
            GetPublicKeyError::InvalidArnError(_inner) => _inner.fmt(f),
            GetPublicKeyError::InvalidGrantTokenError(_inner) => _inner.fmt(f),
            GetPublicKeyError::InvalidKeyUsageError(_inner) => _inner.fmt(f),
            GetPublicKeyError::KeyUnavailableError(_inner) => _inner.fmt(f),
            GetPublicKeyError::KMSInternalError(_inner) => _inner.fmt(f),
            GetPublicKeyError::KMSInvalidStateError(_inner) => _inner.fmt(f),
            GetPublicKeyError::NotFoundError(_inner) => _inner.fmt(f),
            GetPublicKeyError::UnsupportedOperationError(_inner) => _inner.fmt(f),
            GetPublicKeyError::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl ::smithy_types::retry::ProvideErrorKind for GetPublicKeyError {
    fn code(&self) -> Option<&str> {
        GetPublicKeyError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<::smithy_types::retry::ErrorKind> {
        match self {
            GetPublicKeyError::DependencyTimeoutError(_inner) => None,
            GetPublicKeyError::DisabledError(_inner) => None,
            GetPublicKeyError::InvalidArnError(_inner) => None,
            GetPublicKeyError::InvalidGrantTokenError(_inner) => None,
            GetPublicKeyError::InvalidKeyUsageError(_inner) => None,
            GetPublicKeyError::KeyUnavailableError(_inner) => None,
            GetPublicKeyError::KMSInternalError(_inner) => None,
            GetPublicKeyError::KMSInvalidStateError(_inner) => None,
            GetPublicKeyError::NotFoundError(_inner) => None,
            GetPublicKeyError::UnsupportedOperationError(_inner) => None,
            GetPublicKeyError::Unhandled(_inner) => {
                match _inner.downcast_ref::<::smithy_types::Error>() {
                    Some(_inner) => _inner.retryable_error_kind(),
                    None => None,
                }
            }
        }
    }
}
impl GetPublicKeyError {
    pub fn unhandled<E: Into<Box<dyn ::std::error::Error>>>(err: E) -> Self {
        GetPublicKeyError::Unhandled(err.into())
    }
    pub fn message(&self) -> Option<&str> {
        match self {
            GetPublicKeyError::DependencyTimeoutError(_inner) => _inner.message(),
            GetPublicKeyError::DisabledError(_inner) => _inner.message(),
            GetPublicKeyError::InvalidArnError(_inner) => _inner.message(),
            GetPublicKeyError::InvalidGrantTokenError(_inner) => _inner.message(),
            GetPublicKeyError::InvalidKeyUsageError(_inner) => _inner.message(),
            GetPublicKeyError::KeyUnavailableError(_inner) => _inner.message(),
            GetPublicKeyError::KMSInternalError(_inner) => _inner.message(),
            GetPublicKeyError::KMSInvalidStateError(_inner) => _inner.message(),
            GetPublicKeyError::NotFoundError(_inner) => _inner.message(),
            GetPublicKeyError::UnsupportedOperationError(_inner) => _inner.message(),
            GetPublicKeyError::Unhandled(_inner) => {
                match _inner.downcast_ref::<::smithy_types::Error>() {
                    Some(_inner) => _inner.message(),
                    None => None,
                }
            }
        }
    }
    pub fn code(&self) -> Option<&str> {
        match self {
            GetPublicKeyError::DependencyTimeoutError(_inner) => Some(_inner.code()),
            GetPublicKeyError::DisabledError(_inner) => Some(_inner.code()),
            GetPublicKeyError::InvalidArnError(_inner) => Some(_inner.code()),
            GetPublicKeyError::InvalidGrantTokenError(_inner) => Some(_inner.code()),
            GetPublicKeyError::InvalidKeyUsageError(_inner) => Some(_inner.code()),
            GetPublicKeyError::KeyUnavailableError(_inner) => Some(_inner.code()),
            GetPublicKeyError::KMSInternalError(_inner) => Some(_inner.code()),
            GetPublicKeyError::KMSInvalidStateError(_inner) => Some(_inner.code()),
            GetPublicKeyError::NotFoundError(_inner) => Some(_inner.code()),
            GetPublicKeyError::UnsupportedOperationError(_inner) => Some(_inner.code()),
            GetPublicKeyError::Unhandled(_inner) => {
                match _inner.downcast_ref::<::smithy_types::Error>() {
                    Some(_inner) => _inner.code(),
                    None => None,
                }
            }
        }
    }
}
impl ::std::error::Error for GetPublicKeyError {
    fn source(&self) -> Option<&(dyn ::std::error::Error + 'static)> {
        match self {
            GetPublicKeyError::DependencyTimeoutError(_inner) => Some(_inner),
            GetPublicKeyError::DisabledError(_inner) => Some(_inner),
            GetPublicKeyError::InvalidArnError(_inner) => Some(_inner),
            GetPublicKeyError::InvalidGrantTokenError(_inner) => Some(_inner),
            GetPublicKeyError::InvalidKeyUsageError(_inner) => Some(_inner),
            GetPublicKeyError::KeyUnavailableError(_inner) => Some(_inner),
            GetPublicKeyError::KMSInternalError(_inner) => Some(_inner),
            GetPublicKeyError::KMSInvalidStateError(_inner) => Some(_inner),
            GetPublicKeyError::NotFoundError(_inner) => Some(_inner),
            GetPublicKeyError::UnsupportedOperationError(_inner) => Some(_inner),
            GetPublicKeyError::Unhandled(_inner) => {
                match _inner.downcast_ref::<::smithy_types::Error>() {
                    Some(_inner) => Some(_inner),
                    None => Some(_inner.as_ref()),
                }
            }
        }
    }
}

#[non_exhaustive]
#[derive(::std::fmt::Debug)]
pub enum ImportKeyMaterialError {
    DependencyTimeoutError(DependencyTimeoutError),
    ExpiredImportTokenError(ExpiredImportTokenError),
    IncorrectKeyMaterialError(IncorrectKeyMaterialError),
    InvalidArnError(InvalidArnError),
    InvalidCiphertextError(InvalidCiphertextError),
    InvalidImportTokenError(InvalidImportTokenError),
    KMSInternalError(KMSInternalError),
    KMSInvalidStateError(KMSInvalidStateError),
    NotFoundError(NotFoundError),
    UnsupportedOperationError(UnsupportedOperationError),

    /// An unexpected error, eg. invalid JSON returned by the service
    Unhandled(Box<dyn ::std::error::Error>),
}
impl ::std::fmt::Display for ImportKeyMaterialError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match self {
            ImportKeyMaterialError::DependencyTimeoutError(_inner) => _inner.fmt(f),
            ImportKeyMaterialError::ExpiredImportTokenError(_inner) => _inner.fmt(f),
            ImportKeyMaterialError::IncorrectKeyMaterialError(_inner) => _inner.fmt(f),
            ImportKeyMaterialError::InvalidArnError(_inner) => _inner.fmt(f),
            ImportKeyMaterialError::InvalidCiphertextError(_inner) => _inner.fmt(f),
            ImportKeyMaterialError::InvalidImportTokenError(_inner) => _inner.fmt(f),
            ImportKeyMaterialError::KMSInternalError(_inner) => _inner.fmt(f),
            ImportKeyMaterialError::KMSInvalidStateError(_inner) => _inner.fmt(f),
            ImportKeyMaterialError::NotFoundError(_inner) => _inner.fmt(f),
            ImportKeyMaterialError::UnsupportedOperationError(_inner) => _inner.fmt(f),
            ImportKeyMaterialError::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl ::smithy_types::retry::ProvideErrorKind for ImportKeyMaterialError {
    fn code(&self) -> Option<&str> {
        ImportKeyMaterialError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<::smithy_types::retry::ErrorKind> {
        match self {
            ImportKeyMaterialError::DependencyTimeoutError(_inner) => None,
            ImportKeyMaterialError::ExpiredImportTokenError(_inner) => None,
            ImportKeyMaterialError::IncorrectKeyMaterialError(_inner) => None,
            ImportKeyMaterialError::InvalidArnError(_inner) => None,
            ImportKeyMaterialError::InvalidCiphertextError(_inner) => None,
            ImportKeyMaterialError::InvalidImportTokenError(_inner) => None,
            ImportKeyMaterialError::KMSInternalError(_inner) => None,
            ImportKeyMaterialError::KMSInvalidStateError(_inner) => None,
            ImportKeyMaterialError::NotFoundError(_inner) => None,
            ImportKeyMaterialError::UnsupportedOperationError(_inner) => None,
            ImportKeyMaterialError::Unhandled(_inner) => {
                match _inner.downcast_ref::<::smithy_types::Error>() {
                    Some(_inner) => _inner.retryable_error_kind(),
                    None => None,
                }
            }
        }
    }
}
impl ImportKeyMaterialError {
    pub fn unhandled<E: Into<Box<dyn ::std::error::Error>>>(err: E) -> Self {
        ImportKeyMaterialError::Unhandled(err.into())
    }
    pub fn message(&self) -> Option<&str> {
        match self {
            ImportKeyMaterialError::DependencyTimeoutError(_inner) => _inner.message(),
            ImportKeyMaterialError::ExpiredImportTokenError(_inner) => _inner.message(),
            ImportKeyMaterialError::IncorrectKeyMaterialError(_inner) => _inner.message(),
            ImportKeyMaterialError::InvalidArnError(_inner) => _inner.message(),
            ImportKeyMaterialError::InvalidCiphertextError(_inner) => _inner.message(),
            ImportKeyMaterialError::InvalidImportTokenError(_inner) => _inner.message(),
            ImportKeyMaterialError::KMSInternalError(_inner) => _inner.message(),
            ImportKeyMaterialError::KMSInvalidStateError(_inner) => _inner.message(),
            ImportKeyMaterialError::NotFoundError(_inner) => _inner.message(),
            ImportKeyMaterialError::UnsupportedOperationError(_inner) => _inner.message(),
            ImportKeyMaterialError::Unhandled(_inner) => {
                match _inner.downcast_ref::<::smithy_types::Error>() {
                    Some(_inner) => _inner.message(),
                    None => None,
                }
            }
        }
    }
    pub fn code(&self) -> Option<&str> {
        match self {
            ImportKeyMaterialError::DependencyTimeoutError(_inner) => Some(_inner.code()),
            ImportKeyMaterialError::ExpiredImportTokenError(_inner) => Some(_inner.code()),
            ImportKeyMaterialError::IncorrectKeyMaterialError(_inner) => Some(_inner.code()),
            ImportKeyMaterialError::InvalidArnError(_inner) => Some(_inner.code()),
            ImportKeyMaterialError::InvalidCiphertextError(_inner) => Some(_inner.code()),
            ImportKeyMaterialError::InvalidImportTokenError(_inner) => Some(_inner.code()),
            ImportKeyMaterialError::KMSInternalError(_inner) => Some(_inner.code()),
            ImportKeyMaterialError::KMSInvalidStateError(_inner) => Some(_inner.code()),
            ImportKeyMaterialError::NotFoundError(_inner) => Some(_inner.code()),
            ImportKeyMaterialError::UnsupportedOperationError(_inner) => Some(_inner.code()),
            ImportKeyMaterialError::Unhandled(_inner) => {
                match _inner.downcast_ref::<::smithy_types::Error>() {
                    Some(_inner) => _inner.code(),
                    None => None,
                }
            }
        }
    }
}
impl ::std::error::Error for ImportKeyMaterialError {
    fn source(&self) -> Option<&(dyn ::std::error::Error + 'static)> {
        match self {
            ImportKeyMaterialError::DependencyTimeoutError(_inner) => Some(_inner),
            ImportKeyMaterialError::ExpiredImportTokenError(_inner) => Some(_inner),
            ImportKeyMaterialError::IncorrectKeyMaterialError(_inner) => Some(_inner),
            ImportKeyMaterialError::InvalidArnError(_inner) => Some(_inner),
            ImportKeyMaterialError::InvalidCiphertextError(_inner) => Some(_inner),
            ImportKeyMaterialError::InvalidImportTokenError(_inner) => Some(_inner),
            ImportKeyMaterialError::KMSInternalError(_inner) => Some(_inner),
            ImportKeyMaterialError::KMSInvalidStateError(_inner) => Some(_inner),
            ImportKeyMaterialError::NotFoundError(_inner) => Some(_inner),
            ImportKeyMaterialError::UnsupportedOperationError(_inner) => Some(_inner),
            ImportKeyMaterialError::Unhandled(_inner) => {
                match _inner.downcast_ref::<::smithy_types::Error>() {
                    Some(_inner) => Some(_inner),
                    None => Some(_inner.as_ref()),
                }
            }
        }
    }
}

#[non_exhaustive]
#[derive(::std::fmt::Debug)]
pub enum ListAliasesError {
    DependencyTimeoutError(DependencyTimeoutError),
    InvalidArnError(InvalidArnError),
    InvalidMarkerError(InvalidMarkerError),
    KMSInternalError(KMSInternalError),
    NotFoundError(NotFoundError),

    /// An unexpected error, eg. invalid JSON returned by the service
    Unhandled(Box<dyn ::std::error::Error>),
}
impl ::std::fmt::Display for ListAliasesError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match self {
            ListAliasesError::DependencyTimeoutError(_inner) => _inner.fmt(f),
            ListAliasesError::InvalidArnError(_inner) => _inner.fmt(f),
            ListAliasesError::InvalidMarkerError(_inner) => _inner.fmt(f),
            ListAliasesError::KMSInternalError(_inner) => _inner.fmt(f),
            ListAliasesError::NotFoundError(_inner) => _inner.fmt(f),
            ListAliasesError::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl ::smithy_types::retry::ProvideErrorKind for ListAliasesError {
    fn code(&self) -> Option<&str> {
        ListAliasesError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<::smithy_types::retry::ErrorKind> {
        match self {
            ListAliasesError::DependencyTimeoutError(_inner) => None,
            ListAliasesError::InvalidArnError(_inner) => None,
            ListAliasesError::InvalidMarkerError(_inner) => None,
            ListAliasesError::KMSInternalError(_inner) => None,
            ListAliasesError::NotFoundError(_inner) => None,
            ListAliasesError::Unhandled(_inner) => {
                match _inner.downcast_ref::<::smithy_types::Error>() {
                    Some(_inner) => _inner.retryable_error_kind(),
                    None => None,
                }
            }
        }
    }
}
impl ListAliasesError {
    pub fn unhandled<E: Into<Box<dyn ::std::error::Error>>>(err: E) -> Self {
        ListAliasesError::Unhandled(err.into())
    }
    pub fn message(&self) -> Option<&str> {
        match self {
            ListAliasesError::DependencyTimeoutError(_inner) => _inner.message(),
            ListAliasesError::InvalidArnError(_inner) => _inner.message(),
            ListAliasesError::InvalidMarkerError(_inner) => _inner.message(),
            ListAliasesError::KMSInternalError(_inner) => _inner.message(),
            ListAliasesError::NotFoundError(_inner) => _inner.message(),
            ListAliasesError::Unhandled(_inner) => {
                match _inner.downcast_ref::<::smithy_types::Error>() {
                    Some(_inner) => _inner.message(),
                    None => None,
                }
            }
        }
    }
    pub fn code(&self) -> Option<&str> {
        match self {
            ListAliasesError::DependencyTimeoutError(_inner) => Some(_inner.code()),
            ListAliasesError::InvalidArnError(_inner) => Some(_inner.code()),
            ListAliasesError::InvalidMarkerError(_inner) => Some(_inner.code()),
            ListAliasesError::KMSInternalError(_inner) => Some(_inner.code()),
            ListAliasesError::NotFoundError(_inner) => Some(_inner.code()),
            ListAliasesError::Unhandled(_inner) => {
                match _inner.downcast_ref::<::smithy_types::Error>() {
                    Some(_inner) => _inner.code(),
                    None => None,
                }
            }
        }
    }
}
impl ::std::error::Error for ListAliasesError {
    fn source(&self) -> Option<&(dyn ::std::error::Error + 'static)> {
        match self {
            ListAliasesError::DependencyTimeoutError(_inner) => Some(_inner),
            ListAliasesError::InvalidArnError(_inner) => Some(_inner),
            ListAliasesError::InvalidMarkerError(_inner) => Some(_inner),
            ListAliasesError::KMSInternalError(_inner) => Some(_inner),
            ListAliasesError::NotFoundError(_inner) => Some(_inner),
            ListAliasesError::Unhandled(_inner) => {
                match _inner.downcast_ref::<::smithy_types::Error>() {
                    Some(_inner) => Some(_inner),
                    None => Some(_inner.as_ref()),
                }
            }
        }
    }
}

#[non_exhaustive]
#[derive(::std::fmt::Debug)]
pub enum ListGrantsError {
    DependencyTimeoutError(DependencyTimeoutError),
    InvalidArnError(InvalidArnError),
    InvalidMarkerError(InvalidMarkerError),
    KMSInternalError(KMSInternalError),
    KMSInvalidStateError(KMSInvalidStateError),
    NotFoundError(NotFoundError),

    /// An unexpected error, eg. invalid JSON returned by the service
    Unhandled(Box<dyn ::std::error::Error>),
}
impl ::std::fmt::Display for ListGrantsError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match self {
            ListGrantsError::DependencyTimeoutError(_inner) => _inner.fmt(f),
            ListGrantsError::InvalidArnError(_inner) => _inner.fmt(f),
            ListGrantsError::InvalidMarkerError(_inner) => _inner.fmt(f),
            ListGrantsError::KMSInternalError(_inner) => _inner.fmt(f),
            ListGrantsError::KMSInvalidStateError(_inner) => _inner.fmt(f),
            ListGrantsError::NotFoundError(_inner) => _inner.fmt(f),
            ListGrantsError::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl ::smithy_types::retry::ProvideErrorKind for ListGrantsError {
    fn code(&self) -> Option<&str> {
        ListGrantsError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<::smithy_types::retry::ErrorKind> {
        match self {
            ListGrantsError::DependencyTimeoutError(_inner) => None,
            ListGrantsError::InvalidArnError(_inner) => None,
            ListGrantsError::InvalidMarkerError(_inner) => None,
            ListGrantsError::KMSInternalError(_inner) => None,
            ListGrantsError::KMSInvalidStateError(_inner) => None,
            ListGrantsError::NotFoundError(_inner) => None,
            ListGrantsError::Unhandled(_inner) => {
                match _inner.downcast_ref::<::smithy_types::Error>() {
                    Some(_inner) => _inner.retryable_error_kind(),
                    None => None,
                }
            }
        }
    }
}
impl ListGrantsError {
    pub fn unhandled<E: Into<Box<dyn ::std::error::Error>>>(err: E) -> Self {
        ListGrantsError::Unhandled(err.into())
    }
    pub fn message(&self) -> Option<&str> {
        match self {
            ListGrantsError::DependencyTimeoutError(_inner) => _inner.message(),
            ListGrantsError::InvalidArnError(_inner) => _inner.message(),
            ListGrantsError::InvalidMarkerError(_inner) => _inner.message(),
            ListGrantsError::KMSInternalError(_inner) => _inner.message(),
            ListGrantsError::KMSInvalidStateError(_inner) => _inner.message(),
            ListGrantsError::NotFoundError(_inner) => _inner.message(),
            ListGrantsError::Unhandled(_inner) => {
                match _inner.downcast_ref::<::smithy_types::Error>() {
                    Some(_inner) => _inner.message(),
                    None => None,
                }
            }
        }
    }
    pub fn code(&self) -> Option<&str> {
        match self {
            ListGrantsError::DependencyTimeoutError(_inner) => Some(_inner.code()),
            ListGrantsError::InvalidArnError(_inner) => Some(_inner.code()),
            ListGrantsError::InvalidMarkerError(_inner) => Some(_inner.code()),
            ListGrantsError::KMSInternalError(_inner) => Some(_inner.code()),
            ListGrantsError::KMSInvalidStateError(_inner) => Some(_inner.code()),
            ListGrantsError::NotFoundError(_inner) => Some(_inner.code()),
            ListGrantsError::Unhandled(_inner) => {
                match _inner.downcast_ref::<::smithy_types::Error>() {
                    Some(_inner) => _inner.code(),
                    None => None,
                }
            }
        }
    }
}
impl ::std::error::Error for ListGrantsError {
    fn source(&self) -> Option<&(dyn ::std::error::Error + 'static)> {
        match self {
            ListGrantsError::DependencyTimeoutError(_inner) => Some(_inner),
            ListGrantsError::InvalidArnError(_inner) => Some(_inner),
            ListGrantsError::InvalidMarkerError(_inner) => Some(_inner),
            ListGrantsError::KMSInternalError(_inner) => Some(_inner),
            ListGrantsError::KMSInvalidStateError(_inner) => Some(_inner),
            ListGrantsError::NotFoundError(_inner) => Some(_inner),
            ListGrantsError::Unhandled(_inner) => {
                match _inner.downcast_ref::<::smithy_types::Error>() {
                    Some(_inner) => Some(_inner),
                    None => Some(_inner.as_ref()),
                }
            }
        }
    }
}

#[non_exhaustive]
#[derive(::std::fmt::Debug)]
pub enum ListKeyPoliciesError {
    DependencyTimeoutError(DependencyTimeoutError),
    InvalidArnError(InvalidArnError),
    KMSInternalError(KMSInternalError),
    KMSInvalidStateError(KMSInvalidStateError),
    NotFoundError(NotFoundError),

    /// An unexpected error, eg. invalid JSON returned by the service
    Unhandled(Box<dyn ::std::error::Error>),
}
impl ::std::fmt::Display for ListKeyPoliciesError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match self {
            ListKeyPoliciesError::DependencyTimeoutError(_inner) => _inner.fmt(f),
            ListKeyPoliciesError::InvalidArnError(_inner) => _inner.fmt(f),
            ListKeyPoliciesError::KMSInternalError(_inner) => _inner.fmt(f),
            ListKeyPoliciesError::KMSInvalidStateError(_inner) => _inner.fmt(f),
            ListKeyPoliciesError::NotFoundError(_inner) => _inner.fmt(f),
            ListKeyPoliciesError::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl ::smithy_types::retry::ProvideErrorKind for ListKeyPoliciesError {
    fn code(&self) -> Option<&str> {
        ListKeyPoliciesError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<::smithy_types::retry::ErrorKind> {
        match self {
            ListKeyPoliciesError::DependencyTimeoutError(_inner) => None,
            ListKeyPoliciesError::InvalidArnError(_inner) => None,
            ListKeyPoliciesError::KMSInternalError(_inner) => None,
            ListKeyPoliciesError::KMSInvalidStateError(_inner) => None,
            ListKeyPoliciesError::NotFoundError(_inner) => None,
            ListKeyPoliciesError::Unhandled(_inner) => {
                match _inner.downcast_ref::<::smithy_types::Error>() {
                    Some(_inner) => _inner.retryable_error_kind(),
                    None => None,
                }
            }
        }
    }
}
impl ListKeyPoliciesError {
    pub fn unhandled<E: Into<Box<dyn ::std::error::Error>>>(err: E) -> Self {
        ListKeyPoliciesError::Unhandled(err.into())
    }
    pub fn message(&self) -> Option<&str> {
        match self {
            ListKeyPoliciesError::DependencyTimeoutError(_inner) => _inner.message(),
            ListKeyPoliciesError::InvalidArnError(_inner) => _inner.message(),
            ListKeyPoliciesError::KMSInternalError(_inner) => _inner.message(),
            ListKeyPoliciesError::KMSInvalidStateError(_inner) => _inner.message(),
            ListKeyPoliciesError::NotFoundError(_inner) => _inner.message(),
            ListKeyPoliciesError::Unhandled(_inner) => {
                match _inner.downcast_ref::<::smithy_types::Error>() {
                    Some(_inner) => _inner.message(),
                    None => None,
                }
            }
        }
    }
    pub fn code(&self) -> Option<&str> {
        match self {
            ListKeyPoliciesError::DependencyTimeoutError(_inner) => Some(_inner.code()),
            ListKeyPoliciesError::InvalidArnError(_inner) => Some(_inner.code()),
            ListKeyPoliciesError::KMSInternalError(_inner) => Some(_inner.code()),
            ListKeyPoliciesError::KMSInvalidStateError(_inner) => Some(_inner.code()),
            ListKeyPoliciesError::NotFoundError(_inner) => Some(_inner.code()),
            ListKeyPoliciesError::Unhandled(_inner) => {
                match _inner.downcast_ref::<::smithy_types::Error>() {
                    Some(_inner) => _inner.code(),
                    None => None,
                }
            }
        }
    }
}
impl ::std::error::Error for ListKeyPoliciesError {
    fn source(&self) -> Option<&(dyn ::std::error::Error + 'static)> {
        match self {
            ListKeyPoliciesError::DependencyTimeoutError(_inner) => Some(_inner),
            ListKeyPoliciesError::InvalidArnError(_inner) => Some(_inner),
            ListKeyPoliciesError::KMSInternalError(_inner) => Some(_inner),
            ListKeyPoliciesError::KMSInvalidStateError(_inner) => Some(_inner),
            ListKeyPoliciesError::NotFoundError(_inner) => Some(_inner),
            ListKeyPoliciesError::Unhandled(_inner) => {
                match _inner.downcast_ref::<::smithy_types::Error>() {
                    Some(_inner) => Some(_inner),
                    None => Some(_inner.as_ref()),
                }
            }
        }
    }
}

#[non_exhaustive]
#[derive(::std::fmt::Debug)]
pub enum ListKeysError {
    DependencyTimeoutError(DependencyTimeoutError),
    InvalidMarkerError(InvalidMarkerError),
    KMSInternalError(KMSInternalError),

    /// An unexpected error, eg. invalid JSON returned by the service
    Unhandled(Box<dyn ::std::error::Error>),
}
impl ::std::fmt::Display for ListKeysError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match self {
            ListKeysError::DependencyTimeoutError(_inner) => _inner.fmt(f),
            ListKeysError::InvalidMarkerError(_inner) => _inner.fmt(f),
            ListKeysError::KMSInternalError(_inner) => _inner.fmt(f),
            ListKeysError::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl ::smithy_types::retry::ProvideErrorKind for ListKeysError {
    fn code(&self) -> Option<&str> {
        ListKeysError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<::smithy_types::retry::ErrorKind> {
        match self {
            ListKeysError::DependencyTimeoutError(_inner) => None,
            ListKeysError::InvalidMarkerError(_inner) => None,
            ListKeysError::KMSInternalError(_inner) => None,
            ListKeysError::Unhandled(_inner) => {
                match _inner.downcast_ref::<::smithy_types::Error>() {
                    Some(_inner) => _inner.retryable_error_kind(),
                    None => None,
                }
            }
        }
    }
}
impl ListKeysError {
    pub fn unhandled<E: Into<Box<dyn ::std::error::Error>>>(err: E) -> Self {
        ListKeysError::Unhandled(err.into())
    }
    pub fn message(&self) -> Option<&str> {
        match self {
            ListKeysError::DependencyTimeoutError(_inner) => _inner.message(),
            ListKeysError::InvalidMarkerError(_inner) => _inner.message(),
            ListKeysError::KMSInternalError(_inner) => _inner.message(),
            ListKeysError::Unhandled(_inner) => {
                match _inner.downcast_ref::<::smithy_types::Error>() {
                    Some(_inner) => _inner.message(),
                    None => None,
                }
            }
        }
    }
    pub fn code(&self) -> Option<&str> {
        match self {
            ListKeysError::DependencyTimeoutError(_inner) => Some(_inner.code()),
            ListKeysError::InvalidMarkerError(_inner) => Some(_inner.code()),
            ListKeysError::KMSInternalError(_inner) => Some(_inner.code()),
            ListKeysError::Unhandled(_inner) => {
                match _inner.downcast_ref::<::smithy_types::Error>() {
                    Some(_inner) => _inner.code(),
                    None => None,
                }
            }
        }
    }
}
impl ::std::error::Error for ListKeysError {
    fn source(&self) -> Option<&(dyn ::std::error::Error + 'static)> {
        match self {
            ListKeysError::DependencyTimeoutError(_inner) => Some(_inner),
            ListKeysError::InvalidMarkerError(_inner) => Some(_inner),
            ListKeysError::KMSInternalError(_inner) => Some(_inner),
            ListKeysError::Unhandled(_inner) => {
                match _inner.downcast_ref::<::smithy_types::Error>() {
                    Some(_inner) => Some(_inner),
                    None => Some(_inner.as_ref()),
                }
            }
        }
    }
}

#[non_exhaustive]
#[derive(::std::fmt::Debug)]
pub enum ListResourceTagsError {
    InvalidArnError(InvalidArnError),
    InvalidMarkerError(InvalidMarkerError),
    KMSInternalError(KMSInternalError),
    NotFoundError(NotFoundError),

    /// An unexpected error, eg. invalid JSON returned by the service
    Unhandled(Box<dyn ::std::error::Error>),
}
impl ::std::fmt::Display for ListResourceTagsError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match self {
            ListResourceTagsError::InvalidArnError(_inner) => _inner.fmt(f),
            ListResourceTagsError::InvalidMarkerError(_inner) => _inner.fmt(f),
            ListResourceTagsError::KMSInternalError(_inner) => _inner.fmt(f),
            ListResourceTagsError::NotFoundError(_inner) => _inner.fmt(f),
            ListResourceTagsError::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl ::smithy_types::retry::ProvideErrorKind for ListResourceTagsError {
    fn code(&self) -> Option<&str> {
        ListResourceTagsError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<::smithy_types::retry::ErrorKind> {
        match self {
            ListResourceTagsError::InvalidArnError(_inner) => None,
            ListResourceTagsError::InvalidMarkerError(_inner) => None,
            ListResourceTagsError::KMSInternalError(_inner) => None,
            ListResourceTagsError::NotFoundError(_inner) => None,
            ListResourceTagsError::Unhandled(_inner) => {
                match _inner.downcast_ref::<::smithy_types::Error>() {
                    Some(_inner) => _inner.retryable_error_kind(),
                    None => None,
                }
            }
        }
    }
}
impl ListResourceTagsError {
    pub fn unhandled<E: Into<Box<dyn ::std::error::Error>>>(err: E) -> Self {
        ListResourceTagsError::Unhandled(err.into())
    }
    pub fn message(&self) -> Option<&str> {
        match self {
            ListResourceTagsError::InvalidArnError(_inner) => _inner.message(),
            ListResourceTagsError::InvalidMarkerError(_inner) => _inner.message(),
            ListResourceTagsError::KMSInternalError(_inner) => _inner.message(),
            ListResourceTagsError::NotFoundError(_inner) => _inner.message(),
            ListResourceTagsError::Unhandled(_inner) => {
                match _inner.downcast_ref::<::smithy_types::Error>() {
                    Some(_inner) => _inner.message(),
                    None => None,
                }
            }
        }
    }
    pub fn code(&self) -> Option<&str> {
        match self {
            ListResourceTagsError::InvalidArnError(_inner) => Some(_inner.code()),
            ListResourceTagsError::InvalidMarkerError(_inner) => Some(_inner.code()),
            ListResourceTagsError::KMSInternalError(_inner) => Some(_inner.code()),
            ListResourceTagsError::NotFoundError(_inner) => Some(_inner.code()),
            ListResourceTagsError::Unhandled(_inner) => {
                match _inner.downcast_ref::<::smithy_types::Error>() {
                    Some(_inner) => _inner.code(),
                    None => None,
                }
            }
        }
    }
}
impl ::std::error::Error for ListResourceTagsError {
    fn source(&self) -> Option<&(dyn ::std::error::Error + 'static)> {
        match self {
            ListResourceTagsError::InvalidArnError(_inner) => Some(_inner),
            ListResourceTagsError::InvalidMarkerError(_inner) => Some(_inner),
            ListResourceTagsError::KMSInternalError(_inner) => Some(_inner),
            ListResourceTagsError::NotFoundError(_inner) => Some(_inner),
            ListResourceTagsError::Unhandled(_inner) => {
                match _inner.downcast_ref::<::smithy_types::Error>() {
                    Some(_inner) => Some(_inner),
                    None => Some(_inner.as_ref()),
                }
            }
        }
    }
}

#[non_exhaustive]
#[derive(::std::fmt::Debug)]
pub enum ListRetirableGrantsError {
    DependencyTimeoutError(DependencyTimeoutError),
    InvalidArnError(InvalidArnError),
    InvalidMarkerError(InvalidMarkerError),
    KMSInternalError(KMSInternalError),
    NotFoundError(NotFoundError),

    /// An unexpected error, eg. invalid JSON returned by the service
    Unhandled(Box<dyn ::std::error::Error>),
}
impl ::std::fmt::Display for ListRetirableGrantsError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match self {
            ListRetirableGrantsError::DependencyTimeoutError(_inner) => _inner.fmt(f),
            ListRetirableGrantsError::InvalidArnError(_inner) => _inner.fmt(f),
            ListRetirableGrantsError::InvalidMarkerError(_inner) => _inner.fmt(f),
            ListRetirableGrantsError::KMSInternalError(_inner) => _inner.fmt(f),
            ListRetirableGrantsError::NotFoundError(_inner) => _inner.fmt(f),
            ListRetirableGrantsError::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl ::smithy_types::retry::ProvideErrorKind for ListRetirableGrantsError {
    fn code(&self) -> Option<&str> {
        ListRetirableGrantsError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<::smithy_types::retry::ErrorKind> {
        match self {
            ListRetirableGrantsError::DependencyTimeoutError(_inner) => None,
            ListRetirableGrantsError::InvalidArnError(_inner) => None,
            ListRetirableGrantsError::InvalidMarkerError(_inner) => None,
            ListRetirableGrantsError::KMSInternalError(_inner) => None,
            ListRetirableGrantsError::NotFoundError(_inner) => None,
            ListRetirableGrantsError::Unhandled(_inner) => {
                match _inner.downcast_ref::<::smithy_types::Error>() {
                    Some(_inner) => _inner.retryable_error_kind(),
                    None => None,
                }
            }
        }
    }
}
impl ListRetirableGrantsError {
    pub fn unhandled<E: Into<Box<dyn ::std::error::Error>>>(err: E) -> Self {
        ListRetirableGrantsError::Unhandled(err.into())
    }
    pub fn message(&self) -> Option<&str> {
        match self {
            ListRetirableGrantsError::DependencyTimeoutError(_inner) => _inner.message(),
            ListRetirableGrantsError::InvalidArnError(_inner) => _inner.message(),
            ListRetirableGrantsError::InvalidMarkerError(_inner) => _inner.message(),
            ListRetirableGrantsError::KMSInternalError(_inner) => _inner.message(),
            ListRetirableGrantsError::NotFoundError(_inner) => _inner.message(),
            ListRetirableGrantsError::Unhandled(_inner) => {
                match _inner.downcast_ref::<::smithy_types::Error>() {
                    Some(_inner) => _inner.message(),
                    None => None,
                }
            }
        }
    }
    pub fn code(&self) -> Option<&str> {
        match self {
            ListRetirableGrantsError::DependencyTimeoutError(_inner) => Some(_inner.code()),
            ListRetirableGrantsError::InvalidArnError(_inner) => Some(_inner.code()),
            ListRetirableGrantsError::InvalidMarkerError(_inner) => Some(_inner.code()),
            ListRetirableGrantsError::KMSInternalError(_inner) => Some(_inner.code()),
            ListRetirableGrantsError::NotFoundError(_inner) => Some(_inner.code()),
            ListRetirableGrantsError::Unhandled(_inner) => {
                match _inner.downcast_ref::<::smithy_types::Error>() {
                    Some(_inner) => _inner.code(),
                    None => None,
                }
            }
        }
    }
}
impl ::std::error::Error for ListRetirableGrantsError {
    fn source(&self) -> Option<&(dyn ::std::error::Error + 'static)> {
        match self {
            ListRetirableGrantsError::DependencyTimeoutError(_inner) => Some(_inner),
            ListRetirableGrantsError::InvalidArnError(_inner) => Some(_inner),
            ListRetirableGrantsError::InvalidMarkerError(_inner) => Some(_inner),
            ListRetirableGrantsError::KMSInternalError(_inner) => Some(_inner),
            ListRetirableGrantsError::NotFoundError(_inner) => Some(_inner),
            ListRetirableGrantsError::Unhandled(_inner) => {
                match _inner.downcast_ref::<::smithy_types::Error>() {
                    Some(_inner) => Some(_inner),
                    None => Some(_inner.as_ref()),
                }
            }
        }
    }
}

#[non_exhaustive]
#[derive(::std::fmt::Debug)]
pub enum PutKeyPolicyError {
    DependencyTimeoutError(DependencyTimeoutError),
    InvalidArnError(InvalidArnError),
    KMSInternalError(KMSInternalError),
    KMSInvalidStateError(KMSInvalidStateError),
    LimitExceededError(LimitExceededError),
    MalformedPolicyDocumentError(MalformedPolicyDocumentError),
    NotFoundError(NotFoundError),
    UnsupportedOperationError(UnsupportedOperationError),

    /// An unexpected error, eg. invalid JSON returned by the service
    Unhandled(Box<dyn ::std::error::Error>),
}
impl ::std::fmt::Display for PutKeyPolicyError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match self {
            PutKeyPolicyError::DependencyTimeoutError(_inner) => _inner.fmt(f),
            PutKeyPolicyError::InvalidArnError(_inner) => _inner.fmt(f),
            PutKeyPolicyError::KMSInternalError(_inner) => _inner.fmt(f),
            PutKeyPolicyError::KMSInvalidStateError(_inner) => _inner.fmt(f),
            PutKeyPolicyError::LimitExceededError(_inner) => _inner.fmt(f),
            PutKeyPolicyError::MalformedPolicyDocumentError(_inner) => _inner.fmt(f),
            PutKeyPolicyError::NotFoundError(_inner) => _inner.fmt(f),
            PutKeyPolicyError::UnsupportedOperationError(_inner) => _inner.fmt(f),
            PutKeyPolicyError::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl ::smithy_types::retry::ProvideErrorKind for PutKeyPolicyError {
    fn code(&self) -> Option<&str> {
        PutKeyPolicyError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<::smithy_types::retry::ErrorKind> {
        match self {
            PutKeyPolicyError::DependencyTimeoutError(_inner) => None,
            PutKeyPolicyError::InvalidArnError(_inner) => None,
            PutKeyPolicyError::KMSInternalError(_inner) => None,
            PutKeyPolicyError::KMSInvalidStateError(_inner) => None,
            PutKeyPolicyError::LimitExceededError(_inner) => None,
            PutKeyPolicyError::MalformedPolicyDocumentError(_inner) => None,
            PutKeyPolicyError::NotFoundError(_inner) => None,
            PutKeyPolicyError::UnsupportedOperationError(_inner) => None,
            PutKeyPolicyError::Unhandled(_inner) => {
                match _inner.downcast_ref::<::smithy_types::Error>() {
                    Some(_inner) => _inner.retryable_error_kind(),
                    None => None,
                }
            }
        }
    }
}
impl PutKeyPolicyError {
    pub fn unhandled<E: Into<Box<dyn ::std::error::Error>>>(err: E) -> Self {
        PutKeyPolicyError::Unhandled(err.into())
    }
    pub fn message(&self) -> Option<&str> {
        match self {
            PutKeyPolicyError::DependencyTimeoutError(_inner) => _inner.message(),
            PutKeyPolicyError::InvalidArnError(_inner) => _inner.message(),
            PutKeyPolicyError::KMSInternalError(_inner) => _inner.message(),
            PutKeyPolicyError::KMSInvalidStateError(_inner) => _inner.message(),
            PutKeyPolicyError::LimitExceededError(_inner) => _inner.message(),
            PutKeyPolicyError::MalformedPolicyDocumentError(_inner) => _inner.message(),
            PutKeyPolicyError::NotFoundError(_inner) => _inner.message(),
            PutKeyPolicyError::UnsupportedOperationError(_inner) => _inner.message(),
            PutKeyPolicyError::Unhandled(_inner) => {
                match _inner.downcast_ref::<::smithy_types::Error>() {
                    Some(_inner) => _inner.message(),
                    None => None,
                }
            }
        }
    }
    pub fn code(&self) -> Option<&str> {
        match self {
            PutKeyPolicyError::DependencyTimeoutError(_inner) => Some(_inner.code()),
            PutKeyPolicyError::InvalidArnError(_inner) => Some(_inner.code()),
            PutKeyPolicyError::KMSInternalError(_inner) => Some(_inner.code()),
            PutKeyPolicyError::KMSInvalidStateError(_inner) => Some(_inner.code()),
            PutKeyPolicyError::LimitExceededError(_inner) => Some(_inner.code()),
            PutKeyPolicyError::MalformedPolicyDocumentError(_inner) => Some(_inner.code()),
            PutKeyPolicyError::NotFoundError(_inner) => Some(_inner.code()),
            PutKeyPolicyError::UnsupportedOperationError(_inner) => Some(_inner.code()),
            PutKeyPolicyError::Unhandled(_inner) => {
                match _inner.downcast_ref::<::smithy_types::Error>() {
                    Some(_inner) => _inner.code(),
                    None => None,
                }
            }
        }
    }
}
impl ::std::error::Error for PutKeyPolicyError {
    fn source(&self) -> Option<&(dyn ::std::error::Error + 'static)> {
        match self {
            PutKeyPolicyError::DependencyTimeoutError(_inner) => Some(_inner),
            PutKeyPolicyError::InvalidArnError(_inner) => Some(_inner),
            PutKeyPolicyError::KMSInternalError(_inner) => Some(_inner),
            PutKeyPolicyError::KMSInvalidStateError(_inner) => Some(_inner),
            PutKeyPolicyError::LimitExceededError(_inner) => Some(_inner),
            PutKeyPolicyError::MalformedPolicyDocumentError(_inner) => Some(_inner),
            PutKeyPolicyError::NotFoundError(_inner) => Some(_inner),
            PutKeyPolicyError::UnsupportedOperationError(_inner) => Some(_inner),
            PutKeyPolicyError::Unhandled(_inner) => {
                match _inner.downcast_ref::<::smithy_types::Error>() {
                    Some(_inner) => Some(_inner),
                    None => Some(_inner.as_ref()),
                }
            }
        }
    }
}

#[non_exhaustive]
#[derive(::std::fmt::Debug)]
pub enum ReEncryptError {
    DependencyTimeoutError(DependencyTimeoutError),
    DisabledError(DisabledError),
    IncorrectKeyError(IncorrectKeyError),
    InvalidCiphertextError(InvalidCiphertextError),
    InvalidGrantTokenError(InvalidGrantTokenError),
    InvalidKeyUsageError(InvalidKeyUsageError),
    KeyUnavailableError(KeyUnavailableError),
    KMSInternalError(KMSInternalError),
    KMSInvalidStateError(KMSInvalidStateError),
    NotFoundError(NotFoundError),

    /// An unexpected error, eg. invalid JSON returned by the service
    Unhandled(Box<dyn ::std::error::Error>),
}
impl ::std::fmt::Display for ReEncryptError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match self {
            ReEncryptError::DependencyTimeoutError(_inner) => _inner.fmt(f),
            ReEncryptError::DisabledError(_inner) => _inner.fmt(f),
            ReEncryptError::IncorrectKeyError(_inner) => _inner.fmt(f),
            ReEncryptError::InvalidCiphertextError(_inner) => _inner.fmt(f),
            ReEncryptError::InvalidGrantTokenError(_inner) => _inner.fmt(f),
            ReEncryptError::InvalidKeyUsageError(_inner) => _inner.fmt(f),
            ReEncryptError::KeyUnavailableError(_inner) => _inner.fmt(f),
            ReEncryptError::KMSInternalError(_inner) => _inner.fmt(f),
            ReEncryptError::KMSInvalidStateError(_inner) => _inner.fmt(f),
            ReEncryptError::NotFoundError(_inner) => _inner.fmt(f),
            ReEncryptError::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl ::smithy_types::retry::ProvideErrorKind for ReEncryptError {
    fn code(&self) -> Option<&str> {
        ReEncryptError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<::smithy_types::retry::ErrorKind> {
        match self {
            ReEncryptError::DependencyTimeoutError(_inner) => None,
            ReEncryptError::DisabledError(_inner) => None,
            ReEncryptError::IncorrectKeyError(_inner) => None,
            ReEncryptError::InvalidCiphertextError(_inner) => None,
            ReEncryptError::InvalidGrantTokenError(_inner) => None,
            ReEncryptError::InvalidKeyUsageError(_inner) => None,
            ReEncryptError::KeyUnavailableError(_inner) => None,
            ReEncryptError::KMSInternalError(_inner) => None,
            ReEncryptError::KMSInvalidStateError(_inner) => None,
            ReEncryptError::NotFoundError(_inner) => None,
            ReEncryptError::Unhandled(_inner) => {
                match _inner.downcast_ref::<::smithy_types::Error>() {
                    Some(_inner) => _inner.retryable_error_kind(),
                    None => None,
                }
            }
        }
    }
}
impl ReEncryptError {
    pub fn unhandled<E: Into<Box<dyn ::std::error::Error>>>(err: E) -> Self {
        ReEncryptError::Unhandled(err.into())
    }
    pub fn message(&self) -> Option<&str> {
        match self {
            ReEncryptError::DependencyTimeoutError(_inner) => _inner.message(),
            ReEncryptError::DisabledError(_inner) => _inner.message(),
            ReEncryptError::IncorrectKeyError(_inner) => _inner.message(),
            ReEncryptError::InvalidCiphertextError(_inner) => _inner.message(),
            ReEncryptError::InvalidGrantTokenError(_inner) => _inner.message(),
            ReEncryptError::InvalidKeyUsageError(_inner) => _inner.message(),
            ReEncryptError::KeyUnavailableError(_inner) => _inner.message(),
            ReEncryptError::KMSInternalError(_inner) => _inner.message(),
            ReEncryptError::KMSInvalidStateError(_inner) => _inner.message(),
            ReEncryptError::NotFoundError(_inner) => _inner.message(),
            ReEncryptError::Unhandled(_inner) => {
                match _inner.downcast_ref::<::smithy_types::Error>() {
                    Some(_inner) => _inner.message(),
                    None => None,
                }
            }
        }
    }
    pub fn code(&self) -> Option<&str> {
        match self {
            ReEncryptError::DependencyTimeoutError(_inner) => Some(_inner.code()),
            ReEncryptError::DisabledError(_inner) => Some(_inner.code()),
            ReEncryptError::IncorrectKeyError(_inner) => Some(_inner.code()),
            ReEncryptError::InvalidCiphertextError(_inner) => Some(_inner.code()),
            ReEncryptError::InvalidGrantTokenError(_inner) => Some(_inner.code()),
            ReEncryptError::InvalidKeyUsageError(_inner) => Some(_inner.code()),
            ReEncryptError::KeyUnavailableError(_inner) => Some(_inner.code()),
            ReEncryptError::KMSInternalError(_inner) => Some(_inner.code()),
            ReEncryptError::KMSInvalidStateError(_inner) => Some(_inner.code()),
            ReEncryptError::NotFoundError(_inner) => Some(_inner.code()),
            ReEncryptError::Unhandled(_inner) => {
                match _inner.downcast_ref::<::smithy_types::Error>() {
                    Some(_inner) => _inner.code(),
                    None => None,
                }
            }
        }
    }
}
impl ::std::error::Error for ReEncryptError {
    fn source(&self) -> Option<&(dyn ::std::error::Error + 'static)> {
        match self {
            ReEncryptError::DependencyTimeoutError(_inner) => Some(_inner),
            ReEncryptError::DisabledError(_inner) => Some(_inner),
            ReEncryptError::IncorrectKeyError(_inner) => Some(_inner),
            ReEncryptError::InvalidCiphertextError(_inner) => Some(_inner),
            ReEncryptError::InvalidGrantTokenError(_inner) => Some(_inner),
            ReEncryptError::InvalidKeyUsageError(_inner) => Some(_inner),
            ReEncryptError::KeyUnavailableError(_inner) => Some(_inner),
            ReEncryptError::KMSInternalError(_inner) => Some(_inner),
            ReEncryptError::KMSInvalidStateError(_inner) => Some(_inner),
            ReEncryptError::NotFoundError(_inner) => Some(_inner),
            ReEncryptError::Unhandled(_inner) => {
                match _inner.downcast_ref::<::smithy_types::Error>() {
                    Some(_inner) => Some(_inner),
                    None => Some(_inner.as_ref()),
                }
            }
        }
    }
}

#[non_exhaustive]
#[derive(::std::fmt::Debug)]
pub enum RetireGrantError {
    DependencyTimeoutError(DependencyTimeoutError),
    InvalidArnError(InvalidArnError),
    InvalidGrantIdError(InvalidGrantIdError),
    InvalidGrantTokenError(InvalidGrantTokenError),
    KMSInternalError(KMSInternalError),
    KMSInvalidStateError(KMSInvalidStateError),
    NotFoundError(NotFoundError),

    /// An unexpected error, eg. invalid JSON returned by the service
    Unhandled(Box<dyn ::std::error::Error>),
}
impl ::std::fmt::Display for RetireGrantError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match self {
            RetireGrantError::DependencyTimeoutError(_inner) => _inner.fmt(f),
            RetireGrantError::InvalidArnError(_inner) => _inner.fmt(f),
            RetireGrantError::InvalidGrantIdError(_inner) => _inner.fmt(f),
            RetireGrantError::InvalidGrantTokenError(_inner) => _inner.fmt(f),
            RetireGrantError::KMSInternalError(_inner) => _inner.fmt(f),
            RetireGrantError::KMSInvalidStateError(_inner) => _inner.fmt(f),
            RetireGrantError::NotFoundError(_inner) => _inner.fmt(f),
            RetireGrantError::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl ::smithy_types::retry::ProvideErrorKind for RetireGrantError {
    fn code(&self) -> Option<&str> {
        RetireGrantError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<::smithy_types::retry::ErrorKind> {
        match self {
            RetireGrantError::DependencyTimeoutError(_inner) => None,
            RetireGrantError::InvalidArnError(_inner) => None,
            RetireGrantError::InvalidGrantIdError(_inner) => None,
            RetireGrantError::InvalidGrantTokenError(_inner) => None,
            RetireGrantError::KMSInternalError(_inner) => None,
            RetireGrantError::KMSInvalidStateError(_inner) => None,
            RetireGrantError::NotFoundError(_inner) => None,
            RetireGrantError::Unhandled(_inner) => {
                match _inner.downcast_ref::<::smithy_types::Error>() {
                    Some(_inner) => _inner.retryable_error_kind(),
                    None => None,
                }
            }
        }
    }
}
impl RetireGrantError {
    pub fn unhandled<E: Into<Box<dyn ::std::error::Error>>>(err: E) -> Self {
        RetireGrantError::Unhandled(err.into())
    }
    pub fn message(&self) -> Option<&str> {
        match self {
            RetireGrantError::DependencyTimeoutError(_inner) => _inner.message(),
            RetireGrantError::InvalidArnError(_inner) => _inner.message(),
            RetireGrantError::InvalidGrantIdError(_inner) => _inner.message(),
            RetireGrantError::InvalidGrantTokenError(_inner) => _inner.message(),
            RetireGrantError::KMSInternalError(_inner) => _inner.message(),
            RetireGrantError::KMSInvalidStateError(_inner) => _inner.message(),
            RetireGrantError::NotFoundError(_inner) => _inner.message(),
            RetireGrantError::Unhandled(_inner) => {
                match _inner.downcast_ref::<::smithy_types::Error>() {
                    Some(_inner) => _inner.message(),
                    None => None,
                }
            }
        }
    }
    pub fn code(&self) -> Option<&str> {
        match self {
            RetireGrantError::DependencyTimeoutError(_inner) => Some(_inner.code()),
            RetireGrantError::InvalidArnError(_inner) => Some(_inner.code()),
            RetireGrantError::InvalidGrantIdError(_inner) => Some(_inner.code()),
            RetireGrantError::InvalidGrantTokenError(_inner) => Some(_inner.code()),
            RetireGrantError::KMSInternalError(_inner) => Some(_inner.code()),
            RetireGrantError::KMSInvalidStateError(_inner) => Some(_inner.code()),
            RetireGrantError::NotFoundError(_inner) => Some(_inner.code()),
            RetireGrantError::Unhandled(_inner) => {
                match _inner.downcast_ref::<::smithy_types::Error>() {
                    Some(_inner) => _inner.code(),
                    None => None,
                }
            }
        }
    }
}
impl ::std::error::Error for RetireGrantError {
    fn source(&self) -> Option<&(dyn ::std::error::Error + 'static)> {
        match self {
            RetireGrantError::DependencyTimeoutError(_inner) => Some(_inner),
            RetireGrantError::InvalidArnError(_inner) => Some(_inner),
            RetireGrantError::InvalidGrantIdError(_inner) => Some(_inner),
            RetireGrantError::InvalidGrantTokenError(_inner) => Some(_inner),
            RetireGrantError::KMSInternalError(_inner) => Some(_inner),
            RetireGrantError::KMSInvalidStateError(_inner) => Some(_inner),
            RetireGrantError::NotFoundError(_inner) => Some(_inner),
            RetireGrantError::Unhandled(_inner) => {
                match _inner.downcast_ref::<::smithy_types::Error>() {
                    Some(_inner) => Some(_inner),
                    None => Some(_inner.as_ref()),
                }
            }
        }
    }
}

#[non_exhaustive]
#[derive(::std::fmt::Debug)]
pub enum RevokeGrantError {
    DependencyTimeoutError(DependencyTimeoutError),
    InvalidArnError(InvalidArnError),
    InvalidGrantIdError(InvalidGrantIdError),
    KMSInternalError(KMSInternalError),
    KMSInvalidStateError(KMSInvalidStateError),
    NotFoundError(NotFoundError),

    /// An unexpected error, eg. invalid JSON returned by the service
    Unhandled(Box<dyn ::std::error::Error>),
}
impl ::std::fmt::Display for RevokeGrantError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match self {
            RevokeGrantError::DependencyTimeoutError(_inner) => _inner.fmt(f),
            RevokeGrantError::InvalidArnError(_inner) => _inner.fmt(f),
            RevokeGrantError::InvalidGrantIdError(_inner) => _inner.fmt(f),
            RevokeGrantError::KMSInternalError(_inner) => _inner.fmt(f),
            RevokeGrantError::KMSInvalidStateError(_inner) => _inner.fmt(f),
            RevokeGrantError::NotFoundError(_inner) => _inner.fmt(f),
            RevokeGrantError::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl ::smithy_types::retry::ProvideErrorKind for RevokeGrantError {
    fn code(&self) -> Option<&str> {
        RevokeGrantError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<::smithy_types::retry::ErrorKind> {
        match self {
            RevokeGrantError::DependencyTimeoutError(_inner) => None,
            RevokeGrantError::InvalidArnError(_inner) => None,
            RevokeGrantError::InvalidGrantIdError(_inner) => None,
            RevokeGrantError::KMSInternalError(_inner) => None,
            RevokeGrantError::KMSInvalidStateError(_inner) => None,
            RevokeGrantError::NotFoundError(_inner) => None,
            RevokeGrantError::Unhandled(_inner) => {
                match _inner.downcast_ref::<::smithy_types::Error>() {
                    Some(_inner) => _inner.retryable_error_kind(),
                    None => None,
                }
            }
        }
    }
}
impl RevokeGrantError {
    pub fn unhandled<E: Into<Box<dyn ::std::error::Error>>>(err: E) -> Self {
        RevokeGrantError::Unhandled(err.into())
    }
    pub fn message(&self) -> Option<&str> {
        match self {
            RevokeGrantError::DependencyTimeoutError(_inner) => _inner.message(),
            RevokeGrantError::InvalidArnError(_inner) => _inner.message(),
            RevokeGrantError::InvalidGrantIdError(_inner) => _inner.message(),
            RevokeGrantError::KMSInternalError(_inner) => _inner.message(),
            RevokeGrantError::KMSInvalidStateError(_inner) => _inner.message(),
            RevokeGrantError::NotFoundError(_inner) => _inner.message(),
            RevokeGrantError::Unhandled(_inner) => {
                match _inner.downcast_ref::<::smithy_types::Error>() {
                    Some(_inner) => _inner.message(),
                    None => None,
                }
            }
        }
    }
    pub fn code(&self) -> Option<&str> {
        match self {
            RevokeGrantError::DependencyTimeoutError(_inner) => Some(_inner.code()),
            RevokeGrantError::InvalidArnError(_inner) => Some(_inner.code()),
            RevokeGrantError::InvalidGrantIdError(_inner) => Some(_inner.code()),
            RevokeGrantError::KMSInternalError(_inner) => Some(_inner.code()),
            RevokeGrantError::KMSInvalidStateError(_inner) => Some(_inner.code()),
            RevokeGrantError::NotFoundError(_inner) => Some(_inner.code()),
            RevokeGrantError::Unhandled(_inner) => {
                match _inner.downcast_ref::<::smithy_types::Error>() {
                    Some(_inner) => _inner.code(),
                    None => None,
                }
            }
        }
    }
}
impl ::std::error::Error for RevokeGrantError {
    fn source(&self) -> Option<&(dyn ::std::error::Error + 'static)> {
        match self {
            RevokeGrantError::DependencyTimeoutError(_inner) => Some(_inner),
            RevokeGrantError::InvalidArnError(_inner) => Some(_inner),
            RevokeGrantError::InvalidGrantIdError(_inner) => Some(_inner),
            RevokeGrantError::KMSInternalError(_inner) => Some(_inner),
            RevokeGrantError::KMSInvalidStateError(_inner) => Some(_inner),
            RevokeGrantError::NotFoundError(_inner) => Some(_inner),
            RevokeGrantError::Unhandled(_inner) => {
                match _inner.downcast_ref::<::smithy_types::Error>() {
                    Some(_inner) => Some(_inner),
                    None => Some(_inner.as_ref()),
                }
            }
        }
    }
}

#[non_exhaustive]
#[derive(::std::fmt::Debug)]
pub enum ScheduleKeyDeletionError {
    DependencyTimeoutError(DependencyTimeoutError),
    InvalidArnError(InvalidArnError),
    KMSInternalError(KMSInternalError),
    KMSInvalidStateError(KMSInvalidStateError),
    NotFoundError(NotFoundError),

    /// An unexpected error, eg. invalid JSON returned by the service
    Unhandled(Box<dyn ::std::error::Error>),
}
impl ::std::fmt::Display for ScheduleKeyDeletionError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match self {
            ScheduleKeyDeletionError::DependencyTimeoutError(_inner) => _inner.fmt(f),
            ScheduleKeyDeletionError::InvalidArnError(_inner) => _inner.fmt(f),
            ScheduleKeyDeletionError::KMSInternalError(_inner) => _inner.fmt(f),
            ScheduleKeyDeletionError::KMSInvalidStateError(_inner) => _inner.fmt(f),
            ScheduleKeyDeletionError::NotFoundError(_inner) => _inner.fmt(f),
            ScheduleKeyDeletionError::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl ::smithy_types::retry::ProvideErrorKind for ScheduleKeyDeletionError {
    fn code(&self) -> Option<&str> {
        ScheduleKeyDeletionError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<::smithy_types::retry::ErrorKind> {
        match self {
            ScheduleKeyDeletionError::DependencyTimeoutError(_inner) => None,
            ScheduleKeyDeletionError::InvalidArnError(_inner) => None,
            ScheduleKeyDeletionError::KMSInternalError(_inner) => None,
            ScheduleKeyDeletionError::KMSInvalidStateError(_inner) => None,
            ScheduleKeyDeletionError::NotFoundError(_inner) => None,
            ScheduleKeyDeletionError::Unhandled(_inner) => {
                match _inner.downcast_ref::<::smithy_types::Error>() {
                    Some(_inner) => _inner.retryable_error_kind(),
                    None => None,
                }
            }
        }
    }
}
impl ScheduleKeyDeletionError {
    pub fn unhandled<E: Into<Box<dyn ::std::error::Error>>>(err: E) -> Self {
        ScheduleKeyDeletionError::Unhandled(err.into())
    }
    pub fn message(&self) -> Option<&str> {
        match self {
            ScheduleKeyDeletionError::DependencyTimeoutError(_inner) => _inner.message(),
            ScheduleKeyDeletionError::InvalidArnError(_inner) => _inner.message(),
            ScheduleKeyDeletionError::KMSInternalError(_inner) => _inner.message(),
            ScheduleKeyDeletionError::KMSInvalidStateError(_inner) => _inner.message(),
            ScheduleKeyDeletionError::NotFoundError(_inner) => _inner.message(),
            ScheduleKeyDeletionError::Unhandled(_inner) => {
                match _inner.downcast_ref::<::smithy_types::Error>() {
                    Some(_inner) => _inner.message(),
                    None => None,
                }
            }
        }
    }
    pub fn code(&self) -> Option<&str> {
        match self {
            ScheduleKeyDeletionError::DependencyTimeoutError(_inner) => Some(_inner.code()),
            ScheduleKeyDeletionError::InvalidArnError(_inner) => Some(_inner.code()),
            ScheduleKeyDeletionError::KMSInternalError(_inner) => Some(_inner.code()),
            ScheduleKeyDeletionError::KMSInvalidStateError(_inner) => Some(_inner.code()),
            ScheduleKeyDeletionError::NotFoundError(_inner) => Some(_inner.code()),
            ScheduleKeyDeletionError::Unhandled(_inner) => {
                match _inner.downcast_ref::<::smithy_types::Error>() {
                    Some(_inner) => _inner.code(),
                    None => None,
                }
            }
        }
    }
}
impl ::std::error::Error for ScheduleKeyDeletionError {
    fn source(&self) -> Option<&(dyn ::std::error::Error + 'static)> {
        match self {
            ScheduleKeyDeletionError::DependencyTimeoutError(_inner) => Some(_inner),
            ScheduleKeyDeletionError::InvalidArnError(_inner) => Some(_inner),
            ScheduleKeyDeletionError::KMSInternalError(_inner) => Some(_inner),
            ScheduleKeyDeletionError::KMSInvalidStateError(_inner) => Some(_inner),
            ScheduleKeyDeletionError::NotFoundError(_inner) => Some(_inner),
            ScheduleKeyDeletionError::Unhandled(_inner) => {
                match _inner.downcast_ref::<::smithy_types::Error>() {
                    Some(_inner) => Some(_inner),
                    None => Some(_inner.as_ref()),
                }
            }
        }
    }
}

#[non_exhaustive]
#[derive(::std::fmt::Debug)]
pub enum SignError {
    DependencyTimeoutError(DependencyTimeoutError),
    DisabledError(DisabledError),
    InvalidGrantTokenError(InvalidGrantTokenError),
    InvalidKeyUsageError(InvalidKeyUsageError),
    KeyUnavailableError(KeyUnavailableError),
    KMSInternalError(KMSInternalError),
    KMSInvalidStateError(KMSInvalidStateError),
    NotFoundError(NotFoundError),

    /// An unexpected error, eg. invalid JSON returned by the service
    Unhandled(Box<dyn ::std::error::Error>),
}
impl ::std::fmt::Display for SignError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match self {
            SignError::DependencyTimeoutError(_inner) => _inner.fmt(f),
            SignError::DisabledError(_inner) => _inner.fmt(f),
            SignError::InvalidGrantTokenError(_inner) => _inner.fmt(f),
            SignError::InvalidKeyUsageError(_inner) => _inner.fmt(f),
            SignError::KeyUnavailableError(_inner) => _inner.fmt(f),
            SignError::KMSInternalError(_inner) => _inner.fmt(f),
            SignError::KMSInvalidStateError(_inner) => _inner.fmt(f),
            SignError::NotFoundError(_inner) => _inner.fmt(f),
            SignError::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl ::smithy_types::retry::ProvideErrorKind for SignError {
    fn code(&self) -> Option<&str> {
        SignError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<::smithy_types::retry::ErrorKind> {
        match self {
            SignError::DependencyTimeoutError(_inner) => None,
            SignError::DisabledError(_inner) => None,
            SignError::InvalidGrantTokenError(_inner) => None,
            SignError::InvalidKeyUsageError(_inner) => None,
            SignError::KeyUnavailableError(_inner) => None,
            SignError::KMSInternalError(_inner) => None,
            SignError::KMSInvalidStateError(_inner) => None,
            SignError::NotFoundError(_inner) => None,
            SignError::Unhandled(_inner) => match _inner.downcast_ref::<::smithy_types::Error>() {
                Some(_inner) => _inner.retryable_error_kind(),
                None => None,
            },
        }
    }
}
impl SignError {
    pub fn unhandled<E: Into<Box<dyn ::std::error::Error>>>(err: E) -> Self {
        SignError::Unhandled(err.into())
    }
    pub fn message(&self) -> Option<&str> {
        match self {
            SignError::DependencyTimeoutError(_inner) => _inner.message(),
            SignError::DisabledError(_inner) => _inner.message(),
            SignError::InvalidGrantTokenError(_inner) => _inner.message(),
            SignError::InvalidKeyUsageError(_inner) => _inner.message(),
            SignError::KeyUnavailableError(_inner) => _inner.message(),
            SignError::KMSInternalError(_inner) => _inner.message(),
            SignError::KMSInvalidStateError(_inner) => _inner.message(),
            SignError::NotFoundError(_inner) => _inner.message(),
            SignError::Unhandled(_inner) => match _inner.downcast_ref::<::smithy_types::Error>() {
                Some(_inner) => _inner.message(),
                None => None,
            },
        }
    }
    pub fn code(&self) -> Option<&str> {
        match self {
            SignError::DependencyTimeoutError(_inner) => Some(_inner.code()),
            SignError::DisabledError(_inner) => Some(_inner.code()),
            SignError::InvalidGrantTokenError(_inner) => Some(_inner.code()),
            SignError::InvalidKeyUsageError(_inner) => Some(_inner.code()),
            SignError::KeyUnavailableError(_inner) => Some(_inner.code()),
            SignError::KMSInternalError(_inner) => Some(_inner.code()),
            SignError::KMSInvalidStateError(_inner) => Some(_inner.code()),
            SignError::NotFoundError(_inner) => Some(_inner.code()),
            SignError::Unhandled(_inner) => match _inner.downcast_ref::<::smithy_types::Error>() {
                Some(_inner) => _inner.code(),
                None => None,
            },
        }
    }
}
impl ::std::error::Error for SignError {
    fn source(&self) -> Option<&(dyn ::std::error::Error + 'static)> {
        match self {
            SignError::DependencyTimeoutError(_inner) => Some(_inner),
            SignError::DisabledError(_inner) => Some(_inner),
            SignError::InvalidGrantTokenError(_inner) => Some(_inner),
            SignError::InvalidKeyUsageError(_inner) => Some(_inner),
            SignError::KeyUnavailableError(_inner) => Some(_inner),
            SignError::KMSInternalError(_inner) => Some(_inner),
            SignError::KMSInvalidStateError(_inner) => Some(_inner),
            SignError::NotFoundError(_inner) => Some(_inner),
            SignError::Unhandled(_inner) => match _inner.downcast_ref::<::smithy_types::Error>() {
                Some(_inner) => Some(_inner),
                None => Some(_inner.as_ref()),
            },
        }
    }
}

#[non_exhaustive]
#[derive(::std::fmt::Debug)]
pub enum TagResourceError {
    InvalidArnError(InvalidArnError),
    KMSInternalError(KMSInternalError),
    KMSInvalidStateError(KMSInvalidStateError),
    LimitExceededError(LimitExceededError),
    NotFoundError(NotFoundError),
    TagError(TagError),

    /// An unexpected error, eg. invalid JSON returned by the service
    Unhandled(Box<dyn ::std::error::Error>),
}
impl ::std::fmt::Display for TagResourceError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match self {
            TagResourceError::InvalidArnError(_inner) => _inner.fmt(f),
            TagResourceError::KMSInternalError(_inner) => _inner.fmt(f),
            TagResourceError::KMSInvalidStateError(_inner) => _inner.fmt(f),
            TagResourceError::LimitExceededError(_inner) => _inner.fmt(f),
            TagResourceError::NotFoundError(_inner) => _inner.fmt(f),
            TagResourceError::TagError(_inner) => _inner.fmt(f),
            TagResourceError::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl ::smithy_types::retry::ProvideErrorKind for TagResourceError {
    fn code(&self) -> Option<&str> {
        TagResourceError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<::smithy_types::retry::ErrorKind> {
        match self {
            TagResourceError::InvalidArnError(_inner) => None,
            TagResourceError::KMSInternalError(_inner) => None,
            TagResourceError::KMSInvalidStateError(_inner) => None,
            TagResourceError::LimitExceededError(_inner) => None,
            TagResourceError::NotFoundError(_inner) => None,
            TagResourceError::TagError(_inner) => None,
            TagResourceError::Unhandled(_inner) => {
                match _inner.downcast_ref::<::smithy_types::Error>() {
                    Some(_inner) => _inner.retryable_error_kind(),
                    None => None,
                }
            }
        }
    }
}
impl TagResourceError {
    pub fn unhandled<E: Into<Box<dyn ::std::error::Error>>>(err: E) -> Self {
        TagResourceError::Unhandled(err.into())
    }
    pub fn message(&self) -> Option<&str> {
        match self {
            TagResourceError::InvalidArnError(_inner) => _inner.message(),
            TagResourceError::KMSInternalError(_inner) => _inner.message(),
            TagResourceError::KMSInvalidStateError(_inner) => _inner.message(),
            TagResourceError::LimitExceededError(_inner) => _inner.message(),
            TagResourceError::NotFoundError(_inner) => _inner.message(),
            TagResourceError::TagError(_inner) => _inner.message(),
            TagResourceError::Unhandled(_inner) => {
                match _inner.downcast_ref::<::smithy_types::Error>() {
                    Some(_inner) => _inner.message(),
                    None => None,
                }
            }
        }
    }
    pub fn code(&self) -> Option<&str> {
        match self {
            TagResourceError::InvalidArnError(_inner) => Some(_inner.code()),
            TagResourceError::KMSInternalError(_inner) => Some(_inner.code()),
            TagResourceError::KMSInvalidStateError(_inner) => Some(_inner.code()),
            TagResourceError::LimitExceededError(_inner) => Some(_inner.code()),
            TagResourceError::NotFoundError(_inner) => Some(_inner.code()),
            TagResourceError::TagError(_inner) => Some(_inner.code()),
            TagResourceError::Unhandled(_inner) => {
                match _inner.downcast_ref::<::smithy_types::Error>() {
                    Some(_inner) => _inner.code(),
                    None => None,
                }
            }
        }
    }
}
impl ::std::error::Error for TagResourceError {
    fn source(&self) -> Option<&(dyn ::std::error::Error + 'static)> {
        match self {
            TagResourceError::InvalidArnError(_inner) => Some(_inner),
            TagResourceError::KMSInternalError(_inner) => Some(_inner),
            TagResourceError::KMSInvalidStateError(_inner) => Some(_inner),
            TagResourceError::LimitExceededError(_inner) => Some(_inner),
            TagResourceError::NotFoundError(_inner) => Some(_inner),
            TagResourceError::TagError(_inner) => Some(_inner),
            TagResourceError::Unhandled(_inner) => {
                match _inner.downcast_ref::<::smithy_types::Error>() {
                    Some(_inner) => Some(_inner),
                    None => Some(_inner.as_ref()),
                }
            }
        }
    }
}

#[non_exhaustive]
#[derive(::std::fmt::Debug)]
pub enum UntagResourceError {
    InvalidArnError(InvalidArnError),
    KMSInternalError(KMSInternalError),
    KMSInvalidStateError(KMSInvalidStateError),
    NotFoundError(NotFoundError),
    TagError(TagError),

    /// An unexpected error, eg. invalid JSON returned by the service
    Unhandled(Box<dyn ::std::error::Error>),
}
impl ::std::fmt::Display for UntagResourceError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match self {
            UntagResourceError::InvalidArnError(_inner) => _inner.fmt(f),
            UntagResourceError::KMSInternalError(_inner) => _inner.fmt(f),
            UntagResourceError::KMSInvalidStateError(_inner) => _inner.fmt(f),
            UntagResourceError::NotFoundError(_inner) => _inner.fmt(f),
            UntagResourceError::TagError(_inner) => _inner.fmt(f),
            UntagResourceError::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl ::smithy_types::retry::ProvideErrorKind for UntagResourceError {
    fn code(&self) -> Option<&str> {
        UntagResourceError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<::smithy_types::retry::ErrorKind> {
        match self {
            UntagResourceError::InvalidArnError(_inner) => None,
            UntagResourceError::KMSInternalError(_inner) => None,
            UntagResourceError::KMSInvalidStateError(_inner) => None,
            UntagResourceError::NotFoundError(_inner) => None,
            UntagResourceError::TagError(_inner) => None,
            UntagResourceError::Unhandled(_inner) => {
                match _inner.downcast_ref::<::smithy_types::Error>() {
                    Some(_inner) => _inner.retryable_error_kind(),
                    None => None,
                }
            }
        }
    }
}
impl UntagResourceError {
    pub fn unhandled<E: Into<Box<dyn ::std::error::Error>>>(err: E) -> Self {
        UntagResourceError::Unhandled(err.into())
    }
    pub fn message(&self) -> Option<&str> {
        match self {
            UntagResourceError::InvalidArnError(_inner) => _inner.message(),
            UntagResourceError::KMSInternalError(_inner) => _inner.message(),
            UntagResourceError::KMSInvalidStateError(_inner) => _inner.message(),
            UntagResourceError::NotFoundError(_inner) => _inner.message(),
            UntagResourceError::TagError(_inner) => _inner.message(),
            UntagResourceError::Unhandled(_inner) => {
                match _inner.downcast_ref::<::smithy_types::Error>() {
                    Some(_inner) => _inner.message(),
                    None => None,
                }
            }
        }
    }
    pub fn code(&self) -> Option<&str> {
        match self {
            UntagResourceError::InvalidArnError(_inner) => Some(_inner.code()),
            UntagResourceError::KMSInternalError(_inner) => Some(_inner.code()),
            UntagResourceError::KMSInvalidStateError(_inner) => Some(_inner.code()),
            UntagResourceError::NotFoundError(_inner) => Some(_inner.code()),
            UntagResourceError::TagError(_inner) => Some(_inner.code()),
            UntagResourceError::Unhandled(_inner) => {
                match _inner.downcast_ref::<::smithy_types::Error>() {
                    Some(_inner) => _inner.code(),
                    None => None,
                }
            }
        }
    }
}
impl ::std::error::Error for UntagResourceError {
    fn source(&self) -> Option<&(dyn ::std::error::Error + 'static)> {
        match self {
            UntagResourceError::InvalidArnError(_inner) => Some(_inner),
            UntagResourceError::KMSInternalError(_inner) => Some(_inner),
            UntagResourceError::KMSInvalidStateError(_inner) => Some(_inner),
            UntagResourceError::NotFoundError(_inner) => Some(_inner),
            UntagResourceError::TagError(_inner) => Some(_inner),
            UntagResourceError::Unhandled(_inner) => {
                match _inner.downcast_ref::<::smithy_types::Error>() {
                    Some(_inner) => Some(_inner),
                    None => Some(_inner.as_ref()),
                }
            }
        }
    }
}

#[non_exhaustive]
#[derive(::std::fmt::Debug)]
pub enum UpdateAliasError {
    DependencyTimeoutError(DependencyTimeoutError),
    KMSInternalError(KMSInternalError),
    KMSInvalidStateError(KMSInvalidStateError),
    LimitExceededError(LimitExceededError),
    NotFoundError(NotFoundError),

    /// An unexpected error, eg. invalid JSON returned by the service
    Unhandled(Box<dyn ::std::error::Error>),
}
impl ::std::fmt::Display for UpdateAliasError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match self {
            UpdateAliasError::DependencyTimeoutError(_inner) => _inner.fmt(f),
            UpdateAliasError::KMSInternalError(_inner) => _inner.fmt(f),
            UpdateAliasError::KMSInvalidStateError(_inner) => _inner.fmt(f),
            UpdateAliasError::LimitExceededError(_inner) => _inner.fmt(f),
            UpdateAliasError::NotFoundError(_inner) => _inner.fmt(f),
            UpdateAliasError::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl ::smithy_types::retry::ProvideErrorKind for UpdateAliasError {
    fn code(&self) -> Option<&str> {
        UpdateAliasError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<::smithy_types::retry::ErrorKind> {
        match self {
            UpdateAliasError::DependencyTimeoutError(_inner) => None,
            UpdateAliasError::KMSInternalError(_inner) => None,
            UpdateAliasError::KMSInvalidStateError(_inner) => None,
            UpdateAliasError::LimitExceededError(_inner) => None,
            UpdateAliasError::NotFoundError(_inner) => None,
            UpdateAliasError::Unhandled(_inner) => {
                match _inner.downcast_ref::<::smithy_types::Error>() {
                    Some(_inner) => _inner.retryable_error_kind(),
                    None => None,
                }
            }
        }
    }
}
impl UpdateAliasError {
    pub fn unhandled<E: Into<Box<dyn ::std::error::Error>>>(err: E) -> Self {
        UpdateAliasError::Unhandled(err.into())
    }
    pub fn message(&self) -> Option<&str> {
        match self {
            UpdateAliasError::DependencyTimeoutError(_inner) => _inner.message(),
            UpdateAliasError::KMSInternalError(_inner) => _inner.message(),
            UpdateAliasError::KMSInvalidStateError(_inner) => _inner.message(),
            UpdateAliasError::LimitExceededError(_inner) => _inner.message(),
            UpdateAliasError::NotFoundError(_inner) => _inner.message(),
            UpdateAliasError::Unhandled(_inner) => {
                match _inner.downcast_ref::<::smithy_types::Error>() {
                    Some(_inner) => _inner.message(),
                    None => None,
                }
            }
        }
    }
    pub fn code(&self) -> Option<&str> {
        match self {
            UpdateAliasError::DependencyTimeoutError(_inner) => Some(_inner.code()),
            UpdateAliasError::KMSInternalError(_inner) => Some(_inner.code()),
            UpdateAliasError::KMSInvalidStateError(_inner) => Some(_inner.code()),
            UpdateAliasError::LimitExceededError(_inner) => Some(_inner.code()),
            UpdateAliasError::NotFoundError(_inner) => Some(_inner.code()),
            UpdateAliasError::Unhandled(_inner) => {
                match _inner.downcast_ref::<::smithy_types::Error>() {
                    Some(_inner) => _inner.code(),
                    None => None,
                }
            }
        }
    }
}
impl ::std::error::Error for UpdateAliasError {
    fn source(&self) -> Option<&(dyn ::std::error::Error + 'static)> {
        match self {
            UpdateAliasError::DependencyTimeoutError(_inner) => Some(_inner),
            UpdateAliasError::KMSInternalError(_inner) => Some(_inner),
            UpdateAliasError::KMSInvalidStateError(_inner) => Some(_inner),
            UpdateAliasError::LimitExceededError(_inner) => Some(_inner),
            UpdateAliasError::NotFoundError(_inner) => Some(_inner),
            UpdateAliasError::Unhandled(_inner) => {
                match _inner.downcast_ref::<::smithy_types::Error>() {
                    Some(_inner) => Some(_inner),
                    None => Some(_inner.as_ref()),
                }
            }
        }
    }
}

#[non_exhaustive]
#[derive(::std::fmt::Debug)]
pub enum UpdateCustomKeyStoreError {
    CloudHsmClusterInvalidConfigurationError(CloudHsmClusterInvalidConfigurationError),
    CloudHsmClusterNotActiveError(CloudHsmClusterNotActiveError),
    CloudHsmClusterNotFoundError(CloudHsmClusterNotFoundError),
    CloudHsmClusterNotRelatedError(CloudHsmClusterNotRelatedError),
    CustomKeyStoreInvalidStateError(CustomKeyStoreInvalidStateError),
    CustomKeyStoreNameInUseError(CustomKeyStoreNameInUseError),
    CustomKeyStoreNotFoundError(CustomKeyStoreNotFoundError),
    KMSInternalError(KMSInternalError),

    /// An unexpected error, eg. invalid JSON returned by the service
    Unhandled(Box<dyn ::std::error::Error>),
}
impl ::std::fmt::Display for UpdateCustomKeyStoreError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match self {
            UpdateCustomKeyStoreError::CloudHsmClusterInvalidConfigurationError(_inner) => {
                _inner.fmt(f)
            }
            UpdateCustomKeyStoreError::CloudHsmClusterNotActiveError(_inner) => _inner.fmt(f),
            UpdateCustomKeyStoreError::CloudHsmClusterNotFoundError(_inner) => _inner.fmt(f),
            UpdateCustomKeyStoreError::CloudHsmClusterNotRelatedError(_inner) => _inner.fmt(f),
            UpdateCustomKeyStoreError::CustomKeyStoreInvalidStateError(_inner) => _inner.fmt(f),
            UpdateCustomKeyStoreError::CustomKeyStoreNameInUseError(_inner) => _inner.fmt(f),
            UpdateCustomKeyStoreError::CustomKeyStoreNotFoundError(_inner) => _inner.fmt(f),
            UpdateCustomKeyStoreError::KMSInternalError(_inner) => _inner.fmt(f),
            UpdateCustomKeyStoreError::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl ::smithy_types::retry::ProvideErrorKind for UpdateCustomKeyStoreError {
    fn code(&self) -> Option<&str> {
        UpdateCustomKeyStoreError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<::smithy_types::retry::ErrorKind> {
        match self {
            UpdateCustomKeyStoreError::CloudHsmClusterInvalidConfigurationError(_inner) => None,
            UpdateCustomKeyStoreError::CloudHsmClusterNotActiveError(_inner) => None,
            UpdateCustomKeyStoreError::CloudHsmClusterNotFoundError(_inner) => None,
            UpdateCustomKeyStoreError::CloudHsmClusterNotRelatedError(_inner) => None,
            UpdateCustomKeyStoreError::CustomKeyStoreInvalidStateError(_inner) => None,
            UpdateCustomKeyStoreError::CustomKeyStoreNameInUseError(_inner) => None,
            UpdateCustomKeyStoreError::CustomKeyStoreNotFoundError(_inner) => None,
            UpdateCustomKeyStoreError::KMSInternalError(_inner) => None,
            UpdateCustomKeyStoreError::Unhandled(_inner) => {
                match _inner.downcast_ref::<::smithy_types::Error>() {
                    Some(_inner) => _inner.retryable_error_kind(),
                    None => None,
                }
            }
        }
    }
}
impl UpdateCustomKeyStoreError {
    pub fn unhandled<E: Into<Box<dyn ::std::error::Error>>>(err: E) -> Self {
        UpdateCustomKeyStoreError::Unhandled(err.into())
    }
    pub fn message(&self) -> Option<&str> {
        match self {
            UpdateCustomKeyStoreError::CloudHsmClusterInvalidConfigurationError(_inner) => {
                _inner.message()
            }
            UpdateCustomKeyStoreError::CloudHsmClusterNotActiveError(_inner) => _inner.message(),
            UpdateCustomKeyStoreError::CloudHsmClusterNotFoundError(_inner) => _inner.message(),
            UpdateCustomKeyStoreError::CloudHsmClusterNotRelatedError(_inner) => _inner.message(),
            UpdateCustomKeyStoreError::CustomKeyStoreInvalidStateError(_inner) => _inner.message(),
            UpdateCustomKeyStoreError::CustomKeyStoreNameInUseError(_inner) => _inner.message(),
            UpdateCustomKeyStoreError::CustomKeyStoreNotFoundError(_inner) => _inner.message(),
            UpdateCustomKeyStoreError::KMSInternalError(_inner) => _inner.message(),
            UpdateCustomKeyStoreError::Unhandled(_inner) => {
                match _inner.downcast_ref::<::smithy_types::Error>() {
                    Some(_inner) => _inner.message(),
                    None => None,
                }
            }
        }
    }
    pub fn code(&self) -> Option<&str> {
        match self {
            UpdateCustomKeyStoreError::CloudHsmClusterInvalidConfigurationError(_inner) => {
                Some(_inner.code())
            }
            UpdateCustomKeyStoreError::CloudHsmClusterNotActiveError(_inner) => Some(_inner.code()),
            UpdateCustomKeyStoreError::CloudHsmClusterNotFoundError(_inner) => Some(_inner.code()),
            UpdateCustomKeyStoreError::CloudHsmClusterNotRelatedError(_inner) => {
                Some(_inner.code())
            }
            UpdateCustomKeyStoreError::CustomKeyStoreInvalidStateError(_inner) => {
                Some(_inner.code())
            }
            UpdateCustomKeyStoreError::CustomKeyStoreNameInUseError(_inner) => Some(_inner.code()),
            UpdateCustomKeyStoreError::CustomKeyStoreNotFoundError(_inner) => Some(_inner.code()),
            UpdateCustomKeyStoreError::KMSInternalError(_inner) => Some(_inner.code()),
            UpdateCustomKeyStoreError::Unhandled(_inner) => {
                match _inner.downcast_ref::<::smithy_types::Error>() {
                    Some(_inner) => _inner.code(),
                    None => None,
                }
            }
        }
    }
}
impl ::std::error::Error for UpdateCustomKeyStoreError {
    fn source(&self) -> Option<&(dyn ::std::error::Error + 'static)> {
        match self {
            UpdateCustomKeyStoreError::CloudHsmClusterInvalidConfigurationError(_inner) => {
                Some(_inner)
            }
            UpdateCustomKeyStoreError::CloudHsmClusterNotActiveError(_inner) => Some(_inner),
            UpdateCustomKeyStoreError::CloudHsmClusterNotFoundError(_inner) => Some(_inner),
            UpdateCustomKeyStoreError::CloudHsmClusterNotRelatedError(_inner) => Some(_inner),
            UpdateCustomKeyStoreError::CustomKeyStoreInvalidStateError(_inner) => Some(_inner),
            UpdateCustomKeyStoreError::CustomKeyStoreNameInUseError(_inner) => Some(_inner),
            UpdateCustomKeyStoreError::CustomKeyStoreNotFoundError(_inner) => Some(_inner),
            UpdateCustomKeyStoreError::KMSInternalError(_inner) => Some(_inner),
            UpdateCustomKeyStoreError::Unhandled(_inner) => {
                match _inner.downcast_ref::<::smithy_types::Error>() {
                    Some(_inner) => Some(_inner),
                    None => Some(_inner.as_ref()),
                }
            }
        }
    }
}

#[non_exhaustive]
#[derive(::std::fmt::Debug)]
pub enum UpdateKeyDescriptionError {
    DependencyTimeoutError(DependencyTimeoutError),
    InvalidArnError(InvalidArnError),
    KMSInternalError(KMSInternalError),
    KMSInvalidStateError(KMSInvalidStateError),
    NotFoundError(NotFoundError),

    /// An unexpected error, eg. invalid JSON returned by the service
    Unhandled(Box<dyn ::std::error::Error>),
}
impl ::std::fmt::Display for UpdateKeyDescriptionError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match self {
            UpdateKeyDescriptionError::DependencyTimeoutError(_inner) => _inner.fmt(f),
            UpdateKeyDescriptionError::InvalidArnError(_inner) => _inner.fmt(f),
            UpdateKeyDescriptionError::KMSInternalError(_inner) => _inner.fmt(f),
            UpdateKeyDescriptionError::KMSInvalidStateError(_inner) => _inner.fmt(f),
            UpdateKeyDescriptionError::NotFoundError(_inner) => _inner.fmt(f),
            UpdateKeyDescriptionError::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl ::smithy_types::retry::ProvideErrorKind for UpdateKeyDescriptionError {
    fn code(&self) -> Option<&str> {
        UpdateKeyDescriptionError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<::smithy_types::retry::ErrorKind> {
        match self {
            UpdateKeyDescriptionError::DependencyTimeoutError(_inner) => None,
            UpdateKeyDescriptionError::InvalidArnError(_inner) => None,
            UpdateKeyDescriptionError::KMSInternalError(_inner) => None,
            UpdateKeyDescriptionError::KMSInvalidStateError(_inner) => None,
            UpdateKeyDescriptionError::NotFoundError(_inner) => None,
            UpdateKeyDescriptionError::Unhandled(_inner) => {
                match _inner.downcast_ref::<::smithy_types::Error>() {
                    Some(_inner) => _inner.retryable_error_kind(),
                    None => None,
                }
            }
        }
    }
}
impl UpdateKeyDescriptionError {
    pub fn unhandled<E: Into<Box<dyn ::std::error::Error>>>(err: E) -> Self {
        UpdateKeyDescriptionError::Unhandled(err.into())
    }
    pub fn message(&self) -> Option<&str> {
        match self {
            UpdateKeyDescriptionError::DependencyTimeoutError(_inner) => _inner.message(),
            UpdateKeyDescriptionError::InvalidArnError(_inner) => _inner.message(),
            UpdateKeyDescriptionError::KMSInternalError(_inner) => _inner.message(),
            UpdateKeyDescriptionError::KMSInvalidStateError(_inner) => _inner.message(),
            UpdateKeyDescriptionError::NotFoundError(_inner) => _inner.message(),
            UpdateKeyDescriptionError::Unhandled(_inner) => {
                match _inner.downcast_ref::<::smithy_types::Error>() {
                    Some(_inner) => _inner.message(),
                    None => None,
                }
            }
        }
    }
    pub fn code(&self) -> Option<&str> {
        match self {
            UpdateKeyDescriptionError::DependencyTimeoutError(_inner) => Some(_inner.code()),
            UpdateKeyDescriptionError::InvalidArnError(_inner) => Some(_inner.code()),
            UpdateKeyDescriptionError::KMSInternalError(_inner) => Some(_inner.code()),
            UpdateKeyDescriptionError::KMSInvalidStateError(_inner) => Some(_inner.code()),
            UpdateKeyDescriptionError::NotFoundError(_inner) => Some(_inner.code()),
            UpdateKeyDescriptionError::Unhandled(_inner) => {
                match _inner.downcast_ref::<::smithy_types::Error>() {
                    Some(_inner) => _inner.code(),
                    None => None,
                }
            }
        }
    }
}
impl ::std::error::Error for UpdateKeyDescriptionError {
    fn source(&self) -> Option<&(dyn ::std::error::Error + 'static)> {
        match self {
            UpdateKeyDescriptionError::DependencyTimeoutError(_inner) => Some(_inner),
            UpdateKeyDescriptionError::InvalidArnError(_inner) => Some(_inner),
            UpdateKeyDescriptionError::KMSInternalError(_inner) => Some(_inner),
            UpdateKeyDescriptionError::KMSInvalidStateError(_inner) => Some(_inner),
            UpdateKeyDescriptionError::NotFoundError(_inner) => Some(_inner),
            UpdateKeyDescriptionError::Unhandled(_inner) => {
                match _inner.downcast_ref::<::smithy_types::Error>() {
                    Some(_inner) => Some(_inner),
                    None => Some(_inner.as_ref()),
                }
            }
        }
    }
}

#[non_exhaustive]
#[derive(::std::fmt::Debug)]
pub enum VerifyError {
    DependencyTimeoutError(DependencyTimeoutError),
    DisabledError(DisabledError),
    InvalidGrantTokenError(InvalidGrantTokenError),
    InvalidKeyUsageError(InvalidKeyUsageError),
    KeyUnavailableError(KeyUnavailableError),
    KMSInternalError(KMSInternalError),
    KMSInvalidSignatureError(KMSInvalidSignatureError),
    KMSInvalidStateError(KMSInvalidStateError),
    NotFoundError(NotFoundError),

    /// An unexpected error, eg. invalid JSON returned by the service
    Unhandled(Box<dyn ::std::error::Error>),
}
impl ::std::fmt::Display for VerifyError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match self {
            VerifyError::DependencyTimeoutError(_inner) => _inner.fmt(f),
            VerifyError::DisabledError(_inner) => _inner.fmt(f),
            VerifyError::InvalidGrantTokenError(_inner) => _inner.fmt(f),
            VerifyError::InvalidKeyUsageError(_inner) => _inner.fmt(f),
            VerifyError::KeyUnavailableError(_inner) => _inner.fmt(f),
            VerifyError::KMSInternalError(_inner) => _inner.fmt(f),
            VerifyError::KMSInvalidSignatureError(_inner) => _inner.fmt(f),
            VerifyError::KMSInvalidStateError(_inner) => _inner.fmt(f),
            VerifyError::NotFoundError(_inner) => _inner.fmt(f),
            VerifyError::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl ::smithy_types::retry::ProvideErrorKind for VerifyError {
    fn code(&self) -> Option<&str> {
        VerifyError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<::smithy_types::retry::ErrorKind> {
        match self {
            VerifyError::DependencyTimeoutError(_inner) => None,
            VerifyError::DisabledError(_inner) => None,
            VerifyError::InvalidGrantTokenError(_inner) => None,
            VerifyError::InvalidKeyUsageError(_inner) => None,
            VerifyError::KeyUnavailableError(_inner) => None,
            VerifyError::KMSInternalError(_inner) => None,
            VerifyError::KMSInvalidSignatureError(_inner) => None,
            VerifyError::KMSInvalidStateError(_inner) => None,
            VerifyError::NotFoundError(_inner) => None,
            VerifyError::Unhandled(_inner) => {
                match _inner.downcast_ref::<::smithy_types::Error>() {
                    Some(_inner) => _inner.retryable_error_kind(),
                    None => None,
                }
            }
        }
    }
}
impl VerifyError {
    pub fn unhandled<E: Into<Box<dyn ::std::error::Error>>>(err: E) -> Self {
        VerifyError::Unhandled(err.into())
    }
    pub fn message(&self) -> Option<&str> {
        match self {
            VerifyError::DependencyTimeoutError(_inner) => _inner.message(),
            VerifyError::DisabledError(_inner) => _inner.message(),
            VerifyError::InvalidGrantTokenError(_inner) => _inner.message(),
            VerifyError::InvalidKeyUsageError(_inner) => _inner.message(),
            VerifyError::KeyUnavailableError(_inner) => _inner.message(),
            VerifyError::KMSInternalError(_inner) => _inner.message(),
            VerifyError::KMSInvalidSignatureError(_inner) => _inner.message(),
            VerifyError::KMSInvalidStateError(_inner) => _inner.message(),
            VerifyError::NotFoundError(_inner) => _inner.message(),
            VerifyError::Unhandled(_inner) => {
                match _inner.downcast_ref::<::smithy_types::Error>() {
                    Some(_inner) => _inner.message(),
                    None => None,
                }
            }
        }
    }
    pub fn code(&self) -> Option<&str> {
        match self {
            VerifyError::DependencyTimeoutError(_inner) => Some(_inner.code()),
            VerifyError::DisabledError(_inner) => Some(_inner.code()),
            VerifyError::InvalidGrantTokenError(_inner) => Some(_inner.code()),
            VerifyError::InvalidKeyUsageError(_inner) => Some(_inner.code()),
            VerifyError::KeyUnavailableError(_inner) => Some(_inner.code()),
            VerifyError::KMSInternalError(_inner) => Some(_inner.code()),
            VerifyError::KMSInvalidSignatureError(_inner) => Some(_inner.code()),
            VerifyError::KMSInvalidStateError(_inner) => Some(_inner.code()),
            VerifyError::NotFoundError(_inner) => Some(_inner.code()),
            VerifyError::Unhandled(_inner) => {
                match _inner.downcast_ref::<::smithy_types::Error>() {
                    Some(_inner) => _inner.code(),
                    None => None,
                }
            }
        }
    }
}
impl ::std::error::Error for VerifyError {
    fn source(&self) -> Option<&(dyn ::std::error::Error + 'static)> {
        match self {
            VerifyError::DependencyTimeoutError(_inner) => Some(_inner),
            VerifyError::DisabledError(_inner) => Some(_inner),
            VerifyError::InvalidGrantTokenError(_inner) => Some(_inner),
            VerifyError::InvalidKeyUsageError(_inner) => Some(_inner),
            VerifyError::KeyUnavailableError(_inner) => Some(_inner),
            VerifyError::KMSInternalError(_inner) => Some(_inner),
            VerifyError::KMSInvalidSignatureError(_inner) => Some(_inner),
            VerifyError::KMSInvalidStateError(_inner) => Some(_inner),
            VerifyError::NotFoundError(_inner) => Some(_inner),
            VerifyError::Unhandled(_inner) => {
                match _inner.downcast_ref::<::smithy_types::Error>() {
                    Some(_inner) => Some(_inner),
                    None => Some(_inner.as_ref()),
                }
            }
        }
    }
}

/// <p>The request was rejected because the specified entity or resource could not be
/// found.</p>
#[non_exhaustive]
#[derive(::serde::Deserialize, ::serde::Serialize, ::std::clone::Clone, ::std::cmp::PartialEq)]
pub struct NotFoundError {
    #[serde(rename = "message")]
    #[serde(skip_serializing_if = "Option::is_none")]
    #[serde(default)]
    pub message: ::std::option::Option<::std::string::String>,
}
impl ::std::fmt::Debug for NotFoundError {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        let mut formatter = f.debug_struct("NotFoundError");
        formatter.field("message", &self.message);
        formatter.finish()
    }
}
impl NotFoundError {
    pub fn code(&self) -> &str {
        "NotFoundException"
    }
    pub fn message(&self) -> Option<&str> {
        self.message.as_deref()
    }
}
impl ::std::fmt::Display for NotFoundError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "NotFoundError")?;
        if let Some(inner_1) = &self.message {
            write!(f, ": {}", inner_1)?;
        }
        Ok(())
    }
}
impl ::std::error::Error for NotFoundError {}
/// See [`NotFoundError`](crate::error::NotFoundError)
pub mod not_found_error {

    use crate::error::NotFoundError;
    /// A builder for [`NotFoundError`](crate::error::NotFoundError)
    #[non_exhaustive]
    #[derive(Debug, Clone, Default)]
    pub struct Builder {
        message: ::std::option::Option<::std::string::String>,
    }
    impl Builder {
        pub fn message(mut self, inp: impl Into<::std::string::String>) -> Self {
            self.message = Some(inp.into());
            self
        }
        /// Consumes the builder and constructs a [`NotFoundError`](crate::error::NotFoundError)
        pub fn build(self) -> NotFoundError {
            NotFoundError {
                message: self.message,
            }
        }
    }
}
impl NotFoundError {
    /// Creates a new builder-style object to manufacture [`NotFoundError`](crate::error::NotFoundError)
    pub fn builder() -> crate::error::not_found_error::Builder {
        crate::error::not_found_error::Builder::default()
    }
}

/// <p>The request was rejected because the state of the specified resource is not valid for this
/// request.</p>
/// <p>For more information about how key state affects the use of a CMK, see <a href="https://docs.aws.amazon.com/kms/latest/developerguide/key-state.html">How Key State Affects Use of a
/// Customer Master Key</a> in the <i>
/// <i>AWS Key Management Service Developer Guide</i>
/// </i>.</p>
#[non_exhaustive]
#[derive(::serde::Deserialize, ::serde::Serialize, ::std::clone::Clone, ::std::cmp::PartialEq)]
pub struct KMSInvalidStateError {
    #[serde(rename = "message")]
    #[serde(skip_serializing_if = "Option::is_none")]
    #[serde(default)]
    pub message: ::std::option::Option<::std::string::String>,
}
impl ::std::fmt::Debug for KMSInvalidStateError {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        let mut formatter = f.debug_struct("KMSInvalidStateError");
        formatter.field("message", &self.message);
        formatter.finish()
    }
}
impl KMSInvalidStateError {
    pub fn code(&self) -> &str {
        "KMSInvalidStateException"
    }
    pub fn message(&self) -> Option<&str> {
        self.message.as_deref()
    }
}
impl ::std::fmt::Display for KMSInvalidStateError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "KMSInvalidStateError")?;
        if let Some(inner_2) = &self.message {
            write!(f, ": {}", inner_2)?;
        }
        Ok(())
    }
}
impl ::std::error::Error for KMSInvalidStateError {}
/// See [`KMSInvalidStateError`](crate::error::KMSInvalidStateError)
pub mod kms_invalid_state_error {

    use crate::error::KMSInvalidStateError;
    /// A builder for [`KMSInvalidStateError`](crate::error::KMSInvalidStateError)
    #[non_exhaustive]
    #[derive(Debug, Clone, Default)]
    pub struct Builder {
        message: ::std::option::Option<::std::string::String>,
    }
    impl Builder {
        pub fn message(mut self, inp: impl Into<::std::string::String>) -> Self {
            self.message = Some(inp.into());
            self
        }
        /// Consumes the builder and constructs a [`KMSInvalidStateError`](crate::error::KMSInvalidStateError)
        pub fn build(self) -> KMSInvalidStateError {
            KMSInvalidStateError {
                message: self.message,
            }
        }
    }
}
impl KMSInvalidStateError {
    /// Creates a new builder-style object to manufacture [`KMSInvalidStateError`](crate::error::KMSInvalidStateError)
    pub fn builder() -> crate::error::kms_invalid_state_error::Builder {
        crate::error::kms_invalid_state_error::Builder::default()
    }
}

/// <p>The request was rejected because the signature verification failed. Signature
/// verification fails when it cannot confirm that signature was produced by signing the specified
/// message with the specified CMK and signing algorithm.</p>
#[non_exhaustive]
#[derive(::serde::Deserialize, ::serde::Serialize, ::std::clone::Clone, ::std::cmp::PartialEq)]
pub struct KMSInvalidSignatureError {
    #[serde(rename = "message")]
    #[serde(skip_serializing_if = "Option::is_none")]
    #[serde(default)]
    pub message: ::std::option::Option<::std::string::String>,
}
impl ::std::fmt::Debug for KMSInvalidSignatureError {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        let mut formatter = f.debug_struct("KMSInvalidSignatureError");
        formatter.field("message", &self.message);
        formatter.finish()
    }
}
impl KMSInvalidSignatureError {
    pub fn code(&self) -> &str {
        "KMSInvalidSignatureException"
    }
    pub fn message(&self) -> Option<&str> {
        self.message.as_deref()
    }
}
impl ::std::fmt::Display for KMSInvalidSignatureError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "KMSInvalidSignatureError")?;
        if let Some(inner_3) = &self.message {
            write!(f, ": {}", inner_3)?;
        }
        Ok(())
    }
}
impl ::std::error::Error for KMSInvalidSignatureError {}
/// See [`KMSInvalidSignatureError`](crate::error::KMSInvalidSignatureError)
pub mod kms_invalid_signature_error {

    use crate::error::KMSInvalidSignatureError;
    /// A builder for [`KMSInvalidSignatureError`](crate::error::KMSInvalidSignatureError)
    #[non_exhaustive]
    #[derive(Debug, Clone, Default)]
    pub struct Builder {
        message: ::std::option::Option<::std::string::String>,
    }
    impl Builder {
        pub fn message(mut self, inp: impl Into<::std::string::String>) -> Self {
            self.message = Some(inp.into());
            self
        }
        /// Consumes the builder and constructs a [`KMSInvalidSignatureError`](crate::error::KMSInvalidSignatureError)
        pub fn build(self) -> KMSInvalidSignatureError {
            KMSInvalidSignatureError {
                message: self.message,
            }
        }
    }
}
impl KMSInvalidSignatureError {
    /// Creates a new builder-style object to manufacture [`KMSInvalidSignatureError`](crate::error::KMSInvalidSignatureError)
    pub fn builder() -> crate::error::kms_invalid_signature_error::Builder {
        crate::error::kms_invalid_signature_error::Builder::default()
    }
}

/// <p>The request was rejected because an internal exception occurred. The request can be
/// retried.</p>
#[non_exhaustive]
#[derive(::serde::Deserialize, ::serde::Serialize, ::std::clone::Clone, ::std::cmp::PartialEq)]
pub struct KMSInternalError {
    #[serde(rename = "message")]
    #[serde(skip_serializing_if = "Option::is_none")]
    #[serde(default)]
    pub message: ::std::option::Option<::std::string::String>,
}
impl ::std::fmt::Debug for KMSInternalError {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        let mut formatter = f.debug_struct("KMSInternalError");
        formatter.field("message", &self.message);
        formatter.finish()
    }
}
impl KMSInternalError {
    pub fn code(&self) -> &str {
        "KMSInternalException"
    }
    pub fn message(&self) -> Option<&str> {
        self.message.as_deref()
    }
}
impl ::std::fmt::Display for KMSInternalError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "KMSInternalError")?;
        if let Some(inner_4) = &self.message {
            write!(f, ": {}", inner_4)?;
        }
        Ok(())
    }
}
impl ::std::error::Error for KMSInternalError {}
/// See [`KMSInternalError`](crate::error::KMSInternalError)
pub mod kms_internal_error {

    use crate::error::KMSInternalError;
    /// A builder for [`KMSInternalError`](crate::error::KMSInternalError)
    #[non_exhaustive]
    #[derive(Debug, Clone, Default)]
    pub struct Builder {
        message: ::std::option::Option<::std::string::String>,
    }
    impl Builder {
        pub fn message(mut self, inp: impl Into<::std::string::String>) -> Self {
            self.message = Some(inp.into());
            self
        }
        /// Consumes the builder and constructs a [`KMSInternalError`](crate::error::KMSInternalError)
        pub fn build(self) -> KMSInternalError {
            KMSInternalError {
                message: self.message,
            }
        }
    }
}
impl KMSInternalError {
    /// Creates a new builder-style object to manufacture [`KMSInternalError`](crate::error::KMSInternalError)
    pub fn builder() -> crate::error::kms_internal_error::Builder {
        crate::error::kms_internal_error::Builder::default()
    }
}

/// <p>The request was rejected because the specified CMK was not available. You can retry the
/// request.</p>
#[non_exhaustive]
#[derive(::serde::Deserialize, ::serde::Serialize, ::std::clone::Clone, ::std::cmp::PartialEq)]
pub struct KeyUnavailableError {
    #[serde(rename = "message")]
    #[serde(skip_serializing_if = "Option::is_none")]
    #[serde(default)]
    pub message: ::std::option::Option<::std::string::String>,
}
impl ::std::fmt::Debug for KeyUnavailableError {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        let mut formatter = f.debug_struct("KeyUnavailableError");
        formatter.field("message", &self.message);
        formatter.finish()
    }
}
impl KeyUnavailableError {
    pub fn code(&self) -> &str {
        "KeyUnavailableException"
    }
    pub fn message(&self) -> Option<&str> {
        self.message.as_deref()
    }
}
impl ::std::fmt::Display for KeyUnavailableError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "KeyUnavailableError")?;
        if let Some(inner_5) = &self.message {
            write!(f, ": {}", inner_5)?;
        }
        Ok(())
    }
}
impl ::std::error::Error for KeyUnavailableError {}
/// See [`KeyUnavailableError`](crate::error::KeyUnavailableError)
pub mod key_unavailable_error {

    use crate::error::KeyUnavailableError;
    /// A builder for [`KeyUnavailableError`](crate::error::KeyUnavailableError)
    #[non_exhaustive]
    #[derive(Debug, Clone, Default)]
    pub struct Builder {
        message: ::std::option::Option<::std::string::String>,
    }
    impl Builder {
        pub fn message(mut self, inp: impl Into<::std::string::String>) -> Self {
            self.message = Some(inp.into());
            self
        }
        /// Consumes the builder and constructs a [`KeyUnavailableError`](crate::error::KeyUnavailableError)
        pub fn build(self) -> KeyUnavailableError {
            KeyUnavailableError {
                message: self.message,
            }
        }
    }
}
impl KeyUnavailableError {
    /// Creates a new builder-style object to manufacture [`KeyUnavailableError`](crate::error::KeyUnavailableError)
    pub fn builder() -> crate::error::key_unavailable_error::Builder {
        crate::error::key_unavailable_error::Builder::default()
    }
}

/// <p>The request was rejected for one of the following reasons: </p>
/// <ul>
/// <li>
/// <p>The <code>KeyUsage</code> value of the CMK is incompatible with the API
/// operation.</p>
/// </li>
/// <li>
/// <p>The encryption algorithm or signing algorithm specified for the operation is
/// incompatible with the type of key material in the CMK
/// <code>(CustomerMasterKeySpec</code>).</p>
/// </li>
/// </ul>
/// <p>For encrypting, decrypting, re-encrypting, and generating data keys, the
/// <code>KeyUsage</code> must be <code>ENCRYPT_DECRYPT</code>. For signing and verifying, the
/// <code>KeyUsage</code> must be <code>SIGN_VERIFY</code>. To find the <code>KeyUsage</code> of
/// a CMK, use the <a>DescribeKey</a> operation.</p>
/// <p>To find the encryption or signing algorithms supported for a particular CMK, use the <a>DescribeKey</a> operation.</p>
#[non_exhaustive]
#[derive(::serde::Deserialize, ::serde::Serialize, ::std::clone::Clone, ::std::cmp::PartialEq)]
pub struct InvalidKeyUsageError {
    #[serde(rename = "message")]
    #[serde(skip_serializing_if = "Option::is_none")]
    #[serde(default)]
    pub message: ::std::option::Option<::std::string::String>,
}
impl ::std::fmt::Debug for InvalidKeyUsageError {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        let mut formatter = f.debug_struct("InvalidKeyUsageError");
        formatter.field("message", &self.message);
        formatter.finish()
    }
}
impl InvalidKeyUsageError {
    pub fn code(&self) -> &str {
        "InvalidKeyUsageException"
    }
    pub fn message(&self) -> Option<&str> {
        self.message.as_deref()
    }
}
impl ::std::fmt::Display for InvalidKeyUsageError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "InvalidKeyUsageError")?;
        if let Some(inner_6) = &self.message {
            write!(f, ": {}", inner_6)?;
        }
        Ok(())
    }
}
impl ::std::error::Error for InvalidKeyUsageError {}
/// See [`InvalidKeyUsageError`](crate::error::InvalidKeyUsageError)
pub mod invalid_key_usage_error {

    use crate::error::InvalidKeyUsageError;
    /// A builder for [`InvalidKeyUsageError`](crate::error::InvalidKeyUsageError)
    #[non_exhaustive]
    #[derive(Debug, Clone, Default)]
    pub struct Builder {
        message: ::std::option::Option<::std::string::String>,
    }
    impl Builder {
        pub fn message(mut self, inp: impl Into<::std::string::String>) -> Self {
            self.message = Some(inp.into());
            self
        }
        /// Consumes the builder and constructs a [`InvalidKeyUsageError`](crate::error::InvalidKeyUsageError)
        pub fn build(self) -> InvalidKeyUsageError {
            InvalidKeyUsageError {
                message: self.message,
            }
        }
    }
}
impl InvalidKeyUsageError {
    /// Creates a new builder-style object to manufacture [`InvalidKeyUsageError`](crate::error::InvalidKeyUsageError)
    pub fn builder() -> crate::error::invalid_key_usage_error::Builder {
        crate::error::invalid_key_usage_error::Builder::default()
    }
}

/// <p>The request was rejected because the specified grant token is not valid.</p>
#[non_exhaustive]
#[derive(::serde::Deserialize, ::serde::Serialize, ::std::clone::Clone, ::std::cmp::PartialEq)]
pub struct InvalidGrantTokenError {
    #[serde(rename = "message")]
    #[serde(skip_serializing_if = "Option::is_none")]
    #[serde(default)]
    pub message: ::std::option::Option<::std::string::String>,
}
impl ::std::fmt::Debug for InvalidGrantTokenError {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        let mut formatter = f.debug_struct("InvalidGrantTokenError");
        formatter.field("message", &self.message);
        formatter.finish()
    }
}
impl InvalidGrantTokenError {
    pub fn code(&self) -> &str {
        "InvalidGrantTokenException"
    }
    pub fn message(&self) -> Option<&str> {
        self.message.as_deref()
    }
}
impl ::std::fmt::Display for InvalidGrantTokenError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "InvalidGrantTokenError")?;
        if let Some(inner_7) = &self.message {
            write!(f, ": {}", inner_7)?;
        }
        Ok(())
    }
}
impl ::std::error::Error for InvalidGrantTokenError {}
/// See [`InvalidGrantTokenError`](crate::error::InvalidGrantTokenError)
pub mod invalid_grant_token_error {

    use crate::error::InvalidGrantTokenError;
    /// A builder for [`InvalidGrantTokenError`](crate::error::InvalidGrantTokenError)
    #[non_exhaustive]
    #[derive(Debug, Clone, Default)]
    pub struct Builder {
        message: ::std::option::Option<::std::string::String>,
    }
    impl Builder {
        pub fn message(mut self, inp: impl Into<::std::string::String>) -> Self {
            self.message = Some(inp.into());
            self
        }
        /// Consumes the builder and constructs a [`InvalidGrantTokenError`](crate::error::InvalidGrantTokenError)
        pub fn build(self) -> InvalidGrantTokenError {
            InvalidGrantTokenError {
                message: self.message,
            }
        }
    }
}
impl InvalidGrantTokenError {
    /// Creates a new builder-style object to manufacture [`InvalidGrantTokenError`](crate::error::InvalidGrantTokenError)
    pub fn builder() -> crate::error::invalid_grant_token_error::Builder {
        crate::error::invalid_grant_token_error::Builder::default()
    }
}

/// <p>The request was rejected because the specified CMK is not enabled.</p>
#[non_exhaustive]
#[derive(::serde::Deserialize, ::serde::Serialize, ::std::clone::Clone, ::std::cmp::PartialEq)]
pub struct DisabledError {
    #[serde(rename = "message")]
    #[serde(skip_serializing_if = "Option::is_none")]
    #[serde(default)]
    pub message: ::std::option::Option<::std::string::String>,
}
impl ::std::fmt::Debug for DisabledError {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        let mut formatter = f.debug_struct("DisabledError");
        formatter.field("message", &self.message);
        formatter.finish()
    }
}
impl DisabledError {
    pub fn code(&self) -> &str {
        "DisabledException"
    }
    pub fn message(&self) -> Option<&str> {
        self.message.as_deref()
    }
}
impl ::std::fmt::Display for DisabledError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "DisabledError")?;
        if let Some(inner_8) = &self.message {
            write!(f, ": {}", inner_8)?;
        }
        Ok(())
    }
}
impl ::std::error::Error for DisabledError {}
/// See [`DisabledError`](crate::error::DisabledError)
pub mod disabled_error {

    use crate::error::DisabledError;
    /// A builder for [`DisabledError`](crate::error::DisabledError)
    #[non_exhaustive]
    #[derive(Debug, Clone, Default)]
    pub struct Builder {
        message: ::std::option::Option<::std::string::String>,
    }
    impl Builder {
        pub fn message(mut self, inp: impl Into<::std::string::String>) -> Self {
            self.message = Some(inp.into());
            self
        }
        /// Consumes the builder and constructs a [`DisabledError`](crate::error::DisabledError)
        pub fn build(self) -> DisabledError {
            DisabledError {
                message: self.message,
            }
        }
    }
}
impl DisabledError {
    /// Creates a new builder-style object to manufacture [`DisabledError`](crate::error::DisabledError)
    pub fn builder() -> crate::error::disabled_error::Builder {
        crate::error::disabled_error::Builder::default()
    }
}

/// <p>The system timed out while trying to fulfill the request. The request can be
/// retried.</p>
#[non_exhaustive]
#[derive(::serde::Deserialize, ::serde::Serialize, ::std::clone::Clone, ::std::cmp::PartialEq)]
pub struct DependencyTimeoutError {
    #[serde(rename = "message")]
    #[serde(skip_serializing_if = "Option::is_none")]
    #[serde(default)]
    pub message: ::std::option::Option<::std::string::String>,
}
impl ::std::fmt::Debug for DependencyTimeoutError {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        let mut formatter = f.debug_struct("DependencyTimeoutError");
        formatter.field("message", &self.message);
        formatter.finish()
    }
}
impl DependencyTimeoutError {
    pub fn code(&self) -> &str {
        "DependencyTimeoutException"
    }
    pub fn message(&self) -> Option<&str> {
        self.message.as_deref()
    }
}
impl ::std::fmt::Display for DependencyTimeoutError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "DependencyTimeoutError")?;
        if let Some(inner_9) = &self.message {
            write!(f, ": {}", inner_9)?;
        }
        Ok(())
    }
}
impl ::std::error::Error for DependencyTimeoutError {}
/// See [`DependencyTimeoutError`](crate::error::DependencyTimeoutError)
pub mod dependency_timeout_error {

    use crate::error::DependencyTimeoutError;
    /// A builder for [`DependencyTimeoutError`](crate::error::DependencyTimeoutError)
    #[non_exhaustive]
    #[derive(Debug, Clone, Default)]
    pub struct Builder {
        message: ::std::option::Option<::std::string::String>,
    }
    impl Builder {
        pub fn message(mut self, inp: impl Into<::std::string::String>) -> Self {
            self.message = Some(inp.into());
            self
        }
        /// Consumes the builder and constructs a [`DependencyTimeoutError`](crate::error::DependencyTimeoutError)
        pub fn build(self) -> DependencyTimeoutError {
            DependencyTimeoutError {
                message: self.message,
            }
        }
    }
}
impl DependencyTimeoutError {
    /// Creates a new builder-style object to manufacture [`DependencyTimeoutError`](crate::error::DependencyTimeoutError)
    pub fn builder() -> crate::error::dependency_timeout_error::Builder {
        crate::error::dependency_timeout_error::Builder::default()
    }
}

/// <p>The request was rejected because a specified ARN, or an ARN in a key policy, is not
/// valid.</p>
#[non_exhaustive]
#[derive(::serde::Deserialize, ::serde::Serialize, ::std::clone::Clone, ::std::cmp::PartialEq)]
pub struct InvalidArnError {
    #[serde(rename = "message")]
    #[serde(skip_serializing_if = "Option::is_none")]
    #[serde(default)]
    pub message: ::std::option::Option<::std::string::String>,
}
impl ::std::fmt::Debug for InvalidArnError {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        let mut formatter = f.debug_struct("InvalidArnError");
        formatter.field("message", &self.message);
        formatter.finish()
    }
}
impl InvalidArnError {
    pub fn code(&self) -> &str {
        "InvalidArnException"
    }
    pub fn message(&self) -> Option<&str> {
        self.message.as_deref()
    }
}
impl ::std::fmt::Display for InvalidArnError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "InvalidArnError")?;
        if let Some(inner_10) = &self.message {
            write!(f, ": {}", inner_10)?;
        }
        Ok(())
    }
}
impl ::std::error::Error for InvalidArnError {}
/// See [`InvalidArnError`](crate::error::InvalidArnError)
pub mod invalid_arn_error {

    use crate::error::InvalidArnError;
    /// A builder for [`InvalidArnError`](crate::error::InvalidArnError)
    #[non_exhaustive]
    #[derive(Debug, Clone, Default)]
    pub struct Builder {
        message: ::std::option::Option<::std::string::String>,
    }
    impl Builder {
        pub fn message(mut self, inp: impl Into<::std::string::String>) -> Self {
            self.message = Some(inp.into());
            self
        }
        /// Consumes the builder and constructs a [`InvalidArnError`](crate::error::InvalidArnError)
        pub fn build(self) -> InvalidArnError {
            InvalidArnError {
                message: self.message,
            }
        }
    }
}
impl InvalidArnError {
    /// Creates a new builder-style object to manufacture [`InvalidArnError`](crate::error::InvalidArnError)
    pub fn builder() -> crate::error::invalid_arn_error::Builder {
        crate::error::invalid_arn_error::Builder::default()
    }
}

/// <p>The request was rejected because AWS KMS cannot find a custom key store with the specified
/// key store name or ID.</p>
#[non_exhaustive]
#[derive(::serde::Deserialize, ::serde::Serialize, ::std::clone::Clone, ::std::cmp::PartialEq)]
pub struct CustomKeyStoreNotFoundError {
    #[serde(rename = "message")]
    #[serde(skip_serializing_if = "Option::is_none")]
    #[serde(default)]
    pub message: ::std::option::Option<::std::string::String>,
}
impl ::std::fmt::Debug for CustomKeyStoreNotFoundError {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        let mut formatter = f.debug_struct("CustomKeyStoreNotFoundError");
        formatter.field("message", &self.message);
        formatter.finish()
    }
}
impl CustomKeyStoreNotFoundError {
    pub fn code(&self) -> &str {
        "CustomKeyStoreNotFoundException"
    }
    pub fn message(&self) -> Option<&str> {
        self.message.as_deref()
    }
}
impl ::std::fmt::Display for CustomKeyStoreNotFoundError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "CustomKeyStoreNotFoundError")?;
        if let Some(inner_11) = &self.message {
            write!(f, ": {}", inner_11)?;
        }
        Ok(())
    }
}
impl ::std::error::Error for CustomKeyStoreNotFoundError {}
/// See [`CustomKeyStoreNotFoundError`](crate::error::CustomKeyStoreNotFoundError)
pub mod custom_key_store_not_found_error {

    use crate::error::CustomKeyStoreNotFoundError;
    /// A builder for [`CustomKeyStoreNotFoundError`](crate::error::CustomKeyStoreNotFoundError)
    #[non_exhaustive]
    #[derive(Debug, Clone, Default)]
    pub struct Builder {
        message: ::std::option::Option<::std::string::String>,
    }
    impl Builder {
        pub fn message(mut self, inp: impl Into<::std::string::String>) -> Self {
            self.message = Some(inp.into());
            self
        }
        /// Consumes the builder and constructs a [`CustomKeyStoreNotFoundError`](crate::error::CustomKeyStoreNotFoundError)
        pub fn build(self) -> CustomKeyStoreNotFoundError {
            CustomKeyStoreNotFoundError {
                message: self.message,
            }
        }
    }
}
impl CustomKeyStoreNotFoundError {
    /// Creates a new builder-style object to manufacture [`CustomKeyStoreNotFoundError`](crate::error::CustomKeyStoreNotFoundError)
    pub fn builder() -> crate::error::custom_key_store_not_found_error::Builder {
        crate::error::custom_key_store_not_found_error::Builder::default()
    }
}

/// <p>The request was rejected because the specified custom key store name is already assigned
/// to another custom key store in the account. Try again with a custom key store name that is
/// unique in the account.</p>
#[non_exhaustive]
#[derive(::serde::Deserialize, ::serde::Serialize, ::std::clone::Clone, ::std::cmp::PartialEq)]
pub struct CustomKeyStoreNameInUseError {
    #[serde(rename = "message")]
    #[serde(skip_serializing_if = "Option::is_none")]
    #[serde(default)]
    pub message: ::std::option::Option<::std::string::String>,
}
impl ::std::fmt::Debug for CustomKeyStoreNameInUseError {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        let mut formatter = f.debug_struct("CustomKeyStoreNameInUseError");
        formatter.field("message", &self.message);
        formatter.finish()
    }
}
impl CustomKeyStoreNameInUseError {
    pub fn code(&self) -> &str {
        "CustomKeyStoreNameInUseException"
    }
    pub fn message(&self) -> Option<&str> {
        self.message.as_deref()
    }
}
impl ::std::fmt::Display for CustomKeyStoreNameInUseError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "CustomKeyStoreNameInUseError")?;
        if let Some(inner_12) = &self.message {
            write!(f, ": {}", inner_12)?;
        }
        Ok(())
    }
}
impl ::std::error::Error for CustomKeyStoreNameInUseError {}
/// See [`CustomKeyStoreNameInUseError`](crate::error::CustomKeyStoreNameInUseError)
pub mod custom_key_store_name_in_use_error {

    use crate::error::CustomKeyStoreNameInUseError;
    /// A builder for [`CustomKeyStoreNameInUseError`](crate::error::CustomKeyStoreNameInUseError)
    #[non_exhaustive]
    #[derive(Debug, Clone, Default)]
    pub struct Builder {
        message: ::std::option::Option<::std::string::String>,
    }
    impl Builder {
        pub fn message(mut self, inp: impl Into<::std::string::String>) -> Self {
            self.message = Some(inp.into());
            self
        }
        /// Consumes the builder and constructs a [`CustomKeyStoreNameInUseError`](crate::error::CustomKeyStoreNameInUseError)
        pub fn build(self) -> CustomKeyStoreNameInUseError {
            CustomKeyStoreNameInUseError {
                message: self.message,
            }
        }
    }
}
impl CustomKeyStoreNameInUseError {
    /// Creates a new builder-style object to manufacture [`CustomKeyStoreNameInUseError`](crate::error::CustomKeyStoreNameInUseError)
    pub fn builder() -> crate::error::custom_key_store_name_in_use_error::Builder {
        crate::error::custom_key_store_name_in_use_error::Builder::default()
    }
}

/// <p>The request was rejected because of the <code>ConnectionState</code> of the custom key
/// store. To get the <code>ConnectionState</code> of a custom key store, use the <a>DescribeCustomKeyStores</a> operation.</p>
/// <p>This exception is thrown under the following conditions:</p>
/// <ul>
/// <li>
/// <p>You requested the <a>CreateKey</a> or <a>GenerateRandom</a>
/// operation in a custom key store that is not connected. These operations are valid only
/// when the custom key store <code>ConnectionState</code> is <code>CONNECTED</code>.</p>
/// </li>
/// <li>
/// <p>You requested the <a>UpdateCustomKeyStore</a> or <a>DeleteCustomKeyStore</a> operation on a custom key store that is not
/// disconnected. This operation is valid only when the custom key store
/// <code>ConnectionState</code> is <code>DISCONNECTED</code>.</p>
/// </li>
/// <li>
/// <p>You requested the <a>ConnectCustomKeyStore</a> operation on a custom key
/// store with a <code>ConnectionState</code> of <code>DISCONNECTING</code> or
/// <code>FAILED</code>. This operation is valid for all other <code>ConnectionState</code>
/// values.</p>
/// </li>
/// </ul>
#[non_exhaustive]
#[derive(::serde::Deserialize, ::serde::Serialize, ::std::clone::Clone, ::std::cmp::PartialEq)]
pub struct CustomKeyStoreInvalidStateError {
    #[serde(rename = "message")]
    #[serde(skip_serializing_if = "Option::is_none")]
    #[serde(default)]
    pub message: ::std::option::Option<::std::string::String>,
}
impl ::std::fmt::Debug for CustomKeyStoreInvalidStateError {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        let mut formatter = f.debug_struct("CustomKeyStoreInvalidStateError");
        formatter.field("message", &self.message);
        formatter.finish()
    }
}
impl CustomKeyStoreInvalidStateError {
    pub fn code(&self) -> &str {
        "CustomKeyStoreInvalidStateException"
    }
    pub fn message(&self) -> Option<&str> {
        self.message.as_deref()
    }
}
impl ::std::fmt::Display for CustomKeyStoreInvalidStateError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "CustomKeyStoreInvalidStateError")?;
        if let Some(inner_13) = &self.message {
            write!(f, ": {}", inner_13)?;
        }
        Ok(())
    }
}
impl ::std::error::Error for CustomKeyStoreInvalidStateError {}
/// See [`CustomKeyStoreInvalidStateError`](crate::error::CustomKeyStoreInvalidStateError)
pub mod custom_key_store_invalid_state_error {

    use crate::error::CustomKeyStoreInvalidStateError;
    /// A builder for [`CustomKeyStoreInvalidStateError`](crate::error::CustomKeyStoreInvalidStateError)
    #[non_exhaustive]
    #[derive(Debug, Clone, Default)]
    pub struct Builder {
        message: ::std::option::Option<::std::string::String>,
    }
    impl Builder {
        pub fn message(mut self, inp: impl Into<::std::string::String>) -> Self {
            self.message = Some(inp.into());
            self
        }
        /// Consumes the builder and constructs a [`CustomKeyStoreInvalidStateError`](crate::error::CustomKeyStoreInvalidStateError)
        pub fn build(self) -> CustomKeyStoreInvalidStateError {
            CustomKeyStoreInvalidStateError {
                message: self.message,
            }
        }
    }
}
impl CustomKeyStoreInvalidStateError {
    /// Creates a new builder-style object to manufacture [`CustomKeyStoreInvalidStateError`](crate::error::CustomKeyStoreInvalidStateError)
    pub fn builder() -> crate::error::custom_key_store_invalid_state_error::Builder {
        crate::error::custom_key_store_invalid_state_error::Builder::default()
    }
}

/// <p>The request was rejected because the specified AWS CloudHSM cluster has a different cluster
/// certificate than the original cluster. You cannot use the operation to specify an unrelated
/// cluster.</p>
/// <p>Specify a cluster that shares a backup history with the original cluster. This includes
/// clusters that were created from a backup of the current cluster, and clusters that were
/// created from the same backup that produced the current cluster.</p>
/// <p>Clusters that share a backup history have the same cluster certificate. To view the
/// cluster certificate of a cluster, use the <a href="https://docs.aws.amazon.com/cloudhsm/latest/APIReference/API_DescribeClusters.html">DescribeClusters</a> operation.</p>
#[non_exhaustive]
#[derive(::serde::Deserialize, ::serde::Serialize, ::std::clone::Clone, ::std::cmp::PartialEq)]
pub struct CloudHsmClusterNotRelatedError {
    #[serde(rename = "message")]
    #[serde(skip_serializing_if = "Option::is_none")]
    #[serde(default)]
    pub message: ::std::option::Option<::std::string::String>,
}
impl ::std::fmt::Debug for CloudHsmClusterNotRelatedError {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        let mut formatter = f.debug_struct("CloudHsmClusterNotRelatedError");
        formatter.field("message", &self.message);
        formatter.finish()
    }
}
impl CloudHsmClusterNotRelatedError {
    pub fn code(&self) -> &str {
        "CloudHsmClusterNotRelatedException"
    }
    pub fn message(&self) -> Option<&str> {
        self.message.as_deref()
    }
}
impl ::std::fmt::Display for CloudHsmClusterNotRelatedError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "CloudHsmClusterNotRelatedError")?;
        if let Some(inner_14) = &self.message {
            write!(f, ": {}", inner_14)?;
        }
        Ok(())
    }
}
impl ::std::error::Error for CloudHsmClusterNotRelatedError {}
/// See [`CloudHsmClusterNotRelatedError`](crate::error::CloudHsmClusterNotRelatedError)
pub mod cloud_hsm_cluster_not_related_error {

    use crate::error::CloudHsmClusterNotRelatedError;
    /// A builder for [`CloudHsmClusterNotRelatedError`](crate::error::CloudHsmClusterNotRelatedError)
    #[non_exhaustive]
    #[derive(Debug, Clone, Default)]
    pub struct Builder {
        message: ::std::option::Option<::std::string::String>,
    }
    impl Builder {
        pub fn message(mut self, inp: impl Into<::std::string::String>) -> Self {
            self.message = Some(inp.into());
            self
        }
        /// Consumes the builder and constructs a [`CloudHsmClusterNotRelatedError`](crate::error::CloudHsmClusterNotRelatedError)
        pub fn build(self) -> CloudHsmClusterNotRelatedError {
            CloudHsmClusterNotRelatedError {
                message: self.message,
            }
        }
    }
}
impl CloudHsmClusterNotRelatedError {
    /// Creates a new builder-style object to manufacture [`CloudHsmClusterNotRelatedError`](crate::error::CloudHsmClusterNotRelatedError)
    pub fn builder() -> crate::error::cloud_hsm_cluster_not_related_error::Builder {
        crate::error::cloud_hsm_cluster_not_related_error::Builder::default()
    }
}

/// <p>The request was rejected because AWS KMS cannot find the AWS CloudHSM cluster with the specified
/// cluster ID. Retry the request with a different cluster ID.</p>
#[non_exhaustive]
#[derive(::serde::Deserialize, ::serde::Serialize, ::std::clone::Clone, ::std::cmp::PartialEq)]
pub struct CloudHsmClusterNotFoundError {
    #[serde(rename = "message")]
    #[serde(skip_serializing_if = "Option::is_none")]
    #[serde(default)]
    pub message: ::std::option::Option<::std::string::String>,
}
impl ::std::fmt::Debug for CloudHsmClusterNotFoundError {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        let mut formatter = f.debug_struct("CloudHsmClusterNotFoundError");
        formatter.field("message", &self.message);
        formatter.finish()
    }
}
impl CloudHsmClusterNotFoundError {
    pub fn code(&self) -> &str {
        "CloudHsmClusterNotFoundException"
    }
    pub fn message(&self) -> Option<&str> {
        self.message.as_deref()
    }
}
impl ::std::fmt::Display for CloudHsmClusterNotFoundError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "CloudHsmClusterNotFoundError")?;
        if let Some(inner_15) = &self.message {
            write!(f, ": {}", inner_15)?;
        }
        Ok(())
    }
}
impl ::std::error::Error for CloudHsmClusterNotFoundError {}
/// See [`CloudHsmClusterNotFoundError`](crate::error::CloudHsmClusterNotFoundError)
pub mod cloud_hsm_cluster_not_found_error {

    use crate::error::CloudHsmClusterNotFoundError;
    /// A builder for [`CloudHsmClusterNotFoundError`](crate::error::CloudHsmClusterNotFoundError)
    #[non_exhaustive]
    #[derive(Debug, Clone, Default)]
    pub struct Builder {
        message: ::std::option::Option<::std::string::String>,
    }
    impl Builder {
        pub fn message(mut self, inp: impl Into<::std::string::String>) -> Self {
            self.message = Some(inp.into());
            self
        }
        /// Consumes the builder and constructs a [`CloudHsmClusterNotFoundError`](crate::error::CloudHsmClusterNotFoundError)
        pub fn build(self) -> CloudHsmClusterNotFoundError {
            CloudHsmClusterNotFoundError {
                message: self.message,
            }
        }
    }
}
impl CloudHsmClusterNotFoundError {
    /// Creates a new builder-style object to manufacture [`CloudHsmClusterNotFoundError`](crate::error::CloudHsmClusterNotFoundError)
    pub fn builder() -> crate::error::cloud_hsm_cluster_not_found_error::Builder {
        crate::error::cloud_hsm_cluster_not_found_error::Builder::default()
    }
}

/// <p>The request was rejected because the AWS CloudHSM cluster that is associated with the custom key
/// store is not active. Initialize and activate the cluster and try the command again. For
/// detailed instructions, see <a href="https://docs.aws.amazon.com/cloudhsm/latest/userguide/getting-started.html">Getting Started</a> in the <i>AWS CloudHSM User Guide</i>.</p>
#[non_exhaustive]
#[derive(::serde::Deserialize, ::serde::Serialize, ::std::clone::Clone, ::std::cmp::PartialEq)]
pub struct CloudHsmClusterNotActiveError {
    #[serde(rename = "message")]
    #[serde(skip_serializing_if = "Option::is_none")]
    #[serde(default)]
    pub message: ::std::option::Option<::std::string::String>,
}
impl ::std::fmt::Debug for CloudHsmClusterNotActiveError {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        let mut formatter = f.debug_struct("CloudHsmClusterNotActiveError");
        formatter.field("message", &self.message);
        formatter.finish()
    }
}
impl CloudHsmClusterNotActiveError {
    pub fn code(&self) -> &str {
        "CloudHsmClusterNotActiveException"
    }
    pub fn message(&self) -> Option<&str> {
        self.message.as_deref()
    }
}
impl ::std::fmt::Display for CloudHsmClusterNotActiveError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "CloudHsmClusterNotActiveError")?;
        if let Some(inner_16) = &self.message {
            write!(f, ": {}", inner_16)?;
        }
        Ok(())
    }
}
impl ::std::error::Error for CloudHsmClusterNotActiveError {}
/// See [`CloudHsmClusterNotActiveError`](crate::error::CloudHsmClusterNotActiveError)
pub mod cloud_hsm_cluster_not_active_error {

    use crate::error::CloudHsmClusterNotActiveError;
    /// A builder for [`CloudHsmClusterNotActiveError`](crate::error::CloudHsmClusterNotActiveError)
    #[non_exhaustive]
    #[derive(Debug, Clone, Default)]
    pub struct Builder {
        message: ::std::option::Option<::std::string::String>,
    }
    impl Builder {
        pub fn message(mut self, inp: impl Into<::std::string::String>) -> Self {
            self.message = Some(inp.into());
            self
        }
        /// Consumes the builder and constructs a [`CloudHsmClusterNotActiveError`](crate::error::CloudHsmClusterNotActiveError)
        pub fn build(self) -> CloudHsmClusterNotActiveError {
            CloudHsmClusterNotActiveError {
                message: self.message,
            }
        }
    }
}
impl CloudHsmClusterNotActiveError {
    /// Creates a new builder-style object to manufacture [`CloudHsmClusterNotActiveError`](crate::error::CloudHsmClusterNotActiveError)
    pub fn builder() -> crate::error::cloud_hsm_cluster_not_active_error::Builder {
        crate::error::cloud_hsm_cluster_not_active_error::Builder::default()
    }
}

/// <p>The request was rejected because the associated AWS CloudHSM cluster did not meet the
/// configuration requirements for a custom key store.</p>
/// <ul>
/// <li>
/// <p>The cluster must be configured with private subnets in at least two different
/// Availability Zones in the Region.</p>
/// </li>
/// <li>
/// <p>The <a href="https://docs.aws.amazon.com/cloudhsm/latest/userguide/configure-sg.html">security group for
/// the cluster</a> (cloudhsm-cluster-<i><cluster-id></i>-sg) must
/// include inbound rules and outbound rules that allow TCP traffic on ports 2223-2225. The
/// <b>Source</b> in the inbound rules and the <b>Destination</b> in the outbound rules must match the security group
/// ID. These rules are set by default when you create the cluster. Do not delete or change
/// them. To get information about a particular security group, use the <a href="https://docs.aws.amazon.com/AWSEC2/latest/APIReference/API_DescribeSecurityGroups.html">DescribeSecurityGroups</a> operation.</p>
/// </li>
/// <li>
/// <p>The cluster must contain at least as many HSMs as the operation requires. To add HSMs,
/// use the AWS CloudHSM <a href="https://docs.aws.amazon.com/cloudhsm/latest/APIReference/API_CreateHsm.html">CreateHsm</a> operation.</p>
/// <p>For the <a>CreateCustomKeyStore</a>, <a>UpdateCustomKeyStore</a>, and <a>CreateKey</a> operations, the AWS CloudHSM cluster must have at least two
/// active HSMs, each in a different Availability Zone. For the <a>ConnectCustomKeyStore</a> operation, the AWS CloudHSM must contain at least one active
/// HSM.</p>
/// </li>
/// </ul>
/// <p>For information about the requirements for an AWS CloudHSM cluster that is associated with a
/// custom key store, see <a href="https://docs.aws.amazon.com/kms/latest/developerguide/create-keystore.html#before-keystore">Assemble the Prerequisites</a>
/// in the <i>AWS Key Management Service Developer Guide</i>. For information about creating a private subnet for an AWS CloudHSM cluster,
/// see <a href="https://docs.aws.amazon.com/cloudhsm/latest/userguide/create-subnets.html">Create a Private
/// Subnet</a> in the <i>AWS CloudHSM User Guide</i>. For information about cluster security groups, see
/// <a href="https://docs.aws.amazon.com/cloudhsm/latest/userguide/configure-sg.html">Configure a Default Security
/// Group</a> in the <i>
/// <i>AWS CloudHSM User Guide</i>
/// </i>. </p>
#[non_exhaustive]
#[derive(::serde::Deserialize, ::serde::Serialize, ::std::clone::Clone, ::std::cmp::PartialEq)]
pub struct CloudHsmClusterInvalidConfigurationError {
    #[serde(rename = "message")]
    #[serde(skip_serializing_if = "Option::is_none")]
    #[serde(default)]
    pub message: ::std::option::Option<::std::string::String>,
}
impl ::std::fmt::Debug for CloudHsmClusterInvalidConfigurationError {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        let mut formatter = f.debug_struct("CloudHsmClusterInvalidConfigurationError");
        formatter.field("message", &self.message);
        formatter.finish()
    }
}
impl CloudHsmClusterInvalidConfigurationError {
    pub fn code(&self) -> &str {
        "CloudHsmClusterInvalidConfigurationException"
    }
    pub fn message(&self) -> Option<&str> {
        self.message.as_deref()
    }
}
impl ::std::fmt::Display for CloudHsmClusterInvalidConfigurationError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "CloudHsmClusterInvalidConfigurationError")?;
        if let Some(inner_17) = &self.message {
            write!(f, ": {}", inner_17)?;
        }
        Ok(())
    }
}
impl ::std::error::Error for CloudHsmClusterInvalidConfigurationError {}
/// See [`CloudHsmClusterInvalidConfigurationError`](crate::error::CloudHsmClusterInvalidConfigurationError)
pub mod cloud_hsm_cluster_invalid_configuration_error {

    use crate::error::CloudHsmClusterInvalidConfigurationError;
    /// A builder for [`CloudHsmClusterInvalidConfigurationError`](crate::error::CloudHsmClusterInvalidConfigurationError)
    #[non_exhaustive]
    #[derive(Debug, Clone, Default)]
    pub struct Builder {
        message: ::std::option::Option<::std::string::String>,
    }
    impl Builder {
        pub fn message(mut self, inp: impl Into<::std::string::String>) -> Self {
            self.message = Some(inp.into());
            self
        }
        /// Consumes the builder and constructs a [`CloudHsmClusterInvalidConfigurationError`](crate::error::CloudHsmClusterInvalidConfigurationError)
        pub fn build(self) -> CloudHsmClusterInvalidConfigurationError {
            CloudHsmClusterInvalidConfigurationError {
                message: self.message,
            }
        }
    }
}
impl CloudHsmClusterInvalidConfigurationError {
    /// Creates a new builder-style object to manufacture [`CloudHsmClusterInvalidConfigurationError`](crate::error::CloudHsmClusterInvalidConfigurationError)
    pub fn builder() -> crate::error::cloud_hsm_cluster_invalid_configuration_error::Builder {
        crate::error::cloud_hsm_cluster_invalid_configuration_error::Builder::default()
    }
}

/// <p>The request was rejected because a quota was exceeded. For more information, see <a href="https://docs.aws.amazon.com/kms/latest/developerguide/limits.html">Quotas</a> in the
/// <i>AWS Key Management Service Developer Guide</i>.</p>
#[non_exhaustive]
#[derive(::serde::Deserialize, ::serde::Serialize, ::std::clone::Clone, ::std::cmp::PartialEq)]
pub struct LimitExceededError {
    #[serde(rename = "message")]
    #[serde(skip_serializing_if = "Option::is_none")]
    #[serde(default)]
    pub message: ::std::option::Option<::std::string::String>,
}
impl ::std::fmt::Debug for LimitExceededError {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        let mut formatter = f.debug_struct("LimitExceededError");
        formatter.field("message", &self.message);
        formatter.finish()
    }
}
impl LimitExceededError {
    pub fn code(&self) -> &str {
        "LimitExceededException"
    }
    pub fn message(&self) -> Option<&str> {
        self.message.as_deref()
    }
}
impl ::std::fmt::Display for LimitExceededError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "LimitExceededError")?;
        if let Some(inner_18) = &self.message {
            write!(f, ": {}", inner_18)?;
        }
        Ok(())
    }
}
impl ::std::error::Error for LimitExceededError {}
/// See [`LimitExceededError`](crate::error::LimitExceededError)
pub mod limit_exceeded_error {

    use crate::error::LimitExceededError;
    /// A builder for [`LimitExceededError`](crate::error::LimitExceededError)
    #[non_exhaustive]
    #[derive(Debug, Clone, Default)]
    pub struct Builder {
        message: ::std::option::Option<::std::string::String>,
    }
    impl Builder {
        pub fn message(mut self, inp: impl Into<::std::string::String>) -> Self {
            self.message = Some(inp.into());
            self
        }
        /// Consumes the builder and constructs a [`LimitExceededError`](crate::error::LimitExceededError)
        pub fn build(self) -> LimitExceededError {
            LimitExceededError {
                message: self.message,
            }
        }
    }
}
impl LimitExceededError {
    /// Creates a new builder-style object to manufacture [`LimitExceededError`](crate::error::LimitExceededError)
    pub fn builder() -> crate::error::limit_exceeded_error::Builder {
        crate::error::limit_exceeded_error::Builder::default()
    }
}

/// <p>The request was rejected because one or more tags are not valid.</p>
#[non_exhaustive]
#[derive(::serde::Deserialize, ::serde::Serialize, ::std::clone::Clone, ::std::cmp::PartialEq)]
pub struct TagError {
    #[serde(rename = "message")]
    #[serde(skip_serializing_if = "Option::is_none")]
    #[serde(default)]
    pub message: ::std::option::Option<::std::string::String>,
}
impl ::std::fmt::Debug for TagError {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        let mut formatter = f.debug_struct("TagError");
        formatter.field("message", &self.message);
        formatter.finish()
    }
}
impl TagError {
    pub fn code(&self) -> &str {
        "TagException"
    }
    pub fn message(&self) -> Option<&str> {
        self.message.as_deref()
    }
}
impl ::std::fmt::Display for TagError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "TagError")?;
        if let Some(inner_19) = &self.message {
            write!(f, ": {}", inner_19)?;
        }
        Ok(())
    }
}
impl ::std::error::Error for TagError {}
/// See [`TagError`](crate::error::TagError)
pub mod tag_error {

    use crate::error::TagError;
    /// A builder for [`TagError`](crate::error::TagError)
    #[non_exhaustive]
    #[derive(Debug, Clone, Default)]
    pub struct Builder {
        message: ::std::option::Option<::std::string::String>,
    }
    impl Builder {
        pub fn message(mut self, inp: impl Into<::std::string::String>) -> Self {
            self.message = Some(inp.into());
            self
        }
        /// Consumes the builder and constructs a [`TagError`](crate::error::TagError)
        pub fn build(self) -> TagError {
            TagError {
                message: self.message,
            }
        }
    }
}
impl TagError {
    /// Creates a new builder-style object to manufacture [`TagError`](crate::error::TagError)
    pub fn builder() -> crate::error::tag_error::Builder {
        crate::error::tag_error::Builder::default()
    }
}

/// <p>The request was rejected because the specified <code>GrantId</code> is not valid.</p>
#[non_exhaustive]
#[derive(::serde::Deserialize, ::serde::Serialize, ::std::clone::Clone, ::std::cmp::PartialEq)]
pub struct InvalidGrantIdError {
    #[serde(rename = "message")]
    #[serde(skip_serializing_if = "Option::is_none")]
    #[serde(default)]
    pub message: ::std::option::Option<::std::string::String>,
}
impl ::std::fmt::Debug for InvalidGrantIdError {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        let mut formatter = f.debug_struct("InvalidGrantIdError");
        formatter.field("message", &self.message);
        formatter.finish()
    }
}
impl InvalidGrantIdError {
    pub fn code(&self) -> &str {
        "InvalidGrantIdException"
    }
    pub fn message(&self) -> Option<&str> {
        self.message.as_deref()
    }
}
impl ::std::fmt::Display for InvalidGrantIdError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "InvalidGrantIdError")?;
        if let Some(inner_20) = &self.message {
            write!(f, ": {}", inner_20)?;
        }
        Ok(())
    }
}
impl ::std::error::Error for InvalidGrantIdError {}
/// See [`InvalidGrantIdError`](crate::error::InvalidGrantIdError)
pub mod invalid_grant_id_error {

    use crate::error::InvalidGrantIdError;
    /// A builder for [`InvalidGrantIdError`](crate::error::InvalidGrantIdError)
    #[non_exhaustive]
    #[derive(Debug, Clone, Default)]
    pub struct Builder {
        message: ::std::option::Option<::std::string::String>,
    }
    impl Builder {
        pub fn message(mut self, inp: impl Into<::std::string::String>) -> Self {
            self.message = Some(inp.into());
            self
        }
        /// Consumes the builder and constructs a [`InvalidGrantIdError`](crate::error::InvalidGrantIdError)
        pub fn build(self) -> InvalidGrantIdError {
            InvalidGrantIdError {
                message: self.message,
            }
        }
    }
}
impl InvalidGrantIdError {
    /// Creates a new builder-style object to manufacture [`InvalidGrantIdError`](crate::error::InvalidGrantIdError)
    pub fn builder() -> crate::error::invalid_grant_id_error::Builder {
        crate::error::invalid_grant_id_error::Builder::default()
    }
}

/// <p>From the <a>Decrypt</a> or <a>ReEncrypt</a> operation, the request
/// was rejected because the specified ciphertext, or additional authenticated data incorporated
/// into the ciphertext, such as the encryption context, is corrupted, missing, or otherwise
/// invalid.</p>
/// <p>From the <a>ImportKeyMaterial</a> operation, the request was rejected because
/// AWS KMS could not decrypt the encrypted (wrapped) key material. </p>
#[non_exhaustive]
#[derive(::serde::Deserialize, ::serde::Serialize, ::std::clone::Clone, ::std::cmp::PartialEq)]
pub struct InvalidCiphertextError {
    #[serde(rename = "message")]
    #[serde(skip_serializing_if = "Option::is_none")]
    #[serde(default)]
    pub message: ::std::option::Option<::std::string::String>,
}
impl ::std::fmt::Debug for InvalidCiphertextError {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        let mut formatter = f.debug_struct("InvalidCiphertextError");
        formatter.field("message", &self.message);
        formatter.finish()
    }
}
impl InvalidCiphertextError {
    pub fn code(&self) -> &str {
        "InvalidCiphertextException"
    }
    pub fn message(&self) -> Option<&str> {
        self.message.as_deref()
    }
}
impl ::std::fmt::Display for InvalidCiphertextError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "InvalidCiphertextError")?;
        if let Some(inner_21) = &self.message {
            write!(f, ": {}", inner_21)?;
        }
        Ok(())
    }
}
impl ::std::error::Error for InvalidCiphertextError {}
/// See [`InvalidCiphertextError`](crate::error::InvalidCiphertextError)
pub mod invalid_ciphertext_error {

    use crate::error::InvalidCiphertextError;
    /// A builder for [`InvalidCiphertextError`](crate::error::InvalidCiphertextError)
    #[non_exhaustive]
    #[derive(Debug, Clone, Default)]
    pub struct Builder {
        message: ::std::option::Option<::std::string::String>,
    }
    impl Builder {
        pub fn message(mut self, inp: impl Into<::std::string::String>) -> Self {
            self.message = Some(inp.into());
            self
        }
        /// Consumes the builder and constructs a [`InvalidCiphertextError`](crate::error::InvalidCiphertextError)
        pub fn build(self) -> InvalidCiphertextError {
            InvalidCiphertextError {
                message: self.message,
            }
        }
    }
}
impl InvalidCiphertextError {
    /// Creates a new builder-style object to manufacture [`InvalidCiphertextError`](crate::error::InvalidCiphertextError)
    pub fn builder() -> crate::error::invalid_ciphertext_error::Builder {
        crate::error::invalid_ciphertext_error::Builder::default()
    }
}

/// <p>The request was rejected because the specified CMK cannot decrypt the data. The
/// <code>KeyId</code> in a <a>Decrypt</a> request and the <code>SourceKeyId</code>
/// in a <a>ReEncrypt</a> request must identify the same CMK that was used to encrypt
/// the ciphertext.</p>
#[non_exhaustive]
#[derive(::serde::Deserialize, ::serde::Serialize, ::std::clone::Clone, ::std::cmp::PartialEq)]
pub struct IncorrectKeyError {
    #[serde(rename = "message")]
    #[serde(skip_serializing_if = "Option::is_none")]
    #[serde(default)]
    pub message: ::std::option::Option<::std::string::String>,
}
impl ::std::fmt::Debug for IncorrectKeyError {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        let mut formatter = f.debug_struct("IncorrectKeyError");
        formatter.field("message", &self.message);
        formatter.finish()
    }
}
impl IncorrectKeyError {
    pub fn code(&self) -> &str {
        "IncorrectKeyException"
    }
    pub fn message(&self) -> Option<&str> {
        self.message.as_deref()
    }
}
impl ::std::fmt::Display for IncorrectKeyError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "IncorrectKeyError")?;
        if let Some(inner_22) = &self.message {
            write!(f, ": {}", inner_22)?;
        }
        Ok(())
    }
}
impl ::std::error::Error for IncorrectKeyError {}
/// See [`IncorrectKeyError`](crate::error::IncorrectKeyError)
pub mod incorrect_key_error {

    use crate::error::IncorrectKeyError;
    /// A builder for [`IncorrectKeyError`](crate::error::IncorrectKeyError)
    #[non_exhaustive]
    #[derive(Debug, Clone, Default)]
    pub struct Builder {
        message: ::std::option::Option<::std::string::String>,
    }
    impl Builder {
        pub fn message(mut self, inp: impl Into<::std::string::String>) -> Self {
            self.message = Some(inp.into());
            self
        }
        /// Consumes the builder and constructs a [`IncorrectKeyError`](crate::error::IncorrectKeyError)
        pub fn build(self) -> IncorrectKeyError {
            IncorrectKeyError {
                message: self.message,
            }
        }
    }
}
impl IncorrectKeyError {
    /// Creates a new builder-style object to manufacture [`IncorrectKeyError`](crate::error::IncorrectKeyError)
    pub fn builder() -> crate::error::incorrect_key_error::Builder {
        crate::error::incorrect_key_error::Builder::default()
    }
}

/// <p>The request was rejected because a specified parameter is not supported or a specified
/// resource is not valid for this operation.</p>
#[non_exhaustive]
#[derive(::serde::Deserialize, ::serde::Serialize, ::std::clone::Clone, ::std::cmp::PartialEq)]
pub struct UnsupportedOperationError {
    #[serde(rename = "message")]
    #[serde(skip_serializing_if = "Option::is_none")]
    #[serde(default)]
    pub message: ::std::option::Option<::std::string::String>,
}
impl ::std::fmt::Debug for UnsupportedOperationError {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        let mut formatter = f.debug_struct("UnsupportedOperationError");
        formatter.field("message", &self.message);
        formatter.finish()
    }
}
impl UnsupportedOperationError {
    pub fn code(&self) -> &str {
        "UnsupportedOperationException"
    }
    pub fn message(&self) -> Option<&str> {
        self.message.as_deref()
    }
}
impl ::std::fmt::Display for UnsupportedOperationError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "UnsupportedOperationError")?;
        if let Some(inner_23) = &self.message {
            write!(f, ": {}", inner_23)?;
        }
        Ok(())
    }
}
impl ::std::error::Error for UnsupportedOperationError {}
/// See [`UnsupportedOperationError`](crate::error::UnsupportedOperationError)
pub mod unsupported_operation_error {

    use crate::error::UnsupportedOperationError;
    /// A builder for [`UnsupportedOperationError`](crate::error::UnsupportedOperationError)
    #[non_exhaustive]
    #[derive(Debug, Clone, Default)]
    pub struct Builder {
        message: ::std::option::Option<::std::string::String>,
    }
    impl Builder {
        pub fn message(mut self, inp: impl Into<::std::string::String>) -> Self {
            self.message = Some(inp.into());
            self
        }
        /// Consumes the builder and constructs a [`UnsupportedOperationError`](crate::error::UnsupportedOperationError)
        pub fn build(self) -> UnsupportedOperationError {
            UnsupportedOperationError {
                message: self.message,
            }
        }
    }
}
impl UnsupportedOperationError {
    /// Creates a new builder-style object to manufacture [`UnsupportedOperationError`](crate::error::UnsupportedOperationError)
    pub fn builder() -> crate::error::unsupported_operation_error::Builder {
        crate::error::unsupported_operation_error::Builder::default()
    }
}

/// <p>The request was rejected because the specified policy is not syntactically or semantically
/// correct.</p>
#[non_exhaustive]
#[derive(::serde::Deserialize, ::serde::Serialize, ::std::clone::Clone, ::std::cmp::PartialEq)]
pub struct MalformedPolicyDocumentError {
    #[serde(rename = "message")]
    #[serde(skip_serializing_if = "Option::is_none")]
    #[serde(default)]
    pub message: ::std::option::Option<::std::string::String>,
}
impl ::std::fmt::Debug for MalformedPolicyDocumentError {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        let mut formatter = f.debug_struct("MalformedPolicyDocumentError");
        formatter.field("message", &self.message);
        formatter.finish()
    }
}
impl MalformedPolicyDocumentError {
    pub fn code(&self) -> &str {
        "MalformedPolicyDocumentException"
    }
    pub fn message(&self) -> Option<&str> {
        self.message.as_deref()
    }
}
impl ::std::fmt::Display for MalformedPolicyDocumentError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "MalformedPolicyDocumentError")?;
        if let Some(inner_24) = &self.message {
            write!(f, ": {}", inner_24)?;
        }
        Ok(())
    }
}
impl ::std::error::Error for MalformedPolicyDocumentError {}
/// See [`MalformedPolicyDocumentError`](crate::error::MalformedPolicyDocumentError)
pub mod malformed_policy_document_error {

    use crate::error::MalformedPolicyDocumentError;
    /// A builder for [`MalformedPolicyDocumentError`](crate::error::MalformedPolicyDocumentError)
    #[non_exhaustive]
    #[derive(Debug, Clone, Default)]
    pub struct Builder {
        message: ::std::option::Option<::std::string::String>,
    }
    impl Builder {
        pub fn message(mut self, inp: impl Into<::std::string::String>) -> Self {
            self.message = Some(inp.into());
            self
        }
        /// Consumes the builder and constructs a [`MalformedPolicyDocumentError`](crate::error::MalformedPolicyDocumentError)
        pub fn build(self) -> MalformedPolicyDocumentError {
            MalformedPolicyDocumentError {
                message: self.message,
            }
        }
    }
}
impl MalformedPolicyDocumentError {
    /// Creates a new builder-style object to manufacture [`MalformedPolicyDocumentError`](crate::error::MalformedPolicyDocumentError)
    pub fn builder() -> crate::error::malformed_policy_document_error::Builder {
        crate::error::malformed_policy_document_error::Builder::default()
    }
}

/// <p>The request was rejected because the marker that specifies where pagination should next
/// begin is not valid.</p>
#[non_exhaustive]
#[derive(::serde::Deserialize, ::serde::Serialize, ::std::clone::Clone, ::std::cmp::PartialEq)]
pub struct InvalidMarkerError {
    #[serde(rename = "message")]
    #[serde(skip_serializing_if = "Option::is_none")]
    #[serde(default)]
    pub message: ::std::option::Option<::std::string::String>,
}
impl ::std::fmt::Debug for InvalidMarkerError {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        let mut formatter = f.debug_struct("InvalidMarkerError");
        formatter.field("message", &self.message);
        formatter.finish()
    }
}
impl InvalidMarkerError {
    pub fn code(&self) -> &str {
        "InvalidMarkerException"
    }
    pub fn message(&self) -> Option<&str> {
        self.message.as_deref()
    }
}
impl ::std::fmt::Display for InvalidMarkerError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "InvalidMarkerError")?;
        if let Some(inner_25) = &self.message {
            write!(f, ": {}", inner_25)?;
        }
        Ok(())
    }
}
impl ::std::error::Error for InvalidMarkerError {}
/// See [`InvalidMarkerError`](crate::error::InvalidMarkerError)
pub mod invalid_marker_error {

    use crate::error::InvalidMarkerError;
    /// A builder for [`InvalidMarkerError`](crate::error::InvalidMarkerError)
    #[non_exhaustive]
    #[derive(Debug, Clone, Default)]
    pub struct Builder {
        message: ::std::option::Option<::std::string::String>,
    }
    impl Builder {
        pub fn message(mut self, inp: impl Into<::std::string::String>) -> Self {
            self.message = Some(inp.into());
            self
        }
        /// Consumes the builder and constructs a [`InvalidMarkerError`](crate::error::InvalidMarkerError)
        pub fn build(self) -> InvalidMarkerError {
            InvalidMarkerError {
                message: self.message,
            }
        }
    }
}
impl InvalidMarkerError {
    /// Creates a new builder-style object to manufacture [`InvalidMarkerError`](crate::error::InvalidMarkerError)
    pub fn builder() -> crate::error::invalid_marker_error::Builder {
        crate::error::invalid_marker_error::Builder::default()
    }
}

/// <p>The request was rejected because the provided import token is invalid or is associated
/// with a different customer master key (CMK).</p>
#[non_exhaustive]
#[derive(::serde::Deserialize, ::serde::Serialize, ::std::clone::Clone, ::std::cmp::PartialEq)]
pub struct InvalidImportTokenError {
    #[serde(rename = "message")]
    #[serde(skip_serializing_if = "Option::is_none")]
    #[serde(default)]
    pub message: ::std::option::Option<::std::string::String>,
}
impl ::std::fmt::Debug for InvalidImportTokenError {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        let mut formatter = f.debug_struct("InvalidImportTokenError");
        formatter.field("message", &self.message);
        formatter.finish()
    }
}
impl InvalidImportTokenError {
    pub fn code(&self) -> &str {
        "InvalidImportTokenException"
    }
    pub fn message(&self) -> Option<&str> {
        self.message.as_deref()
    }
}
impl ::std::fmt::Display for InvalidImportTokenError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "InvalidImportTokenError")?;
        if let Some(inner_26) = &self.message {
            write!(f, ": {}", inner_26)?;
        }
        Ok(())
    }
}
impl ::std::error::Error for InvalidImportTokenError {}
/// See [`InvalidImportTokenError`](crate::error::InvalidImportTokenError)
pub mod invalid_import_token_error {

    use crate::error::InvalidImportTokenError;
    /// A builder for [`InvalidImportTokenError`](crate::error::InvalidImportTokenError)
    #[non_exhaustive]
    #[derive(Debug, Clone, Default)]
    pub struct Builder {
        message: ::std::option::Option<::std::string::String>,
    }
    impl Builder {
        pub fn message(mut self, inp: impl Into<::std::string::String>) -> Self {
            self.message = Some(inp.into());
            self
        }
        /// Consumes the builder and constructs a [`InvalidImportTokenError`](crate::error::InvalidImportTokenError)
        pub fn build(self) -> InvalidImportTokenError {
            InvalidImportTokenError {
                message: self.message,
            }
        }
    }
}
impl InvalidImportTokenError {
    /// Creates a new builder-style object to manufacture [`InvalidImportTokenError`](crate::error::InvalidImportTokenError)
    pub fn builder() -> crate::error::invalid_import_token_error::Builder {
        crate::error::invalid_import_token_error::Builder::default()
    }
}

/// <p>The request was rejected because the key material in the request is, expired, invalid, or
/// is not the same key material that was previously imported into this customer master key
/// (CMK).</p>
#[non_exhaustive]
#[derive(::serde::Deserialize, ::serde::Serialize, ::std::clone::Clone, ::std::cmp::PartialEq)]
pub struct IncorrectKeyMaterialError {
    #[serde(rename = "message")]
    #[serde(skip_serializing_if = "Option::is_none")]
    #[serde(default)]
    pub message: ::std::option::Option<::std::string::String>,
}
impl ::std::fmt::Debug for IncorrectKeyMaterialError {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        let mut formatter = f.debug_struct("IncorrectKeyMaterialError");
        formatter.field("message", &self.message);
        formatter.finish()
    }
}
impl IncorrectKeyMaterialError {
    pub fn code(&self) -> &str {
        "IncorrectKeyMaterialException"
    }
    pub fn message(&self) -> Option<&str> {
        self.message.as_deref()
    }
}
impl ::std::fmt::Display for IncorrectKeyMaterialError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "IncorrectKeyMaterialError")?;
        if let Some(inner_27) = &self.message {
            write!(f, ": {}", inner_27)?;
        }
        Ok(())
    }
}
impl ::std::error::Error for IncorrectKeyMaterialError {}
/// See [`IncorrectKeyMaterialError`](crate::error::IncorrectKeyMaterialError)
pub mod incorrect_key_material_error {

    use crate::error::IncorrectKeyMaterialError;
    /// A builder for [`IncorrectKeyMaterialError`](crate::error::IncorrectKeyMaterialError)
    #[non_exhaustive]
    #[derive(Debug, Clone, Default)]
    pub struct Builder {
        message: ::std::option::Option<::std::string::String>,
    }
    impl Builder {
        pub fn message(mut self, inp: impl Into<::std::string::String>) -> Self {
            self.message = Some(inp.into());
            self
        }
        /// Consumes the builder and constructs a [`IncorrectKeyMaterialError`](crate::error::IncorrectKeyMaterialError)
        pub fn build(self) -> IncorrectKeyMaterialError {
            IncorrectKeyMaterialError {
                message: self.message,
            }
        }
    }
}
impl IncorrectKeyMaterialError {
    /// Creates a new builder-style object to manufacture [`IncorrectKeyMaterialError`](crate::error::IncorrectKeyMaterialError)
    pub fn builder() -> crate::error::incorrect_key_material_error::Builder {
        crate::error::incorrect_key_material_error::Builder::default()
    }
}

/// <p>The request was rejected because the specified import token is expired. Use <a>GetParametersForImport</a> to get a new import token and public key, use the new
/// public key to encrypt the key material, and then try the request again.</p>
#[non_exhaustive]
#[derive(::serde::Deserialize, ::serde::Serialize, ::std::clone::Clone, ::std::cmp::PartialEq)]
pub struct ExpiredImportTokenError {
    #[serde(rename = "message")]
    #[serde(skip_serializing_if = "Option::is_none")]
    #[serde(default)]
    pub message: ::std::option::Option<::std::string::String>,
}
impl ::std::fmt::Debug for ExpiredImportTokenError {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        let mut formatter = f.debug_struct("ExpiredImportTokenError");
        formatter.field("message", &self.message);
        formatter.finish()
    }
}
impl ExpiredImportTokenError {
    pub fn code(&self) -> &str {
        "ExpiredImportTokenException"
    }
    pub fn message(&self) -> Option<&str> {
        self.message.as_deref()
    }
}
impl ::std::fmt::Display for ExpiredImportTokenError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "ExpiredImportTokenError")?;
        if let Some(inner_28) = &self.message {
            write!(f, ": {}", inner_28)?;
        }
        Ok(())
    }
}
impl ::std::error::Error for ExpiredImportTokenError {}
/// See [`ExpiredImportTokenError`](crate::error::ExpiredImportTokenError)
pub mod expired_import_token_error {

    use crate::error::ExpiredImportTokenError;
    /// A builder for [`ExpiredImportTokenError`](crate::error::ExpiredImportTokenError)
    #[non_exhaustive]
    #[derive(Debug, Clone, Default)]
    pub struct Builder {
        message: ::std::option::Option<::std::string::String>,
    }
    impl Builder {
        pub fn message(mut self, inp: impl Into<::std::string::String>) -> Self {
            self.message = Some(inp.into());
            self
        }
        /// Consumes the builder and constructs a [`ExpiredImportTokenError`](crate::error::ExpiredImportTokenError)
        pub fn build(self) -> ExpiredImportTokenError {
            ExpiredImportTokenError {
                message: self.message,
            }
        }
    }
}
impl ExpiredImportTokenError {
    /// Creates a new builder-style object to manufacture [`ExpiredImportTokenError`](crate::error::ExpiredImportTokenError)
    pub fn builder() -> crate::error::expired_import_token_error::Builder {
        crate::error::expired_import_token_error::Builder::default()
    }
}

/// <p>The request was rejected because the custom key store contains AWS KMS customer master keys
/// (CMKs). After verifying that you do not need to use the CMKs, use the <a>ScheduleKeyDeletion</a> operation to delete the CMKs. After they are deleted, you
/// can delete the custom key store.</p>
#[non_exhaustive]
#[derive(::serde::Deserialize, ::serde::Serialize, ::std::clone::Clone, ::std::cmp::PartialEq)]
pub struct CustomKeyStoreHasCMKsError {
    #[serde(rename = "message")]
    #[serde(skip_serializing_if = "Option::is_none")]
    #[serde(default)]
    pub message: ::std::option::Option<::std::string::String>,
}
impl ::std::fmt::Debug for CustomKeyStoreHasCMKsError {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        let mut formatter = f.debug_struct("CustomKeyStoreHasCMKsError");
        formatter.field("message", &self.message);
        formatter.finish()
    }
}
impl CustomKeyStoreHasCMKsError {
    pub fn code(&self) -> &str {
        "CustomKeyStoreHasCMKsException"
    }
    pub fn message(&self) -> Option<&str> {
        self.message.as_deref()
    }
}
impl ::std::fmt::Display for CustomKeyStoreHasCMKsError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "CustomKeyStoreHasCMKsError")?;
        if let Some(inner_29) = &self.message {
            write!(f, ": {}", inner_29)?;
        }
        Ok(())
    }
}
impl ::std::error::Error for CustomKeyStoreHasCMKsError {}
/// See [`CustomKeyStoreHasCMKsError`](crate::error::CustomKeyStoreHasCMKsError)
pub mod custom_key_store_has_cm_ks_error {

    use crate::error::CustomKeyStoreHasCMKsError;
    /// A builder for [`CustomKeyStoreHasCMKsError`](crate::error::CustomKeyStoreHasCMKsError)
    #[non_exhaustive]
    #[derive(Debug, Clone, Default)]
    pub struct Builder {
        message: ::std::option::Option<::std::string::String>,
    }
    impl Builder {
        pub fn message(mut self, inp: impl Into<::std::string::String>) -> Self {
            self.message = Some(inp.into());
            self
        }
        /// Consumes the builder and constructs a [`CustomKeyStoreHasCMKsError`](crate::error::CustomKeyStoreHasCMKsError)
        pub fn build(self) -> CustomKeyStoreHasCMKsError {
            CustomKeyStoreHasCMKsError {
                message: self.message,
            }
        }
    }
}
impl CustomKeyStoreHasCMKsError {
    /// Creates a new builder-style object to manufacture [`CustomKeyStoreHasCMKsError`](crate::error::CustomKeyStoreHasCMKsError)
    pub fn builder() -> crate::error::custom_key_store_has_cm_ks_error::Builder {
        crate::error::custom_key_store_has_cm_ks_error::Builder::default()
    }
}

/// <p>The request was rejected because the trust anchor certificate in the request is not the
/// trust anchor certificate for the specified AWS CloudHSM cluster.</p>
/// <p>When you <a href="https://docs.aws.amazon.com/cloudhsm/latest/userguide/initialize-cluster.html#sign-csr">initialize the cluster</a>, you create the trust anchor certificate and save it in the
/// <code>customerCA.crt</code> file.</p>
#[non_exhaustive]
#[derive(::serde::Deserialize, ::serde::Serialize, ::std::clone::Clone, ::std::cmp::PartialEq)]
pub struct IncorrectTrustAnchorError {
    #[serde(rename = "message")]
    #[serde(skip_serializing_if = "Option::is_none")]
    #[serde(default)]
    pub message: ::std::option::Option<::std::string::String>,
}
impl ::std::fmt::Debug for IncorrectTrustAnchorError {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        let mut formatter = f.debug_struct("IncorrectTrustAnchorError");
        formatter.field("message", &self.message);
        formatter.finish()
    }
}
impl IncorrectTrustAnchorError {
    pub fn code(&self) -> &str {
        "IncorrectTrustAnchorException"
    }
    pub fn message(&self) -> Option<&str> {
        self.message.as_deref()
    }
}
impl ::std::fmt::Display for IncorrectTrustAnchorError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "IncorrectTrustAnchorError")?;
        if let Some(inner_30) = &self.message {
            write!(f, ": {}", inner_30)?;
        }
        Ok(())
    }
}
impl ::std::error::Error for IncorrectTrustAnchorError {}
/// See [`IncorrectTrustAnchorError`](crate::error::IncorrectTrustAnchorError)
pub mod incorrect_trust_anchor_error {

    use crate::error::IncorrectTrustAnchorError;
    /// A builder for [`IncorrectTrustAnchorError`](crate::error::IncorrectTrustAnchorError)
    #[non_exhaustive]
    #[derive(Debug, Clone, Default)]
    pub struct Builder {
        message: ::std::option::Option<::std::string::String>,
    }
    impl Builder {
        pub fn message(mut self, inp: impl Into<::std::string::String>) -> Self {
            self.message = Some(inp.into());
            self
        }
        /// Consumes the builder and constructs a [`IncorrectTrustAnchorError`](crate::error::IncorrectTrustAnchorError)
        pub fn build(self) -> IncorrectTrustAnchorError {
            IncorrectTrustAnchorError {
                message: self.message,
            }
        }
    }
}
impl IncorrectTrustAnchorError {
    /// Creates a new builder-style object to manufacture [`IncorrectTrustAnchorError`](crate::error::IncorrectTrustAnchorError)
    pub fn builder() -> crate::error::incorrect_trust_anchor_error::Builder {
        crate::error::incorrect_trust_anchor_error::Builder::default()
    }
}

/// <p>The request was rejected because the specified AWS CloudHSM cluster is already associated with a
/// custom key store or it shares a backup history with a cluster that is associated with a custom
/// key store. Each custom key store must be associated with a different AWS CloudHSM cluster.</p>
/// <p>Clusters that share a backup history have the same cluster certificate. To view the
/// cluster certificate of a cluster, use the <a href="https://docs.aws.amazon.com/cloudhsm/latest/APIReference/API_DescribeClusters.html">DescribeClusters</a> operation.</p>
#[non_exhaustive]
#[derive(::serde::Deserialize, ::serde::Serialize, ::std::clone::Clone, ::std::cmp::PartialEq)]
pub struct CloudHsmClusterInUseError {
    #[serde(rename = "message")]
    #[serde(skip_serializing_if = "Option::is_none")]
    #[serde(default)]
    pub message: ::std::option::Option<::std::string::String>,
}
impl ::std::fmt::Debug for CloudHsmClusterInUseError {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        let mut formatter = f.debug_struct("CloudHsmClusterInUseError");
        formatter.field("message", &self.message);
        formatter.finish()
    }
}
impl CloudHsmClusterInUseError {
    pub fn code(&self) -> &str {
        "CloudHsmClusterInUseException"
    }
    pub fn message(&self) -> Option<&str> {
        self.message.as_deref()
    }
}
impl ::std::fmt::Display for CloudHsmClusterInUseError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "CloudHsmClusterInUseError")?;
        if let Some(inner_31) = &self.message {
            write!(f, ": {}", inner_31)?;
        }
        Ok(())
    }
}
impl ::std::error::Error for CloudHsmClusterInUseError {}
/// See [`CloudHsmClusterInUseError`](crate::error::CloudHsmClusterInUseError)
pub mod cloud_hsm_cluster_in_use_error {

    use crate::error::CloudHsmClusterInUseError;
    /// A builder for [`CloudHsmClusterInUseError`](crate::error::CloudHsmClusterInUseError)
    #[non_exhaustive]
    #[derive(Debug, Clone, Default)]
    pub struct Builder {
        message: ::std::option::Option<::std::string::String>,
    }
    impl Builder {
        pub fn message(mut self, inp: impl Into<::std::string::String>) -> Self {
            self.message = Some(inp.into());
            self
        }
        /// Consumes the builder and constructs a [`CloudHsmClusterInUseError`](crate::error::CloudHsmClusterInUseError)
        pub fn build(self) -> CloudHsmClusterInUseError {
            CloudHsmClusterInUseError {
                message: self.message,
            }
        }
    }
}
impl CloudHsmClusterInUseError {
    /// Creates a new builder-style object to manufacture [`CloudHsmClusterInUseError`](crate::error::CloudHsmClusterInUseError)
    pub fn builder() -> crate::error::cloud_hsm_cluster_in_use_error::Builder {
        crate::error::cloud_hsm_cluster_in_use_error::Builder::default()
    }
}

/// <p>The request was rejected because the specified alias name is not valid.</p>
#[non_exhaustive]
#[derive(::serde::Deserialize, ::serde::Serialize, ::std::clone::Clone, ::std::cmp::PartialEq)]
pub struct InvalidAliasNameError {
    #[serde(rename = "message")]
    #[serde(skip_serializing_if = "Option::is_none")]
    #[serde(default)]
    pub message: ::std::option::Option<::std::string::String>,
}
impl ::std::fmt::Debug for InvalidAliasNameError {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        let mut formatter = f.debug_struct("InvalidAliasNameError");
        formatter.field("message", &self.message);
        formatter.finish()
    }
}
impl InvalidAliasNameError {
    pub fn code(&self) -> &str {
        "InvalidAliasNameException"
    }
    pub fn message(&self) -> Option<&str> {
        self.message.as_deref()
    }
}
impl ::std::fmt::Display for InvalidAliasNameError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "InvalidAliasNameError")?;
        if let Some(inner_32) = &self.message {
            write!(f, ": {}", inner_32)?;
        }
        Ok(())
    }
}
impl ::std::error::Error for InvalidAliasNameError {}
/// See [`InvalidAliasNameError`](crate::error::InvalidAliasNameError)
pub mod invalid_alias_name_error {

    use crate::error::InvalidAliasNameError;
    /// A builder for [`InvalidAliasNameError`](crate::error::InvalidAliasNameError)
    #[non_exhaustive]
    #[derive(Debug, Clone, Default)]
    pub struct Builder {
        message: ::std::option::Option<::std::string::String>,
    }
    impl Builder {
        pub fn message(mut self, inp: impl Into<::std::string::String>) -> Self {
            self.message = Some(inp.into());
            self
        }
        /// Consumes the builder and constructs a [`InvalidAliasNameError`](crate::error::InvalidAliasNameError)
        pub fn build(self) -> InvalidAliasNameError {
            InvalidAliasNameError {
                message: self.message,
            }
        }
    }
}
impl InvalidAliasNameError {
    /// Creates a new builder-style object to manufacture [`InvalidAliasNameError`](crate::error::InvalidAliasNameError)
    pub fn builder() -> crate::error::invalid_alias_name_error::Builder {
        crate::error::invalid_alias_name_error::Builder::default()
    }
}

/// <p>The request was rejected because it attempted to create a resource that already
/// exists.</p>
#[non_exhaustive]
#[derive(::serde::Deserialize, ::serde::Serialize, ::std::clone::Clone, ::std::cmp::PartialEq)]
pub struct AlreadyExistsError {
    #[serde(rename = "message")]
    #[serde(skip_serializing_if = "Option::is_none")]
    #[serde(default)]
    pub message: ::std::option::Option<::std::string::String>,
}
impl ::std::fmt::Debug for AlreadyExistsError {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        let mut formatter = f.debug_struct("AlreadyExistsError");
        formatter.field("message", &self.message);
        formatter.finish()
    }
}
impl AlreadyExistsError {
    pub fn code(&self) -> &str {
        "AlreadyExistsException"
    }
    pub fn message(&self) -> Option<&str> {
        self.message.as_deref()
    }
}
impl ::std::fmt::Display for AlreadyExistsError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "AlreadyExistsError")?;
        if let Some(inner_33) = &self.message {
            write!(f, ": {}", inner_33)?;
        }
        Ok(())
    }
}
impl ::std::error::Error for AlreadyExistsError {}
/// See [`AlreadyExistsError`](crate::error::AlreadyExistsError)
pub mod already_exists_error {

    use crate::error::AlreadyExistsError;
    /// A builder for [`AlreadyExistsError`](crate::error::AlreadyExistsError)
    #[non_exhaustive]
    #[derive(Debug, Clone, Default)]
    pub struct Builder {
        message: ::std::option::Option<::std::string::String>,
    }
    impl Builder {
        pub fn message(mut self, inp: impl Into<::std::string::String>) -> Self {
            self.message = Some(inp.into());
            self
        }
        /// Consumes the builder and constructs a [`AlreadyExistsError`](crate::error::AlreadyExistsError)
        pub fn build(self) -> AlreadyExistsError {
            AlreadyExistsError {
                message: self.message,
            }
        }
    }
}
impl AlreadyExistsError {
    /// Creates a new builder-style object to manufacture [`AlreadyExistsError`](crate::error::AlreadyExistsError)
    pub fn builder() -> crate::error::already_exists_error::Builder {
        crate::error::already_exists_error::Builder::default()
    }
}
