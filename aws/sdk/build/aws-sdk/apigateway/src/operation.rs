// Code generated by software.amazon.smithy.rust.codegen.smithy-rs. DO NOT EDIT.
/// <p>Create an <a>ApiKey</a> resource. </p>
/// <div class="seeAlso"><a href="https://docs.aws.amazon.com/cli/latest/reference/apigateway/create-api-key.html">AWS CLI</a></div>
#[derive(std::clone::Clone)]
pub struct CreateApiKey {
    _private: (),
}
impl CreateApiKey {
    /// Creates a new builder-style object to manufacture [`CreateApiKeyInput`](crate::input::CreateApiKeyInput)
    pub fn builder() -> crate::input::create_api_key_input::Builder {
        crate::input::create_api_key_input::Builder::default()
    }
    #[allow(clippy::unnecessary_wraps)]
    fn from_response(
        response: &http::response::Response<impl AsRef<[u8]>>,
    ) -> Result<crate::output::CreateApiKeyOutput, crate::error::CreateApiKeyError> {
        if crate::aws_json_errors::is_error(&response) && response.status().as_u16() != 201 {
            let body = serde_json::from_slice(response.body().as_ref())
                .unwrap_or_else(|_| serde_json::json!({}));
            let generic = crate::aws_json_errors::parse_generic_error(&response, &body);

            let error_code = match generic.code() {
                Some(code) => code,
                None => return Err(crate::error::CreateApiKeyError::unhandled(generic)),
            };
            return Err(match error_code {
                "BadRequestException" => crate::error::CreateApiKeyError {
                    meta: generic,
                    kind: crate::error::CreateApiKeyErrorKind::BadRequestError({
                        #[allow(unused_mut)]
                        let mut output = crate::error::bad_request_error::Builder::default();
                        let _ = response;

                        let body_slice = response.body().as_ref();

                        let parsed_body: crate::error::BadRequestError = if body_slice.is_empty() {
                            // To enable JSON parsing to succeed, replace an empty body
                            // with an empty JSON body. If a member was required, it will fail slightly later
                            // during the operation construction phase.
                            serde_json::from_slice(b"{}")
                                .map_err(crate::error::CreateApiKeyError::unhandled)?
                        } else {
                            serde_json::from_slice(response.body().as_ref())
                                .map_err(crate::error::CreateApiKeyError::unhandled)?
                        };

                        output = output.set_message(parsed_body.message);
                        output.build()
                    }),
                },
                "ConflictException" => crate::error::CreateApiKeyError {
                    meta: generic,
                    kind: crate::error::CreateApiKeyErrorKind::ConflictError({
                        #[allow(unused_mut)]
                        let mut output = crate::error::conflict_error::Builder::default();
                        let _ = response;

                        let body_slice = response.body().as_ref();

                        let parsed_body: crate::error::ConflictError = if body_slice.is_empty() {
                            // To enable JSON parsing to succeed, replace an empty body
                            // with an empty JSON body. If a member was required, it will fail slightly later
                            // during the operation construction phase.
                            serde_json::from_slice(b"{}")
                                .map_err(crate::error::CreateApiKeyError::unhandled)?
                        } else {
                            serde_json::from_slice(response.body().as_ref())
                                .map_err(crate::error::CreateApiKeyError::unhandled)?
                        };

                        output = output.set_message(parsed_body.message);
                        output.build()
                    }),
                },
                "LimitExceededException" => {
                    crate::error::CreateApiKeyError {
                        meta: generic,
                        kind: crate::error::CreateApiKeyErrorKind::LimitExceededError({
                            #[allow(unused_mut)]
                            let mut output = crate::error::limit_exceeded_error::Builder::default();
                            let _ = response;

                            let body_slice = response.body().as_ref();

                            let parsed_body: crate::error::LimitExceededError =
                                if body_slice.is_empty() {
                                    // To enable JSON parsing to succeed, replace an empty body
                                    // with an empty JSON body. If a member was required, it will fail slightly later
                                    // during the operation construction phase.
                                    serde_json::from_slice(b"{}")
                                        .map_err(crate::error::CreateApiKeyError::unhandled)?
                                } else {
                                    serde_json::from_slice(response.body().as_ref())
                                        .map_err(crate::error::CreateApiKeyError::unhandled)?
                                };

                            output = output.set_retry_after_seconds(
                        
                                                crate::http_serde::deser_header_create_api_key_retry_after_seconds(response.headers())
                                                    .map_err(|_|crate::error::CreateApiKeyError::unhandled("Failed to parse retryAfterSeconds from header `Retry-After"))?
                                                
                    );
                            output = output.set_message(parsed_body.message);
                            output.build()
                        }),
                    }
                }
                "NotFoundException" => crate::error::CreateApiKeyError {
                    meta: generic,
                    kind: crate::error::CreateApiKeyErrorKind::NotFoundError({
                        #[allow(unused_mut)]
                        let mut output = crate::error::not_found_error::Builder::default();
                        let _ = response;

                        let body_slice = response.body().as_ref();

                        let parsed_body: crate::error::NotFoundError = if body_slice.is_empty() {
                            // To enable JSON parsing to succeed, replace an empty body
                            // with an empty JSON body. If a member was required, it will fail slightly later
                            // during the operation construction phase.
                            serde_json::from_slice(b"{}")
                                .map_err(crate::error::CreateApiKeyError::unhandled)?
                        } else {
                            serde_json::from_slice(response.body().as_ref())
                                .map_err(crate::error::CreateApiKeyError::unhandled)?
                        };

                        output = output.set_message(parsed_body.message);
                        output.build()
                    }),
                },
                "TooManyRequestsException" => {
                    crate::error::CreateApiKeyError {
                        meta: generic,
                        kind: crate::error::CreateApiKeyErrorKind::TooManyRequestsError({
                            #[allow(unused_mut)]
                            let mut output =
                                crate::error::too_many_requests_error::Builder::default();
                            let _ = response;

                            let body_slice = response.body().as_ref();

                            let parsed_body: crate::error::TooManyRequestsError =
                                if body_slice.is_empty() {
                                    // To enable JSON parsing to succeed, replace an empty body
                                    // with an empty JSON body. If a member was required, it will fail slightly later
                                    // during the operation construction phase.
                                    serde_json::from_slice(b"{}")
                                        .map_err(crate::error::CreateApiKeyError::unhandled)?
                                } else {
                                    serde_json::from_slice(response.body().as_ref())
                                        .map_err(crate::error::CreateApiKeyError::unhandled)?
                                };

                            output = output.set_retry_after_seconds(
                        
                                                crate::http_serde::deser_header_create_api_key_retry_after_seconds(response.headers())
                                                    .map_err(|_|crate::error::CreateApiKeyError::unhandled("Failed to parse retryAfterSeconds from header `Retry-After"))?
                                                
                    );
                            output = output.set_message(parsed_body.message);
                            output.build()
                        }),
                    }
                }
                "UnauthorizedException" => crate::error::CreateApiKeyError {
                    meta: generic,
                    kind: crate::error::CreateApiKeyErrorKind::UnauthorizedError({
                        #[allow(unused_mut)]
                        let mut output = crate::error::unauthorized_error::Builder::default();
                        let _ = response;

                        let body_slice = response.body().as_ref();

                        let parsed_body: crate::error::UnauthorizedError = if body_slice.is_empty()
                        {
                            // To enable JSON parsing to succeed, replace an empty body
                            // with an empty JSON body. If a member was required, it will fail slightly later
                            // during the operation construction phase.
                            serde_json::from_slice(b"{}")
                                .map_err(crate::error::CreateApiKeyError::unhandled)?
                        } else {
                            serde_json::from_slice(response.body().as_ref())
                                .map_err(crate::error::CreateApiKeyError::unhandled)?
                        };

                        output = output.set_message(parsed_body.message);
                        output.build()
                    }),
                },
                _ => crate::error::CreateApiKeyError::generic(generic),
            });
        }
        Ok({
            #[allow(unused_mut)]
            let mut output = crate::output::create_api_key_output::Builder::default();
            let _ = response;

            let body_slice = response.body().as_ref();

            let parsed_body: crate::serializer::CreateApiKeyOutputBody = if body_slice.is_empty() {
                // To enable JSON parsing to succeed, replace an empty body
                // with an empty JSON body. If a member was required, it will fail slightly later
                // during the operation construction phase.
                serde_json::from_slice(b"{}").map_err(crate::error::CreateApiKeyError::unhandled)?
            } else {
                serde_json::from_slice(response.body().as_ref())
                    .map_err(crate::error::CreateApiKeyError::unhandled)?
            };

            output = output.set_id(parsed_body.id);
            output = output.set_value(parsed_body.value);
            output = output.set_name(parsed_body.name);
            output = output.set_customer_id(parsed_body.customer_id);
            output = output.set_description(parsed_body.description);
            output = output.set_enabled(parsed_body.enabled);
            output = output.set_created_date(parsed_body.created_date);
            output = output.set_last_updated_date(parsed_body.last_updated_date);
            output = output.set_stage_keys(parsed_body.stage_keys);
            output = output.set_tags(parsed_body.tags);
            output.build()
        })
    }
    pub fn parse_response(
        &self,
        response: &http::response::Response<impl AsRef<[u8]>>,
    ) -> Result<crate::output::CreateApiKeyOutput, crate::error::CreateApiKeyError> {
        Self::from_response(&response)
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}

impl smithy_http::response::ParseStrictResponse for CreateApiKey {
    type Output = Result<crate::output::CreateApiKeyOutput, crate::error::CreateApiKeyError>;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        self.parse_response(response)
    }
}

/// <p>Adds a new <a>Authorizer</a> resource to an existing <a>RestApi</a> resource.</p>
/// <div class="seeAlso"><a href="https://docs.aws.amazon.com/cli/latest/reference/apigateway/create-authorizer.html">AWS CLI</a></div>
#[derive(std::clone::Clone)]
pub struct CreateAuthorizer {
    _private: (),
}
impl CreateAuthorizer {
    /// Creates a new builder-style object to manufacture [`CreateAuthorizerInput`](crate::input::CreateAuthorizerInput)
    pub fn builder() -> crate::input::create_authorizer_input::Builder {
        crate::input::create_authorizer_input::Builder::default()
    }
    #[allow(clippy::unnecessary_wraps)]
    fn from_response(
        response: &http::response::Response<impl AsRef<[u8]>>,
    ) -> Result<crate::output::CreateAuthorizerOutput, crate::error::CreateAuthorizerError> {
        if crate::aws_json_errors::is_error(&response) && response.status().as_u16() != 201 {
            let body = serde_json::from_slice(response.body().as_ref())
                .unwrap_or_else(|_| serde_json::json!({}));
            let generic = crate::aws_json_errors::parse_generic_error(&response, &body);

            let error_code = match generic.code() {
                Some(code) => code,
                None => return Err(crate::error::CreateAuthorizerError::unhandled(generic)),
            };
            return Err(match error_code {
                "BadRequestException" => crate::error::CreateAuthorizerError {
                    meta: generic,
                    kind: crate::error::CreateAuthorizerErrorKind::BadRequestError({
                        #[allow(unused_mut)]
                        let mut output = crate::error::bad_request_error::Builder::default();
                        let _ = response;

                        let body_slice = response.body().as_ref();

                        let parsed_body: crate::error::BadRequestError = if body_slice.is_empty() {
                            // To enable JSON parsing to succeed, replace an empty body
                            // with an empty JSON body. If a member was required, it will fail slightly later
                            // during the operation construction phase.
                            serde_json::from_slice(b"{}")
                                .map_err(crate::error::CreateAuthorizerError::unhandled)?
                        } else {
                            serde_json::from_slice(response.body().as_ref())
                                .map_err(crate::error::CreateAuthorizerError::unhandled)?
                        };

                        output = output.set_message(parsed_body.message);
                        output.build()
                    }),
                },
                "LimitExceededException" => {
                    crate::error::CreateAuthorizerError {
                        meta: generic,
                        kind: crate::error::CreateAuthorizerErrorKind::LimitExceededError({
                            #[allow(unused_mut)]
                            let mut output = crate::error::limit_exceeded_error::Builder::default();
                            let _ = response;

                            let body_slice = response.body().as_ref();

                            let parsed_body: crate::error::LimitExceededError =
                                if body_slice.is_empty() {
                                    // To enable JSON parsing to succeed, replace an empty body
                                    // with an empty JSON body. If a member was required, it will fail slightly later
                                    // during the operation construction phase.
                                    serde_json::from_slice(b"{}")
                                        .map_err(crate::error::CreateAuthorizerError::unhandled)?
                                } else {
                                    serde_json::from_slice(response.body().as_ref())
                                        .map_err(crate::error::CreateAuthorizerError::unhandled)?
                                };

                            output = output.set_retry_after_seconds(
                        
                                                crate::http_serde::deser_header_create_authorizer_retry_after_seconds(response.headers())
                                                    .map_err(|_|crate::error::CreateAuthorizerError::unhandled("Failed to parse retryAfterSeconds from header `Retry-After"))?
                                                
                    );
                            output = output.set_message(parsed_body.message);
                            output.build()
                        }),
                    }
                }
                "NotFoundException" => crate::error::CreateAuthorizerError {
                    meta: generic,
                    kind: crate::error::CreateAuthorizerErrorKind::NotFoundError({
                        #[allow(unused_mut)]
                        let mut output = crate::error::not_found_error::Builder::default();
                        let _ = response;

                        let body_slice = response.body().as_ref();

                        let parsed_body: crate::error::NotFoundError = if body_slice.is_empty() {
                            // To enable JSON parsing to succeed, replace an empty body
                            // with an empty JSON body. If a member was required, it will fail slightly later
                            // during the operation construction phase.
                            serde_json::from_slice(b"{}")
                                .map_err(crate::error::CreateAuthorizerError::unhandled)?
                        } else {
                            serde_json::from_slice(response.body().as_ref())
                                .map_err(crate::error::CreateAuthorizerError::unhandled)?
                        };

                        output = output.set_message(parsed_body.message);
                        output.build()
                    }),
                },
                "TooManyRequestsException" => {
                    crate::error::CreateAuthorizerError {
                        meta: generic,
                        kind: crate::error::CreateAuthorizerErrorKind::TooManyRequestsError({
                            #[allow(unused_mut)]
                            let mut output =
                                crate::error::too_many_requests_error::Builder::default();
                            let _ = response;

                            let body_slice = response.body().as_ref();

                            let parsed_body: crate::error::TooManyRequestsError =
                                if body_slice.is_empty() {
                                    // To enable JSON parsing to succeed, replace an empty body
                                    // with an empty JSON body. If a member was required, it will fail slightly later
                                    // during the operation construction phase.
                                    serde_json::from_slice(b"{}")
                                        .map_err(crate::error::CreateAuthorizerError::unhandled)?
                                } else {
                                    serde_json::from_slice(response.body().as_ref())
                                        .map_err(crate::error::CreateAuthorizerError::unhandled)?
                                };

                            output = output.set_retry_after_seconds(
                        
                                                crate::http_serde::deser_header_create_authorizer_retry_after_seconds(response.headers())
                                                    .map_err(|_|crate::error::CreateAuthorizerError::unhandled("Failed to parse retryAfterSeconds from header `Retry-After"))?
                                                
                    );
                            output = output.set_message(parsed_body.message);
                            output.build()
                        }),
                    }
                }
                "UnauthorizedException" => crate::error::CreateAuthorizerError {
                    meta: generic,
                    kind: crate::error::CreateAuthorizerErrorKind::UnauthorizedError({
                        #[allow(unused_mut)]
                        let mut output = crate::error::unauthorized_error::Builder::default();
                        let _ = response;

                        let body_slice = response.body().as_ref();

                        let parsed_body: crate::error::UnauthorizedError = if body_slice.is_empty()
                        {
                            // To enable JSON parsing to succeed, replace an empty body
                            // with an empty JSON body. If a member was required, it will fail slightly later
                            // during the operation construction phase.
                            serde_json::from_slice(b"{}")
                                .map_err(crate::error::CreateAuthorizerError::unhandled)?
                        } else {
                            serde_json::from_slice(response.body().as_ref())
                                .map_err(crate::error::CreateAuthorizerError::unhandled)?
                        };

                        output = output.set_message(parsed_body.message);
                        output.build()
                    }),
                },
                _ => crate::error::CreateAuthorizerError::generic(generic),
            });
        }
        Ok({
            #[allow(unused_mut)]
            let mut output = crate::output::create_authorizer_output::Builder::default();
            let _ = response;

            let body_slice = response.body().as_ref();

            let parsed_body: crate::serializer::CreateAuthorizerOutputBody =
                if body_slice.is_empty() {
                    // To enable JSON parsing to succeed, replace an empty body
                    // with an empty JSON body. If a member was required, it will fail slightly later
                    // during the operation construction phase.
                    serde_json::from_slice(b"{}")
                        .map_err(crate::error::CreateAuthorizerError::unhandled)?
                } else {
                    serde_json::from_slice(response.body().as_ref())
                        .map_err(crate::error::CreateAuthorizerError::unhandled)?
                };

            output = output.set_id(parsed_body.id);
            output = output.set_name(parsed_body.name);
            output = output.set_type(parsed_body.r#type);
            output = output.set_provider_ar_ns(parsed_body.provider_ar_ns);
            output = output.set_auth_type(parsed_body.auth_type);
            output = output.set_authorizer_uri(parsed_body.authorizer_uri);
            output = output.set_authorizer_credentials(parsed_body.authorizer_credentials);
            output = output.set_identity_source(parsed_body.identity_source);
            output = output
                .set_identity_validation_expression(parsed_body.identity_validation_expression);
            output = output
                .set_authorizer_result_ttl_in_seconds(parsed_body.authorizer_result_ttl_in_seconds);
            output.build()
        })
    }
    pub fn parse_response(
        &self,
        response: &http::response::Response<impl AsRef<[u8]>>,
    ) -> Result<crate::output::CreateAuthorizerOutput, crate::error::CreateAuthorizerError> {
        Self::from_response(&response)
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}

impl smithy_http::response::ParseStrictResponse for CreateAuthorizer {
    type Output =
        Result<crate::output::CreateAuthorizerOutput, crate::error::CreateAuthorizerError>;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        self.parse_response(response)
    }
}

/// <p>Creates a new <a>BasePathMapping</a> resource.</p>
#[derive(std::clone::Clone)]
pub struct CreateBasePathMapping {
    _private: (),
}
impl CreateBasePathMapping {
    /// Creates a new builder-style object to manufacture [`CreateBasePathMappingInput`](crate::input::CreateBasePathMappingInput)
    pub fn builder() -> crate::input::create_base_path_mapping_input::Builder {
        crate::input::create_base_path_mapping_input::Builder::default()
    }
    #[allow(clippy::unnecessary_wraps)]
    fn from_response(
        response: &http::response::Response<impl AsRef<[u8]>>,
    ) -> Result<crate::output::CreateBasePathMappingOutput, crate::error::CreateBasePathMappingError>
    {
        if crate::aws_json_errors::is_error(&response) && response.status().as_u16() != 201 {
            let body = serde_json::from_slice(response.body().as_ref())
                .unwrap_or_else(|_| serde_json::json!({}));
            let generic = crate::aws_json_errors::parse_generic_error(&response, &body);

            let error_code = match generic.code() {
                Some(code) => code,
                None => return Err(crate::error::CreateBasePathMappingError::unhandled(generic)),
            };
            return Err(match error_code {
                "BadRequestException" => crate::error::CreateBasePathMappingError {
                    meta: generic,
                    kind: crate::error::CreateBasePathMappingErrorKind::BadRequestError({
                        #[allow(unused_mut)]
                        let mut output = crate::error::bad_request_error::Builder::default();
                        let _ = response;

                        let body_slice = response.body().as_ref();

                        let parsed_body: crate::error::BadRequestError = if body_slice.is_empty() {
                            // To enable JSON parsing to succeed, replace an empty body
                            // with an empty JSON body. If a member was required, it will fail slightly later
                            // during the operation construction phase.
                            serde_json::from_slice(b"{}")
                                .map_err(crate::error::CreateBasePathMappingError::unhandled)?
                        } else {
                            serde_json::from_slice(response.body().as_ref())
                                .map_err(crate::error::CreateBasePathMappingError::unhandled)?
                        };

                        output = output.set_message(parsed_body.message);
                        output.build()
                    }),
                },
                "ConflictException" => crate::error::CreateBasePathMappingError {
                    meta: generic,
                    kind: crate::error::CreateBasePathMappingErrorKind::ConflictError({
                        #[allow(unused_mut)]
                        let mut output = crate::error::conflict_error::Builder::default();
                        let _ = response;

                        let body_slice = response.body().as_ref();

                        let parsed_body: crate::error::ConflictError = if body_slice.is_empty() {
                            // To enable JSON parsing to succeed, replace an empty body
                            // with an empty JSON body. If a member was required, it will fail slightly later
                            // during the operation construction phase.
                            serde_json::from_slice(b"{}")
                                .map_err(crate::error::CreateBasePathMappingError::unhandled)?
                        } else {
                            serde_json::from_slice(response.body().as_ref())
                                .map_err(crate::error::CreateBasePathMappingError::unhandled)?
                        };

                        output = output.set_message(parsed_body.message);
                        output.build()
                    }),
                },
                "NotFoundException" => crate::error::CreateBasePathMappingError {
                    meta: generic,
                    kind: crate::error::CreateBasePathMappingErrorKind::NotFoundError({
                        #[allow(unused_mut)]
                        let mut output = crate::error::not_found_error::Builder::default();
                        let _ = response;

                        let body_slice = response.body().as_ref();

                        let parsed_body: crate::error::NotFoundError = if body_slice.is_empty() {
                            // To enable JSON parsing to succeed, replace an empty body
                            // with an empty JSON body. If a member was required, it will fail slightly later
                            // during the operation construction phase.
                            serde_json::from_slice(b"{}")
                                .map_err(crate::error::CreateBasePathMappingError::unhandled)?
                        } else {
                            serde_json::from_slice(response.body().as_ref())
                                .map_err(crate::error::CreateBasePathMappingError::unhandled)?
                        };

                        output = output.set_message(parsed_body.message);
                        output.build()
                    }),
                },
                "TooManyRequestsException" => crate::error::CreateBasePathMappingError {
                    meta: generic,
                    kind: crate::error::CreateBasePathMappingErrorKind::TooManyRequestsError({
                        #[allow(unused_mut)]
                        let mut output = crate::error::too_many_requests_error::Builder::default();
                        let _ = response;

                        let body_slice = response.body().as_ref();

                        let parsed_body: crate::error::TooManyRequestsError =
                            if body_slice.is_empty() {
                                // To enable JSON parsing to succeed, replace an empty body
                                // with an empty JSON body. If a member was required, it will fail slightly later
                                // during the operation construction phase.
                                serde_json::from_slice(b"{}")
                                    .map_err(crate::error::CreateBasePathMappingError::unhandled)?
                            } else {
                                serde_json::from_slice(response.body().as_ref())
                                    .map_err(crate::error::CreateBasePathMappingError::unhandled)?
                            };

                        output = output.set_retry_after_seconds(
                        
                                                crate::http_serde::deser_header_create_base_path_mapping_retry_after_seconds(response.headers())
                                                    .map_err(|_|crate::error::CreateBasePathMappingError::unhandled("Failed to parse retryAfterSeconds from header `Retry-After"))?
                                                
                    );
                        output = output.set_message(parsed_body.message);
                        output.build()
                    }),
                },
                "UnauthorizedException" => crate::error::CreateBasePathMappingError {
                    meta: generic,
                    kind: crate::error::CreateBasePathMappingErrorKind::UnauthorizedError({
                        #[allow(unused_mut)]
                        let mut output = crate::error::unauthorized_error::Builder::default();
                        let _ = response;

                        let body_slice = response.body().as_ref();

                        let parsed_body: crate::error::UnauthorizedError = if body_slice.is_empty()
                        {
                            // To enable JSON parsing to succeed, replace an empty body
                            // with an empty JSON body. If a member was required, it will fail slightly later
                            // during the operation construction phase.
                            serde_json::from_slice(b"{}")
                                .map_err(crate::error::CreateBasePathMappingError::unhandled)?
                        } else {
                            serde_json::from_slice(response.body().as_ref())
                                .map_err(crate::error::CreateBasePathMappingError::unhandled)?
                        };

                        output = output.set_message(parsed_body.message);
                        output.build()
                    }),
                },
                _ => crate::error::CreateBasePathMappingError::generic(generic),
            });
        }
        Ok({
            #[allow(unused_mut)]
            let mut output = crate::output::create_base_path_mapping_output::Builder::default();
            let _ = response;

            let body_slice = response.body().as_ref();

            let parsed_body: crate::serializer::CreateBasePathMappingOutputBody =
                if body_slice.is_empty() {
                    // To enable JSON parsing to succeed, replace an empty body
                    // with an empty JSON body. If a member was required, it will fail slightly later
                    // during the operation construction phase.
                    serde_json::from_slice(b"{}")
                        .map_err(crate::error::CreateBasePathMappingError::unhandled)?
                } else {
                    serde_json::from_slice(response.body().as_ref())
                        .map_err(crate::error::CreateBasePathMappingError::unhandled)?
                };

            output = output.set_base_path(parsed_body.base_path);
            output = output.set_rest_api_id(parsed_body.rest_api_id);
            output = output.set_stage(parsed_body.stage);
            output.build()
        })
    }
    pub fn parse_response(
        &self,
        response: &http::response::Response<impl AsRef<[u8]>>,
    ) -> Result<crate::output::CreateBasePathMappingOutput, crate::error::CreateBasePathMappingError>
    {
        Self::from_response(&response)
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}

impl smithy_http::response::ParseStrictResponse for CreateBasePathMapping {
    type Output = Result<
        crate::output::CreateBasePathMappingOutput,
        crate::error::CreateBasePathMappingError,
    >;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        self.parse_response(response)
    }
}

/// <p>Creates a <a>Deployment</a> resource, which makes a specified <a>RestApi</a> callable over the internet.</p>
#[derive(std::clone::Clone)]
pub struct CreateDeployment {
    _private: (),
}
impl CreateDeployment {
    /// Creates a new builder-style object to manufacture [`CreateDeploymentInput`](crate::input::CreateDeploymentInput)
    pub fn builder() -> crate::input::create_deployment_input::Builder {
        crate::input::create_deployment_input::Builder::default()
    }
    #[allow(clippy::unnecessary_wraps)]
    fn from_response(
        response: &http::response::Response<impl AsRef<[u8]>>,
    ) -> Result<crate::output::CreateDeploymentOutput, crate::error::CreateDeploymentError> {
        if crate::aws_json_errors::is_error(&response) && response.status().as_u16() != 201 {
            let body = serde_json::from_slice(response.body().as_ref())
                .unwrap_or_else(|_| serde_json::json!({}));
            let generic = crate::aws_json_errors::parse_generic_error(&response, &body);

            let error_code = match generic.code() {
                Some(code) => code,
                None => return Err(crate::error::CreateDeploymentError::unhandled(generic)),
            };
            return Err(match error_code {
                "BadRequestException" => crate::error::CreateDeploymentError {
                    meta: generic,
                    kind: crate::error::CreateDeploymentErrorKind::BadRequestError({
                        #[allow(unused_mut)]
                        let mut output = crate::error::bad_request_error::Builder::default();
                        let _ = response;

                        let body_slice = response.body().as_ref();

                        let parsed_body: crate::error::BadRequestError = if body_slice.is_empty() {
                            // To enable JSON parsing to succeed, replace an empty body
                            // with an empty JSON body. If a member was required, it will fail slightly later
                            // during the operation construction phase.
                            serde_json::from_slice(b"{}")
                                .map_err(crate::error::CreateDeploymentError::unhandled)?
                        } else {
                            serde_json::from_slice(response.body().as_ref())
                                .map_err(crate::error::CreateDeploymentError::unhandled)?
                        };

                        output = output.set_message(parsed_body.message);
                        output.build()
                    }),
                },
                "ConflictException" => crate::error::CreateDeploymentError {
                    meta: generic,
                    kind: crate::error::CreateDeploymentErrorKind::ConflictError({
                        #[allow(unused_mut)]
                        let mut output = crate::error::conflict_error::Builder::default();
                        let _ = response;

                        let body_slice = response.body().as_ref();

                        let parsed_body: crate::error::ConflictError = if body_slice.is_empty() {
                            // To enable JSON parsing to succeed, replace an empty body
                            // with an empty JSON body. If a member was required, it will fail slightly later
                            // during the operation construction phase.
                            serde_json::from_slice(b"{}")
                                .map_err(crate::error::CreateDeploymentError::unhandled)?
                        } else {
                            serde_json::from_slice(response.body().as_ref())
                                .map_err(crate::error::CreateDeploymentError::unhandled)?
                        };

                        output = output.set_message(parsed_body.message);
                        output.build()
                    }),
                },
                "LimitExceededException" => {
                    crate::error::CreateDeploymentError {
                        meta: generic,
                        kind: crate::error::CreateDeploymentErrorKind::LimitExceededError({
                            #[allow(unused_mut)]
                            let mut output = crate::error::limit_exceeded_error::Builder::default();
                            let _ = response;

                            let body_slice = response.body().as_ref();

                            let parsed_body: crate::error::LimitExceededError =
                                if body_slice.is_empty() {
                                    // To enable JSON parsing to succeed, replace an empty body
                                    // with an empty JSON body. If a member was required, it will fail slightly later
                                    // during the operation construction phase.
                                    serde_json::from_slice(b"{}")
                                        .map_err(crate::error::CreateDeploymentError::unhandled)?
                                } else {
                                    serde_json::from_slice(response.body().as_ref())
                                        .map_err(crate::error::CreateDeploymentError::unhandled)?
                                };

                            output = output.set_retry_after_seconds(
                        
                                                crate::http_serde::deser_header_create_deployment_retry_after_seconds(response.headers())
                                                    .map_err(|_|crate::error::CreateDeploymentError::unhandled("Failed to parse retryAfterSeconds from header `Retry-After"))?
                                                
                    );
                            output = output.set_message(parsed_body.message);
                            output.build()
                        }),
                    }
                }
                "NotFoundException" => crate::error::CreateDeploymentError {
                    meta: generic,
                    kind: crate::error::CreateDeploymentErrorKind::NotFoundError({
                        #[allow(unused_mut)]
                        let mut output = crate::error::not_found_error::Builder::default();
                        let _ = response;

                        let body_slice = response.body().as_ref();

                        let parsed_body: crate::error::NotFoundError = if body_slice.is_empty() {
                            // To enable JSON parsing to succeed, replace an empty body
                            // with an empty JSON body. If a member was required, it will fail slightly later
                            // during the operation construction phase.
                            serde_json::from_slice(b"{}")
                                .map_err(crate::error::CreateDeploymentError::unhandled)?
                        } else {
                            serde_json::from_slice(response.body().as_ref())
                                .map_err(crate::error::CreateDeploymentError::unhandled)?
                        };

                        output = output.set_message(parsed_body.message);
                        output.build()
                    }),
                },
                "ServiceUnavailableException" => {
                    crate::error::CreateDeploymentError {
                        meta: generic,
                        kind: crate::error::CreateDeploymentErrorKind::ServiceUnavailableError({
                            #[allow(unused_mut)]
                            let mut output =
                                crate::error::service_unavailable_error::Builder::default();
                            let _ = response;

                            let body_slice = response.body().as_ref();

                            let parsed_body: crate::error::ServiceUnavailableError =
                                if body_slice.is_empty() {
                                    // To enable JSON parsing to succeed, replace an empty body
                                    // with an empty JSON body. If a member was required, it will fail slightly later
                                    // during the operation construction phase.
                                    serde_json::from_slice(b"{}")
                                        .map_err(crate::error::CreateDeploymentError::unhandled)?
                                } else {
                                    serde_json::from_slice(response.body().as_ref())
                                        .map_err(crate::error::CreateDeploymentError::unhandled)?
                                };

                            output = output.set_retry_after_seconds(
                        
                                                crate::http_serde::deser_header_create_deployment_retry_after_seconds(response.headers())
                                                    .map_err(|_|crate::error::CreateDeploymentError::unhandled("Failed to parse retryAfterSeconds from header `Retry-After"))?
                                                
                    );
                            output = output.set_message(parsed_body.message);
                            output.build()
                        }),
                    }
                }
                "TooManyRequestsException" => {
                    crate::error::CreateDeploymentError {
                        meta: generic,
                        kind: crate::error::CreateDeploymentErrorKind::TooManyRequestsError({
                            #[allow(unused_mut)]
                            let mut output =
                                crate::error::too_many_requests_error::Builder::default();
                            let _ = response;

                            let body_slice = response.body().as_ref();

                            let parsed_body: crate::error::TooManyRequestsError =
                                if body_slice.is_empty() {
                                    // To enable JSON parsing to succeed, replace an empty body
                                    // with an empty JSON body. If a member was required, it will fail slightly later
                                    // during the operation construction phase.
                                    serde_json::from_slice(b"{}")
                                        .map_err(crate::error::CreateDeploymentError::unhandled)?
                                } else {
                                    serde_json::from_slice(response.body().as_ref())
                                        .map_err(crate::error::CreateDeploymentError::unhandled)?
                                };

                            output = output.set_retry_after_seconds(
                        
                                                crate::http_serde::deser_header_create_deployment_retry_after_seconds(response.headers())
                                                    .map_err(|_|crate::error::CreateDeploymentError::unhandled("Failed to parse retryAfterSeconds from header `Retry-After"))?
                                                
                    );
                            output = output.set_message(parsed_body.message);
                            output.build()
                        }),
                    }
                }
                "UnauthorizedException" => crate::error::CreateDeploymentError {
                    meta: generic,
                    kind: crate::error::CreateDeploymentErrorKind::UnauthorizedError({
                        #[allow(unused_mut)]
                        let mut output = crate::error::unauthorized_error::Builder::default();
                        let _ = response;

                        let body_slice = response.body().as_ref();

                        let parsed_body: crate::error::UnauthorizedError = if body_slice.is_empty()
                        {
                            // To enable JSON parsing to succeed, replace an empty body
                            // with an empty JSON body. If a member was required, it will fail slightly later
                            // during the operation construction phase.
                            serde_json::from_slice(b"{}")
                                .map_err(crate::error::CreateDeploymentError::unhandled)?
                        } else {
                            serde_json::from_slice(response.body().as_ref())
                                .map_err(crate::error::CreateDeploymentError::unhandled)?
                        };

                        output = output.set_message(parsed_body.message);
                        output.build()
                    }),
                },
                _ => crate::error::CreateDeploymentError::generic(generic),
            });
        }
        Ok({
            #[allow(unused_mut)]
            let mut output = crate::output::create_deployment_output::Builder::default();
            let _ = response;

            let body_slice = response.body().as_ref();

            let parsed_body: crate::serializer::CreateDeploymentOutputBody =
                if body_slice.is_empty() {
                    // To enable JSON parsing to succeed, replace an empty body
                    // with an empty JSON body. If a member was required, it will fail slightly later
                    // during the operation construction phase.
                    serde_json::from_slice(b"{}")
                        .map_err(crate::error::CreateDeploymentError::unhandled)?
                } else {
                    serde_json::from_slice(response.body().as_ref())
                        .map_err(crate::error::CreateDeploymentError::unhandled)?
                };

            output = output.set_id(parsed_body.id);
            output = output.set_description(parsed_body.description);
            output = output.set_created_date(parsed_body.created_date);
            output = output.set_api_summary(parsed_body.api_summary);
            output.build()
        })
    }
    pub fn parse_response(
        &self,
        response: &http::response::Response<impl AsRef<[u8]>>,
    ) -> Result<crate::output::CreateDeploymentOutput, crate::error::CreateDeploymentError> {
        Self::from_response(&response)
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}

impl smithy_http::response::ParseStrictResponse for CreateDeployment {
    type Output =
        Result<crate::output::CreateDeploymentOutput, crate::error::CreateDeploymentError>;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        self.parse_response(response)
    }
}

#[derive(std::clone::Clone)]
pub struct CreateDocumentationPart {
    _private: (),
}
impl CreateDocumentationPart {
    /// Creates a new builder-style object to manufacture [`CreateDocumentationPartInput`](crate::input::CreateDocumentationPartInput)
    pub fn builder() -> crate::input::create_documentation_part_input::Builder {
        crate::input::create_documentation_part_input::Builder::default()
    }
    #[allow(clippy::unnecessary_wraps)]
    fn from_response(
        response: &http::response::Response<impl AsRef<[u8]>>,
    ) -> Result<
        crate::output::CreateDocumentationPartOutput,
        crate::error::CreateDocumentationPartError,
    > {
        if crate::aws_json_errors::is_error(&response) && response.status().as_u16() != 201 {
            let body = serde_json::from_slice(response.body().as_ref())
                .unwrap_or_else(|_| serde_json::json!({}));
            let generic = crate::aws_json_errors::parse_generic_error(&response, &body);

            let error_code = match generic.code() {
                Some(code) => code,
                None => {
                    return Err(crate::error::CreateDocumentationPartError::unhandled(
                        generic,
                    ))
                }
            };
            return Err(match error_code {
                "BadRequestException" => crate::error::CreateDocumentationPartError {
                    meta: generic,
                    kind: crate::error::CreateDocumentationPartErrorKind::BadRequestError({
                        #[allow(unused_mut)]
                        let mut output = crate::error::bad_request_error::Builder::default();
                        let _ = response;

                        let body_slice = response.body().as_ref();

                        let parsed_body: crate::error::BadRequestError = if body_slice.is_empty() {
                            // To enable JSON parsing to succeed, replace an empty body
                            // with an empty JSON body. If a member was required, it will fail slightly later
                            // during the operation construction phase.
                            serde_json::from_slice(b"{}")
                                .map_err(crate::error::CreateDocumentationPartError::unhandled)?
                        } else {
                            serde_json::from_slice(response.body().as_ref())
                                .map_err(crate::error::CreateDocumentationPartError::unhandled)?
                        };

                        output = output.set_message(parsed_body.message);
                        output.build()
                    }),
                },
                "ConflictException" => crate::error::CreateDocumentationPartError {
                    meta: generic,
                    kind: crate::error::CreateDocumentationPartErrorKind::ConflictError({
                        #[allow(unused_mut)]
                        let mut output = crate::error::conflict_error::Builder::default();
                        let _ = response;

                        let body_slice = response.body().as_ref();

                        let parsed_body: crate::error::ConflictError = if body_slice.is_empty() {
                            // To enable JSON parsing to succeed, replace an empty body
                            // with an empty JSON body. If a member was required, it will fail slightly later
                            // during the operation construction phase.
                            serde_json::from_slice(b"{}")
                                .map_err(crate::error::CreateDocumentationPartError::unhandled)?
                        } else {
                            serde_json::from_slice(response.body().as_ref())
                                .map_err(crate::error::CreateDocumentationPartError::unhandled)?
                        };

                        output = output.set_message(parsed_body.message);
                        output.build()
                    }),
                },
                "LimitExceededException" => crate::error::CreateDocumentationPartError {
                    meta: generic,
                    kind: crate::error::CreateDocumentationPartErrorKind::LimitExceededError({
                        #[allow(unused_mut)]
                        let mut output = crate::error::limit_exceeded_error::Builder::default();
                        let _ = response;

                        let body_slice = response.body().as_ref();

                        let parsed_body: crate::error::LimitExceededError = if body_slice.is_empty()
                        {
                            // To enable JSON parsing to succeed, replace an empty body
                            // with an empty JSON body. If a member was required, it will fail slightly later
                            // during the operation construction phase.
                            serde_json::from_slice(b"{}")
                                .map_err(crate::error::CreateDocumentationPartError::unhandled)?
                        } else {
                            serde_json::from_slice(response.body().as_ref())
                                .map_err(crate::error::CreateDocumentationPartError::unhandled)?
                        };

                        output = output.set_retry_after_seconds(
                        
                                                crate::http_serde::deser_header_create_documentation_part_retry_after_seconds(response.headers())
                                                    .map_err(|_|crate::error::CreateDocumentationPartError::unhandled("Failed to parse retryAfterSeconds from header `Retry-After"))?
                                                
                    );
                        output = output.set_message(parsed_body.message);
                        output.build()
                    }),
                },
                "NotFoundException" => crate::error::CreateDocumentationPartError {
                    meta: generic,
                    kind: crate::error::CreateDocumentationPartErrorKind::NotFoundError({
                        #[allow(unused_mut)]
                        let mut output = crate::error::not_found_error::Builder::default();
                        let _ = response;

                        let body_slice = response.body().as_ref();

                        let parsed_body: crate::error::NotFoundError = if body_slice.is_empty() {
                            // To enable JSON parsing to succeed, replace an empty body
                            // with an empty JSON body. If a member was required, it will fail slightly later
                            // during the operation construction phase.
                            serde_json::from_slice(b"{}")
                                .map_err(crate::error::CreateDocumentationPartError::unhandled)?
                        } else {
                            serde_json::from_slice(response.body().as_ref())
                                .map_err(crate::error::CreateDocumentationPartError::unhandled)?
                        };

                        output = output.set_message(parsed_body.message);
                        output.build()
                    }),
                },
                "TooManyRequestsException" => crate::error::CreateDocumentationPartError {
                    meta: generic,
                    kind: crate::error::CreateDocumentationPartErrorKind::TooManyRequestsError({
                        #[allow(unused_mut)]
                        let mut output = crate::error::too_many_requests_error::Builder::default();
                        let _ = response;

                        let body_slice = response.body().as_ref();

                        let parsed_body: crate::error::TooManyRequestsError = if body_slice
                            .is_empty()
                        {
                            // To enable JSON parsing to succeed, replace an empty body
                            // with an empty JSON body. If a member was required, it will fail slightly later
                            // during the operation construction phase.
                            serde_json::from_slice(b"{}")
                                .map_err(crate::error::CreateDocumentationPartError::unhandled)?
                        } else {
                            serde_json::from_slice(response.body().as_ref())
                                .map_err(crate::error::CreateDocumentationPartError::unhandled)?
                        };

                        output = output.set_retry_after_seconds(
                        
                                                crate::http_serde::deser_header_create_documentation_part_retry_after_seconds(response.headers())
                                                    .map_err(|_|crate::error::CreateDocumentationPartError::unhandled("Failed to parse retryAfterSeconds from header `Retry-After"))?
                                                
                    );
                        output = output.set_message(parsed_body.message);
                        output.build()
                    }),
                },
                "UnauthorizedException" => crate::error::CreateDocumentationPartError {
                    meta: generic,
                    kind: crate::error::CreateDocumentationPartErrorKind::UnauthorizedError({
                        #[allow(unused_mut)]
                        let mut output = crate::error::unauthorized_error::Builder::default();
                        let _ = response;

                        let body_slice = response.body().as_ref();

                        let parsed_body: crate::error::UnauthorizedError = if body_slice.is_empty()
                        {
                            // To enable JSON parsing to succeed, replace an empty body
                            // with an empty JSON body. If a member was required, it will fail slightly later
                            // during the operation construction phase.
                            serde_json::from_slice(b"{}")
                                .map_err(crate::error::CreateDocumentationPartError::unhandled)?
                        } else {
                            serde_json::from_slice(response.body().as_ref())
                                .map_err(crate::error::CreateDocumentationPartError::unhandled)?
                        };

                        output = output.set_message(parsed_body.message);
                        output.build()
                    }),
                },
                _ => crate::error::CreateDocumentationPartError::generic(generic),
            });
        }
        Ok({
            #[allow(unused_mut)]
            let mut output = crate::output::create_documentation_part_output::Builder::default();
            let _ = response;

            let body_slice = response.body().as_ref();

            let parsed_body: crate::serializer::CreateDocumentationPartOutputBody =
                if body_slice.is_empty() {
                    // To enable JSON parsing to succeed, replace an empty body
                    // with an empty JSON body. If a member was required, it will fail slightly later
                    // during the operation construction phase.
                    serde_json::from_slice(b"{}")
                        .map_err(crate::error::CreateDocumentationPartError::unhandled)?
                } else {
                    serde_json::from_slice(response.body().as_ref())
                        .map_err(crate::error::CreateDocumentationPartError::unhandled)?
                };

            output = output.set_id(parsed_body.id);
            output = output.set_location(parsed_body.location);
            output = output.set_properties(parsed_body.properties);
            output.build()
        })
    }
    pub fn parse_response(
        &self,
        response: &http::response::Response<impl AsRef<[u8]>>,
    ) -> Result<
        crate::output::CreateDocumentationPartOutput,
        crate::error::CreateDocumentationPartError,
    > {
        Self::from_response(&response)
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}

impl smithy_http::response::ParseStrictResponse for CreateDocumentationPart {
    type Output = Result<
        crate::output::CreateDocumentationPartOutput,
        crate::error::CreateDocumentationPartError,
    >;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        self.parse_response(response)
    }
}

#[derive(std::clone::Clone)]
pub struct CreateDocumentationVersion {
    _private: (),
}
impl CreateDocumentationVersion {
    /// Creates a new builder-style object to manufacture [`CreateDocumentationVersionInput`](crate::input::CreateDocumentationVersionInput)
    pub fn builder() -> crate::input::create_documentation_version_input::Builder {
        crate::input::create_documentation_version_input::Builder::default()
    }
    #[allow(clippy::unnecessary_wraps)]
    fn from_response(
        response: &http::response::Response<impl AsRef<[u8]>>,
    ) -> Result<
        crate::output::CreateDocumentationVersionOutput,
        crate::error::CreateDocumentationVersionError,
    > {
        if crate::aws_json_errors::is_error(&response) && response.status().as_u16() != 201 {
            let body = serde_json::from_slice(response.body().as_ref())
                .unwrap_or_else(|_| serde_json::json!({}));
            let generic = crate::aws_json_errors::parse_generic_error(&response, &body);

            let error_code = match generic.code() {
                Some(code) => code,
                None => {
                    return Err(crate::error::CreateDocumentationVersionError::unhandled(
                        generic,
                    ))
                }
            };
            return Err(match error_code {
                "BadRequestException" => crate::error::CreateDocumentationVersionError {
                    meta: generic,
                    kind: crate::error::CreateDocumentationVersionErrorKind::BadRequestError({
                        #[allow(unused_mut)]
                        let mut output = crate::error::bad_request_error::Builder::default();
                        let _ = response;

                        let body_slice = response.body().as_ref();

                        let parsed_body: crate::error::BadRequestError = if body_slice.is_empty() {
                            // To enable JSON parsing to succeed, replace an empty body
                            // with an empty JSON body. If a member was required, it will fail slightly later
                            // during the operation construction phase.
                            serde_json::from_slice(b"{}")
                                .map_err(crate::error::CreateDocumentationVersionError::unhandled)?
                        } else {
                            serde_json::from_slice(response.body().as_ref())
                                .map_err(crate::error::CreateDocumentationVersionError::unhandled)?
                        };

                        output = output.set_message(parsed_body.message);
                        output.build()
                    }),
                },
                "ConflictException" => crate::error::CreateDocumentationVersionError {
                    meta: generic,
                    kind: crate::error::CreateDocumentationVersionErrorKind::ConflictError({
                        #[allow(unused_mut)]
                        let mut output = crate::error::conflict_error::Builder::default();
                        let _ = response;

                        let body_slice = response.body().as_ref();

                        let parsed_body: crate::error::ConflictError = if body_slice.is_empty() {
                            // To enable JSON parsing to succeed, replace an empty body
                            // with an empty JSON body. If a member was required, it will fail slightly later
                            // during the operation construction phase.
                            serde_json::from_slice(b"{}")
                                .map_err(crate::error::CreateDocumentationVersionError::unhandled)?
                        } else {
                            serde_json::from_slice(response.body().as_ref())
                                .map_err(crate::error::CreateDocumentationVersionError::unhandled)?
                        };

                        output = output.set_message(parsed_body.message);
                        output.build()
                    }),
                },
                "LimitExceededException" => crate::error::CreateDocumentationVersionError {
                    meta: generic,
                    kind: crate::error::CreateDocumentationVersionErrorKind::LimitExceededError({
                        #[allow(unused_mut)]
                        let mut output = crate::error::limit_exceeded_error::Builder::default();
                        let _ = response;

                        let body_slice = response.body().as_ref();

                        let parsed_body: crate::error::LimitExceededError = if body_slice.is_empty()
                        {
                            // To enable JSON parsing to succeed, replace an empty body
                            // with an empty JSON body. If a member was required, it will fail slightly later
                            // during the operation construction phase.
                            serde_json::from_slice(b"{}")
                                .map_err(crate::error::CreateDocumentationVersionError::unhandled)?
                        } else {
                            serde_json::from_slice(response.body().as_ref())
                                .map_err(crate::error::CreateDocumentationVersionError::unhandled)?
                        };

                        output = output.set_retry_after_seconds(
                        
                                                crate::http_serde::deser_header_create_documentation_version_retry_after_seconds(response.headers())
                                                    .map_err(|_|crate::error::CreateDocumentationVersionError::unhandled("Failed to parse retryAfterSeconds from header `Retry-After"))?
                                                
                    );
                        output = output.set_message(parsed_body.message);
                        output.build()
                    }),
                },
                "NotFoundException" => crate::error::CreateDocumentationVersionError {
                    meta: generic,
                    kind: crate::error::CreateDocumentationVersionErrorKind::NotFoundError({
                        #[allow(unused_mut)]
                        let mut output = crate::error::not_found_error::Builder::default();
                        let _ = response;

                        let body_slice = response.body().as_ref();

                        let parsed_body: crate::error::NotFoundError = if body_slice.is_empty() {
                            // To enable JSON parsing to succeed, replace an empty body
                            // with an empty JSON body. If a member was required, it will fail slightly later
                            // during the operation construction phase.
                            serde_json::from_slice(b"{}")
                                .map_err(crate::error::CreateDocumentationVersionError::unhandled)?
                        } else {
                            serde_json::from_slice(response.body().as_ref())
                                .map_err(crate::error::CreateDocumentationVersionError::unhandled)?
                        };

                        output = output.set_message(parsed_body.message);
                        output.build()
                    }),
                },
                "TooManyRequestsException" => {
                    crate::error::CreateDocumentationVersionError {
                        meta: generic,
                        kind:
                            crate::error::CreateDocumentationVersionErrorKind::TooManyRequestsError(
                                {
                                    #[allow(unused_mut)]
                                    let mut output =
                                        crate::error::too_many_requests_error::Builder::default();
                                    let _ = response;

                                    let body_slice = response.body().as_ref();

                                    let parsed_body: crate::error::TooManyRequestsError =
                                        if body_slice.is_empty() {
                                            // To enable JSON parsing to succeed, replace an empty body
                                            // with an empty JSON body. If a member was required, it will fail slightly later
                                            // during the operation construction phase.
                                            serde_json::from_slice(b"{}").map_err(crate::error::CreateDocumentationVersionError::unhandled)?
                                        } else {
                                            serde_json::from_slice(response.body().as_ref()).map_err(crate::error::CreateDocumentationVersionError::unhandled)?
                                        };

                                    output = output.set_retry_after_seconds(
                        
                                                crate::http_serde::deser_header_create_documentation_version_retry_after_seconds(response.headers())
                                                    .map_err(|_|crate::error::CreateDocumentationVersionError::unhandled("Failed to parse retryAfterSeconds from header `Retry-After"))?
                                                
                    );
                                    output = output.set_message(parsed_body.message);
                                    output.build()
                                },
                            ),
                    }
                }
                "UnauthorizedException" => crate::error::CreateDocumentationVersionError {
                    meta: generic,
                    kind: crate::error::CreateDocumentationVersionErrorKind::UnauthorizedError({
                        #[allow(unused_mut)]
                        let mut output = crate::error::unauthorized_error::Builder::default();
                        let _ = response;

                        let body_slice = response.body().as_ref();

                        let parsed_body: crate::error::UnauthorizedError = if body_slice.is_empty()
                        {
                            // To enable JSON parsing to succeed, replace an empty body
                            // with an empty JSON body. If a member was required, it will fail slightly later
                            // during the operation construction phase.
                            serde_json::from_slice(b"{}")
                                .map_err(crate::error::CreateDocumentationVersionError::unhandled)?
                        } else {
                            serde_json::from_slice(response.body().as_ref())
                                .map_err(crate::error::CreateDocumentationVersionError::unhandled)?
                        };

                        output = output.set_message(parsed_body.message);
                        output.build()
                    }),
                },
                _ => crate::error::CreateDocumentationVersionError::generic(generic),
            });
        }
        Ok({
            #[allow(unused_mut)]
            let mut output = crate::output::create_documentation_version_output::Builder::default();
            let _ = response;

            let body_slice = response.body().as_ref();

            let parsed_body: crate::serializer::CreateDocumentationVersionOutputBody =
                if body_slice.is_empty() {
                    // To enable JSON parsing to succeed, replace an empty body
                    // with an empty JSON body. If a member was required, it will fail slightly later
                    // during the operation construction phase.
                    serde_json::from_slice(b"{}")
                        .map_err(crate::error::CreateDocumentationVersionError::unhandled)?
                } else {
                    serde_json::from_slice(response.body().as_ref())
                        .map_err(crate::error::CreateDocumentationVersionError::unhandled)?
                };

            output = output.set_version(parsed_body.version);
            output = output.set_created_date(parsed_body.created_date);
            output = output.set_description(parsed_body.description);
            output.build()
        })
    }
    pub fn parse_response(
        &self,
        response: &http::response::Response<impl AsRef<[u8]>>,
    ) -> Result<
        crate::output::CreateDocumentationVersionOutput,
        crate::error::CreateDocumentationVersionError,
    > {
        Self::from_response(&response)
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}

impl smithy_http::response::ParseStrictResponse for CreateDocumentationVersion {
    type Output = Result<
        crate::output::CreateDocumentationVersionOutput,
        crate::error::CreateDocumentationVersionError,
    >;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        self.parse_response(response)
    }
}

/// <p>Creates a new domain name.</p>
#[derive(std::clone::Clone)]
pub struct CreateDomainName {
    _private: (),
}
impl CreateDomainName {
    /// Creates a new builder-style object to manufacture [`CreateDomainNameInput`](crate::input::CreateDomainNameInput)
    pub fn builder() -> crate::input::create_domain_name_input::Builder {
        crate::input::create_domain_name_input::Builder::default()
    }
    #[allow(clippy::unnecessary_wraps)]
    fn from_response(
        response: &http::response::Response<impl AsRef<[u8]>>,
    ) -> Result<crate::output::CreateDomainNameOutput, crate::error::CreateDomainNameError> {
        if crate::aws_json_errors::is_error(&response) && response.status().as_u16() != 201 {
            let body = serde_json::from_slice(response.body().as_ref())
                .unwrap_or_else(|_| serde_json::json!({}));
            let generic = crate::aws_json_errors::parse_generic_error(&response, &body);

            let error_code = match generic.code() {
                Some(code) => code,
                None => return Err(crate::error::CreateDomainNameError::unhandled(generic)),
            };
            return Err(match error_code {
                "BadRequestException" => crate::error::CreateDomainNameError {
                    meta: generic,
                    kind: crate::error::CreateDomainNameErrorKind::BadRequestError({
                        #[allow(unused_mut)]
                        let mut output = crate::error::bad_request_error::Builder::default();
                        let _ = response;

                        let body_slice = response.body().as_ref();

                        let parsed_body: crate::error::BadRequestError = if body_slice.is_empty() {
                            // To enable JSON parsing to succeed, replace an empty body
                            // with an empty JSON body. If a member was required, it will fail slightly later
                            // during the operation construction phase.
                            serde_json::from_slice(b"{}")
                                .map_err(crate::error::CreateDomainNameError::unhandled)?
                        } else {
                            serde_json::from_slice(response.body().as_ref())
                                .map_err(crate::error::CreateDomainNameError::unhandled)?
                        };

                        output = output.set_message(parsed_body.message);
                        output.build()
                    }),
                },
                "ConflictException" => crate::error::CreateDomainNameError {
                    meta: generic,
                    kind: crate::error::CreateDomainNameErrorKind::ConflictError({
                        #[allow(unused_mut)]
                        let mut output = crate::error::conflict_error::Builder::default();
                        let _ = response;

                        let body_slice = response.body().as_ref();

                        let parsed_body: crate::error::ConflictError = if body_slice.is_empty() {
                            // To enable JSON parsing to succeed, replace an empty body
                            // with an empty JSON body. If a member was required, it will fail slightly later
                            // during the operation construction phase.
                            serde_json::from_slice(b"{}")
                                .map_err(crate::error::CreateDomainNameError::unhandled)?
                        } else {
                            serde_json::from_slice(response.body().as_ref())
                                .map_err(crate::error::CreateDomainNameError::unhandled)?
                        };

                        output = output.set_message(parsed_body.message);
                        output.build()
                    }),
                },
                "TooManyRequestsException" => {
                    crate::error::CreateDomainNameError {
                        meta: generic,
                        kind: crate::error::CreateDomainNameErrorKind::TooManyRequestsError({
                            #[allow(unused_mut)]
                            let mut output =
                                crate::error::too_many_requests_error::Builder::default();
                            let _ = response;

                            let body_slice = response.body().as_ref();

                            let parsed_body: crate::error::TooManyRequestsError =
                                if body_slice.is_empty() {
                                    // To enable JSON parsing to succeed, replace an empty body
                                    // with an empty JSON body. If a member was required, it will fail slightly later
                                    // during the operation construction phase.
                                    serde_json::from_slice(b"{}")
                                        .map_err(crate::error::CreateDomainNameError::unhandled)?
                                } else {
                                    serde_json::from_slice(response.body().as_ref())
                                        .map_err(crate::error::CreateDomainNameError::unhandled)?
                                };

                            output = output.set_retry_after_seconds(
                        
                                                crate::http_serde::deser_header_create_domain_name_retry_after_seconds(response.headers())
                                                    .map_err(|_|crate::error::CreateDomainNameError::unhandled("Failed to parse retryAfterSeconds from header `Retry-After"))?
                                                
                    );
                            output = output.set_message(parsed_body.message);
                            output.build()
                        }),
                    }
                }
                "UnauthorizedException" => crate::error::CreateDomainNameError {
                    meta: generic,
                    kind: crate::error::CreateDomainNameErrorKind::UnauthorizedError({
                        #[allow(unused_mut)]
                        let mut output = crate::error::unauthorized_error::Builder::default();
                        let _ = response;

                        let body_slice = response.body().as_ref();

                        let parsed_body: crate::error::UnauthorizedError = if body_slice.is_empty()
                        {
                            // To enable JSON parsing to succeed, replace an empty body
                            // with an empty JSON body. If a member was required, it will fail slightly later
                            // during the operation construction phase.
                            serde_json::from_slice(b"{}")
                                .map_err(crate::error::CreateDomainNameError::unhandled)?
                        } else {
                            serde_json::from_slice(response.body().as_ref())
                                .map_err(crate::error::CreateDomainNameError::unhandled)?
                        };

                        output = output.set_message(parsed_body.message);
                        output.build()
                    }),
                },
                _ => crate::error::CreateDomainNameError::generic(generic),
            });
        }
        Ok({
            #[allow(unused_mut)]
            let mut output = crate::output::create_domain_name_output::Builder::default();
            let _ = response;

            let body_slice = response.body().as_ref();

            let parsed_body: crate::serializer::CreateDomainNameOutputBody =
                if body_slice.is_empty() {
                    // To enable JSON parsing to succeed, replace an empty body
                    // with an empty JSON body. If a member was required, it will fail slightly later
                    // during the operation construction phase.
                    serde_json::from_slice(b"{}")
                        .map_err(crate::error::CreateDomainNameError::unhandled)?
                } else {
                    serde_json::from_slice(response.body().as_ref())
                        .map_err(crate::error::CreateDomainNameError::unhandled)?
                };

            output = output.set_domain_name(parsed_body.domain_name);
            output = output.set_certificate_name(parsed_body.certificate_name);
            output = output.set_certificate_arn(parsed_body.certificate_arn);
            output = output.set_certificate_upload_date(parsed_body.certificate_upload_date);
            output = output.set_regional_domain_name(parsed_body.regional_domain_name);
            output = output.set_regional_hosted_zone_id(parsed_body.regional_hosted_zone_id);
            output = output.set_regional_certificate_name(parsed_body.regional_certificate_name);
            output = output.set_regional_certificate_arn(parsed_body.regional_certificate_arn);
            output = output.set_distribution_domain_name(parsed_body.distribution_domain_name);
            output =
                output.set_distribution_hosted_zone_id(parsed_body.distribution_hosted_zone_id);
            output = output.set_endpoint_configuration(parsed_body.endpoint_configuration);
            output = output.set_domain_name_status(parsed_body.domain_name_status);
            output = output.set_domain_name_status_message(parsed_body.domain_name_status_message);
            output = output.set_security_policy(parsed_body.security_policy);
            output = output.set_tags(parsed_body.tags);
            output = output.set_mutual_tls_authentication(parsed_body.mutual_tls_authentication);
            output.build()
        })
    }
    pub fn parse_response(
        &self,
        response: &http::response::Response<impl AsRef<[u8]>>,
    ) -> Result<crate::output::CreateDomainNameOutput, crate::error::CreateDomainNameError> {
        Self::from_response(&response)
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}

impl smithy_http::response::ParseStrictResponse for CreateDomainName {
    type Output =
        Result<crate::output::CreateDomainNameOutput, crate::error::CreateDomainNameError>;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        self.parse_response(response)
    }
}

/// <p>Adds a new <a>Model</a> resource to an existing <a>RestApi</a> resource.</p>
#[derive(std::clone::Clone)]
pub struct CreateModel {
    _private: (),
}
impl CreateModel {
    /// Creates a new builder-style object to manufacture [`CreateModelInput`](crate::input::CreateModelInput)
    pub fn builder() -> crate::input::create_model_input::Builder {
        crate::input::create_model_input::Builder::default()
    }
    #[allow(clippy::unnecessary_wraps)]
    fn from_response(
        response: &http::response::Response<impl AsRef<[u8]>>,
    ) -> Result<crate::output::CreateModelOutput, crate::error::CreateModelError> {
        if crate::aws_json_errors::is_error(&response) && response.status().as_u16() != 201 {
            let body = serde_json::from_slice(response.body().as_ref())
                .unwrap_or_else(|_| serde_json::json!({}));
            let generic = crate::aws_json_errors::parse_generic_error(&response, &body);

            let error_code = match generic.code() {
                Some(code) => code,
                None => return Err(crate::error::CreateModelError::unhandled(generic)),
            };
            return Err(match error_code {
                "BadRequestException" => crate::error::CreateModelError {
                    meta: generic,
                    kind: crate::error::CreateModelErrorKind::BadRequestError({
                        #[allow(unused_mut)]
                        let mut output = crate::error::bad_request_error::Builder::default();
                        let _ = response;

                        let body_slice = response.body().as_ref();

                        let parsed_body: crate::error::BadRequestError = if body_slice.is_empty() {
                            // To enable JSON parsing to succeed, replace an empty body
                            // with an empty JSON body. If a member was required, it will fail slightly later
                            // during the operation construction phase.
                            serde_json::from_slice(b"{}")
                                .map_err(crate::error::CreateModelError::unhandled)?
                        } else {
                            serde_json::from_slice(response.body().as_ref())
                                .map_err(crate::error::CreateModelError::unhandled)?
                        };

                        output = output.set_message(parsed_body.message);
                        output.build()
                    }),
                },
                "ConflictException" => crate::error::CreateModelError {
                    meta: generic,
                    kind: crate::error::CreateModelErrorKind::ConflictError({
                        #[allow(unused_mut)]
                        let mut output = crate::error::conflict_error::Builder::default();
                        let _ = response;

                        let body_slice = response.body().as_ref();

                        let parsed_body: crate::error::ConflictError = if body_slice.is_empty() {
                            // To enable JSON parsing to succeed, replace an empty body
                            // with an empty JSON body. If a member was required, it will fail slightly later
                            // during the operation construction phase.
                            serde_json::from_slice(b"{}")
                                .map_err(crate::error::CreateModelError::unhandled)?
                        } else {
                            serde_json::from_slice(response.body().as_ref())
                                .map_err(crate::error::CreateModelError::unhandled)?
                        };

                        output = output.set_message(parsed_body.message);
                        output.build()
                    }),
                },
                "LimitExceededException" => {
                    crate::error::CreateModelError {
                        meta: generic,
                        kind: crate::error::CreateModelErrorKind::LimitExceededError({
                            #[allow(unused_mut)]
                            let mut output = crate::error::limit_exceeded_error::Builder::default();
                            let _ = response;

                            let body_slice = response.body().as_ref();

                            let parsed_body: crate::error::LimitExceededError =
                                if body_slice.is_empty() {
                                    // To enable JSON parsing to succeed, replace an empty body
                                    // with an empty JSON body. If a member was required, it will fail slightly later
                                    // during the operation construction phase.
                                    serde_json::from_slice(b"{}")
                                        .map_err(crate::error::CreateModelError::unhandled)?
                                } else {
                                    serde_json::from_slice(response.body().as_ref())
                                        .map_err(crate::error::CreateModelError::unhandled)?
                                };

                            output = output.set_retry_after_seconds(
                        
                                                crate::http_serde::deser_header_create_model_retry_after_seconds(response.headers())
                                                    .map_err(|_|crate::error::CreateModelError::unhandled("Failed to parse retryAfterSeconds from header `Retry-After"))?
                                                
                    );
                            output = output.set_message(parsed_body.message);
                            output.build()
                        }),
                    }
                }
                "NotFoundException" => crate::error::CreateModelError {
                    meta: generic,
                    kind: crate::error::CreateModelErrorKind::NotFoundError({
                        #[allow(unused_mut)]
                        let mut output = crate::error::not_found_error::Builder::default();
                        let _ = response;

                        let body_slice = response.body().as_ref();

                        let parsed_body: crate::error::NotFoundError = if body_slice.is_empty() {
                            // To enable JSON parsing to succeed, replace an empty body
                            // with an empty JSON body. If a member was required, it will fail slightly later
                            // during the operation construction phase.
                            serde_json::from_slice(b"{}")
                                .map_err(crate::error::CreateModelError::unhandled)?
                        } else {
                            serde_json::from_slice(response.body().as_ref())
                                .map_err(crate::error::CreateModelError::unhandled)?
                        };

                        output = output.set_message(parsed_body.message);
                        output.build()
                    }),
                },
                "TooManyRequestsException" => {
                    crate::error::CreateModelError {
                        meta: generic,
                        kind: crate::error::CreateModelErrorKind::TooManyRequestsError({
                            #[allow(unused_mut)]
                            let mut output =
                                crate::error::too_many_requests_error::Builder::default();
                            let _ = response;

                            let body_slice = response.body().as_ref();

                            let parsed_body: crate::error::TooManyRequestsError =
                                if body_slice.is_empty() {
                                    // To enable JSON parsing to succeed, replace an empty body
                                    // with an empty JSON body. If a member was required, it will fail slightly later
                                    // during the operation construction phase.
                                    serde_json::from_slice(b"{}")
                                        .map_err(crate::error::CreateModelError::unhandled)?
                                } else {
                                    serde_json::from_slice(response.body().as_ref())
                                        .map_err(crate::error::CreateModelError::unhandled)?
                                };

                            output = output.set_retry_after_seconds(
                        
                                                crate::http_serde::deser_header_create_model_retry_after_seconds(response.headers())
                                                    .map_err(|_|crate::error::CreateModelError::unhandled("Failed to parse retryAfterSeconds from header `Retry-After"))?
                                                
                    );
                            output = output.set_message(parsed_body.message);
                            output.build()
                        }),
                    }
                }
                "UnauthorizedException" => crate::error::CreateModelError {
                    meta: generic,
                    kind: crate::error::CreateModelErrorKind::UnauthorizedError({
                        #[allow(unused_mut)]
                        let mut output = crate::error::unauthorized_error::Builder::default();
                        let _ = response;

                        let body_slice = response.body().as_ref();

                        let parsed_body: crate::error::UnauthorizedError = if body_slice.is_empty()
                        {
                            // To enable JSON parsing to succeed, replace an empty body
                            // with an empty JSON body. If a member was required, it will fail slightly later
                            // during the operation construction phase.
                            serde_json::from_slice(b"{}")
                                .map_err(crate::error::CreateModelError::unhandled)?
                        } else {
                            serde_json::from_slice(response.body().as_ref())
                                .map_err(crate::error::CreateModelError::unhandled)?
                        };

                        output = output.set_message(parsed_body.message);
                        output.build()
                    }),
                },
                _ => crate::error::CreateModelError::generic(generic),
            });
        }
        Ok({
            #[allow(unused_mut)]
            let mut output = crate::output::create_model_output::Builder::default();
            let _ = response;

            let body_slice = response.body().as_ref();

            let parsed_body: crate::serializer::CreateModelOutputBody = if body_slice.is_empty() {
                // To enable JSON parsing to succeed, replace an empty body
                // with an empty JSON body. If a member was required, it will fail slightly later
                // during the operation construction phase.
                serde_json::from_slice(b"{}").map_err(crate::error::CreateModelError::unhandled)?
            } else {
                serde_json::from_slice(response.body().as_ref())
                    .map_err(crate::error::CreateModelError::unhandled)?
            };

            output = output.set_id(parsed_body.id);
            output = output.set_name(parsed_body.name);
            output = output.set_description(parsed_body.description);
            output = output.set_schema(parsed_body.schema);
            output = output.set_content_type(parsed_body.content_type);
            output.build()
        })
    }
    pub fn parse_response(
        &self,
        response: &http::response::Response<impl AsRef<[u8]>>,
    ) -> Result<crate::output::CreateModelOutput, crate::error::CreateModelError> {
        Self::from_response(&response)
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}

impl smithy_http::response::ParseStrictResponse for CreateModel {
    type Output = Result<crate::output::CreateModelOutput, crate::error::CreateModelError>;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        self.parse_response(response)
    }
}

/// <p>Creates a <a>ReqeustValidator</a> of a given <a>RestApi</a>.</p>
#[derive(std::clone::Clone)]
pub struct CreateRequestValidator {
    _private: (),
}
impl CreateRequestValidator {
    /// Creates a new builder-style object to manufacture [`CreateRequestValidatorInput`](crate::input::CreateRequestValidatorInput)
    pub fn builder() -> crate::input::create_request_validator_input::Builder {
        crate::input::create_request_validator_input::Builder::default()
    }
    #[allow(clippy::unnecessary_wraps)]
    fn from_response(
        response: &http::response::Response<impl AsRef<[u8]>>,
    ) -> Result<
        crate::output::CreateRequestValidatorOutput,
        crate::error::CreateRequestValidatorError,
    > {
        if crate::aws_json_errors::is_error(&response) && response.status().as_u16() != 201 {
            let body = serde_json::from_slice(response.body().as_ref())
                .unwrap_or_else(|_| serde_json::json!({}));
            let generic = crate::aws_json_errors::parse_generic_error(&response, &body);

            let error_code = match generic.code() {
                Some(code) => code,
                None => {
                    return Err(crate::error::CreateRequestValidatorError::unhandled(
                        generic,
                    ))
                }
            };
            return Err(match error_code {
                "BadRequestException" => crate::error::CreateRequestValidatorError {
                    meta: generic,
                    kind: crate::error::CreateRequestValidatorErrorKind::BadRequestError({
                        #[allow(unused_mut)]
                        let mut output = crate::error::bad_request_error::Builder::default();
                        let _ = response;

                        let body_slice = response.body().as_ref();

                        let parsed_body: crate::error::BadRequestError = if body_slice.is_empty() {
                            // To enable JSON parsing to succeed, replace an empty body
                            // with an empty JSON body. If a member was required, it will fail slightly later
                            // during the operation construction phase.
                            serde_json::from_slice(b"{}")
                                .map_err(crate::error::CreateRequestValidatorError::unhandled)?
                        } else {
                            serde_json::from_slice(response.body().as_ref())
                                .map_err(crate::error::CreateRequestValidatorError::unhandled)?
                        };

                        output = output.set_message(parsed_body.message);
                        output.build()
                    }),
                },
                "LimitExceededException" => crate::error::CreateRequestValidatorError {
                    meta: generic,
                    kind: crate::error::CreateRequestValidatorErrorKind::LimitExceededError({
                        #[allow(unused_mut)]
                        let mut output = crate::error::limit_exceeded_error::Builder::default();
                        let _ = response;

                        let body_slice = response.body().as_ref();

                        let parsed_body: crate::error::LimitExceededError = if body_slice.is_empty()
                        {
                            // To enable JSON parsing to succeed, replace an empty body
                            // with an empty JSON body. If a member was required, it will fail slightly later
                            // during the operation construction phase.
                            serde_json::from_slice(b"{}")
                                .map_err(crate::error::CreateRequestValidatorError::unhandled)?
                        } else {
                            serde_json::from_slice(response.body().as_ref())
                                .map_err(crate::error::CreateRequestValidatorError::unhandled)?
                        };

                        output = output.set_retry_after_seconds(
                        
                                                crate::http_serde::deser_header_create_request_validator_retry_after_seconds(response.headers())
                                                    .map_err(|_|crate::error::CreateRequestValidatorError::unhandled("Failed to parse retryAfterSeconds from header `Retry-After"))?
                                                
                    );
                        output = output.set_message(parsed_body.message);
                        output.build()
                    }),
                },
                "NotFoundException" => crate::error::CreateRequestValidatorError {
                    meta: generic,
                    kind: crate::error::CreateRequestValidatorErrorKind::NotFoundError({
                        #[allow(unused_mut)]
                        let mut output = crate::error::not_found_error::Builder::default();
                        let _ = response;

                        let body_slice = response.body().as_ref();

                        let parsed_body: crate::error::NotFoundError = if body_slice.is_empty() {
                            // To enable JSON parsing to succeed, replace an empty body
                            // with an empty JSON body. If a member was required, it will fail slightly later
                            // during the operation construction phase.
                            serde_json::from_slice(b"{}")
                                .map_err(crate::error::CreateRequestValidatorError::unhandled)?
                        } else {
                            serde_json::from_slice(response.body().as_ref())
                                .map_err(crate::error::CreateRequestValidatorError::unhandled)?
                        };

                        output = output.set_message(parsed_body.message);
                        output.build()
                    }),
                },
                "TooManyRequestsException" => crate::error::CreateRequestValidatorError {
                    meta: generic,
                    kind: crate::error::CreateRequestValidatorErrorKind::TooManyRequestsError({
                        #[allow(unused_mut)]
                        let mut output = crate::error::too_many_requests_error::Builder::default();
                        let _ = response;

                        let body_slice = response.body().as_ref();

                        let parsed_body: crate::error::TooManyRequestsError =
                            if body_slice.is_empty() {
                                // To enable JSON parsing to succeed, replace an empty body
                                // with an empty JSON body. If a member was required, it will fail slightly later
                                // during the operation construction phase.
                                serde_json::from_slice(b"{}")
                                    .map_err(crate::error::CreateRequestValidatorError::unhandled)?
                            } else {
                                serde_json::from_slice(response.body().as_ref())
                                    .map_err(crate::error::CreateRequestValidatorError::unhandled)?
                            };

                        output = output.set_retry_after_seconds(
                        
                                                crate::http_serde::deser_header_create_request_validator_retry_after_seconds(response.headers())
                                                    .map_err(|_|crate::error::CreateRequestValidatorError::unhandled("Failed to parse retryAfterSeconds from header `Retry-After"))?
                                                
                    );
                        output = output.set_message(parsed_body.message);
                        output.build()
                    }),
                },
                "UnauthorizedException" => crate::error::CreateRequestValidatorError {
                    meta: generic,
                    kind: crate::error::CreateRequestValidatorErrorKind::UnauthorizedError({
                        #[allow(unused_mut)]
                        let mut output = crate::error::unauthorized_error::Builder::default();
                        let _ = response;

                        let body_slice = response.body().as_ref();

                        let parsed_body: crate::error::UnauthorizedError = if body_slice.is_empty()
                        {
                            // To enable JSON parsing to succeed, replace an empty body
                            // with an empty JSON body. If a member was required, it will fail slightly later
                            // during the operation construction phase.
                            serde_json::from_slice(b"{}")
                                .map_err(crate::error::CreateRequestValidatorError::unhandled)?
                        } else {
                            serde_json::from_slice(response.body().as_ref())
                                .map_err(crate::error::CreateRequestValidatorError::unhandled)?
                        };

                        output = output.set_message(parsed_body.message);
                        output.build()
                    }),
                },
                _ => crate::error::CreateRequestValidatorError::generic(generic),
            });
        }
        Ok({
            #[allow(unused_mut)]
            let mut output = crate::output::create_request_validator_output::Builder::default();
            let _ = response;

            let body_slice = response.body().as_ref();

            let parsed_body: crate::serializer::CreateRequestValidatorOutputBody =
                if body_slice.is_empty() {
                    // To enable JSON parsing to succeed, replace an empty body
                    // with an empty JSON body. If a member was required, it will fail slightly later
                    // during the operation construction phase.
                    serde_json::from_slice(b"{}")
                        .map_err(crate::error::CreateRequestValidatorError::unhandled)?
                } else {
                    serde_json::from_slice(response.body().as_ref())
                        .map_err(crate::error::CreateRequestValidatorError::unhandled)?
                };

            output = output.set_id(parsed_body.id);
            output = output.set_name(parsed_body.name);
            output = output.set_validate_request_body(parsed_body.validate_request_body);
            output =
                output.set_validate_request_parameters(parsed_body.validate_request_parameters);
            output.build()
        })
    }
    pub fn parse_response(
        &self,
        response: &http::response::Response<impl AsRef<[u8]>>,
    ) -> Result<
        crate::output::CreateRequestValidatorOutput,
        crate::error::CreateRequestValidatorError,
    > {
        Self::from_response(&response)
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}

impl smithy_http::response::ParseStrictResponse for CreateRequestValidator {
    type Output = Result<
        crate::output::CreateRequestValidatorOutput,
        crate::error::CreateRequestValidatorError,
    >;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        self.parse_response(response)
    }
}

/// <p>Creates a <a>Resource</a> resource.</p>
#[derive(std::clone::Clone)]
pub struct CreateResource {
    _private: (),
}
impl CreateResource {
    /// Creates a new builder-style object to manufacture [`CreateResourceInput`](crate::input::CreateResourceInput)
    pub fn builder() -> crate::input::create_resource_input::Builder {
        crate::input::create_resource_input::Builder::default()
    }
    #[allow(clippy::unnecessary_wraps)]
    fn from_response(
        response: &http::response::Response<impl AsRef<[u8]>>,
    ) -> Result<crate::output::CreateResourceOutput, crate::error::CreateResourceError> {
        if crate::aws_json_errors::is_error(&response) && response.status().as_u16() != 201 {
            let body = serde_json::from_slice(response.body().as_ref())
                .unwrap_or_else(|_| serde_json::json!({}));
            let generic = crate::aws_json_errors::parse_generic_error(&response, &body);

            let error_code = match generic.code() {
                Some(code) => code,
                None => return Err(crate::error::CreateResourceError::unhandled(generic)),
            };
            return Err(match error_code {
                "BadRequestException" => crate::error::CreateResourceError {
                    meta: generic,
                    kind: crate::error::CreateResourceErrorKind::BadRequestError({
                        #[allow(unused_mut)]
                        let mut output = crate::error::bad_request_error::Builder::default();
                        let _ = response;

                        let body_slice = response.body().as_ref();

                        let parsed_body: crate::error::BadRequestError = if body_slice.is_empty() {
                            // To enable JSON parsing to succeed, replace an empty body
                            // with an empty JSON body. If a member was required, it will fail slightly later
                            // during the operation construction phase.
                            serde_json::from_slice(b"{}")
                                .map_err(crate::error::CreateResourceError::unhandled)?
                        } else {
                            serde_json::from_slice(response.body().as_ref())
                                .map_err(crate::error::CreateResourceError::unhandled)?
                        };

                        output = output.set_message(parsed_body.message);
                        output.build()
                    }),
                },
                "ConflictException" => crate::error::CreateResourceError {
                    meta: generic,
                    kind: crate::error::CreateResourceErrorKind::ConflictError({
                        #[allow(unused_mut)]
                        let mut output = crate::error::conflict_error::Builder::default();
                        let _ = response;

                        let body_slice = response.body().as_ref();

                        let parsed_body: crate::error::ConflictError = if body_slice.is_empty() {
                            // To enable JSON parsing to succeed, replace an empty body
                            // with an empty JSON body. If a member was required, it will fail slightly later
                            // during the operation construction phase.
                            serde_json::from_slice(b"{}")
                                .map_err(crate::error::CreateResourceError::unhandled)?
                        } else {
                            serde_json::from_slice(response.body().as_ref())
                                .map_err(crate::error::CreateResourceError::unhandled)?
                        };

                        output = output.set_message(parsed_body.message);
                        output.build()
                    }),
                },
                "LimitExceededException" => {
                    crate::error::CreateResourceError {
                        meta: generic,
                        kind: crate::error::CreateResourceErrorKind::LimitExceededError({
                            #[allow(unused_mut)]
                            let mut output = crate::error::limit_exceeded_error::Builder::default();
                            let _ = response;

                            let body_slice = response.body().as_ref();

                            let parsed_body: crate::error::LimitExceededError =
                                if body_slice.is_empty() {
                                    // To enable JSON parsing to succeed, replace an empty body
                                    // with an empty JSON body. If a member was required, it will fail slightly later
                                    // during the operation construction phase.
                                    serde_json::from_slice(b"{}")
                                        .map_err(crate::error::CreateResourceError::unhandled)?
                                } else {
                                    serde_json::from_slice(response.body().as_ref())
                                        .map_err(crate::error::CreateResourceError::unhandled)?
                                };

                            output = output.set_retry_after_seconds(
                        
                                                crate::http_serde::deser_header_create_resource_retry_after_seconds(response.headers())
                                                    .map_err(|_|crate::error::CreateResourceError::unhandled("Failed to parse retryAfterSeconds from header `Retry-After"))?
                                                
                    );
                            output = output.set_message(parsed_body.message);
                            output.build()
                        }),
                    }
                }
                "NotFoundException" => crate::error::CreateResourceError {
                    meta: generic,
                    kind: crate::error::CreateResourceErrorKind::NotFoundError({
                        #[allow(unused_mut)]
                        let mut output = crate::error::not_found_error::Builder::default();
                        let _ = response;

                        let body_slice = response.body().as_ref();

                        let parsed_body: crate::error::NotFoundError = if body_slice.is_empty() {
                            // To enable JSON parsing to succeed, replace an empty body
                            // with an empty JSON body. If a member was required, it will fail slightly later
                            // during the operation construction phase.
                            serde_json::from_slice(b"{}")
                                .map_err(crate::error::CreateResourceError::unhandled)?
                        } else {
                            serde_json::from_slice(response.body().as_ref())
                                .map_err(crate::error::CreateResourceError::unhandled)?
                        };

                        output = output.set_message(parsed_body.message);
                        output.build()
                    }),
                },
                "TooManyRequestsException" => {
                    crate::error::CreateResourceError {
                        meta: generic,
                        kind: crate::error::CreateResourceErrorKind::TooManyRequestsError({
                            #[allow(unused_mut)]
                            let mut output =
                                crate::error::too_many_requests_error::Builder::default();
                            let _ = response;

                            let body_slice = response.body().as_ref();

                            let parsed_body: crate::error::TooManyRequestsError =
                                if body_slice.is_empty() {
                                    // To enable JSON parsing to succeed, replace an empty body
                                    // with an empty JSON body. If a member was required, it will fail slightly later
                                    // during the operation construction phase.
                                    serde_json::from_slice(b"{}")
                                        .map_err(crate::error::CreateResourceError::unhandled)?
                                } else {
                                    serde_json::from_slice(response.body().as_ref())
                                        .map_err(crate::error::CreateResourceError::unhandled)?
                                };

                            output = output.set_retry_after_seconds(
                        
                                                crate::http_serde::deser_header_create_resource_retry_after_seconds(response.headers())
                                                    .map_err(|_|crate::error::CreateResourceError::unhandled("Failed to parse retryAfterSeconds from header `Retry-After"))?
                                                
                    );
                            output = output.set_message(parsed_body.message);
                            output.build()
                        }),
                    }
                }
                "UnauthorizedException" => crate::error::CreateResourceError {
                    meta: generic,
                    kind: crate::error::CreateResourceErrorKind::UnauthorizedError({
                        #[allow(unused_mut)]
                        let mut output = crate::error::unauthorized_error::Builder::default();
                        let _ = response;

                        let body_slice = response.body().as_ref();

                        let parsed_body: crate::error::UnauthorizedError = if body_slice.is_empty()
                        {
                            // To enable JSON parsing to succeed, replace an empty body
                            // with an empty JSON body. If a member was required, it will fail slightly later
                            // during the operation construction phase.
                            serde_json::from_slice(b"{}")
                                .map_err(crate::error::CreateResourceError::unhandled)?
                        } else {
                            serde_json::from_slice(response.body().as_ref())
                                .map_err(crate::error::CreateResourceError::unhandled)?
                        };

                        output = output.set_message(parsed_body.message);
                        output.build()
                    }),
                },
                _ => crate::error::CreateResourceError::generic(generic),
            });
        }
        Ok({
            #[allow(unused_mut)]
            let mut output = crate::output::create_resource_output::Builder::default();
            let _ = response;

            let body_slice = response.body().as_ref();

            let parsed_body: crate::serializer::CreateResourceOutputBody = if body_slice.is_empty()
            {
                // To enable JSON parsing to succeed, replace an empty body
                // with an empty JSON body. If a member was required, it will fail slightly later
                // during the operation construction phase.
                serde_json::from_slice(b"{}")
                    .map_err(crate::error::CreateResourceError::unhandled)?
            } else {
                serde_json::from_slice(response.body().as_ref())
                    .map_err(crate::error::CreateResourceError::unhandled)?
            };

            output = output.set_id(parsed_body.id);
            output = output.set_parent_id(parsed_body.parent_id);
            output = output.set_path_part(parsed_body.path_part);
            output = output.set_path(parsed_body.path);
            output = output.set_resource_methods(parsed_body.resource_methods);
            output.build()
        })
    }
    pub fn parse_response(
        &self,
        response: &http::response::Response<impl AsRef<[u8]>>,
    ) -> Result<crate::output::CreateResourceOutput, crate::error::CreateResourceError> {
        Self::from_response(&response)
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}

impl smithy_http::response::ParseStrictResponse for CreateResource {
    type Output = Result<crate::output::CreateResourceOutput, crate::error::CreateResourceError>;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        self.parse_response(response)
    }
}

/// <p>Creates a new <a>RestApi</a> resource.</p>
#[derive(std::clone::Clone)]
pub struct CreateRestApi {
    _private: (),
}
impl CreateRestApi {
    /// Creates a new builder-style object to manufacture [`CreateRestApiInput`](crate::input::CreateRestApiInput)
    pub fn builder() -> crate::input::create_rest_api_input::Builder {
        crate::input::create_rest_api_input::Builder::default()
    }
    #[allow(clippy::unnecessary_wraps)]
    fn from_response(
        response: &http::response::Response<impl AsRef<[u8]>>,
    ) -> Result<crate::output::CreateRestApiOutput, crate::error::CreateRestApiError> {
        if crate::aws_json_errors::is_error(&response) && response.status().as_u16() != 201 {
            let body = serde_json::from_slice(response.body().as_ref())
                .unwrap_or_else(|_| serde_json::json!({}));
            let generic = crate::aws_json_errors::parse_generic_error(&response, &body);

            let error_code = match generic.code() {
                Some(code) => code,
                None => return Err(crate::error::CreateRestApiError::unhandled(generic)),
            };
            return Err(match error_code {
                "BadRequestException" => crate::error::CreateRestApiError {
                    meta: generic,
                    kind: crate::error::CreateRestApiErrorKind::BadRequestError({
                        #[allow(unused_mut)]
                        let mut output = crate::error::bad_request_error::Builder::default();
                        let _ = response;

                        let body_slice = response.body().as_ref();

                        let parsed_body: crate::error::BadRequestError = if body_slice.is_empty() {
                            // To enable JSON parsing to succeed, replace an empty body
                            // with an empty JSON body. If a member was required, it will fail slightly later
                            // during the operation construction phase.
                            serde_json::from_slice(b"{}")
                                .map_err(crate::error::CreateRestApiError::unhandled)?
                        } else {
                            serde_json::from_slice(response.body().as_ref())
                                .map_err(crate::error::CreateRestApiError::unhandled)?
                        };

                        output = output.set_message(parsed_body.message);
                        output.build()
                    }),
                },
                "LimitExceededException" => {
                    crate::error::CreateRestApiError {
                        meta: generic,
                        kind: crate::error::CreateRestApiErrorKind::LimitExceededError({
                            #[allow(unused_mut)]
                            let mut output = crate::error::limit_exceeded_error::Builder::default();
                            let _ = response;

                            let body_slice = response.body().as_ref();

                            let parsed_body: crate::error::LimitExceededError =
                                if body_slice.is_empty() {
                                    // To enable JSON parsing to succeed, replace an empty body
                                    // with an empty JSON body. If a member was required, it will fail slightly later
                                    // during the operation construction phase.
                                    serde_json::from_slice(b"{}")
                                        .map_err(crate::error::CreateRestApiError::unhandled)?
                                } else {
                                    serde_json::from_slice(response.body().as_ref())
                                        .map_err(crate::error::CreateRestApiError::unhandled)?
                                };

                            output = output.set_retry_after_seconds(
                        
                                                crate::http_serde::deser_header_create_rest_api_retry_after_seconds(response.headers())
                                                    .map_err(|_|crate::error::CreateRestApiError::unhandled("Failed to parse retryAfterSeconds from header `Retry-After"))?
                                                
                    );
                            output = output.set_message(parsed_body.message);
                            output.build()
                        }),
                    }
                }
                "TooManyRequestsException" => {
                    crate::error::CreateRestApiError {
                        meta: generic,
                        kind: crate::error::CreateRestApiErrorKind::TooManyRequestsError({
                            #[allow(unused_mut)]
                            let mut output =
                                crate::error::too_many_requests_error::Builder::default();
                            let _ = response;

                            let body_slice = response.body().as_ref();

                            let parsed_body: crate::error::TooManyRequestsError =
                                if body_slice.is_empty() {
                                    // To enable JSON parsing to succeed, replace an empty body
                                    // with an empty JSON body. If a member was required, it will fail slightly later
                                    // during the operation construction phase.
                                    serde_json::from_slice(b"{}")
                                        .map_err(crate::error::CreateRestApiError::unhandled)?
                                } else {
                                    serde_json::from_slice(response.body().as_ref())
                                        .map_err(crate::error::CreateRestApiError::unhandled)?
                                };

                            output = output.set_retry_after_seconds(
                        
                                                crate::http_serde::deser_header_create_rest_api_retry_after_seconds(response.headers())
                                                    .map_err(|_|crate::error::CreateRestApiError::unhandled("Failed to parse retryAfterSeconds from header `Retry-After"))?
                                                
                    );
                            output = output.set_message(parsed_body.message);
                            output.build()
                        }),
                    }
                }
                "UnauthorizedException" => crate::error::CreateRestApiError {
                    meta: generic,
                    kind: crate::error::CreateRestApiErrorKind::UnauthorizedError({
                        #[allow(unused_mut)]
                        let mut output = crate::error::unauthorized_error::Builder::default();
                        let _ = response;

                        let body_slice = response.body().as_ref();

                        let parsed_body: crate::error::UnauthorizedError = if body_slice.is_empty()
                        {
                            // To enable JSON parsing to succeed, replace an empty body
                            // with an empty JSON body. If a member was required, it will fail slightly later
                            // during the operation construction phase.
                            serde_json::from_slice(b"{}")
                                .map_err(crate::error::CreateRestApiError::unhandled)?
                        } else {
                            serde_json::from_slice(response.body().as_ref())
                                .map_err(crate::error::CreateRestApiError::unhandled)?
                        };

                        output = output.set_message(parsed_body.message);
                        output.build()
                    }),
                },
                _ => crate::error::CreateRestApiError::generic(generic),
            });
        }
        Ok({
            #[allow(unused_mut)]
            let mut output = crate::output::create_rest_api_output::Builder::default();
            let _ = response;

            let body_slice = response.body().as_ref();

            let parsed_body: crate::serializer::CreateRestApiOutputBody = if body_slice.is_empty() {
                // To enable JSON parsing to succeed, replace an empty body
                // with an empty JSON body. If a member was required, it will fail slightly later
                // during the operation construction phase.
                serde_json::from_slice(b"{}")
                    .map_err(crate::error::CreateRestApiError::unhandled)?
            } else {
                serde_json::from_slice(response.body().as_ref())
                    .map_err(crate::error::CreateRestApiError::unhandled)?
            };

            output = output.set_id(parsed_body.id);
            output = output.set_name(parsed_body.name);
            output = output.set_description(parsed_body.description);
            output = output.set_created_date(parsed_body.created_date);
            output = output.set_version(parsed_body.version);
            output = output.set_warnings(parsed_body.warnings);
            output = output.set_binary_media_types(parsed_body.binary_media_types);
            output = output.set_minimum_compression_size(parsed_body.minimum_compression_size);
            output = output.set_api_key_source(parsed_body.api_key_source);
            output = output.set_endpoint_configuration(parsed_body.endpoint_configuration);
            output = output.set_policy(parsed_body.policy);
            output = output.set_tags(parsed_body.tags);
            output =
                output.set_disable_execute_api_endpoint(parsed_body.disable_execute_api_endpoint);
            output.build()
        })
    }
    pub fn parse_response(
        &self,
        response: &http::response::Response<impl AsRef<[u8]>>,
    ) -> Result<crate::output::CreateRestApiOutput, crate::error::CreateRestApiError> {
        Self::from_response(&response)
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}

impl smithy_http::response::ParseStrictResponse for CreateRestApi {
    type Output = Result<crate::output::CreateRestApiOutput, crate::error::CreateRestApiError>;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        self.parse_response(response)
    }
}

/// <p>Creates a new <a>Stage</a> resource that references a pre-existing <a>Deployment</a> for the API. </p>
/// <!--   <p>Creates a <a>Stage</a> resource.</p>  -->
#[derive(std::clone::Clone)]
pub struct CreateStage {
    _private: (),
}
impl CreateStage {
    /// Creates a new builder-style object to manufacture [`CreateStageInput`](crate::input::CreateStageInput)
    pub fn builder() -> crate::input::create_stage_input::Builder {
        crate::input::create_stage_input::Builder::default()
    }
    #[allow(clippy::unnecessary_wraps)]
    fn from_response(
        response: &http::response::Response<impl AsRef<[u8]>>,
    ) -> Result<crate::output::CreateStageOutput, crate::error::CreateStageError> {
        if crate::aws_json_errors::is_error(&response) && response.status().as_u16() != 201 {
            let body = serde_json::from_slice(response.body().as_ref())
                .unwrap_or_else(|_| serde_json::json!({}));
            let generic = crate::aws_json_errors::parse_generic_error(&response, &body);

            let error_code = match generic.code() {
                Some(code) => code,
                None => return Err(crate::error::CreateStageError::unhandled(generic)),
            };
            return Err(match error_code {
                "BadRequestException" => crate::error::CreateStageError {
                    meta: generic,
                    kind: crate::error::CreateStageErrorKind::BadRequestError({
                        #[allow(unused_mut)]
                        let mut output = crate::error::bad_request_error::Builder::default();
                        let _ = response;

                        let body_slice = response.body().as_ref();

                        let parsed_body: crate::error::BadRequestError = if body_slice.is_empty() {
                            // To enable JSON parsing to succeed, replace an empty body
                            // with an empty JSON body. If a member was required, it will fail slightly later
                            // during the operation construction phase.
                            serde_json::from_slice(b"{}")
                                .map_err(crate::error::CreateStageError::unhandled)?
                        } else {
                            serde_json::from_slice(response.body().as_ref())
                                .map_err(crate::error::CreateStageError::unhandled)?
                        };

                        output = output.set_message(parsed_body.message);
                        output.build()
                    }),
                },
                "ConflictException" => crate::error::CreateStageError {
                    meta: generic,
                    kind: crate::error::CreateStageErrorKind::ConflictError({
                        #[allow(unused_mut)]
                        let mut output = crate::error::conflict_error::Builder::default();
                        let _ = response;

                        let body_slice = response.body().as_ref();

                        let parsed_body: crate::error::ConflictError = if body_slice.is_empty() {
                            // To enable JSON parsing to succeed, replace an empty body
                            // with an empty JSON body. If a member was required, it will fail slightly later
                            // during the operation construction phase.
                            serde_json::from_slice(b"{}")
                                .map_err(crate::error::CreateStageError::unhandled)?
                        } else {
                            serde_json::from_slice(response.body().as_ref())
                                .map_err(crate::error::CreateStageError::unhandled)?
                        };

                        output = output.set_message(parsed_body.message);
                        output.build()
                    }),
                },
                "LimitExceededException" => {
                    crate::error::CreateStageError {
                        meta: generic,
                        kind: crate::error::CreateStageErrorKind::LimitExceededError({
                            #[allow(unused_mut)]
                            let mut output = crate::error::limit_exceeded_error::Builder::default();
                            let _ = response;

                            let body_slice = response.body().as_ref();

                            let parsed_body: crate::error::LimitExceededError =
                                if body_slice.is_empty() {
                                    // To enable JSON parsing to succeed, replace an empty body
                                    // with an empty JSON body. If a member was required, it will fail slightly later
                                    // during the operation construction phase.
                                    serde_json::from_slice(b"{}")
                                        .map_err(crate::error::CreateStageError::unhandled)?
                                } else {
                                    serde_json::from_slice(response.body().as_ref())
                                        .map_err(crate::error::CreateStageError::unhandled)?
                                };

                            output = output.set_retry_after_seconds(
                        
                                                crate::http_serde::deser_header_create_stage_retry_after_seconds(response.headers())
                                                    .map_err(|_|crate::error::CreateStageError::unhandled("Failed to parse retryAfterSeconds from header `Retry-After"))?
                                                
                    );
                            output = output.set_message(parsed_body.message);
                            output.build()
                        }),
                    }
                }
                "NotFoundException" => crate::error::CreateStageError {
                    meta: generic,
                    kind: crate::error::CreateStageErrorKind::NotFoundError({
                        #[allow(unused_mut)]
                        let mut output = crate::error::not_found_error::Builder::default();
                        let _ = response;

                        let body_slice = response.body().as_ref();

                        let parsed_body: crate::error::NotFoundError = if body_slice.is_empty() {
                            // To enable JSON parsing to succeed, replace an empty body
                            // with an empty JSON body. If a member was required, it will fail slightly later
                            // during the operation construction phase.
                            serde_json::from_slice(b"{}")
                                .map_err(crate::error::CreateStageError::unhandled)?
                        } else {
                            serde_json::from_slice(response.body().as_ref())
                                .map_err(crate::error::CreateStageError::unhandled)?
                        };

                        output = output.set_message(parsed_body.message);
                        output.build()
                    }),
                },
                "TooManyRequestsException" => {
                    crate::error::CreateStageError {
                        meta: generic,
                        kind: crate::error::CreateStageErrorKind::TooManyRequestsError({
                            #[allow(unused_mut)]
                            let mut output =
                                crate::error::too_many_requests_error::Builder::default();
                            let _ = response;

                            let body_slice = response.body().as_ref();

                            let parsed_body: crate::error::TooManyRequestsError =
                                if body_slice.is_empty() {
                                    // To enable JSON parsing to succeed, replace an empty body
                                    // with an empty JSON body. If a member was required, it will fail slightly later
                                    // during the operation construction phase.
                                    serde_json::from_slice(b"{}")
                                        .map_err(crate::error::CreateStageError::unhandled)?
                                } else {
                                    serde_json::from_slice(response.body().as_ref())
                                        .map_err(crate::error::CreateStageError::unhandled)?
                                };

                            output = output.set_retry_after_seconds(
                        
                                                crate::http_serde::deser_header_create_stage_retry_after_seconds(response.headers())
                                                    .map_err(|_|crate::error::CreateStageError::unhandled("Failed to parse retryAfterSeconds from header `Retry-After"))?
                                                
                    );
                            output = output.set_message(parsed_body.message);
                            output.build()
                        }),
                    }
                }
                "UnauthorizedException" => crate::error::CreateStageError {
                    meta: generic,
                    kind: crate::error::CreateStageErrorKind::UnauthorizedError({
                        #[allow(unused_mut)]
                        let mut output = crate::error::unauthorized_error::Builder::default();
                        let _ = response;

                        let body_slice = response.body().as_ref();

                        let parsed_body: crate::error::UnauthorizedError = if body_slice.is_empty()
                        {
                            // To enable JSON parsing to succeed, replace an empty body
                            // with an empty JSON body. If a member was required, it will fail slightly later
                            // during the operation construction phase.
                            serde_json::from_slice(b"{}")
                                .map_err(crate::error::CreateStageError::unhandled)?
                        } else {
                            serde_json::from_slice(response.body().as_ref())
                                .map_err(crate::error::CreateStageError::unhandled)?
                        };

                        output = output.set_message(parsed_body.message);
                        output.build()
                    }),
                },
                _ => crate::error::CreateStageError::generic(generic),
            });
        }
        Ok({
            #[allow(unused_mut)]
            let mut output = crate::output::create_stage_output::Builder::default();
            let _ = response;

            let body_slice = response.body().as_ref();

            let parsed_body: crate::serializer::CreateStageOutputBody = if body_slice.is_empty() {
                // To enable JSON parsing to succeed, replace an empty body
                // with an empty JSON body. If a member was required, it will fail slightly later
                // during the operation construction phase.
                serde_json::from_slice(b"{}").map_err(crate::error::CreateStageError::unhandled)?
            } else {
                serde_json::from_slice(response.body().as_ref())
                    .map_err(crate::error::CreateStageError::unhandled)?
            };

            output = output.set_deployment_id(parsed_body.deployment_id);
            output = output.set_client_certificate_id(parsed_body.client_certificate_id);
            output = output.set_stage_name(parsed_body.stage_name);
            output = output.set_description(parsed_body.description);
            output = output.set_cache_cluster_enabled(parsed_body.cache_cluster_enabled);
            output = output.set_cache_cluster_size(parsed_body.cache_cluster_size);
            output = output.set_cache_cluster_status(parsed_body.cache_cluster_status);
            output = output.set_method_settings(parsed_body.method_settings);
            output = output.set_variables(parsed_body.variables);
            output = output.set_documentation_version(parsed_body.documentation_version);
            output = output.set_access_log_settings(parsed_body.access_log_settings);
            output = output.set_canary_settings(parsed_body.canary_settings);
            output = output.set_tracing_enabled(parsed_body.tracing_enabled);
            output = output.set_web_acl_arn(parsed_body.web_acl_arn);
            output = output.set_tags(parsed_body.tags);
            output = output.set_created_date(parsed_body.created_date);
            output = output.set_last_updated_date(parsed_body.last_updated_date);
            output.build()
        })
    }
    pub fn parse_response(
        &self,
        response: &http::response::Response<impl AsRef<[u8]>>,
    ) -> Result<crate::output::CreateStageOutput, crate::error::CreateStageError> {
        Self::from_response(&response)
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}

impl smithy_http::response::ParseStrictResponse for CreateStage {
    type Output = Result<crate::output::CreateStageOutput, crate::error::CreateStageError>;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        self.parse_response(response)
    }
}

/// <p>Creates a usage plan with the throttle and quota limits, as well as the associated API stages, specified in the payload. </p>
#[derive(std::clone::Clone)]
pub struct CreateUsagePlan {
    _private: (),
}
impl CreateUsagePlan {
    /// Creates a new builder-style object to manufacture [`CreateUsagePlanInput`](crate::input::CreateUsagePlanInput)
    pub fn builder() -> crate::input::create_usage_plan_input::Builder {
        crate::input::create_usage_plan_input::Builder::default()
    }
    #[allow(clippy::unnecessary_wraps)]
    fn from_response(
        response: &http::response::Response<impl AsRef<[u8]>>,
    ) -> Result<crate::output::CreateUsagePlanOutput, crate::error::CreateUsagePlanError> {
        if crate::aws_json_errors::is_error(&response) && response.status().as_u16() != 201 {
            let body = serde_json::from_slice(response.body().as_ref())
                .unwrap_or_else(|_| serde_json::json!({}));
            let generic = crate::aws_json_errors::parse_generic_error(&response, &body);

            let error_code = match generic.code() {
                Some(code) => code,
                None => return Err(crate::error::CreateUsagePlanError::unhandled(generic)),
            };
            return Err(match error_code {
                "BadRequestException" => crate::error::CreateUsagePlanError {
                    meta: generic,
                    kind: crate::error::CreateUsagePlanErrorKind::BadRequestError({
                        #[allow(unused_mut)]
                        let mut output = crate::error::bad_request_error::Builder::default();
                        let _ = response;

                        let body_slice = response.body().as_ref();

                        let parsed_body: crate::error::BadRequestError = if body_slice.is_empty() {
                            // To enable JSON parsing to succeed, replace an empty body
                            // with an empty JSON body. If a member was required, it will fail slightly later
                            // during the operation construction phase.
                            serde_json::from_slice(b"{}")
                                .map_err(crate::error::CreateUsagePlanError::unhandled)?
                        } else {
                            serde_json::from_slice(response.body().as_ref())
                                .map_err(crate::error::CreateUsagePlanError::unhandled)?
                        };

                        output = output.set_message(parsed_body.message);
                        output.build()
                    }),
                },
                "ConflictException" => crate::error::CreateUsagePlanError {
                    meta: generic,
                    kind: crate::error::CreateUsagePlanErrorKind::ConflictError({
                        #[allow(unused_mut)]
                        let mut output = crate::error::conflict_error::Builder::default();
                        let _ = response;

                        let body_slice = response.body().as_ref();

                        let parsed_body: crate::error::ConflictError = if body_slice.is_empty() {
                            // To enable JSON parsing to succeed, replace an empty body
                            // with an empty JSON body. If a member was required, it will fail slightly later
                            // during the operation construction phase.
                            serde_json::from_slice(b"{}")
                                .map_err(crate::error::CreateUsagePlanError::unhandled)?
                        } else {
                            serde_json::from_slice(response.body().as_ref())
                                .map_err(crate::error::CreateUsagePlanError::unhandled)?
                        };

                        output = output.set_message(parsed_body.message);
                        output.build()
                    }),
                },
                "LimitExceededException" => {
                    crate::error::CreateUsagePlanError {
                        meta: generic,
                        kind: crate::error::CreateUsagePlanErrorKind::LimitExceededError({
                            #[allow(unused_mut)]
                            let mut output = crate::error::limit_exceeded_error::Builder::default();
                            let _ = response;

                            let body_slice = response.body().as_ref();

                            let parsed_body: crate::error::LimitExceededError =
                                if body_slice.is_empty() {
                                    // To enable JSON parsing to succeed, replace an empty body
                                    // with an empty JSON body. If a member was required, it will fail slightly later
                                    // during the operation construction phase.
                                    serde_json::from_slice(b"{}")
                                        .map_err(crate::error::CreateUsagePlanError::unhandled)?
                                } else {
                                    serde_json::from_slice(response.body().as_ref())
                                        .map_err(crate::error::CreateUsagePlanError::unhandled)?
                                };

                            output = output.set_retry_after_seconds(
                        
                                                crate::http_serde::deser_header_create_usage_plan_retry_after_seconds(response.headers())
                                                    .map_err(|_|crate::error::CreateUsagePlanError::unhandled("Failed to parse retryAfterSeconds from header `Retry-After"))?
                                                
                    );
                            output = output.set_message(parsed_body.message);
                            output.build()
                        }),
                    }
                }
                "NotFoundException" => crate::error::CreateUsagePlanError {
                    meta: generic,
                    kind: crate::error::CreateUsagePlanErrorKind::NotFoundError({
                        #[allow(unused_mut)]
                        let mut output = crate::error::not_found_error::Builder::default();
                        let _ = response;

                        let body_slice = response.body().as_ref();

                        let parsed_body: crate::error::NotFoundError = if body_slice.is_empty() {
                            // To enable JSON parsing to succeed, replace an empty body
                            // with an empty JSON body. If a member was required, it will fail slightly later
                            // during the operation construction phase.
                            serde_json::from_slice(b"{}")
                                .map_err(crate::error::CreateUsagePlanError::unhandled)?
                        } else {
                            serde_json::from_slice(response.body().as_ref())
                                .map_err(crate::error::CreateUsagePlanError::unhandled)?
                        };

                        output = output.set_message(parsed_body.message);
                        output.build()
                    }),
                },
                "TooManyRequestsException" => {
                    crate::error::CreateUsagePlanError {
                        meta: generic,
                        kind: crate::error::CreateUsagePlanErrorKind::TooManyRequestsError({
                            #[allow(unused_mut)]
                            let mut output =
                                crate::error::too_many_requests_error::Builder::default();
                            let _ = response;

                            let body_slice = response.body().as_ref();

                            let parsed_body: crate::error::TooManyRequestsError =
                                if body_slice.is_empty() {
                                    // To enable JSON parsing to succeed, replace an empty body
                                    // with an empty JSON body. If a member was required, it will fail slightly later
                                    // during the operation construction phase.
                                    serde_json::from_slice(b"{}")
                                        .map_err(crate::error::CreateUsagePlanError::unhandled)?
                                } else {
                                    serde_json::from_slice(response.body().as_ref())
                                        .map_err(crate::error::CreateUsagePlanError::unhandled)?
                                };

                            output = output.set_retry_after_seconds(
                        
                                                crate::http_serde::deser_header_create_usage_plan_retry_after_seconds(response.headers())
                                                    .map_err(|_|crate::error::CreateUsagePlanError::unhandled("Failed to parse retryAfterSeconds from header `Retry-After"))?
                                                
                    );
                            output = output.set_message(parsed_body.message);
                            output.build()
                        }),
                    }
                }
                "UnauthorizedException" => crate::error::CreateUsagePlanError {
                    meta: generic,
                    kind: crate::error::CreateUsagePlanErrorKind::UnauthorizedError({
                        #[allow(unused_mut)]
                        let mut output = crate::error::unauthorized_error::Builder::default();
                        let _ = response;

                        let body_slice = response.body().as_ref();

                        let parsed_body: crate::error::UnauthorizedError = if body_slice.is_empty()
                        {
                            // To enable JSON parsing to succeed, replace an empty body
                            // with an empty JSON body. If a member was required, it will fail slightly later
                            // during the operation construction phase.
                            serde_json::from_slice(b"{}")
                                .map_err(crate::error::CreateUsagePlanError::unhandled)?
                        } else {
                            serde_json::from_slice(response.body().as_ref())
                                .map_err(crate::error::CreateUsagePlanError::unhandled)?
                        };

                        output = output.set_message(parsed_body.message);
                        output.build()
                    }),
                },
                _ => crate::error::CreateUsagePlanError::generic(generic),
            });
        }
        Ok({
            #[allow(unused_mut)]
            let mut output = crate::output::create_usage_plan_output::Builder::default();
            let _ = response;

            let body_slice = response.body().as_ref();

            let parsed_body: crate::serializer::CreateUsagePlanOutputBody = if body_slice.is_empty()
            {
                // To enable JSON parsing to succeed, replace an empty body
                // with an empty JSON body. If a member was required, it will fail slightly later
                // during the operation construction phase.
                serde_json::from_slice(b"{}")
                    .map_err(crate::error::CreateUsagePlanError::unhandled)?
            } else {
                serde_json::from_slice(response.body().as_ref())
                    .map_err(crate::error::CreateUsagePlanError::unhandled)?
            };

            output = output.set_id(parsed_body.id);
            output = output.set_name(parsed_body.name);
            output = output.set_description(parsed_body.description);
            output = output.set_api_stages(parsed_body.api_stages);
            output = output.set_throttle(parsed_body.throttle);
            output = output.set_quota(parsed_body.quota);
            output = output.set_product_code(parsed_body.product_code);
            output = output.set_tags(parsed_body.tags);
            output.build()
        })
    }
    pub fn parse_response(
        &self,
        response: &http::response::Response<impl AsRef<[u8]>>,
    ) -> Result<crate::output::CreateUsagePlanOutput, crate::error::CreateUsagePlanError> {
        Self::from_response(&response)
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}

impl smithy_http::response::ParseStrictResponse for CreateUsagePlan {
    type Output = Result<crate::output::CreateUsagePlanOutput, crate::error::CreateUsagePlanError>;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        self.parse_response(response)
    }
}

/// <p>Creates a usage plan key for adding an existing API key to a usage plan.</p>
#[derive(std::clone::Clone)]
pub struct CreateUsagePlanKey {
    _private: (),
}
impl CreateUsagePlanKey {
    /// Creates a new builder-style object to manufacture [`CreateUsagePlanKeyInput`](crate::input::CreateUsagePlanKeyInput)
    pub fn builder() -> crate::input::create_usage_plan_key_input::Builder {
        crate::input::create_usage_plan_key_input::Builder::default()
    }
    #[allow(clippy::unnecessary_wraps)]
    fn from_response(
        response: &http::response::Response<impl AsRef<[u8]>>,
    ) -> Result<crate::output::CreateUsagePlanKeyOutput, crate::error::CreateUsagePlanKeyError>
    {
        if crate::aws_json_errors::is_error(&response) && response.status().as_u16() != 201 {
            let body = serde_json::from_slice(response.body().as_ref())
                .unwrap_or_else(|_| serde_json::json!({}));
            let generic = crate::aws_json_errors::parse_generic_error(&response, &body);

            let error_code = match generic.code() {
                Some(code) => code,
                None => return Err(crate::error::CreateUsagePlanKeyError::unhandled(generic)),
            };
            return Err(match error_code {
                "BadRequestException" => crate::error::CreateUsagePlanKeyError {
                    meta: generic,
                    kind: crate::error::CreateUsagePlanKeyErrorKind::BadRequestError({
                        #[allow(unused_mut)]
                        let mut output = crate::error::bad_request_error::Builder::default();
                        let _ = response;

                        let body_slice = response.body().as_ref();

                        let parsed_body: crate::error::BadRequestError = if body_slice.is_empty() {
                            // To enable JSON parsing to succeed, replace an empty body
                            // with an empty JSON body. If a member was required, it will fail slightly later
                            // during the operation construction phase.
                            serde_json::from_slice(b"{}")
                                .map_err(crate::error::CreateUsagePlanKeyError::unhandled)?
                        } else {
                            serde_json::from_slice(response.body().as_ref())
                                .map_err(crate::error::CreateUsagePlanKeyError::unhandled)?
                        };

                        output = output.set_message(parsed_body.message);
                        output.build()
                    }),
                },
                "ConflictException" => crate::error::CreateUsagePlanKeyError {
                    meta: generic,
                    kind: crate::error::CreateUsagePlanKeyErrorKind::ConflictError({
                        #[allow(unused_mut)]
                        let mut output = crate::error::conflict_error::Builder::default();
                        let _ = response;

                        let body_slice = response.body().as_ref();

                        let parsed_body: crate::error::ConflictError = if body_slice.is_empty() {
                            // To enable JSON parsing to succeed, replace an empty body
                            // with an empty JSON body. If a member was required, it will fail slightly later
                            // during the operation construction phase.
                            serde_json::from_slice(b"{}")
                                .map_err(crate::error::CreateUsagePlanKeyError::unhandled)?
                        } else {
                            serde_json::from_slice(response.body().as_ref())
                                .map_err(crate::error::CreateUsagePlanKeyError::unhandled)?
                        };

                        output = output.set_message(parsed_body.message);
                        output.build()
                    }),
                },
                "NotFoundException" => crate::error::CreateUsagePlanKeyError {
                    meta: generic,
                    kind: crate::error::CreateUsagePlanKeyErrorKind::NotFoundError({
                        #[allow(unused_mut)]
                        let mut output = crate::error::not_found_error::Builder::default();
                        let _ = response;

                        let body_slice = response.body().as_ref();

                        let parsed_body: crate::error::NotFoundError = if body_slice.is_empty() {
                            // To enable JSON parsing to succeed, replace an empty body
                            // with an empty JSON body. If a member was required, it will fail slightly later
                            // during the operation construction phase.
                            serde_json::from_slice(b"{}")
                                .map_err(crate::error::CreateUsagePlanKeyError::unhandled)?
                        } else {
                            serde_json::from_slice(response.body().as_ref())
                                .map_err(crate::error::CreateUsagePlanKeyError::unhandled)?
                        };

                        output = output.set_message(parsed_body.message);
                        output.build()
                    }),
                },
                "TooManyRequestsException" => crate::error::CreateUsagePlanKeyError {
                    meta: generic,
                    kind: crate::error::CreateUsagePlanKeyErrorKind::TooManyRequestsError({
                        #[allow(unused_mut)]
                        let mut output = crate::error::too_many_requests_error::Builder::default();
                        let _ = response;

                        let body_slice = response.body().as_ref();

                        let parsed_body: crate::error::TooManyRequestsError =
                            if body_slice.is_empty() {
                                // To enable JSON parsing to succeed, replace an empty body
                                // with an empty JSON body. If a member was required, it will fail slightly later
                                // during the operation construction phase.
                                serde_json::from_slice(b"{}")
                                    .map_err(crate::error::CreateUsagePlanKeyError::unhandled)?
                            } else {
                                serde_json::from_slice(response.body().as_ref())
                                    .map_err(crate::error::CreateUsagePlanKeyError::unhandled)?
                            };

                        output = output.set_retry_after_seconds(
                        
                                                crate::http_serde::deser_header_create_usage_plan_key_retry_after_seconds(response.headers())
                                                    .map_err(|_|crate::error::CreateUsagePlanKeyError::unhandled("Failed to parse retryAfterSeconds from header `Retry-After"))?
                                                
                    );
                        output = output.set_message(parsed_body.message);
                        output.build()
                    }),
                },
                "UnauthorizedException" => crate::error::CreateUsagePlanKeyError {
                    meta: generic,
                    kind: crate::error::CreateUsagePlanKeyErrorKind::UnauthorizedError({
                        #[allow(unused_mut)]
                        let mut output = crate::error::unauthorized_error::Builder::default();
                        let _ = response;

                        let body_slice = response.body().as_ref();

                        let parsed_body: crate::error::UnauthorizedError = if body_slice.is_empty()
                        {
                            // To enable JSON parsing to succeed, replace an empty body
                            // with an empty JSON body. If a member was required, it will fail slightly later
                            // during the operation construction phase.
                            serde_json::from_slice(b"{}")
                                .map_err(crate::error::CreateUsagePlanKeyError::unhandled)?
                        } else {
                            serde_json::from_slice(response.body().as_ref())
                                .map_err(crate::error::CreateUsagePlanKeyError::unhandled)?
                        };

                        output = output.set_message(parsed_body.message);
                        output.build()
                    }),
                },
                _ => crate::error::CreateUsagePlanKeyError::generic(generic),
            });
        }
        Ok({
            #[allow(unused_mut)]
            let mut output = crate::output::create_usage_plan_key_output::Builder::default();
            let _ = response;

            let body_slice = response.body().as_ref();

            let parsed_body: crate::serializer::CreateUsagePlanKeyOutputBody =
                if body_slice.is_empty() {
                    // To enable JSON parsing to succeed, replace an empty body
                    // with an empty JSON body. If a member was required, it will fail slightly later
                    // during the operation construction phase.
                    serde_json::from_slice(b"{}")
                        .map_err(crate::error::CreateUsagePlanKeyError::unhandled)?
                } else {
                    serde_json::from_slice(response.body().as_ref())
                        .map_err(crate::error::CreateUsagePlanKeyError::unhandled)?
                };

            output = output.set_id(parsed_body.id);
            output = output.set_type(parsed_body.r#type);
            output = output.set_value(parsed_body.value);
            output = output.set_name(parsed_body.name);
            output.build()
        })
    }
    pub fn parse_response(
        &self,
        response: &http::response::Response<impl AsRef<[u8]>>,
    ) -> Result<crate::output::CreateUsagePlanKeyOutput, crate::error::CreateUsagePlanKeyError>
    {
        Self::from_response(&response)
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}

impl smithy_http::response::ParseStrictResponse for CreateUsagePlanKey {
    type Output =
        Result<crate::output::CreateUsagePlanKeyOutput, crate::error::CreateUsagePlanKeyError>;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        self.parse_response(response)
    }
}

/// <p>Creates a VPC link, under the caller's account in a selected region, in an asynchronous operation that typically takes 2-4 minutes to complete and become operational. The caller must have permissions to create and update VPC Endpoint services.</p>
#[derive(std::clone::Clone)]
pub struct CreateVpcLink {
    _private: (),
}
impl CreateVpcLink {
    /// Creates a new builder-style object to manufacture [`CreateVpcLinkInput`](crate::input::CreateVpcLinkInput)
    pub fn builder() -> crate::input::create_vpc_link_input::Builder {
        crate::input::create_vpc_link_input::Builder::default()
    }
    #[allow(clippy::unnecessary_wraps)]
    fn from_response(
        response: &http::response::Response<impl AsRef<[u8]>>,
    ) -> Result<crate::output::CreateVpcLinkOutput, crate::error::CreateVpcLinkError> {
        if crate::aws_json_errors::is_error(&response) && response.status().as_u16() != 202 {
            let body = serde_json::from_slice(response.body().as_ref())
                .unwrap_or_else(|_| serde_json::json!({}));
            let generic = crate::aws_json_errors::parse_generic_error(&response, &body);

            let error_code = match generic.code() {
                Some(code) => code,
                None => return Err(crate::error::CreateVpcLinkError::unhandled(generic)),
            };
            return Err(match error_code {
                "BadRequestException" => crate::error::CreateVpcLinkError {
                    meta: generic,
                    kind: crate::error::CreateVpcLinkErrorKind::BadRequestError({
                        #[allow(unused_mut)]
                        let mut output = crate::error::bad_request_error::Builder::default();
                        let _ = response;

                        let body_slice = response.body().as_ref();

                        let parsed_body: crate::error::BadRequestError = if body_slice.is_empty() {
                            // To enable JSON parsing to succeed, replace an empty body
                            // with an empty JSON body. If a member was required, it will fail slightly later
                            // during the operation construction phase.
                            serde_json::from_slice(b"{}")
                                .map_err(crate::error::CreateVpcLinkError::unhandled)?
                        } else {
                            serde_json::from_slice(response.body().as_ref())
                                .map_err(crate::error::CreateVpcLinkError::unhandled)?
                        };

                        output = output.set_message(parsed_body.message);
                        output.build()
                    }),
                },
                "TooManyRequestsException" => {
                    crate::error::CreateVpcLinkError {
                        meta: generic,
                        kind: crate::error::CreateVpcLinkErrorKind::TooManyRequestsError({
                            #[allow(unused_mut)]
                            let mut output =
                                crate::error::too_many_requests_error::Builder::default();
                            let _ = response;

                            let body_slice = response.body().as_ref();

                            let parsed_body: crate::error::TooManyRequestsError =
                                if body_slice.is_empty() {
                                    // To enable JSON parsing to succeed, replace an empty body
                                    // with an empty JSON body. If a member was required, it will fail slightly later
                                    // during the operation construction phase.
                                    serde_json::from_slice(b"{}")
                                        .map_err(crate::error::CreateVpcLinkError::unhandled)?
                                } else {
                                    serde_json::from_slice(response.body().as_ref())
                                        .map_err(crate::error::CreateVpcLinkError::unhandled)?
                                };

                            output = output.set_retry_after_seconds(
                        
                                                crate::http_serde::deser_header_create_vpc_link_retry_after_seconds(response.headers())
                                                    .map_err(|_|crate::error::CreateVpcLinkError::unhandled("Failed to parse retryAfterSeconds from header `Retry-After"))?
                                                
                    );
                            output = output.set_message(parsed_body.message);
                            output.build()
                        }),
                    }
                }
                "UnauthorizedException" => crate::error::CreateVpcLinkError {
                    meta: generic,
                    kind: crate::error::CreateVpcLinkErrorKind::UnauthorizedError({
                        #[allow(unused_mut)]
                        let mut output = crate::error::unauthorized_error::Builder::default();
                        let _ = response;

                        let body_slice = response.body().as_ref();

                        let parsed_body: crate::error::UnauthorizedError = if body_slice.is_empty()
                        {
                            // To enable JSON parsing to succeed, replace an empty body
                            // with an empty JSON body. If a member was required, it will fail slightly later
                            // during the operation construction phase.
                            serde_json::from_slice(b"{}")
                                .map_err(crate::error::CreateVpcLinkError::unhandled)?
                        } else {
                            serde_json::from_slice(response.body().as_ref())
                                .map_err(crate::error::CreateVpcLinkError::unhandled)?
                        };

                        output = output.set_message(parsed_body.message);
                        output.build()
                    }),
                },
                _ => crate::error::CreateVpcLinkError::generic(generic),
            });
        }
        Ok({
            #[allow(unused_mut)]
            let mut output = crate::output::create_vpc_link_output::Builder::default();
            let _ = response;

            let body_slice = response.body().as_ref();

            let parsed_body: crate::serializer::CreateVpcLinkOutputBody = if body_slice.is_empty() {
                // To enable JSON parsing to succeed, replace an empty body
                // with an empty JSON body. If a member was required, it will fail slightly later
                // during the operation construction phase.
                serde_json::from_slice(b"{}")
                    .map_err(crate::error::CreateVpcLinkError::unhandled)?
            } else {
                serde_json::from_slice(response.body().as_ref())
                    .map_err(crate::error::CreateVpcLinkError::unhandled)?
            };

            output = output.set_id(parsed_body.id);
            output = output.set_name(parsed_body.name);
            output = output.set_description(parsed_body.description);
            output = output.set_target_arns(parsed_body.target_arns);
            output = output.set_status(parsed_body.status);
            output = output.set_status_message(parsed_body.status_message);
            output = output.set_tags(parsed_body.tags);
            output.build()
        })
    }
    pub fn parse_response(
        &self,
        response: &http::response::Response<impl AsRef<[u8]>>,
    ) -> Result<crate::output::CreateVpcLinkOutput, crate::error::CreateVpcLinkError> {
        Self::from_response(&response)
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}

impl smithy_http::response::ParseStrictResponse for CreateVpcLink {
    type Output = Result<crate::output::CreateVpcLinkOutput, crate::error::CreateVpcLinkError>;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        self.parse_response(response)
    }
}

/// <p>Deletes the <a>ApiKey</a> resource.</p>
#[derive(std::clone::Clone)]
pub struct DeleteApiKey {
    _private: (),
}
impl DeleteApiKey {
    /// Creates a new builder-style object to manufacture [`DeleteApiKeyInput`](crate::input::DeleteApiKeyInput)
    pub fn builder() -> crate::input::delete_api_key_input::Builder {
        crate::input::delete_api_key_input::Builder::default()
    }
    #[allow(clippy::unnecessary_wraps)]
    fn from_response(
        response: &http::response::Response<impl AsRef<[u8]>>,
    ) -> Result<crate::output::DeleteApiKeyOutput, crate::error::DeleteApiKeyError> {
        if crate::aws_json_errors::is_error(&response) && response.status().as_u16() != 202 {
            let body = serde_json::from_slice(response.body().as_ref())
                .unwrap_or_else(|_| serde_json::json!({}));
            let generic = crate::aws_json_errors::parse_generic_error(&response, &body);

            let error_code = match generic.code() {
                Some(code) => code,
                None => return Err(crate::error::DeleteApiKeyError::unhandled(generic)),
            };
            return Err(match error_code {
                "NotFoundException" => crate::error::DeleteApiKeyError {
                    meta: generic,
                    kind: crate::error::DeleteApiKeyErrorKind::NotFoundError({
                        #[allow(unused_mut)]
                        let mut output = crate::error::not_found_error::Builder::default();
                        let _ = response;

                        let body_slice = response.body().as_ref();

                        let parsed_body: crate::error::NotFoundError = if body_slice.is_empty() {
                            // To enable JSON parsing to succeed, replace an empty body
                            // with an empty JSON body. If a member was required, it will fail slightly later
                            // during the operation construction phase.
                            serde_json::from_slice(b"{}")
                                .map_err(crate::error::DeleteApiKeyError::unhandled)?
                        } else {
                            serde_json::from_slice(response.body().as_ref())
                                .map_err(crate::error::DeleteApiKeyError::unhandled)?
                        };

                        output = output.set_message(parsed_body.message);
                        output.build()
                    }),
                },
                "TooManyRequestsException" => {
                    crate::error::DeleteApiKeyError {
                        meta: generic,
                        kind: crate::error::DeleteApiKeyErrorKind::TooManyRequestsError({
                            #[allow(unused_mut)]
                            let mut output =
                                crate::error::too_many_requests_error::Builder::default();
                            let _ = response;

                            let body_slice = response.body().as_ref();

                            let parsed_body: crate::error::TooManyRequestsError =
                                if body_slice.is_empty() {
                                    // To enable JSON parsing to succeed, replace an empty body
                                    // with an empty JSON body. If a member was required, it will fail slightly later
                                    // during the operation construction phase.
                                    serde_json::from_slice(b"{}")
                                        .map_err(crate::error::DeleteApiKeyError::unhandled)?
                                } else {
                                    serde_json::from_slice(response.body().as_ref())
                                        .map_err(crate::error::DeleteApiKeyError::unhandled)?
                                };

                            output = output.set_retry_after_seconds(
                        
                                                crate::http_serde::deser_header_delete_api_key_retry_after_seconds(response.headers())
                                                    .map_err(|_|crate::error::DeleteApiKeyError::unhandled("Failed to parse retryAfterSeconds from header `Retry-After"))?
                                                
                    );
                            output = output.set_message(parsed_body.message);
                            output.build()
                        }),
                    }
                }
                "UnauthorizedException" => crate::error::DeleteApiKeyError {
                    meta: generic,
                    kind: crate::error::DeleteApiKeyErrorKind::UnauthorizedError({
                        #[allow(unused_mut)]
                        let mut output = crate::error::unauthorized_error::Builder::default();
                        let _ = response;

                        let body_slice = response.body().as_ref();

                        let parsed_body: crate::error::UnauthorizedError = if body_slice.is_empty()
                        {
                            // To enable JSON parsing to succeed, replace an empty body
                            // with an empty JSON body. If a member was required, it will fail slightly later
                            // during the operation construction phase.
                            serde_json::from_slice(b"{}")
                                .map_err(crate::error::DeleteApiKeyError::unhandled)?
                        } else {
                            serde_json::from_slice(response.body().as_ref())
                                .map_err(crate::error::DeleteApiKeyError::unhandled)?
                        };

                        output = output.set_message(parsed_body.message);
                        output.build()
                    }),
                },
                _ => crate::error::DeleteApiKeyError::generic(generic),
            });
        }
        Ok({
            #[allow(unused_mut)]
            let mut output = crate::output::delete_api_key_output::Builder::default();
            let _ = response;
            output.build()
        })
    }
    pub fn parse_response(
        &self,
        response: &http::response::Response<impl AsRef<[u8]>>,
    ) -> Result<crate::output::DeleteApiKeyOutput, crate::error::DeleteApiKeyError> {
        Self::from_response(&response)
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}

impl smithy_http::response::ParseStrictResponse for DeleteApiKey {
    type Output = Result<crate::output::DeleteApiKeyOutput, crate::error::DeleteApiKeyError>;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        self.parse_response(response)
    }
}

/// <p>Deletes an existing <a>Authorizer</a> resource.</p>
/// <div class="seeAlso"><a href="https://docs.aws.amazon.com/cli/latest/reference/apigateway/delete-authorizer.html">AWS CLI</a></div>
#[derive(std::clone::Clone)]
pub struct DeleteAuthorizer {
    _private: (),
}
impl DeleteAuthorizer {
    /// Creates a new builder-style object to manufacture [`DeleteAuthorizerInput`](crate::input::DeleteAuthorizerInput)
    pub fn builder() -> crate::input::delete_authorizer_input::Builder {
        crate::input::delete_authorizer_input::Builder::default()
    }
    #[allow(clippy::unnecessary_wraps)]
    fn from_response(
        response: &http::response::Response<impl AsRef<[u8]>>,
    ) -> Result<crate::output::DeleteAuthorizerOutput, crate::error::DeleteAuthorizerError> {
        if crate::aws_json_errors::is_error(&response) && response.status().as_u16() != 202 {
            let body = serde_json::from_slice(response.body().as_ref())
                .unwrap_or_else(|_| serde_json::json!({}));
            let generic = crate::aws_json_errors::parse_generic_error(&response, &body);

            let error_code = match generic.code() {
                Some(code) => code,
                None => return Err(crate::error::DeleteAuthorizerError::unhandled(generic)),
            };
            return Err(match error_code {
                "BadRequestException" => crate::error::DeleteAuthorizerError {
                    meta: generic,
                    kind: crate::error::DeleteAuthorizerErrorKind::BadRequestError({
                        #[allow(unused_mut)]
                        let mut output = crate::error::bad_request_error::Builder::default();
                        let _ = response;

                        let body_slice = response.body().as_ref();

                        let parsed_body: crate::error::BadRequestError = if body_slice.is_empty() {
                            // To enable JSON parsing to succeed, replace an empty body
                            // with an empty JSON body. If a member was required, it will fail slightly later
                            // during the operation construction phase.
                            serde_json::from_slice(b"{}")
                                .map_err(crate::error::DeleteAuthorizerError::unhandled)?
                        } else {
                            serde_json::from_slice(response.body().as_ref())
                                .map_err(crate::error::DeleteAuthorizerError::unhandled)?
                        };

                        output = output.set_message(parsed_body.message);
                        output.build()
                    }),
                },
                "ConflictException" => crate::error::DeleteAuthorizerError {
                    meta: generic,
                    kind: crate::error::DeleteAuthorizerErrorKind::ConflictError({
                        #[allow(unused_mut)]
                        let mut output = crate::error::conflict_error::Builder::default();
                        let _ = response;

                        let body_slice = response.body().as_ref();

                        let parsed_body: crate::error::ConflictError = if body_slice.is_empty() {
                            // To enable JSON parsing to succeed, replace an empty body
                            // with an empty JSON body. If a member was required, it will fail slightly later
                            // during the operation construction phase.
                            serde_json::from_slice(b"{}")
                                .map_err(crate::error::DeleteAuthorizerError::unhandled)?
                        } else {
                            serde_json::from_slice(response.body().as_ref())
                                .map_err(crate::error::DeleteAuthorizerError::unhandled)?
                        };

                        output = output.set_message(parsed_body.message);
                        output.build()
                    }),
                },
                "NotFoundException" => crate::error::DeleteAuthorizerError {
                    meta: generic,
                    kind: crate::error::DeleteAuthorizerErrorKind::NotFoundError({
                        #[allow(unused_mut)]
                        let mut output = crate::error::not_found_error::Builder::default();
                        let _ = response;

                        let body_slice = response.body().as_ref();

                        let parsed_body: crate::error::NotFoundError = if body_slice.is_empty() {
                            // To enable JSON parsing to succeed, replace an empty body
                            // with an empty JSON body. If a member was required, it will fail slightly later
                            // during the operation construction phase.
                            serde_json::from_slice(b"{}")
                                .map_err(crate::error::DeleteAuthorizerError::unhandled)?
                        } else {
                            serde_json::from_slice(response.body().as_ref())
                                .map_err(crate::error::DeleteAuthorizerError::unhandled)?
                        };

                        output = output.set_message(parsed_body.message);
                        output.build()
                    }),
                },
                "TooManyRequestsException" => {
                    crate::error::DeleteAuthorizerError {
                        meta: generic,
                        kind: crate::error::DeleteAuthorizerErrorKind::TooManyRequestsError({
                            #[allow(unused_mut)]
                            let mut output =
                                crate::error::too_many_requests_error::Builder::default();
                            let _ = response;

                            let body_slice = response.body().as_ref();

                            let parsed_body: crate::error::TooManyRequestsError =
                                if body_slice.is_empty() {
                                    // To enable JSON parsing to succeed, replace an empty body
                                    // with an empty JSON body. If a member was required, it will fail slightly later
                                    // during the operation construction phase.
                                    serde_json::from_slice(b"{}")
                                        .map_err(crate::error::DeleteAuthorizerError::unhandled)?
                                } else {
                                    serde_json::from_slice(response.body().as_ref())
                                        .map_err(crate::error::DeleteAuthorizerError::unhandled)?
                                };

                            output = output.set_retry_after_seconds(
                        
                                                crate::http_serde::deser_header_delete_authorizer_retry_after_seconds(response.headers())
                                                    .map_err(|_|crate::error::DeleteAuthorizerError::unhandled("Failed to parse retryAfterSeconds from header `Retry-After"))?
                                                
                    );
                            output = output.set_message(parsed_body.message);
                            output.build()
                        }),
                    }
                }
                "UnauthorizedException" => crate::error::DeleteAuthorizerError {
                    meta: generic,
                    kind: crate::error::DeleteAuthorizerErrorKind::UnauthorizedError({
                        #[allow(unused_mut)]
                        let mut output = crate::error::unauthorized_error::Builder::default();
                        let _ = response;

                        let body_slice = response.body().as_ref();

                        let parsed_body: crate::error::UnauthorizedError = if body_slice.is_empty()
                        {
                            // To enable JSON parsing to succeed, replace an empty body
                            // with an empty JSON body. If a member was required, it will fail slightly later
                            // during the operation construction phase.
                            serde_json::from_slice(b"{}")
                                .map_err(crate::error::DeleteAuthorizerError::unhandled)?
                        } else {
                            serde_json::from_slice(response.body().as_ref())
                                .map_err(crate::error::DeleteAuthorizerError::unhandled)?
                        };

                        output = output.set_message(parsed_body.message);
                        output.build()
                    }),
                },
                _ => crate::error::DeleteAuthorizerError::generic(generic),
            });
        }
        Ok({
            #[allow(unused_mut)]
            let mut output = crate::output::delete_authorizer_output::Builder::default();
            let _ = response;
            output.build()
        })
    }
    pub fn parse_response(
        &self,
        response: &http::response::Response<impl AsRef<[u8]>>,
    ) -> Result<crate::output::DeleteAuthorizerOutput, crate::error::DeleteAuthorizerError> {
        Self::from_response(&response)
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}

impl smithy_http::response::ParseStrictResponse for DeleteAuthorizer {
    type Output =
        Result<crate::output::DeleteAuthorizerOutput, crate::error::DeleteAuthorizerError>;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        self.parse_response(response)
    }
}

/// <p>Deletes the <a>BasePathMapping</a> resource.</p>
#[derive(std::clone::Clone)]
pub struct DeleteBasePathMapping {
    _private: (),
}
impl DeleteBasePathMapping {
    /// Creates a new builder-style object to manufacture [`DeleteBasePathMappingInput`](crate::input::DeleteBasePathMappingInput)
    pub fn builder() -> crate::input::delete_base_path_mapping_input::Builder {
        crate::input::delete_base_path_mapping_input::Builder::default()
    }
    #[allow(clippy::unnecessary_wraps)]
    fn from_response(
        response: &http::response::Response<impl AsRef<[u8]>>,
    ) -> Result<crate::output::DeleteBasePathMappingOutput, crate::error::DeleteBasePathMappingError>
    {
        if crate::aws_json_errors::is_error(&response) && response.status().as_u16() != 202 {
            let body = serde_json::from_slice(response.body().as_ref())
                .unwrap_or_else(|_| serde_json::json!({}));
            let generic = crate::aws_json_errors::parse_generic_error(&response, &body);

            let error_code = match generic.code() {
                Some(code) => code,
                None => return Err(crate::error::DeleteBasePathMappingError::unhandled(generic)),
            };
            return Err(match error_code {
                "BadRequestException" => crate::error::DeleteBasePathMappingError {
                    meta: generic,
                    kind: crate::error::DeleteBasePathMappingErrorKind::BadRequestError({
                        #[allow(unused_mut)]
                        let mut output = crate::error::bad_request_error::Builder::default();
                        let _ = response;

                        let body_slice = response.body().as_ref();

                        let parsed_body: crate::error::BadRequestError = if body_slice.is_empty() {
                            // To enable JSON parsing to succeed, replace an empty body
                            // with an empty JSON body. If a member was required, it will fail slightly later
                            // during the operation construction phase.
                            serde_json::from_slice(b"{}")
                                .map_err(crate::error::DeleteBasePathMappingError::unhandled)?
                        } else {
                            serde_json::from_slice(response.body().as_ref())
                                .map_err(crate::error::DeleteBasePathMappingError::unhandled)?
                        };

                        output = output.set_message(parsed_body.message);
                        output.build()
                    }),
                },
                "ConflictException" => crate::error::DeleteBasePathMappingError {
                    meta: generic,
                    kind: crate::error::DeleteBasePathMappingErrorKind::ConflictError({
                        #[allow(unused_mut)]
                        let mut output = crate::error::conflict_error::Builder::default();
                        let _ = response;

                        let body_slice = response.body().as_ref();

                        let parsed_body: crate::error::ConflictError = if body_slice.is_empty() {
                            // To enable JSON parsing to succeed, replace an empty body
                            // with an empty JSON body. If a member was required, it will fail slightly later
                            // during the operation construction phase.
                            serde_json::from_slice(b"{}")
                                .map_err(crate::error::DeleteBasePathMappingError::unhandled)?
                        } else {
                            serde_json::from_slice(response.body().as_ref())
                                .map_err(crate::error::DeleteBasePathMappingError::unhandled)?
                        };

                        output = output.set_message(parsed_body.message);
                        output.build()
                    }),
                },
                "NotFoundException" => crate::error::DeleteBasePathMappingError {
                    meta: generic,
                    kind: crate::error::DeleteBasePathMappingErrorKind::NotFoundError({
                        #[allow(unused_mut)]
                        let mut output = crate::error::not_found_error::Builder::default();
                        let _ = response;

                        let body_slice = response.body().as_ref();

                        let parsed_body: crate::error::NotFoundError = if body_slice.is_empty() {
                            // To enable JSON parsing to succeed, replace an empty body
                            // with an empty JSON body. If a member was required, it will fail slightly later
                            // during the operation construction phase.
                            serde_json::from_slice(b"{}")
                                .map_err(crate::error::DeleteBasePathMappingError::unhandled)?
                        } else {
                            serde_json::from_slice(response.body().as_ref())
                                .map_err(crate::error::DeleteBasePathMappingError::unhandled)?
                        };

                        output = output.set_message(parsed_body.message);
                        output.build()
                    }),
                },
                "TooManyRequestsException" => crate::error::DeleteBasePathMappingError {
                    meta: generic,
                    kind: crate::error::DeleteBasePathMappingErrorKind::TooManyRequestsError({
                        #[allow(unused_mut)]
                        let mut output = crate::error::too_many_requests_error::Builder::default();
                        let _ = response;

                        let body_slice = response.body().as_ref();

                        let parsed_body: crate::error::TooManyRequestsError =
                            if body_slice.is_empty() {
                                // To enable JSON parsing to succeed, replace an empty body
                                // with an empty JSON body. If a member was required, it will fail slightly later
                                // during the operation construction phase.
                                serde_json::from_slice(b"{}")
                                    .map_err(crate::error::DeleteBasePathMappingError::unhandled)?
                            } else {
                                serde_json::from_slice(response.body().as_ref())
                                    .map_err(crate::error::DeleteBasePathMappingError::unhandled)?
                            };

                        output = output.set_retry_after_seconds(
                        
                                                crate::http_serde::deser_header_delete_base_path_mapping_retry_after_seconds(response.headers())
                                                    .map_err(|_|crate::error::DeleteBasePathMappingError::unhandled("Failed to parse retryAfterSeconds from header `Retry-After"))?
                                                
                    );
                        output = output.set_message(parsed_body.message);
                        output.build()
                    }),
                },
                "UnauthorizedException" => crate::error::DeleteBasePathMappingError {
                    meta: generic,
                    kind: crate::error::DeleteBasePathMappingErrorKind::UnauthorizedError({
                        #[allow(unused_mut)]
                        let mut output = crate::error::unauthorized_error::Builder::default();
                        let _ = response;

                        let body_slice = response.body().as_ref();

                        let parsed_body: crate::error::UnauthorizedError = if body_slice.is_empty()
                        {
                            // To enable JSON parsing to succeed, replace an empty body
                            // with an empty JSON body. If a member was required, it will fail slightly later
                            // during the operation construction phase.
                            serde_json::from_slice(b"{}")
                                .map_err(crate::error::DeleteBasePathMappingError::unhandled)?
                        } else {
                            serde_json::from_slice(response.body().as_ref())
                                .map_err(crate::error::DeleteBasePathMappingError::unhandled)?
                        };

                        output = output.set_message(parsed_body.message);
                        output.build()
                    }),
                },
                _ => crate::error::DeleteBasePathMappingError::generic(generic),
            });
        }
        Ok({
            #[allow(unused_mut)]
            let mut output = crate::output::delete_base_path_mapping_output::Builder::default();
            let _ = response;
            output.build()
        })
    }
    pub fn parse_response(
        &self,
        response: &http::response::Response<impl AsRef<[u8]>>,
    ) -> Result<crate::output::DeleteBasePathMappingOutput, crate::error::DeleteBasePathMappingError>
    {
        Self::from_response(&response)
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}

impl smithy_http::response::ParseStrictResponse for DeleteBasePathMapping {
    type Output = Result<
        crate::output::DeleteBasePathMappingOutput,
        crate::error::DeleteBasePathMappingError,
    >;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        self.parse_response(response)
    }
}

/// <p>Deletes the <a>ClientCertificate</a> resource.</p>
#[derive(std::clone::Clone)]
pub struct DeleteClientCertificate {
    _private: (),
}
impl DeleteClientCertificate {
    /// Creates a new builder-style object to manufacture [`DeleteClientCertificateInput`](crate::input::DeleteClientCertificateInput)
    pub fn builder() -> crate::input::delete_client_certificate_input::Builder {
        crate::input::delete_client_certificate_input::Builder::default()
    }
    #[allow(clippy::unnecessary_wraps)]
    fn from_response(
        response: &http::response::Response<impl AsRef<[u8]>>,
    ) -> Result<
        crate::output::DeleteClientCertificateOutput,
        crate::error::DeleteClientCertificateError,
    > {
        if crate::aws_json_errors::is_error(&response) && response.status().as_u16() != 202 {
            let body = serde_json::from_slice(response.body().as_ref())
                .unwrap_or_else(|_| serde_json::json!({}));
            let generic = crate::aws_json_errors::parse_generic_error(&response, &body);

            let error_code = match generic.code() {
                Some(code) => code,
                None => {
                    return Err(crate::error::DeleteClientCertificateError::unhandled(
                        generic,
                    ))
                }
            };
            return Err(match error_code {
                "BadRequestException" => crate::error::DeleteClientCertificateError {
                    meta: generic,
                    kind: crate::error::DeleteClientCertificateErrorKind::BadRequestError({
                        #[allow(unused_mut)]
                        let mut output = crate::error::bad_request_error::Builder::default();
                        let _ = response;

                        let body_slice = response.body().as_ref();

                        let parsed_body: crate::error::BadRequestError = if body_slice.is_empty() {
                            // To enable JSON parsing to succeed, replace an empty body
                            // with an empty JSON body. If a member was required, it will fail slightly later
                            // during the operation construction phase.
                            serde_json::from_slice(b"{}")
                                .map_err(crate::error::DeleteClientCertificateError::unhandled)?
                        } else {
                            serde_json::from_slice(response.body().as_ref())
                                .map_err(crate::error::DeleteClientCertificateError::unhandled)?
                        };

                        output = output.set_message(parsed_body.message);
                        output.build()
                    }),
                },
                "NotFoundException" => crate::error::DeleteClientCertificateError {
                    meta: generic,
                    kind: crate::error::DeleteClientCertificateErrorKind::NotFoundError({
                        #[allow(unused_mut)]
                        let mut output = crate::error::not_found_error::Builder::default();
                        let _ = response;

                        let body_slice = response.body().as_ref();

                        let parsed_body: crate::error::NotFoundError = if body_slice.is_empty() {
                            // To enable JSON parsing to succeed, replace an empty body
                            // with an empty JSON body. If a member was required, it will fail slightly later
                            // during the operation construction phase.
                            serde_json::from_slice(b"{}")
                                .map_err(crate::error::DeleteClientCertificateError::unhandled)?
                        } else {
                            serde_json::from_slice(response.body().as_ref())
                                .map_err(crate::error::DeleteClientCertificateError::unhandled)?
                        };

                        output = output.set_message(parsed_body.message);
                        output.build()
                    }),
                },
                "TooManyRequestsException" => crate::error::DeleteClientCertificateError {
                    meta: generic,
                    kind: crate::error::DeleteClientCertificateErrorKind::TooManyRequestsError({
                        #[allow(unused_mut)]
                        let mut output = crate::error::too_many_requests_error::Builder::default();
                        let _ = response;

                        let body_slice = response.body().as_ref();

                        let parsed_body: crate::error::TooManyRequestsError = if body_slice
                            .is_empty()
                        {
                            // To enable JSON parsing to succeed, replace an empty body
                            // with an empty JSON body. If a member was required, it will fail slightly later
                            // during the operation construction phase.
                            serde_json::from_slice(b"{}")
                                .map_err(crate::error::DeleteClientCertificateError::unhandled)?
                        } else {
                            serde_json::from_slice(response.body().as_ref())
                                .map_err(crate::error::DeleteClientCertificateError::unhandled)?
                        };

                        output = output.set_retry_after_seconds(
                        
                                                crate::http_serde::deser_header_delete_client_certificate_retry_after_seconds(response.headers())
                                                    .map_err(|_|crate::error::DeleteClientCertificateError::unhandled("Failed to parse retryAfterSeconds from header `Retry-After"))?
                                                
                    );
                        output = output.set_message(parsed_body.message);
                        output.build()
                    }),
                },
                "UnauthorizedException" => crate::error::DeleteClientCertificateError {
                    meta: generic,
                    kind: crate::error::DeleteClientCertificateErrorKind::UnauthorizedError({
                        #[allow(unused_mut)]
                        let mut output = crate::error::unauthorized_error::Builder::default();
                        let _ = response;

                        let body_slice = response.body().as_ref();

                        let parsed_body: crate::error::UnauthorizedError = if body_slice.is_empty()
                        {
                            // To enable JSON parsing to succeed, replace an empty body
                            // with an empty JSON body. If a member was required, it will fail slightly later
                            // during the operation construction phase.
                            serde_json::from_slice(b"{}")
                                .map_err(crate::error::DeleteClientCertificateError::unhandled)?
                        } else {
                            serde_json::from_slice(response.body().as_ref())
                                .map_err(crate::error::DeleteClientCertificateError::unhandled)?
                        };

                        output = output.set_message(parsed_body.message);
                        output.build()
                    }),
                },
                _ => crate::error::DeleteClientCertificateError::generic(generic),
            });
        }
        Ok({
            #[allow(unused_mut)]
            let mut output = crate::output::delete_client_certificate_output::Builder::default();
            let _ = response;
            output.build()
        })
    }
    pub fn parse_response(
        &self,
        response: &http::response::Response<impl AsRef<[u8]>>,
    ) -> Result<
        crate::output::DeleteClientCertificateOutput,
        crate::error::DeleteClientCertificateError,
    > {
        Self::from_response(&response)
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}

impl smithy_http::response::ParseStrictResponse for DeleteClientCertificate {
    type Output = Result<
        crate::output::DeleteClientCertificateOutput,
        crate::error::DeleteClientCertificateError,
    >;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        self.parse_response(response)
    }
}

/// <p>Deletes a <a>Deployment</a> resource. Deleting a deployment will only succeed if there are no <a>Stage</a> resources associated with it.</p>
#[derive(std::clone::Clone)]
pub struct DeleteDeployment {
    _private: (),
}
impl DeleteDeployment {
    /// Creates a new builder-style object to manufacture [`DeleteDeploymentInput`](crate::input::DeleteDeploymentInput)
    pub fn builder() -> crate::input::delete_deployment_input::Builder {
        crate::input::delete_deployment_input::Builder::default()
    }
    #[allow(clippy::unnecessary_wraps)]
    fn from_response(
        response: &http::response::Response<impl AsRef<[u8]>>,
    ) -> Result<crate::output::DeleteDeploymentOutput, crate::error::DeleteDeploymentError> {
        if crate::aws_json_errors::is_error(&response) && response.status().as_u16() != 202 {
            let body = serde_json::from_slice(response.body().as_ref())
                .unwrap_or_else(|_| serde_json::json!({}));
            let generic = crate::aws_json_errors::parse_generic_error(&response, &body);

            let error_code = match generic.code() {
                Some(code) => code,
                None => return Err(crate::error::DeleteDeploymentError::unhandled(generic)),
            };
            return Err(match error_code {
                "BadRequestException" => crate::error::DeleteDeploymentError {
                    meta: generic,
                    kind: crate::error::DeleteDeploymentErrorKind::BadRequestError({
                        #[allow(unused_mut)]
                        let mut output = crate::error::bad_request_error::Builder::default();
                        let _ = response;

                        let body_slice = response.body().as_ref();

                        let parsed_body: crate::error::BadRequestError = if body_slice.is_empty() {
                            // To enable JSON parsing to succeed, replace an empty body
                            // with an empty JSON body. If a member was required, it will fail slightly later
                            // during the operation construction phase.
                            serde_json::from_slice(b"{}")
                                .map_err(crate::error::DeleteDeploymentError::unhandled)?
                        } else {
                            serde_json::from_slice(response.body().as_ref())
                                .map_err(crate::error::DeleteDeploymentError::unhandled)?
                        };

                        output = output.set_message(parsed_body.message);
                        output.build()
                    }),
                },
                "NotFoundException" => crate::error::DeleteDeploymentError {
                    meta: generic,
                    kind: crate::error::DeleteDeploymentErrorKind::NotFoundError({
                        #[allow(unused_mut)]
                        let mut output = crate::error::not_found_error::Builder::default();
                        let _ = response;

                        let body_slice = response.body().as_ref();

                        let parsed_body: crate::error::NotFoundError = if body_slice.is_empty() {
                            // To enable JSON parsing to succeed, replace an empty body
                            // with an empty JSON body. If a member was required, it will fail slightly later
                            // during the operation construction phase.
                            serde_json::from_slice(b"{}")
                                .map_err(crate::error::DeleteDeploymentError::unhandled)?
                        } else {
                            serde_json::from_slice(response.body().as_ref())
                                .map_err(crate::error::DeleteDeploymentError::unhandled)?
                        };

                        output = output.set_message(parsed_body.message);
                        output.build()
                    }),
                },
                "TooManyRequestsException" => {
                    crate::error::DeleteDeploymentError {
                        meta: generic,
                        kind: crate::error::DeleteDeploymentErrorKind::TooManyRequestsError({
                            #[allow(unused_mut)]
                            let mut output =
                                crate::error::too_many_requests_error::Builder::default();
                            let _ = response;

                            let body_slice = response.body().as_ref();

                            let parsed_body: crate::error::TooManyRequestsError =
                                if body_slice.is_empty() {
                                    // To enable JSON parsing to succeed, replace an empty body
                                    // with an empty JSON body. If a member was required, it will fail slightly later
                                    // during the operation construction phase.
                                    serde_json::from_slice(b"{}")
                                        .map_err(crate::error::DeleteDeploymentError::unhandled)?
                                } else {
                                    serde_json::from_slice(response.body().as_ref())
                                        .map_err(crate::error::DeleteDeploymentError::unhandled)?
                                };

                            output = output.set_retry_after_seconds(
                        
                                                crate::http_serde::deser_header_delete_deployment_retry_after_seconds(response.headers())
                                                    .map_err(|_|crate::error::DeleteDeploymentError::unhandled("Failed to parse retryAfterSeconds from header `Retry-After"))?
                                                
                    );
                            output = output.set_message(parsed_body.message);
                            output.build()
                        }),
                    }
                }
                "UnauthorizedException" => crate::error::DeleteDeploymentError {
                    meta: generic,
                    kind: crate::error::DeleteDeploymentErrorKind::UnauthorizedError({
                        #[allow(unused_mut)]
                        let mut output = crate::error::unauthorized_error::Builder::default();
                        let _ = response;

                        let body_slice = response.body().as_ref();

                        let parsed_body: crate::error::UnauthorizedError = if body_slice.is_empty()
                        {
                            // To enable JSON parsing to succeed, replace an empty body
                            // with an empty JSON body. If a member was required, it will fail slightly later
                            // during the operation construction phase.
                            serde_json::from_slice(b"{}")
                                .map_err(crate::error::DeleteDeploymentError::unhandled)?
                        } else {
                            serde_json::from_slice(response.body().as_ref())
                                .map_err(crate::error::DeleteDeploymentError::unhandled)?
                        };

                        output = output.set_message(parsed_body.message);
                        output.build()
                    }),
                },
                _ => crate::error::DeleteDeploymentError::generic(generic),
            });
        }
        Ok({
            #[allow(unused_mut)]
            let mut output = crate::output::delete_deployment_output::Builder::default();
            let _ = response;
            output.build()
        })
    }
    pub fn parse_response(
        &self,
        response: &http::response::Response<impl AsRef<[u8]>>,
    ) -> Result<crate::output::DeleteDeploymentOutput, crate::error::DeleteDeploymentError> {
        Self::from_response(&response)
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}

impl smithy_http::response::ParseStrictResponse for DeleteDeployment {
    type Output =
        Result<crate::output::DeleteDeploymentOutput, crate::error::DeleteDeploymentError>;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        self.parse_response(response)
    }
}

#[derive(std::clone::Clone)]
pub struct DeleteDocumentationPart {
    _private: (),
}
impl DeleteDocumentationPart {
    /// Creates a new builder-style object to manufacture [`DeleteDocumentationPartInput`](crate::input::DeleteDocumentationPartInput)
    pub fn builder() -> crate::input::delete_documentation_part_input::Builder {
        crate::input::delete_documentation_part_input::Builder::default()
    }
    #[allow(clippy::unnecessary_wraps)]
    fn from_response(
        response: &http::response::Response<impl AsRef<[u8]>>,
    ) -> Result<
        crate::output::DeleteDocumentationPartOutput,
        crate::error::DeleteDocumentationPartError,
    > {
        if crate::aws_json_errors::is_error(&response) && response.status().as_u16() != 202 {
            let body = serde_json::from_slice(response.body().as_ref())
                .unwrap_or_else(|_| serde_json::json!({}));
            let generic = crate::aws_json_errors::parse_generic_error(&response, &body);

            let error_code = match generic.code() {
                Some(code) => code,
                None => {
                    return Err(crate::error::DeleteDocumentationPartError::unhandled(
                        generic,
                    ))
                }
            };
            return Err(match error_code {
                "BadRequestException" => crate::error::DeleteDocumentationPartError {
                    meta: generic,
                    kind: crate::error::DeleteDocumentationPartErrorKind::BadRequestError({
                        #[allow(unused_mut)]
                        let mut output = crate::error::bad_request_error::Builder::default();
                        let _ = response;

                        let body_slice = response.body().as_ref();

                        let parsed_body: crate::error::BadRequestError = if body_slice.is_empty() {
                            // To enable JSON parsing to succeed, replace an empty body
                            // with an empty JSON body. If a member was required, it will fail slightly later
                            // during the operation construction phase.
                            serde_json::from_slice(b"{}")
                                .map_err(crate::error::DeleteDocumentationPartError::unhandled)?
                        } else {
                            serde_json::from_slice(response.body().as_ref())
                                .map_err(crate::error::DeleteDocumentationPartError::unhandled)?
                        };

                        output = output.set_message(parsed_body.message);
                        output.build()
                    }),
                },
                "ConflictException" => crate::error::DeleteDocumentationPartError {
                    meta: generic,
                    kind: crate::error::DeleteDocumentationPartErrorKind::ConflictError({
                        #[allow(unused_mut)]
                        let mut output = crate::error::conflict_error::Builder::default();
                        let _ = response;

                        let body_slice = response.body().as_ref();

                        let parsed_body: crate::error::ConflictError = if body_slice.is_empty() {
                            // To enable JSON parsing to succeed, replace an empty body
                            // with an empty JSON body. If a member was required, it will fail slightly later
                            // during the operation construction phase.
                            serde_json::from_slice(b"{}")
                                .map_err(crate::error::DeleteDocumentationPartError::unhandled)?
                        } else {
                            serde_json::from_slice(response.body().as_ref())
                                .map_err(crate::error::DeleteDocumentationPartError::unhandled)?
                        };

                        output = output.set_message(parsed_body.message);
                        output.build()
                    }),
                },
                "NotFoundException" => crate::error::DeleteDocumentationPartError {
                    meta: generic,
                    kind: crate::error::DeleteDocumentationPartErrorKind::NotFoundError({
                        #[allow(unused_mut)]
                        let mut output = crate::error::not_found_error::Builder::default();
                        let _ = response;

                        let body_slice = response.body().as_ref();

                        let parsed_body: crate::error::NotFoundError = if body_slice.is_empty() {
                            // To enable JSON parsing to succeed, replace an empty body
                            // with an empty JSON body. If a member was required, it will fail slightly later
                            // during the operation construction phase.
                            serde_json::from_slice(b"{}")
                                .map_err(crate::error::DeleteDocumentationPartError::unhandled)?
                        } else {
                            serde_json::from_slice(response.body().as_ref())
                                .map_err(crate::error::DeleteDocumentationPartError::unhandled)?
                        };

                        output = output.set_message(parsed_body.message);
                        output.build()
                    }),
                },
                "TooManyRequestsException" => crate::error::DeleteDocumentationPartError {
                    meta: generic,
                    kind: crate::error::DeleteDocumentationPartErrorKind::TooManyRequestsError({
                        #[allow(unused_mut)]
                        let mut output = crate::error::too_many_requests_error::Builder::default();
                        let _ = response;

                        let body_slice = response.body().as_ref();

                        let parsed_body: crate::error::TooManyRequestsError = if body_slice
                            .is_empty()
                        {
                            // To enable JSON parsing to succeed, replace an empty body
                            // with an empty JSON body. If a member was required, it will fail slightly later
                            // during the operation construction phase.
                            serde_json::from_slice(b"{}")
                                .map_err(crate::error::DeleteDocumentationPartError::unhandled)?
                        } else {
                            serde_json::from_slice(response.body().as_ref())
                                .map_err(crate::error::DeleteDocumentationPartError::unhandled)?
                        };

                        output = output.set_retry_after_seconds(
                        
                                                crate::http_serde::deser_header_delete_documentation_part_retry_after_seconds(response.headers())
                                                    .map_err(|_|crate::error::DeleteDocumentationPartError::unhandled("Failed to parse retryAfterSeconds from header `Retry-After"))?
                                                
                    );
                        output = output.set_message(parsed_body.message);
                        output.build()
                    }),
                },
                "UnauthorizedException" => crate::error::DeleteDocumentationPartError {
                    meta: generic,
                    kind: crate::error::DeleteDocumentationPartErrorKind::UnauthorizedError({
                        #[allow(unused_mut)]
                        let mut output = crate::error::unauthorized_error::Builder::default();
                        let _ = response;

                        let body_slice = response.body().as_ref();

                        let parsed_body: crate::error::UnauthorizedError = if body_slice.is_empty()
                        {
                            // To enable JSON parsing to succeed, replace an empty body
                            // with an empty JSON body. If a member was required, it will fail slightly later
                            // during the operation construction phase.
                            serde_json::from_slice(b"{}")
                                .map_err(crate::error::DeleteDocumentationPartError::unhandled)?
                        } else {
                            serde_json::from_slice(response.body().as_ref())
                                .map_err(crate::error::DeleteDocumentationPartError::unhandled)?
                        };

                        output = output.set_message(parsed_body.message);
                        output.build()
                    }),
                },
                _ => crate::error::DeleteDocumentationPartError::generic(generic),
            });
        }
        Ok({
            #[allow(unused_mut)]
            let mut output = crate::output::delete_documentation_part_output::Builder::default();
            let _ = response;
            output.build()
        })
    }
    pub fn parse_response(
        &self,
        response: &http::response::Response<impl AsRef<[u8]>>,
    ) -> Result<
        crate::output::DeleteDocumentationPartOutput,
        crate::error::DeleteDocumentationPartError,
    > {
        Self::from_response(&response)
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}

impl smithy_http::response::ParseStrictResponse for DeleteDocumentationPart {
    type Output = Result<
        crate::output::DeleteDocumentationPartOutput,
        crate::error::DeleteDocumentationPartError,
    >;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        self.parse_response(response)
    }
}

#[derive(std::clone::Clone)]
pub struct DeleteDocumentationVersion {
    _private: (),
}
impl DeleteDocumentationVersion {
    /// Creates a new builder-style object to manufacture [`DeleteDocumentationVersionInput`](crate::input::DeleteDocumentationVersionInput)
    pub fn builder() -> crate::input::delete_documentation_version_input::Builder {
        crate::input::delete_documentation_version_input::Builder::default()
    }
    #[allow(clippy::unnecessary_wraps)]
    fn from_response(
        response: &http::response::Response<impl AsRef<[u8]>>,
    ) -> Result<
        crate::output::DeleteDocumentationVersionOutput,
        crate::error::DeleteDocumentationVersionError,
    > {
        if crate::aws_json_errors::is_error(&response) && response.status().as_u16() != 202 {
            let body = serde_json::from_slice(response.body().as_ref())
                .unwrap_or_else(|_| serde_json::json!({}));
            let generic = crate::aws_json_errors::parse_generic_error(&response, &body);

            let error_code = match generic.code() {
                Some(code) => code,
                None => {
                    return Err(crate::error::DeleteDocumentationVersionError::unhandled(
                        generic,
                    ))
                }
            };
            return Err(match error_code {
                "BadRequestException" => crate::error::DeleteDocumentationVersionError {
                    meta: generic,
                    kind: crate::error::DeleteDocumentationVersionErrorKind::BadRequestError({
                        #[allow(unused_mut)]
                        let mut output = crate::error::bad_request_error::Builder::default();
                        let _ = response;

                        let body_slice = response.body().as_ref();

                        let parsed_body: crate::error::BadRequestError = if body_slice.is_empty() {
                            // To enable JSON parsing to succeed, replace an empty body
                            // with an empty JSON body. If a member was required, it will fail slightly later
                            // during the operation construction phase.
                            serde_json::from_slice(b"{}")
                                .map_err(crate::error::DeleteDocumentationVersionError::unhandled)?
                        } else {
                            serde_json::from_slice(response.body().as_ref())
                                .map_err(crate::error::DeleteDocumentationVersionError::unhandled)?
                        };

                        output = output.set_message(parsed_body.message);
                        output.build()
                    }),
                },
                "ConflictException" => crate::error::DeleteDocumentationVersionError {
                    meta: generic,
                    kind: crate::error::DeleteDocumentationVersionErrorKind::ConflictError({
                        #[allow(unused_mut)]
                        let mut output = crate::error::conflict_error::Builder::default();
                        let _ = response;

                        let body_slice = response.body().as_ref();

                        let parsed_body: crate::error::ConflictError = if body_slice.is_empty() {
                            // To enable JSON parsing to succeed, replace an empty body
                            // with an empty JSON body. If a member was required, it will fail slightly later
                            // during the operation construction phase.
                            serde_json::from_slice(b"{}")
                                .map_err(crate::error::DeleteDocumentationVersionError::unhandled)?
                        } else {
                            serde_json::from_slice(response.body().as_ref())
                                .map_err(crate::error::DeleteDocumentationVersionError::unhandled)?
                        };

                        output = output.set_message(parsed_body.message);
                        output.build()
                    }),
                },
                "NotFoundException" => crate::error::DeleteDocumentationVersionError {
                    meta: generic,
                    kind: crate::error::DeleteDocumentationVersionErrorKind::NotFoundError({
                        #[allow(unused_mut)]
                        let mut output = crate::error::not_found_error::Builder::default();
                        let _ = response;

                        let body_slice = response.body().as_ref();

                        let parsed_body: crate::error::NotFoundError = if body_slice.is_empty() {
                            // To enable JSON parsing to succeed, replace an empty body
                            // with an empty JSON body. If a member was required, it will fail slightly later
                            // during the operation construction phase.
                            serde_json::from_slice(b"{}")
                                .map_err(crate::error::DeleteDocumentationVersionError::unhandled)?
                        } else {
                            serde_json::from_slice(response.body().as_ref())
                                .map_err(crate::error::DeleteDocumentationVersionError::unhandled)?
                        };

                        output = output.set_message(parsed_body.message);
                        output.build()
                    }),
                },
                "TooManyRequestsException" => {
                    crate::error::DeleteDocumentationVersionError {
                        meta: generic,
                        kind:
                            crate::error::DeleteDocumentationVersionErrorKind::TooManyRequestsError(
                                {
                                    #[allow(unused_mut)]
                                    let mut output =
                                        crate::error::too_many_requests_error::Builder::default();
                                    let _ = response;

                                    let body_slice = response.body().as_ref();

                                    let parsed_body: crate::error::TooManyRequestsError =
                                        if body_slice.is_empty() {
                                            // To enable JSON parsing to succeed, replace an empty body
                                            // with an empty JSON body. If a member was required, it will fail slightly later
                                            // during the operation construction phase.
                                            serde_json::from_slice(b"{}").map_err(crate::error::DeleteDocumentationVersionError::unhandled)?
                                        } else {
                                            serde_json::from_slice(response.body().as_ref()).map_err(crate::error::DeleteDocumentationVersionError::unhandled)?
                                        };

                                    output = output.set_retry_after_seconds(
                        
                                                crate::http_serde::deser_header_delete_documentation_version_retry_after_seconds(response.headers())
                                                    .map_err(|_|crate::error::DeleteDocumentationVersionError::unhandled("Failed to parse retryAfterSeconds from header `Retry-After"))?
                                                
                    );
                                    output = output.set_message(parsed_body.message);
                                    output.build()
                                },
                            ),
                    }
                }
                "UnauthorizedException" => crate::error::DeleteDocumentationVersionError {
                    meta: generic,
                    kind: crate::error::DeleteDocumentationVersionErrorKind::UnauthorizedError({
                        #[allow(unused_mut)]
                        let mut output = crate::error::unauthorized_error::Builder::default();
                        let _ = response;

                        let body_slice = response.body().as_ref();

                        let parsed_body: crate::error::UnauthorizedError = if body_slice.is_empty()
                        {
                            // To enable JSON parsing to succeed, replace an empty body
                            // with an empty JSON body. If a member was required, it will fail slightly later
                            // during the operation construction phase.
                            serde_json::from_slice(b"{}")
                                .map_err(crate::error::DeleteDocumentationVersionError::unhandled)?
                        } else {
                            serde_json::from_slice(response.body().as_ref())
                                .map_err(crate::error::DeleteDocumentationVersionError::unhandled)?
                        };

                        output = output.set_message(parsed_body.message);
                        output.build()
                    }),
                },
                _ => crate::error::DeleteDocumentationVersionError::generic(generic),
            });
        }
        Ok({
            #[allow(unused_mut)]
            let mut output = crate::output::delete_documentation_version_output::Builder::default();
            let _ = response;
            output.build()
        })
    }
    pub fn parse_response(
        &self,
        response: &http::response::Response<impl AsRef<[u8]>>,
    ) -> Result<
        crate::output::DeleteDocumentationVersionOutput,
        crate::error::DeleteDocumentationVersionError,
    > {
        Self::from_response(&response)
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}

impl smithy_http::response::ParseStrictResponse for DeleteDocumentationVersion {
    type Output = Result<
        crate::output::DeleteDocumentationVersionOutput,
        crate::error::DeleteDocumentationVersionError,
    >;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        self.parse_response(response)
    }
}

/// <p>Deletes the <a>DomainName</a> resource.</p>
#[derive(std::clone::Clone)]
pub struct DeleteDomainName {
    _private: (),
}
impl DeleteDomainName {
    /// Creates a new builder-style object to manufacture [`DeleteDomainNameInput`](crate::input::DeleteDomainNameInput)
    pub fn builder() -> crate::input::delete_domain_name_input::Builder {
        crate::input::delete_domain_name_input::Builder::default()
    }
    #[allow(clippy::unnecessary_wraps)]
    fn from_response(
        response: &http::response::Response<impl AsRef<[u8]>>,
    ) -> Result<crate::output::DeleteDomainNameOutput, crate::error::DeleteDomainNameError> {
        if crate::aws_json_errors::is_error(&response) && response.status().as_u16() != 202 {
            let body = serde_json::from_slice(response.body().as_ref())
                .unwrap_or_else(|_| serde_json::json!({}));
            let generic = crate::aws_json_errors::parse_generic_error(&response, &body);

            let error_code = match generic.code() {
                Some(code) => code,
                None => return Err(crate::error::DeleteDomainNameError::unhandled(generic)),
            };
            return Err(match error_code {
                "BadRequestException" => crate::error::DeleteDomainNameError {
                    meta: generic,
                    kind: crate::error::DeleteDomainNameErrorKind::BadRequestError({
                        #[allow(unused_mut)]
                        let mut output = crate::error::bad_request_error::Builder::default();
                        let _ = response;

                        let body_slice = response.body().as_ref();

                        let parsed_body: crate::error::BadRequestError = if body_slice.is_empty() {
                            // To enable JSON parsing to succeed, replace an empty body
                            // with an empty JSON body. If a member was required, it will fail slightly later
                            // during the operation construction phase.
                            serde_json::from_slice(b"{}")
                                .map_err(crate::error::DeleteDomainNameError::unhandled)?
                        } else {
                            serde_json::from_slice(response.body().as_ref())
                                .map_err(crate::error::DeleteDomainNameError::unhandled)?
                        };

                        output = output.set_message(parsed_body.message);
                        output.build()
                    }),
                },
                "NotFoundException" => crate::error::DeleteDomainNameError {
                    meta: generic,
                    kind: crate::error::DeleteDomainNameErrorKind::NotFoundError({
                        #[allow(unused_mut)]
                        let mut output = crate::error::not_found_error::Builder::default();
                        let _ = response;

                        let body_slice = response.body().as_ref();

                        let parsed_body: crate::error::NotFoundError = if body_slice.is_empty() {
                            // To enable JSON parsing to succeed, replace an empty body
                            // with an empty JSON body. If a member was required, it will fail slightly later
                            // during the operation construction phase.
                            serde_json::from_slice(b"{}")
                                .map_err(crate::error::DeleteDomainNameError::unhandled)?
                        } else {
                            serde_json::from_slice(response.body().as_ref())
                                .map_err(crate::error::DeleteDomainNameError::unhandled)?
                        };

                        output = output.set_message(parsed_body.message);
                        output.build()
                    }),
                },
                "TooManyRequestsException" => {
                    crate::error::DeleteDomainNameError {
                        meta: generic,
                        kind: crate::error::DeleteDomainNameErrorKind::TooManyRequestsError({
                            #[allow(unused_mut)]
                            let mut output =
                                crate::error::too_many_requests_error::Builder::default();
                            let _ = response;

                            let body_slice = response.body().as_ref();

                            let parsed_body: crate::error::TooManyRequestsError =
                                if body_slice.is_empty() {
                                    // To enable JSON parsing to succeed, replace an empty body
                                    // with an empty JSON body. If a member was required, it will fail slightly later
                                    // during the operation construction phase.
                                    serde_json::from_slice(b"{}")
                                        .map_err(crate::error::DeleteDomainNameError::unhandled)?
                                } else {
                                    serde_json::from_slice(response.body().as_ref())
                                        .map_err(crate::error::DeleteDomainNameError::unhandled)?
                                };

                            output = output.set_retry_after_seconds(
                        
                                                crate::http_serde::deser_header_delete_domain_name_retry_after_seconds(response.headers())
                                                    .map_err(|_|crate::error::DeleteDomainNameError::unhandled("Failed to parse retryAfterSeconds from header `Retry-After"))?
                                                
                    );
                            output = output.set_message(parsed_body.message);
                            output.build()
                        }),
                    }
                }
                "UnauthorizedException" => crate::error::DeleteDomainNameError {
                    meta: generic,
                    kind: crate::error::DeleteDomainNameErrorKind::UnauthorizedError({
                        #[allow(unused_mut)]
                        let mut output = crate::error::unauthorized_error::Builder::default();
                        let _ = response;

                        let body_slice = response.body().as_ref();

                        let parsed_body: crate::error::UnauthorizedError = if body_slice.is_empty()
                        {
                            // To enable JSON parsing to succeed, replace an empty body
                            // with an empty JSON body. If a member was required, it will fail slightly later
                            // during the operation construction phase.
                            serde_json::from_slice(b"{}")
                                .map_err(crate::error::DeleteDomainNameError::unhandled)?
                        } else {
                            serde_json::from_slice(response.body().as_ref())
                                .map_err(crate::error::DeleteDomainNameError::unhandled)?
                        };

                        output = output.set_message(parsed_body.message);
                        output.build()
                    }),
                },
                _ => crate::error::DeleteDomainNameError::generic(generic),
            });
        }
        Ok({
            #[allow(unused_mut)]
            let mut output = crate::output::delete_domain_name_output::Builder::default();
            let _ = response;
            output.build()
        })
    }
    pub fn parse_response(
        &self,
        response: &http::response::Response<impl AsRef<[u8]>>,
    ) -> Result<crate::output::DeleteDomainNameOutput, crate::error::DeleteDomainNameError> {
        Self::from_response(&response)
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}

impl smithy_http::response::ParseStrictResponse for DeleteDomainName {
    type Output =
        Result<crate::output::DeleteDomainNameOutput, crate::error::DeleteDomainNameError>;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        self.parse_response(response)
    }
}

/// <p>Clears any customization of a <a>GatewayResponse</a> of a specified response type on the given <a>RestApi</a> and resets it with the default settings.</p>
#[derive(std::clone::Clone)]
pub struct DeleteGatewayResponse {
    _private: (),
}
impl DeleteGatewayResponse {
    /// Creates a new builder-style object to manufacture [`DeleteGatewayResponseInput`](crate::input::DeleteGatewayResponseInput)
    pub fn builder() -> crate::input::delete_gateway_response_input::Builder {
        crate::input::delete_gateway_response_input::Builder::default()
    }
    #[allow(clippy::unnecessary_wraps)]
    fn from_response(
        response: &http::response::Response<impl AsRef<[u8]>>,
    ) -> Result<crate::output::DeleteGatewayResponseOutput, crate::error::DeleteGatewayResponseError>
    {
        if crate::aws_json_errors::is_error(&response) && response.status().as_u16() != 202 {
            let body = serde_json::from_slice(response.body().as_ref())
                .unwrap_or_else(|_| serde_json::json!({}));
            let generic = crate::aws_json_errors::parse_generic_error(&response, &body);

            let error_code = match generic.code() {
                Some(code) => code,
                None => return Err(crate::error::DeleteGatewayResponseError::unhandled(generic)),
            };
            return Err(match error_code {
                "BadRequestException" => crate::error::DeleteGatewayResponseError {
                    meta: generic,
                    kind: crate::error::DeleteGatewayResponseErrorKind::BadRequestError({
                        #[allow(unused_mut)]
                        let mut output = crate::error::bad_request_error::Builder::default();
                        let _ = response;

                        let body_slice = response.body().as_ref();

                        let parsed_body: crate::error::BadRequestError = if body_slice.is_empty() {
                            // To enable JSON parsing to succeed, replace an empty body
                            // with an empty JSON body. If a member was required, it will fail slightly later
                            // during the operation construction phase.
                            serde_json::from_slice(b"{}")
                                .map_err(crate::error::DeleteGatewayResponseError::unhandled)?
                        } else {
                            serde_json::from_slice(response.body().as_ref())
                                .map_err(crate::error::DeleteGatewayResponseError::unhandled)?
                        };

                        output = output.set_message(parsed_body.message);
                        output.build()
                    }),
                },
                "ConflictException" => crate::error::DeleteGatewayResponseError {
                    meta: generic,
                    kind: crate::error::DeleteGatewayResponseErrorKind::ConflictError({
                        #[allow(unused_mut)]
                        let mut output = crate::error::conflict_error::Builder::default();
                        let _ = response;

                        let body_slice = response.body().as_ref();

                        let parsed_body: crate::error::ConflictError = if body_slice.is_empty() {
                            // To enable JSON parsing to succeed, replace an empty body
                            // with an empty JSON body. If a member was required, it will fail slightly later
                            // during the operation construction phase.
                            serde_json::from_slice(b"{}")
                                .map_err(crate::error::DeleteGatewayResponseError::unhandled)?
                        } else {
                            serde_json::from_slice(response.body().as_ref())
                                .map_err(crate::error::DeleteGatewayResponseError::unhandled)?
                        };

                        output = output.set_message(parsed_body.message);
                        output.build()
                    }),
                },
                "NotFoundException" => crate::error::DeleteGatewayResponseError {
                    meta: generic,
                    kind: crate::error::DeleteGatewayResponseErrorKind::NotFoundError({
                        #[allow(unused_mut)]
                        let mut output = crate::error::not_found_error::Builder::default();
                        let _ = response;

                        let body_slice = response.body().as_ref();

                        let parsed_body: crate::error::NotFoundError = if body_slice.is_empty() {
                            // To enable JSON parsing to succeed, replace an empty body
                            // with an empty JSON body. If a member was required, it will fail slightly later
                            // during the operation construction phase.
                            serde_json::from_slice(b"{}")
                                .map_err(crate::error::DeleteGatewayResponseError::unhandled)?
                        } else {
                            serde_json::from_slice(response.body().as_ref())
                                .map_err(crate::error::DeleteGatewayResponseError::unhandled)?
                        };

                        output = output.set_message(parsed_body.message);
                        output.build()
                    }),
                },
                "TooManyRequestsException" => crate::error::DeleteGatewayResponseError {
                    meta: generic,
                    kind: crate::error::DeleteGatewayResponseErrorKind::TooManyRequestsError({
                        #[allow(unused_mut)]
                        let mut output = crate::error::too_many_requests_error::Builder::default();
                        let _ = response;

                        let body_slice = response.body().as_ref();

                        let parsed_body: crate::error::TooManyRequestsError =
                            if body_slice.is_empty() {
                                // To enable JSON parsing to succeed, replace an empty body
                                // with an empty JSON body. If a member was required, it will fail slightly later
                                // during the operation construction phase.
                                serde_json::from_slice(b"{}")
                                    .map_err(crate::error::DeleteGatewayResponseError::unhandled)?
                            } else {
                                serde_json::from_slice(response.body().as_ref())
                                    .map_err(crate::error::DeleteGatewayResponseError::unhandled)?
                            };

                        output = output.set_retry_after_seconds(
                        
                                                crate::http_serde::deser_header_delete_gateway_response_retry_after_seconds(response.headers())
                                                    .map_err(|_|crate::error::DeleteGatewayResponseError::unhandled("Failed to parse retryAfterSeconds from header `Retry-After"))?
                                                
                    );
                        output = output.set_message(parsed_body.message);
                        output.build()
                    }),
                },
                "UnauthorizedException" => crate::error::DeleteGatewayResponseError {
                    meta: generic,
                    kind: crate::error::DeleteGatewayResponseErrorKind::UnauthorizedError({
                        #[allow(unused_mut)]
                        let mut output = crate::error::unauthorized_error::Builder::default();
                        let _ = response;

                        let body_slice = response.body().as_ref();

                        let parsed_body: crate::error::UnauthorizedError = if body_slice.is_empty()
                        {
                            // To enable JSON parsing to succeed, replace an empty body
                            // with an empty JSON body. If a member was required, it will fail slightly later
                            // during the operation construction phase.
                            serde_json::from_slice(b"{}")
                                .map_err(crate::error::DeleteGatewayResponseError::unhandled)?
                        } else {
                            serde_json::from_slice(response.body().as_ref())
                                .map_err(crate::error::DeleteGatewayResponseError::unhandled)?
                        };

                        output = output.set_message(parsed_body.message);
                        output.build()
                    }),
                },
                _ => crate::error::DeleteGatewayResponseError::generic(generic),
            });
        }
        Ok({
            #[allow(unused_mut)]
            let mut output = crate::output::delete_gateway_response_output::Builder::default();
            let _ = response;
            output.build()
        })
    }
    pub fn parse_response(
        &self,
        response: &http::response::Response<impl AsRef<[u8]>>,
    ) -> Result<crate::output::DeleteGatewayResponseOutput, crate::error::DeleteGatewayResponseError>
    {
        Self::from_response(&response)
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}

impl smithy_http::response::ParseStrictResponse for DeleteGatewayResponse {
    type Output = Result<
        crate::output::DeleteGatewayResponseOutput,
        crate::error::DeleteGatewayResponseError,
    >;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        self.parse_response(response)
    }
}

/// <p>Represents a delete integration.</p>
#[derive(std::clone::Clone)]
pub struct DeleteIntegration {
    _private: (),
}
impl DeleteIntegration {
    /// Creates a new builder-style object to manufacture [`DeleteIntegrationInput`](crate::input::DeleteIntegrationInput)
    pub fn builder() -> crate::input::delete_integration_input::Builder {
        crate::input::delete_integration_input::Builder::default()
    }
    #[allow(clippy::unnecessary_wraps)]
    fn from_response(
        response: &http::response::Response<impl AsRef<[u8]>>,
    ) -> Result<crate::output::DeleteIntegrationOutput, crate::error::DeleteIntegrationError> {
        if crate::aws_json_errors::is_error(&response) && response.status().as_u16() != 204 {
            let body = serde_json::from_slice(response.body().as_ref())
                .unwrap_or_else(|_| serde_json::json!({}));
            let generic = crate::aws_json_errors::parse_generic_error(&response, &body);

            let error_code = match generic.code() {
                Some(code) => code,
                None => return Err(crate::error::DeleteIntegrationError::unhandled(generic)),
            };
            return Err(match error_code {
                "ConflictException" => crate::error::DeleteIntegrationError {
                    meta: generic,
                    kind: crate::error::DeleteIntegrationErrorKind::ConflictError({
                        #[allow(unused_mut)]
                        let mut output = crate::error::conflict_error::Builder::default();
                        let _ = response;

                        let body_slice = response.body().as_ref();

                        let parsed_body: crate::error::ConflictError = if body_slice.is_empty() {
                            // To enable JSON parsing to succeed, replace an empty body
                            // with an empty JSON body. If a member was required, it will fail slightly later
                            // during the operation construction phase.
                            serde_json::from_slice(b"{}")
                                .map_err(crate::error::DeleteIntegrationError::unhandled)?
                        } else {
                            serde_json::from_slice(response.body().as_ref())
                                .map_err(crate::error::DeleteIntegrationError::unhandled)?
                        };

                        output = output.set_message(parsed_body.message);
                        output.build()
                    }),
                },
                "NotFoundException" => crate::error::DeleteIntegrationError {
                    meta: generic,
                    kind: crate::error::DeleteIntegrationErrorKind::NotFoundError({
                        #[allow(unused_mut)]
                        let mut output = crate::error::not_found_error::Builder::default();
                        let _ = response;

                        let body_slice = response.body().as_ref();

                        let parsed_body: crate::error::NotFoundError = if body_slice.is_empty() {
                            // To enable JSON parsing to succeed, replace an empty body
                            // with an empty JSON body. If a member was required, it will fail slightly later
                            // during the operation construction phase.
                            serde_json::from_slice(b"{}")
                                .map_err(crate::error::DeleteIntegrationError::unhandled)?
                        } else {
                            serde_json::from_slice(response.body().as_ref())
                                .map_err(crate::error::DeleteIntegrationError::unhandled)?
                        };

                        output = output.set_message(parsed_body.message);
                        output.build()
                    }),
                },
                "TooManyRequestsException" => {
                    crate::error::DeleteIntegrationError {
                        meta: generic,
                        kind: crate::error::DeleteIntegrationErrorKind::TooManyRequestsError({
                            #[allow(unused_mut)]
                            let mut output =
                                crate::error::too_many_requests_error::Builder::default();
                            let _ = response;

                            let body_slice = response.body().as_ref();

                            let parsed_body: crate::error::TooManyRequestsError =
                                if body_slice.is_empty() {
                                    // To enable JSON parsing to succeed, replace an empty body
                                    // with an empty JSON body. If a member was required, it will fail slightly later
                                    // during the operation construction phase.
                                    serde_json::from_slice(b"{}")
                                        .map_err(crate::error::DeleteIntegrationError::unhandled)?
                                } else {
                                    serde_json::from_slice(response.body().as_ref())
                                        .map_err(crate::error::DeleteIntegrationError::unhandled)?
                                };

                            output = output.set_retry_after_seconds(
                        
                                                crate::http_serde::deser_header_delete_integration_retry_after_seconds(response.headers())
                                                    .map_err(|_|crate::error::DeleteIntegrationError::unhandled("Failed to parse retryAfterSeconds from header `Retry-After"))?
                                                
                    );
                            output = output.set_message(parsed_body.message);
                            output.build()
                        }),
                    }
                }
                "UnauthorizedException" => crate::error::DeleteIntegrationError {
                    meta: generic,
                    kind: crate::error::DeleteIntegrationErrorKind::UnauthorizedError({
                        #[allow(unused_mut)]
                        let mut output = crate::error::unauthorized_error::Builder::default();
                        let _ = response;

                        let body_slice = response.body().as_ref();

                        let parsed_body: crate::error::UnauthorizedError = if body_slice.is_empty()
                        {
                            // To enable JSON parsing to succeed, replace an empty body
                            // with an empty JSON body. If a member was required, it will fail slightly later
                            // during the operation construction phase.
                            serde_json::from_slice(b"{}")
                                .map_err(crate::error::DeleteIntegrationError::unhandled)?
                        } else {
                            serde_json::from_slice(response.body().as_ref())
                                .map_err(crate::error::DeleteIntegrationError::unhandled)?
                        };

                        output = output.set_message(parsed_body.message);
                        output.build()
                    }),
                },
                _ => crate::error::DeleteIntegrationError::generic(generic),
            });
        }
        Ok({
            #[allow(unused_mut)]
            let mut output = crate::output::delete_integration_output::Builder::default();
            let _ = response;
            output.build()
        })
    }
    pub fn parse_response(
        &self,
        response: &http::response::Response<impl AsRef<[u8]>>,
    ) -> Result<crate::output::DeleteIntegrationOutput, crate::error::DeleteIntegrationError> {
        Self::from_response(&response)
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}

impl smithy_http::response::ParseStrictResponse for DeleteIntegration {
    type Output =
        Result<crate::output::DeleteIntegrationOutput, crate::error::DeleteIntegrationError>;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        self.parse_response(response)
    }
}

/// <p>Represents a delete integration response.</p>
#[derive(std::clone::Clone)]
pub struct DeleteIntegrationResponse {
    _private: (),
}
impl DeleteIntegrationResponse {
    /// Creates a new builder-style object to manufacture [`DeleteIntegrationResponseInput`](crate::input::DeleteIntegrationResponseInput)
    pub fn builder() -> crate::input::delete_integration_response_input::Builder {
        crate::input::delete_integration_response_input::Builder::default()
    }
    #[allow(clippy::unnecessary_wraps)]
    fn from_response(
        response: &http::response::Response<impl AsRef<[u8]>>,
    ) -> Result<
        crate::output::DeleteIntegrationResponseOutput,
        crate::error::DeleteIntegrationResponseError,
    > {
        if crate::aws_json_errors::is_error(&response) && response.status().as_u16() != 204 {
            let body = serde_json::from_slice(response.body().as_ref())
                .unwrap_or_else(|_| serde_json::json!({}));
            let generic = crate::aws_json_errors::parse_generic_error(&response, &body);

            let error_code = match generic.code() {
                Some(code) => code,
                None => {
                    return Err(crate::error::DeleteIntegrationResponseError::unhandled(
                        generic,
                    ))
                }
            };
            return Err(match error_code {
                "BadRequestException" => crate::error::DeleteIntegrationResponseError {
                    meta: generic,
                    kind: crate::error::DeleteIntegrationResponseErrorKind::BadRequestError({
                        #[allow(unused_mut)]
                        let mut output = crate::error::bad_request_error::Builder::default();
                        let _ = response;

                        let body_slice = response.body().as_ref();

                        let parsed_body: crate::error::BadRequestError = if body_slice.is_empty() {
                            // To enable JSON parsing to succeed, replace an empty body
                            // with an empty JSON body. If a member was required, it will fail slightly later
                            // during the operation construction phase.
                            serde_json::from_slice(b"{}")
                                .map_err(crate::error::DeleteIntegrationResponseError::unhandled)?
                        } else {
                            serde_json::from_slice(response.body().as_ref())
                                .map_err(crate::error::DeleteIntegrationResponseError::unhandled)?
                        };

                        output = output.set_message(parsed_body.message);
                        output.build()
                    }),
                },
                "ConflictException" => crate::error::DeleteIntegrationResponseError {
                    meta: generic,
                    kind: crate::error::DeleteIntegrationResponseErrorKind::ConflictError({
                        #[allow(unused_mut)]
                        let mut output = crate::error::conflict_error::Builder::default();
                        let _ = response;

                        let body_slice = response.body().as_ref();

                        let parsed_body: crate::error::ConflictError = if body_slice.is_empty() {
                            // To enable JSON parsing to succeed, replace an empty body
                            // with an empty JSON body. If a member was required, it will fail slightly later
                            // during the operation construction phase.
                            serde_json::from_slice(b"{}")
                                .map_err(crate::error::DeleteIntegrationResponseError::unhandled)?
                        } else {
                            serde_json::from_slice(response.body().as_ref())
                                .map_err(crate::error::DeleteIntegrationResponseError::unhandled)?
                        };

                        output = output.set_message(parsed_body.message);
                        output.build()
                    }),
                },
                "NotFoundException" => crate::error::DeleteIntegrationResponseError {
                    meta: generic,
                    kind: crate::error::DeleteIntegrationResponseErrorKind::NotFoundError({
                        #[allow(unused_mut)]
                        let mut output = crate::error::not_found_error::Builder::default();
                        let _ = response;

                        let body_slice = response.body().as_ref();

                        let parsed_body: crate::error::NotFoundError = if body_slice.is_empty() {
                            // To enable JSON parsing to succeed, replace an empty body
                            // with an empty JSON body. If a member was required, it will fail slightly later
                            // during the operation construction phase.
                            serde_json::from_slice(b"{}")
                                .map_err(crate::error::DeleteIntegrationResponseError::unhandled)?
                        } else {
                            serde_json::from_slice(response.body().as_ref())
                                .map_err(crate::error::DeleteIntegrationResponseError::unhandled)?
                        };

                        output = output.set_message(parsed_body.message);
                        output.build()
                    }),
                },
                "TooManyRequestsException" => crate::error::DeleteIntegrationResponseError {
                    meta: generic,
                    kind: crate::error::DeleteIntegrationResponseErrorKind::TooManyRequestsError({
                        #[allow(unused_mut)]
                        let mut output = crate::error::too_many_requests_error::Builder::default();
                        let _ = response;

                        let body_slice = response.body().as_ref();

                        let parsed_body: crate::error::TooManyRequestsError = if body_slice
                            .is_empty()
                        {
                            // To enable JSON parsing to succeed, replace an empty body
                            // with an empty JSON body. If a member was required, it will fail slightly later
                            // during the operation construction phase.
                            serde_json::from_slice(b"{}")
                                .map_err(crate::error::DeleteIntegrationResponseError::unhandled)?
                        } else {
                            serde_json::from_slice(response.body().as_ref())
                                .map_err(crate::error::DeleteIntegrationResponseError::unhandled)?
                        };

                        output = output.set_retry_after_seconds(
                        
                                                crate::http_serde::deser_header_delete_integration_response_retry_after_seconds(response.headers())
                                                    .map_err(|_|crate::error::DeleteIntegrationResponseError::unhandled("Failed to parse retryAfterSeconds from header `Retry-After"))?
                                                
                    );
                        output = output.set_message(parsed_body.message);
                        output.build()
                    }),
                },
                "UnauthorizedException" => crate::error::DeleteIntegrationResponseError {
                    meta: generic,
                    kind: crate::error::DeleteIntegrationResponseErrorKind::UnauthorizedError({
                        #[allow(unused_mut)]
                        let mut output = crate::error::unauthorized_error::Builder::default();
                        let _ = response;

                        let body_slice = response.body().as_ref();

                        let parsed_body: crate::error::UnauthorizedError = if body_slice.is_empty()
                        {
                            // To enable JSON parsing to succeed, replace an empty body
                            // with an empty JSON body. If a member was required, it will fail slightly later
                            // during the operation construction phase.
                            serde_json::from_slice(b"{}")
                                .map_err(crate::error::DeleteIntegrationResponseError::unhandled)?
                        } else {
                            serde_json::from_slice(response.body().as_ref())
                                .map_err(crate::error::DeleteIntegrationResponseError::unhandled)?
                        };

                        output = output.set_message(parsed_body.message);
                        output.build()
                    }),
                },
                _ => crate::error::DeleteIntegrationResponseError::generic(generic),
            });
        }
        Ok({
            #[allow(unused_mut)]
            let mut output = crate::output::delete_integration_response_output::Builder::default();
            let _ = response;
            output.build()
        })
    }
    pub fn parse_response(
        &self,
        response: &http::response::Response<impl AsRef<[u8]>>,
    ) -> Result<
        crate::output::DeleteIntegrationResponseOutput,
        crate::error::DeleteIntegrationResponseError,
    > {
        Self::from_response(&response)
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}

impl smithy_http::response::ParseStrictResponse for DeleteIntegrationResponse {
    type Output = Result<
        crate::output::DeleteIntegrationResponseOutput,
        crate::error::DeleteIntegrationResponseError,
    >;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        self.parse_response(response)
    }
}

/// <p>Deletes an existing <a>Method</a> resource.</p>
#[derive(std::clone::Clone)]
pub struct DeleteMethod {
    _private: (),
}
impl DeleteMethod {
    /// Creates a new builder-style object to manufacture [`DeleteMethodInput`](crate::input::DeleteMethodInput)
    pub fn builder() -> crate::input::delete_method_input::Builder {
        crate::input::delete_method_input::Builder::default()
    }
    #[allow(clippy::unnecessary_wraps)]
    fn from_response(
        response: &http::response::Response<impl AsRef<[u8]>>,
    ) -> Result<crate::output::DeleteMethodOutput, crate::error::DeleteMethodError> {
        if crate::aws_json_errors::is_error(&response) && response.status().as_u16() != 204 {
            let body = serde_json::from_slice(response.body().as_ref())
                .unwrap_or_else(|_| serde_json::json!({}));
            let generic = crate::aws_json_errors::parse_generic_error(&response, &body);

            let error_code = match generic.code() {
                Some(code) => code,
                None => return Err(crate::error::DeleteMethodError::unhandled(generic)),
            };
            return Err(match error_code {
                "ConflictException" => crate::error::DeleteMethodError {
                    meta: generic,
                    kind: crate::error::DeleteMethodErrorKind::ConflictError({
                        #[allow(unused_mut)]
                        let mut output = crate::error::conflict_error::Builder::default();
                        let _ = response;

                        let body_slice = response.body().as_ref();

                        let parsed_body: crate::error::ConflictError = if body_slice.is_empty() {
                            // To enable JSON parsing to succeed, replace an empty body
                            // with an empty JSON body. If a member was required, it will fail slightly later
                            // during the operation construction phase.
                            serde_json::from_slice(b"{}")
                                .map_err(crate::error::DeleteMethodError::unhandled)?
                        } else {
                            serde_json::from_slice(response.body().as_ref())
                                .map_err(crate::error::DeleteMethodError::unhandled)?
                        };

                        output = output.set_message(parsed_body.message);
                        output.build()
                    }),
                },
                "NotFoundException" => crate::error::DeleteMethodError {
                    meta: generic,
                    kind: crate::error::DeleteMethodErrorKind::NotFoundError({
                        #[allow(unused_mut)]
                        let mut output = crate::error::not_found_error::Builder::default();
                        let _ = response;

                        let body_slice = response.body().as_ref();

                        let parsed_body: crate::error::NotFoundError = if body_slice.is_empty() {
                            // To enable JSON parsing to succeed, replace an empty body
                            // with an empty JSON body. If a member was required, it will fail slightly later
                            // during the operation construction phase.
                            serde_json::from_slice(b"{}")
                                .map_err(crate::error::DeleteMethodError::unhandled)?
                        } else {
                            serde_json::from_slice(response.body().as_ref())
                                .map_err(crate::error::DeleteMethodError::unhandled)?
                        };

                        output = output.set_message(parsed_body.message);
                        output.build()
                    }),
                },
                "TooManyRequestsException" => {
                    crate::error::DeleteMethodError {
                        meta: generic,
                        kind: crate::error::DeleteMethodErrorKind::TooManyRequestsError({
                            #[allow(unused_mut)]
                            let mut output =
                                crate::error::too_many_requests_error::Builder::default();
                            let _ = response;

                            let body_slice = response.body().as_ref();

                            let parsed_body: crate::error::TooManyRequestsError =
                                if body_slice.is_empty() {
                                    // To enable JSON parsing to succeed, replace an empty body
                                    // with an empty JSON body. If a member was required, it will fail slightly later
                                    // during the operation construction phase.
                                    serde_json::from_slice(b"{}")
                                        .map_err(crate::error::DeleteMethodError::unhandled)?
                                } else {
                                    serde_json::from_slice(response.body().as_ref())
                                        .map_err(crate::error::DeleteMethodError::unhandled)?
                                };

                            output = output.set_retry_after_seconds(
                        
                                                crate::http_serde::deser_header_delete_method_retry_after_seconds(response.headers())
                                                    .map_err(|_|crate::error::DeleteMethodError::unhandled("Failed to parse retryAfterSeconds from header `Retry-After"))?
                                                
                    );
                            output = output.set_message(parsed_body.message);
                            output.build()
                        }),
                    }
                }
                "UnauthorizedException" => crate::error::DeleteMethodError {
                    meta: generic,
                    kind: crate::error::DeleteMethodErrorKind::UnauthorizedError({
                        #[allow(unused_mut)]
                        let mut output = crate::error::unauthorized_error::Builder::default();
                        let _ = response;

                        let body_slice = response.body().as_ref();

                        let parsed_body: crate::error::UnauthorizedError = if body_slice.is_empty()
                        {
                            // To enable JSON parsing to succeed, replace an empty body
                            // with an empty JSON body. If a member was required, it will fail slightly later
                            // during the operation construction phase.
                            serde_json::from_slice(b"{}")
                                .map_err(crate::error::DeleteMethodError::unhandled)?
                        } else {
                            serde_json::from_slice(response.body().as_ref())
                                .map_err(crate::error::DeleteMethodError::unhandled)?
                        };

                        output = output.set_message(parsed_body.message);
                        output.build()
                    }),
                },
                _ => crate::error::DeleteMethodError::generic(generic),
            });
        }
        Ok({
            #[allow(unused_mut)]
            let mut output = crate::output::delete_method_output::Builder::default();
            let _ = response;
            output.build()
        })
    }
    pub fn parse_response(
        &self,
        response: &http::response::Response<impl AsRef<[u8]>>,
    ) -> Result<crate::output::DeleteMethodOutput, crate::error::DeleteMethodError> {
        Self::from_response(&response)
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}

impl smithy_http::response::ParseStrictResponse for DeleteMethod {
    type Output = Result<crate::output::DeleteMethodOutput, crate::error::DeleteMethodError>;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        self.parse_response(response)
    }
}

/// <p>Deletes an existing <a>MethodResponse</a> resource.</p>
#[derive(std::clone::Clone)]
pub struct DeleteMethodResponse {
    _private: (),
}
impl DeleteMethodResponse {
    /// Creates a new builder-style object to manufacture [`DeleteMethodResponseInput`](crate::input::DeleteMethodResponseInput)
    pub fn builder() -> crate::input::delete_method_response_input::Builder {
        crate::input::delete_method_response_input::Builder::default()
    }
    #[allow(clippy::unnecessary_wraps)]
    fn from_response(
        response: &http::response::Response<impl AsRef<[u8]>>,
    ) -> Result<crate::output::DeleteMethodResponseOutput, crate::error::DeleteMethodResponseError>
    {
        if crate::aws_json_errors::is_error(&response) && response.status().as_u16() != 204 {
            let body = serde_json::from_slice(response.body().as_ref())
                .unwrap_or_else(|_| serde_json::json!({}));
            let generic = crate::aws_json_errors::parse_generic_error(&response, &body);

            let error_code = match generic.code() {
                Some(code) => code,
                None => return Err(crate::error::DeleteMethodResponseError::unhandled(generic)),
            };
            return Err(match error_code {
                "BadRequestException" => crate::error::DeleteMethodResponseError {
                    meta: generic,
                    kind: crate::error::DeleteMethodResponseErrorKind::BadRequestError({
                        #[allow(unused_mut)]
                        let mut output = crate::error::bad_request_error::Builder::default();
                        let _ = response;

                        let body_slice = response.body().as_ref();

                        let parsed_body: crate::error::BadRequestError = if body_slice.is_empty() {
                            // To enable JSON parsing to succeed, replace an empty body
                            // with an empty JSON body. If a member was required, it will fail slightly later
                            // during the operation construction phase.
                            serde_json::from_slice(b"{}")
                                .map_err(crate::error::DeleteMethodResponseError::unhandled)?
                        } else {
                            serde_json::from_slice(response.body().as_ref())
                                .map_err(crate::error::DeleteMethodResponseError::unhandled)?
                        };

                        output = output.set_message(parsed_body.message);
                        output.build()
                    }),
                },
                "ConflictException" => crate::error::DeleteMethodResponseError {
                    meta: generic,
                    kind: crate::error::DeleteMethodResponseErrorKind::ConflictError({
                        #[allow(unused_mut)]
                        let mut output = crate::error::conflict_error::Builder::default();
                        let _ = response;

                        let body_slice = response.body().as_ref();

                        let parsed_body: crate::error::ConflictError = if body_slice.is_empty() {
                            // To enable JSON parsing to succeed, replace an empty body
                            // with an empty JSON body. If a member was required, it will fail slightly later
                            // during the operation construction phase.
                            serde_json::from_slice(b"{}")
                                .map_err(crate::error::DeleteMethodResponseError::unhandled)?
                        } else {
                            serde_json::from_slice(response.body().as_ref())
                                .map_err(crate::error::DeleteMethodResponseError::unhandled)?
                        };

                        output = output.set_message(parsed_body.message);
                        output.build()
                    }),
                },
                "NotFoundException" => crate::error::DeleteMethodResponseError {
                    meta: generic,
                    kind: crate::error::DeleteMethodResponseErrorKind::NotFoundError({
                        #[allow(unused_mut)]
                        let mut output = crate::error::not_found_error::Builder::default();
                        let _ = response;

                        let body_slice = response.body().as_ref();

                        let parsed_body: crate::error::NotFoundError = if body_slice.is_empty() {
                            // To enable JSON parsing to succeed, replace an empty body
                            // with an empty JSON body. If a member was required, it will fail slightly later
                            // during the operation construction phase.
                            serde_json::from_slice(b"{}")
                                .map_err(crate::error::DeleteMethodResponseError::unhandled)?
                        } else {
                            serde_json::from_slice(response.body().as_ref())
                                .map_err(crate::error::DeleteMethodResponseError::unhandled)?
                        };

                        output = output.set_message(parsed_body.message);
                        output.build()
                    }),
                },
                "TooManyRequestsException" => crate::error::DeleteMethodResponseError {
                    meta: generic,
                    kind: crate::error::DeleteMethodResponseErrorKind::TooManyRequestsError({
                        #[allow(unused_mut)]
                        let mut output = crate::error::too_many_requests_error::Builder::default();
                        let _ = response;

                        let body_slice = response.body().as_ref();

                        let parsed_body: crate::error::TooManyRequestsError =
                            if body_slice.is_empty() {
                                // To enable JSON parsing to succeed, replace an empty body
                                // with an empty JSON body. If a member was required, it will fail slightly later
                                // during the operation construction phase.
                                serde_json::from_slice(b"{}")
                                    .map_err(crate::error::DeleteMethodResponseError::unhandled)?
                            } else {
                                serde_json::from_slice(response.body().as_ref())
                                    .map_err(crate::error::DeleteMethodResponseError::unhandled)?
                            };

                        output = output.set_retry_after_seconds(
                        
                                                crate::http_serde::deser_header_delete_method_response_retry_after_seconds(response.headers())
                                                    .map_err(|_|crate::error::DeleteMethodResponseError::unhandled("Failed to parse retryAfterSeconds from header `Retry-After"))?
                                                
                    );
                        output = output.set_message(parsed_body.message);
                        output.build()
                    }),
                },
                "UnauthorizedException" => crate::error::DeleteMethodResponseError {
                    meta: generic,
                    kind: crate::error::DeleteMethodResponseErrorKind::UnauthorizedError({
                        #[allow(unused_mut)]
                        let mut output = crate::error::unauthorized_error::Builder::default();
                        let _ = response;

                        let body_slice = response.body().as_ref();

                        let parsed_body: crate::error::UnauthorizedError = if body_slice.is_empty()
                        {
                            // To enable JSON parsing to succeed, replace an empty body
                            // with an empty JSON body. If a member was required, it will fail slightly later
                            // during the operation construction phase.
                            serde_json::from_slice(b"{}")
                                .map_err(crate::error::DeleteMethodResponseError::unhandled)?
                        } else {
                            serde_json::from_slice(response.body().as_ref())
                                .map_err(crate::error::DeleteMethodResponseError::unhandled)?
                        };

                        output = output.set_message(parsed_body.message);
                        output.build()
                    }),
                },
                _ => crate::error::DeleteMethodResponseError::generic(generic),
            });
        }
        Ok({
            #[allow(unused_mut)]
            let mut output = crate::output::delete_method_response_output::Builder::default();
            let _ = response;
            output.build()
        })
    }
    pub fn parse_response(
        &self,
        response: &http::response::Response<impl AsRef<[u8]>>,
    ) -> Result<crate::output::DeleteMethodResponseOutput, crate::error::DeleteMethodResponseError>
    {
        Self::from_response(&response)
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}

impl smithy_http::response::ParseStrictResponse for DeleteMethodResponse {
    type Output =
        Result<crate::output::DeleteMethodResponseOutput, crate::error::DeleteMethodResponseError>;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        self.parse_response(response)
    }
}

/// <p>Deletes a model.</p>
#[derive(std::clone::Clone)]
pub struct DeleteModel {
    _private: (),
}
impl DeleteModel {
    /// Creates a new builder-style object to manufacture [`DeleteModelInput`](crate::input::DeleteModelInput)
    pub fn builder() -> crate::input::delete_model_input::Builder {
        crate::input::delete_model_input::Builder::default()
    }
    #[allow(clippy::unnecessary_wraps)]
    fn from_response(
        response: &http::response::Response<impl AsRef<[u8]>>,
    ) -> Result<crate::output::DeleteModelOutput, crate::error::DeleteModelError> {
        if crate::aws_json_errors::is_error(&response) && response.status().as_u16() != 202 {
            let body = serde_json::from_slice(response.body().as_ref())
                .unwrap_or_else(|_| serde_json::json!({}));
            let generic = crate::aws_json_errors::parse_generic_error(&response, &body);

            let error_code = match generic.code() {
                Some(code) => code,
                None => return Err(crate::error::DeleteModelError::unhandled(generic)),
            };
            return Err(match error_code {
                "BadRequestException" => crate::error::DeleteModelError {
                    meta: generic,
                    kind: crate::error::DeleteModelErrorKind::BadRequestError({
                        #[allow(unused_mut)]
                        let mut output = crate::error::bad_request_error::Builder::default();
                        let _ = response;

                        let body_slice = response.body().as_ref();

                        let parsed_body: crate::error::BadRequestError = if body_slice.is_empty() {
                            // To enable JSON parsing to succeed, replace an empty body
                            // with an empty JSON body. If a member was required, it will fail slightly later
                            // during the operation construction phase.
                            serde_json::from_slice(b"{}")
                                .map_err(crate::error::DeleteModelError::unhandled)?
                        } else {
                            serde_json::from_slice(response.body().as_ref())
                                .map_err(crate::error::DeleteModelError::unhandled)?
                        };

                        output = output.set_message(parsed_body.message);
                        output.build()
                    }),
                },
                "ConflictException" => crate::error::DeleteModelError {
                    meta: generic,
                    kind: crate::error::DeleteModelErrorKind::ConflictError({
                        #[allow(unused_mut)]
                        let mut output = crate::error::conflict_error::Builder::default();
                        let _ = response;

                        let body_slice = response.body().as_ref();

                        let parsed_body: crate::error::ConflictError = if body_slice.is_empty() {
                            // To enable JSON parsing to succeed, replace an empty body
                            // with an empty JSON body. If a member was required, it will fail slightly later
                            // during the operation construction phase.
                            serde_json::from_slice(b"{}")
                                .map_err(crate::error::DeleteModelError::unhandled)?
                        } else {
                            serde_json::from_slice(response.body().as_ref())
                                .map_err(crate::error::DeleteModelError::unhandled)?
                        };

                        output = output.set_message(parsed_body.message);
                        output.build()
                    }),
                },
                "NotFoundException" => crate::error::DeleteModelError {
                    meta: generic,
                    kind: crate::error::DeleteModelErrorKind::NotFoundError({
                        #[allow(unused_mut)]
                        let mut output = crate::error::not_found_error::Builder::default();
                        let _ = response;

                        let body_slice = response.body().as_ref();

                        let parsed_body: crate::error::NotFoundError = if body_slice.is_empty() {
                            // To enable JSON parsing to succeed, replace an empty body
                            // with an empty JSON body. If a member was required, it will fail slightly later
                            // during the operation construction phase.
                            serde_json::from_slice(b"{}")
                                .map_err(crate::error::DeleteModelError::unhandled)?
                        } else {
                            serde_json::from_slice(response.body().as_ref())
                                .map_err(crate::error::DeleteModelError::unhandled)?
                        };

                        output = output.set_message(parsed_body.message);
                        output.build()
                    }),
                },
                "TooManyRequestsException" => {
                    crate::error::DeleteModelError {
                        meta: generic,
                        kind: crate::error::DeleteModelErrorKind::TooManyRequestsError({
                            #[allow(unused_mut)]
                            let mut output =
                                crate::error::too_many_requests_error::Builder::default();
                            let _ = response;

                            let body_slice = response.body().as_ref();

                            let parsed_body: crate::error::TooManyRequestsError =
                                if body_slice.is_empty() {
                                    // To enable JSON parsing to succeed, replace an empty body
                                    // with an empty JSON body. If a member was required, it will fail slightly later
                                    // during the operation construction phase.
                                    serde_json::from_slice(b"{}")
                                        .map_err(crate::error::DeleteModelError::unhandled)?
                                } else {
                                    serde_json::from_slice(response.body().as_ref())
                                        .map_err(crate::error::DeleteModelError::unhandled)?
                                };

                            output = output.set_retry_after_seconds(
                        
                                                crate::http_serde::deser_header_delete_model_retry_after_seconds(response.headers())
                                                    .map_err(|_|crate::error::DeleteModelError::unhandled("Failed to parse retryAfterSeconds from header `Retry-After"))?
                                                
                    );
                            output = output.set_message(parsed_body.message);
                            output.build()
                        }),
                    }
                }
                "UnauthorizedException" => crate::error::DeleteModelError {
                    meta: generic,
                    kind: crate::error::DeleteModelErrorKind::UnauthorizedError({
                        #[allow(unused_mut)]
                        let mut output = crate::error::unauthorized_error::Builder::default();
                        let _ = response;

                        let body_slice = response.body().as_ref();

                        let parsed_body: crate::error::UnauthorizedError = if body_slice.is_empty()
                        {
                            // To enable JSON parsing to succeed, replace an empty body
                            // with an empty JSON body. If a member was required, it will fail slightly later
                            // during the operation construction phase.
                            serde_json::from_slice(b"{}")
                                .map_err(crate::error::DeleteModelError::unhandled)?
                        } else {
                            serde_json::from_slice(response.body().as_ref())
                                .map_err(crate::error::DeleteModelError::unhandled)?
                        };

                        output = output.set_message(parsed_body.message);
                        output.build()
                    }),
                },
                _ => crate::error::DeleteModelError::generic(generic),
            });
        }
        Ok({
            #[allow(unused_mut)]
            let mut output = crate::output::delete_model_output::Builder::default();
            let _ = response;
            output.build()
        })
    }
    pub fn parse_response(
        &self,
        response: &http::response::Response<impl AsRef<[u8]>>,
    ) -> Result<crate::output::DeleteModelOutput, crate::error::DeleteModelError> {
        Self::from_response(&response)
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}

impl smithy_http::response::ParseStrictResponse for DeleteModel {
    type Output = Result<crate::output::DeleteModelOutput, crate::error::DeleteModelError>;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        self.parse_response(response)
    }
}

/// <p>Deletes a <a>RequestValidator</a> of a given <a>RestApi</a>.</p>
#[derive(std::clone::Clone)]
pub struct DeleteRequestValidator {
    _private: (),
}
impl DeleteRequestValidator {
    /// Creates a new builder-style object to manufacture [`DeleteRequestValidatorInput`](crate::input::DeleteRequestValidatorInput)
    pub fn builder() -> crate::input::delete_request_validator_input::Builder {
        crate::input::delete_request_validator_input::Builder::default()
    }
    #[allow(clippy::unnecessary_wraps)]
    fn from_response(
        response: &http::response::Response<impl AsRef<[u8]>>,
    ) -> Result<
        crate::output::DeleteRequestValidatorOutput,
        crate::error::DeleteRequestValidatorError,
    > {
        if crate::aws_json_errors::is_error(&response) && response.status().as_u16() != 202 {
            let body = serde_json::from_slice(response.body().as_ref())
                .unwrap_or_else(|_| serde_json::json!({}));
            let generic = crate::aws_json_errors::parse_generic_error(&response, &body);

            let error_code = match generic.code() {
                Some(code) => code,
                None => {
                    return Err(crate::error::DeleteRequestValidatorError::unhandled(
                        generic,
                    ))
                }
            };
            return Err(match error_code {
                "BadRequestException" => crate::error::DeleteRequestValidatorError {
                    meta: generic,
                    kind: crate::error::DeleteRequestValidatorErrorKind::BadRequestError({
                        #[allow(unused_mut)]
                        let mut output = crate::error::bad_request_error::Builder::default();
                        let _ = response;

                        let body_slice = response.body().as_ref();

                        let parsed_body: crate::error::BadRequestError = if body_slice.is_empty() {
                            // To enable JSON parsing to succeed, replace an empty body
                            // with an empty JSON body. If a member was required, it will fail slightly later
                            // during the operation construction phase.
                            serde_json::from_slice(b"{}")
                                .map_err(crate::error::DeleteRequestValidatorError::unhandled)?
                        } else {
                            serde_json::from_slice(response.body().as_ref())
                                .map_err(crate::error::DeleteRequestValidatorError::unhandled)?
                        };

                        output = output.set_message(parsed_body.message);
                        output.build()
                    }),
                },
                "ConflictException" => crate::error::DeleteRequestValidatorError {
                    meta: generic,
                    kind: crate::error::DeleteRequestValidatorErrorKind::ConflictError({
                        #[allow(unused_mut)]
                        let mut output = crate::error::conflict_error::Builder::default();
                        let _ = response;

                        let body_slice = response.body().as_ref();

                        let parsed_body: crate::error::ConflictError = if body_slice.is_empty() {
                            // To enable JSON parsing to succeed, replace an empty body
                            // with an empty JSON body. If a member was required, it will fail slightly later
                            // during the operation construction phase.
                            serde_json::from_slice(b"{}")
                                .map_err(crate::error::DeleteRequestValidatorError::unhandled)?
                        } else {
                            serde_json::from_slice(response.body().as_ref())
                                .map_err(crate::error::DeleteRequestValidatorError::unhandled)?
                        };

                        output = output.set_message(parsed_body.message);
                        output.build()
                    }),
                },
                "NotFoundException" => crate::error::DeleteRequestValidatorError {
                    meta: generic,
                    kind: crate::error::DeleteRequestValidatorErrorKind::NotFoundError({
                        #[allow(unused_mut)]
                        let mut output = crate::error::not_found_error::Builder::default();
                        let _ = response;

                        let body_slice = response.body().as_ref();

                        let parsed_body: crate::error::NotFoundError = if body_slice.is_empty() {
                            // To enable JSON parsing to succeed, replace an empty body
                            // with an empty JSON body. If a member was required, it will fail slightly later
                            // during the operation construction phase.
                            serde_json::from_slice(b"{}")
                                .map_err(crate::error::DeleteRequestValidatorError::unhandled)?
                        } else {
                            serde_json::from_slice(response.body().as_ref())
                                .map_err(crate::error::DeleteRequestValidatorError::unhandled)?
                        };

                        output = output.set_message(parsed_body.message);
                        output.build()
                    }),
                },
                "TooManyRequestsException" => crate::error::DeleteRequestValidatorError {
                    meta: generic,
                    kind: crate::error::DeleteRequestValidatorErrorKind::TooManyRequestsError({
                        #[allow(unused_mut)]
                        let mut output = crate::error::too_many_requests_error::Builder::default();
                        let _ = response;

                        let body_slice = response.body().as_ref();

                        let parsed_body: crate::error::TooManyRequestsError =
                            if body_slice.is_empty() {
                                // To enable JSON parsing to succeed, replace an empty body
                                // with an empty JSON body. If a member was required, it will fail slightly later
                                // during the operation construction phase.
                                serde_json::from_slice(b"{}")
                                    .map_err(crate::error::DeleteRequestValidatorError::unhandled)?
                            } else {
                                serde_json::from_slice(response.body().as_ref())
                                    .map_err(crate::error::DeleteRequestValidatorError::unhandled)?
                            };

                        output = output.set_retry_after_seconds(
                        
                                                crate::http_serde::deser_header_delete_request_validator_retry_after_seconds(response.headers())
                                                    .map_err(|_|crate::error::DeleteRequestValidatorError::unhandled("Failed to parse retryAfterSeconds from header `Retry-After"))?
                                                
                    );
                        output = output.set_message(parsed_body.message);
                        output.build()
                    }),
                },
                "UnauthorizedException" => crate::error::DeleteRequestValidatorError {
                    meta: generic,
                    kind: crate::error::DeleteRequestValidatorErrorKind::UnauthorizedError({
                        #[allow(unused_mut)]
                        let mut output = crate::error::unauthorized_error::Builder::default();
                        let _ = response;

                        let body_slice = response.body().as_ref();

                        let parsed_body: crate::error::UnauthorizedError = if body_slice.is_empty()
                        {
                            // To enable JSON parsing to succeed, replace an empty body
                            // with an empty JSON body. If a member was required, it will fail slightly later
                            // during the operation construction phase.
                            serde_json::from_slice(b"{}")
                                .map_err(crate::error::DeleteRequestValidatorError::unhandled)?
                        } else {
                            serde_json::from_slice(response.body().as_ref())
                                .map_err(crate::error::DeleteRequestValidatorError::unhandled)?
                        };

                        output = output.set_message(parsed_body.message);
                        output.build()
                    }),
                },
                _ => crate::error::DeleteRequestValidatorError::generic(generic),
            });
        }
        Ok({
            #[allow(unused_mut)]
            let mut output = crate::output::delete_request_validator_output::Builder::default();
            let _ = response;
            output.build()
        })
    }
    pub fn parse_response(
        &self,
        response: &http::response::Response<impl AsRef<[u8]>>,
    ) -> Result<
        crate::output::DeleteRequestValidatorOutput,
        crate::error::DeleteRequestValidatorError,
    > {
        Self::from_response(&response)
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}

impl smithy_http::response::ParseStrictResponse for DeleteRequestValidator {
    type Output = Result<
        crate::output::DeleteRequestValidatorOutput,
        crate::error::DeleteRequestValidatorError,
    >;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        self.parse_response(response)
    }
}

/// <p>Deletes a <a>Resource</a> resource.</p>
#[derive(std::clone::Clone)]
pub struct DeleteResource {
    _private: (),
}
impl DeleteResource {
    /// Creates a new builder-style object to manufacture [`DeleteResourceInput`](crate::input::DeleteResourceInput)
    pub fn builder() -> crate::input::delete_resource_input::Builder {
        crate::input::delete_resource_input::Builder::default()
    }
    #[allow(clippy::unnecessary_wraps)]
    fn from_response(
        response: &http::response::Response<impl AsRef<[u8]>>,
    ) -> Result<crate::output::DeleteResourceOutput, crate::error::DeleteResourceError> {
        if crate::aws_json_errors::is_error(&response) && response.status().as_u16() != 202 {
            let body = serde_json::from_slice(response.body().as_ref())
                .unwrap_or_else(|_| serde_json::json!({}));
            let generic = crate::aws_json_errors::parse_generic_error(&response, &body);

            let error_code = match generic.code() {
                Some(code) => code,
                None => return Err(crate::error::DeleteResourceError::unhandled(generic)),
            };
            return Err(match error_code {
                "BadRequestException" => crate::error::DeleteResourceError {
                    meta: generic,
                    kind: crate::error::DeleteResourceErrorKind::BadRequestError({
                        #[allow(unused_mut)]
                        let mut output = crate::error::bad_request_error::Builder::default();
                        let _ = response;

                        let body_slice = response.body().as_ref();

                        let parsed_body: crate::error::BadRequestError = if body_slice.is_empty() {
                            // To enable JSON parsing to succeed, replace an empty body
                            // with an empty JSON body. If a member was required, it will fail slightly later
                            // during the operation construction phase.
                            serde_json::from_slice(b"{}")
                                .map_err(crate::error::DeleteResourceError::unhandled)?
                        } else {
                            serde_json::from_slice(response.body().as_ref())
                                .map_err(crate::error::DeleteResourceError::unhandled)?
                        };

                        output = output.set_message(parsed_body.message);
                        output.build()
                    }),
                },
                "ConflictException" => crate::error::DeleteResourceError {
                    meta: generic,
                    kind: crate::error::DeleteResourceErrorKind::ConflictError({
                        #[allow(unused_mut)]
                        let mut output = crate::error::conflict_error::Builder::default();
                        let _ = response;

                        let body_slice = response.body().as_ref();

                        let parsed_body: crate::error::ConflictError = if body_slice.is_empty() {
                            // To enable JSON parsing to succeed, replace an empty body
                            // with an empty JSON body. If a member was required, it will fail slightly later
                            // during the operation construction phase.
                            serde_json::from_slice(b"{}")
                                .map_err(crate::error::DeleteResourceError::unhandled)?
                        } else {
                            serde_json::from_slice(response.body().as_ref())
                                .map_err(crate::error::DeleteResourceError::unhandled)?
                        };

                        output = output.set_message(parsed_body.message);
                        output.build()
                    }),
                },
                "NotFoundException" => crate::error::DeleteResourceError {
                    meta: generic,
                    kind: crate::error::DeleteResourceErrorKind::NotFoundError({
                        #[allow(unused_mut)]
                        let mut output = crate::error::not_found_error::Builder::default();
                        let _ = response;

                        let body_slice = response.body().as_ref();

                        let parsed_body: crate::error::NotFoundError = if body_slice.is_empty() {
                            // To enable JSON parsing to succeed, replace an empty body
                            // with an empty JSON body. If a member was required, it will fail slightly later
                            // during the operation construction phase.
                            serde_json::from_slice(b"{}")
                                .map_err(crate::error::DeleteResourceError::unhandled)?
                        } else {
                            serde_json::from_slice(response.body().as_ref())
                                .map_err(crate::error::DeleteResourceError::unhandled)?
                        };

                        output = output.set_message(parsed_body.message);
                        output.build()
                    }),
                },
                "TooManyRequestsException" => {
                    crate::error::DeleteResourceError {
                        meta: generic,
                        kind: crate::error::DeleteResourceErrorKind::TooManyRequestsError({
                            #[allow(unused_mut)]
                            let mut output =
                                crate::error::too_many_requests_error::Builder::default();
                            let _ = response;

                            let body_slice = response.body().as_ref();

                            let parsed_body: crate::error::TooManyRequestsError =
                                if body_slice.is_empty() {
                                    // To enable JSON parsing to succeed, replace an empty body
                                    // with an empty JSON body. If a member was required, it will fail slightly later
                                    // during the operation construction phase.
                                    serde_json::from_slice(b"{}")
                                        .map_err(crate::error::DeleteResourceError::unhandled)?
                                } else {
                                    serde_json::from_slice(response.body().as_ref())
                                        .map_err(crate::error::DeleteResourceError::unhandled)?
                                };

                            output = output.set_retry_after_seconds(
                        
                                                crate::http_serde::deser_header_delete_resource_retry_after_seconds(response.headers())
                                                    .map_err(|_|crate::error::DeleteResourceError::unhandled("Failed to parse retryAfterSeconds from header `Retry-After"))?
                                                
                    );
                            output = output.set_message(parsed_body.message);
                            output.build()
                        }),
                    }
                }
                "UnauthorizedException" => crate::error::DeleteResourceError {
                    meta: generic,
                    kind: crate::error::DeleteResourceErrorKind::UnauthorizedError({
                        #[allow(unused_mut)]
                        let mut output = crate::error::unauthorized_error::Builder::default();
                        let _ = response;

                        let body_slice = response.body().as_ref();

                        let parsed_body: crate::error::UnauthorizedError = if body_slice.is_empty()
                        {
                            // To enable JSON parsing to succeed, replace an empty body
                            // with an empty JSON body. If a member was required, it will fail slightly later
                            // during the operation construction phase.
                            serde_json::from_slice(b"{}")
                                .map_err(crate::error::DeleteResourceError::unhandled)?
                        } else {
                            serde_json::from_slice(response.body().as_ref())
                                .map_err(crate::error::DeleteResourceError::unhandled)?
                        };

                        output = output.set_message(parsed_body.message);
                        output.build()
                    }),
                },
                _ => crate::error::DeleteResourceError::generic(generic),
            });
        }
        Ok({
            #[allow(unused_mut)]
            let mut output = crate::output::delete_resource_output::Builder::default();
            let _ = response;
            output.build()
        })
    }
    pub fn parse_response(
        &self,
        response: &http::response::Response<impl AsRef<[u8]>>,
    ) -> Result<crate::output::DeleteResourceOutput, crate::error::DeleteResourceError> {
        Self::from_response(&response)
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}

impl smithy_http::response::ParseStrictResponse for DeleteResource {
    type Output = Result<crate::output::DeleteResourceOutput, crate::error::DeleteResourceError>;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        self.parse_response(response)
    }
}

/// <p>Deletes the specified API.</p>
#[derive(std::clone::Clone)]
pub struct DeleteRestApi {
    _private: (),
}
impl DeleteRestApi {
    /// Creates a new builder-style object to manufacture [`DeleteRestApiInput`](crate::input::DeleteRestApiInput)
    pub fn builder() -> crate::input::delete_rest_api_input::Builder {
        crate::input::delete_rest_api_input::Builder::default()
    }
    #[allow(clippy::unnecessary_wraps)]
    fn from_response(
        response: &http::response::Response<impl AsRef<[u8]>>,
    ) -> Result<crate::output::DeleteRestApiOutput, crate::error::DeleteRestApiError> {
        if crate::aws_json_errors::is_error(&response) && response.status().as_u16() != 202 {
            let body = serde_json::from_slice(response.body().as_ref())
                .unwrap_or_else(|_| serde_json::json!({}));
            let generic = crate::aws_json_errors::parse_generic_error(&response, &body);

            let error_code = match generic.code() {
                Some(code) => code,
                None => return Err(crate::error::DeleteRestApiError::unhandled(generic)),
            };
            return Err(match error_code {
                "BadRequestException" => crate::error::DeleteRestApiError {
                    meta: generic,
                    kind: crate::error::DeleteRestApiErrorKind::BadRequestError({
                        #[allow(unused_mut)]
                        let mut output = crate::error::bad_request_error::Builder::default();
                        let _ = response;

                        let body_slice = response.body().as_ref();

                        let parsed_body: crate::error::BadRequestError = if body_slice.is_empty() {
                            // To enable JSON parsing to succeed, replace an empty body
                            // with an empty JSON body. If a member was required, it will fail slightly later
                            // during the operation construction phase.
                            serde_json::from_slice(b"{}")
                                .map_err(crate::error::DeleteRestApiError::unhandled)?
                        } else {
                            serde_json::from_slice(response.body().as_ref())
                                .map_err(crate::error::DeleteRestApiError::unhandled)?
                        };

                        output = output.set_message(parsed_body.message);
                        output.build()
                    }),
                },
                "NotFoundException" => crate::error::DeleteRestApiError {
                    meta: generic,
                    kind: crate::error::DeleteRestApiErrorKind::NotFoundError({
                        #[allow(unused_mut)]
                        let mut output = crate::error::not_found_error::Builder::default();
                        let _ = response;

                        let body_slice = response.body().as_ref();

                        let parsed_body: crate::error::NotFoundError = if body_slice.is_empty() {
                            // To enable JSON parsing to succeed, replace an empty body
                            // with an empty JSON body. If a member was required, it will fail slightly later
                            // during the operation construction phase.
                            serde_json::from_slice(b"{}")
                                .map_err(crate::error::DeleteRestApiError::unhandled)?
                        } else {
                            serde_json::from_slice(response.body().as_ref())
                                .map_err(crate::error::DeleteRestApiError::unhandled)?
                        };

                        output = output.set_message(parsed_body.message);
                        output.build()
                    }),
                },
                "TooManyRequestsException" => {
                    crate::error::DeleteRestApiError {
                        meta: generic,
                        kind: crate::error::DeleteRestApiErrorKind::TooManyRequestsError({
                            #[allow(unused_mut)]
                            let mut output =
                                crate::error::too_many_requests_error::Builder::default();
                            let _ = response;

                            let body_slice = response.body().as_ref();

                            let parsed_body: crate::error::TooManyRequestsError =
                                if body_slice.is_empty() {
                                    // To enable JSON parsing to succeed, replace an empty body
                                    // with an empty JSON body. If a member was required, it will fail slightly later
                                    // during the operation construction phase.
                                    serde_json::from_slice(b"{}")
                                        .map_err(crate::error::DeleteRestApiError::unhandled)?
                                } else {
                                    serde_json::from_slice(response.body().as_ref())
                                        .map_err(crate::error::DeleteRestApiError::unhandled)?
                                };

                            output = output.set_retry_after_seconds(
                        
                                                crate::http_serde::deser_header_delete_rest_api_retry_after_seconds(response.headers())
                                                    .map_err(|_|crate::error::DeleteRestApiError::unhandled("Failed to parse retryAfterSeconds from header `Retry-After"))?
                                                
                    );
                            output = output.set_message(parsed_body.message);
                            output.build()
                        }),
                    }
                }
                "UnauthorizedException" => crate::error::DeleteRestApiError {
                    meta: generic,
                    kind: crate::error::DeleteRestApiErrorKind::UnauthorizedError({
                        #[allow(unused_mut)]
                        let mut output = crate::error::unauthorized_error::Builder::default();
                        let _ = response;

                        let body_slice = response.body().as_ref();

                        let parsed_body: crate::error::UnauthorizedError = if body_slice.is_empty()
                        {
                            // To enable JSON parsing to succeed, replace an empty body
                            // with an empty JSON body. If a member was required, it will fail slightly later
                            // during the operation construction phase.
                            serde_json::from_slice(b"{}")
                                .map_err(crate::error::DeleteRestApiError::unhandled)?
                        } else {
                            serde_json::from_slice(response.body().as_ref())
                                .map_err(crate::error::DeleteRestApiError::unhandled)?
                        };

                        output = output.set_message(parsed_body.message);
                        output.build()
                    }),
                },
                _ => crate::error::DeleteRestApiError::generic(generic),
            });
        }
        Ok({
            #[allow(unused_mut)]
            let mut output = crate::output::delete_rest_api_output::Builder::default();
            let _ = response;
            output.build()
        })
    }
    pub fn parse_response(
        &self,
        response: &http::response::Response<impl AsRef<[u8]>>,
    ) -> Result<crate::output::DeleteRestApiOutput, crate::error::DeleteRestApiError> {
        Self::from_response(&response)
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}

impl smithy_http::response::ParseStrictResponse for DeleteRestApi {
    type Output = Result<crate::output::DeleteRestApiOutput, crate::error::DeleteRestApiError>;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        self.parse_response(response)
    }
}

/// <p>Deletes a <a>Stage</a> resource.</p>
#[derive(std::clone::Clone)]
pub struct DeleteStage {
    _private: (),
}
impl DeleteStage {
    /// Creates a new builder-style object to manufacture [`DeleteStageInput`](crate::input::DeleteStageInput)
    pub fn builder() -> crate::input::delete_stage_input::Builder {
        crate::input::delete_stage_input::Builder::default()
    }
    #[allow(clippy::unnecessary_wraps)]
    fn from_response(
        response: &http::response::Response<impl AsRef<[u8]>>,
    ) -> Result<crate::output::DeleteStageOutput, crate::error::DeleteStageError> {
        if crate::aws_json_errors::is_error(&response) && response.status().as_u16() != 202 {
            let body = serde_json::from_slice(response.body().as_ref())
                .unwrap_or_else(|_| serde_json::json!({}));
            let generic = crate::aws_json_errors::parse_generic_error(&response, &body);

            let error_code = match generic.code() {
                Some(code) => code,
                None => return Err(crate::error::DeleteStageError::unhandled(generic)),
            };
            return Err(match error_code {
                "BadRequestException" => crate::error::DeleteStageError {
                    meta: generic,
                    kind: crate::error::DeleteStageErrorKind::BadRequestError({
                        #[allow(unused_mut)]
                        let mut output = crate::error::bad_request_error::Builder::default();
                        let _ = response;

                        let body_slice = response.body().as_ref();

                        let parsed_body: crate::error::BadRequestError = if body_slice.is_empty() {
                            // To enable JSON parsing to succeed, replace an empty body
                            // with an empty JSON body. If a member was required, it will fail slightly later
                            // during the operation construction phase.
                            serde_json::from_slice(b"{}")
                                .map_err(crate::error::DeleteStageError::unhandled)?
                        } else {
                            serde_json::from_slice(response.body().as_ref())
                                .map_err(crate::error::DeleteStageError::unhandled)?
                        };

                        output = output.set_message(parsed_body.message);
                        output.build()
                    }),
                },
                "NotFoundException" => crate::error::DeleteStageError {
                    meta: generic,
                    kind: crate::error::DeleteStageErrorKind::NotFoundError({
                        #[allow(unused_mut)]
                        let mut output = crate::error::not_found_error::Builder::default();
                        let _ = response;

                        let body_slice = response.body().as_ref();

                        let parsed_body: crate::error::NotFoundError = if body_slice.is_empty() {
                            // To enable JSON parsing to succeed, replace an empty body
                            // with an empty JSON body. If a member was required, it will fail slightly later
                            // during the operation construction phase.
                            serde_json::from_slice(b"{}")
                                .map_err(crate::error::DeleteStageError::unhandled)?
                        } else {
                            serde_json::from_slice(response.body().as_ref())
                                .map_err(crate::error::DeleteStageError::unhandled)?
                        };

                        output = output.set_message(parsed_body.message);
                        output.build()
                    }),
                },
                "TooManyRequestsException" => {
                    crate::error::DeleteStageError {
                        meta: generic,
                        kind: crate::error::DeleteStageErrorKind::TooManyRequestsError({
                            #[allow(unused_mut)]
                            let mut output =
                                crate::error::too_many_requests_error::Builder::default();
                            let _ = response;

                            let body_slice = response.body().as_ref();

                            let parsed_body: crate::error::TooManyRequestsError =
                                if body_slice.is_empty() {
                                    // To enable JSON parsing to succeed, replace an empty body
                                    // with an empty JSON body. If a member was required, it will fail slightly later
                                    // during the operation construction phase.
                                    serde_json::from_slice(b"{}")
                                        .map_err(crate::error::DeleteStageError::unhandled)?
                                } else {
                                    serde_json::from_slice(response.body().as_ref())
                                        .map_err(crate::error::DeleteStageError::unhandled)?
                                };

                            output = output.set_retry_after_seconds(
                        
                                                crate::http_serde::deser_header_delete_stage_retry_after_seconds(response.headers())
                                                    .map_err(|_|crate::error::DeleteStageError::unhandled("Failed to parse retryAfterSeconds from header `Retry-After"))?
                                                
                    );
                            output = output.set_message(parsed_body.message);
                            output.build()
                        }),
                    }
                }
                "UnauthorizedException" => crate::error::DeleteStageError {
                    meta: generic,
                    kind: crate::error::DeleteStageErrorKind::UnauthorizedError({
                        #[allow(unused_mut)]
                        let mut output = crate::error::unauthorized_error::Builder::default();
                        let _ = response;

                        let body_slice = response.body().as_ref();

                        let parsed_body: crate::error::UnauthorizedError = if body_slice.is_empty()
                        {
                            // To enable JSON parsing to succeed, replace an empty body
                            // with an empty JSON body. If a member was required, it will fail slightly later
                            // during the operation construction phase.
                            serde_json::from_slice(b"{}")
                                .map_err(crate::error::DeleteStageError::unhandled)?
                        } else {
                            serde_json::from_slice(response.body().as_ref())
                                .map_err(crate::error::DeleteStageError::unhandled)?
                        };

                        output = output.set_message(parsed_body.message);
                        output.build()
                    }),
                },
                _ => crate::error::DeleteStageError::generic(generic),
            });
        }
        Ok({
            #[allow(unused_mut)]
            let mut output = crate::output::delete_stage_output::Builder::default();
            let _ = response;
            output.build()
        })
    }
    pub fn parse_response(
        &self,
        response: &http::response::Response<impl AsRef<[u8]>>,
    ) -> Result<crate::output::DeleteStageOutput, crate::error::DeleteStageError> {
        Self::from_response(&response)
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}

impl smithy_http::response::ParseStrictResponse for DeleteStage {
    type Output = Result<crate::output::DeleteStageOutput, crate::error::DeleteStageError>;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        self.parse_response(response)
    }
}

/// <p>Deletes a usage plan of a given plan Id.</p>
#[derive(std::clone::Clone)]
pub struct DeleteUsagePlan {
    _private: (),
}
impl DeleteUsagePlan {
    /// Creates a new builder-style object to manufacture [`DeleteUsagePlanInput`](crate::input::DeleteUsagePlanInput)
    pub fn builder() -> crate::input::delete_usage_plan_input::Builder {
        crate::input::delete_usage_plan_input::Builder::default()
    }
    #[allow(clippy::unnecessary_wraps)]
    fn from_response(
        response: &http::response::Response<impl AsRef<[u8]>>,
    ) -> Result<crate::output::DeleteUsagePlanOutput, crate::error::DeleteUsagePlanError> {
        if crate::aws_json_errors::is_error(&response) && response.status().as_u16() != 202 {
            let body = serde_json::from_slice(response.body().as_ref())
                .unwrap_or_else(|_| serde_json::json!({}));
            let generic = crate::aws_json_errors::parse_generic_error(&response, &body);

            let error_code = match generic.code() {
                Some(code) => code,
                None => return Err(crate::error::DeleteUsagePlanError::unhandled(generic)),
            };
            return Err(match error_code {
                "BadRequestException" => crate::error::DeleteUsagePlanError {
                    meta: generic,
                    kind: crate::error::DeleteUsagePlanErrorKind::BadRequestError({
                        #[allow(unused_mut)]
                        let mut output = crate::error::bad_request_error::Builder::default();
                        let _ = response;

                        let body_slice = response.body().as_ref();

                        let parsed_body: crate::error::BadRequestError = if body_slice.is_empty() {
                            // To enable JSON parsing to succeed, replace an empty body
                            // with an empty JSON body. If a member was required, it will fail slightly later
                            // during the operation construction phase.
                            serde_json::from_slice(b"{}")
                                .map_err(crate::error::DeleteUsagePlanError::unhandled)?
                        } else {
                            serde_json::from_slice(response.body().as_ref())
                                .map_err(crate::error::DeleteUsagePlanError::unhandled)?
                        };

                        output = output.set_message(parsed_body.message);
                        output.build()
                    }),
                },
                "NotFoundException" => crate::error::DeleteUsagePlanError {
                    meta: generic,
                    kind: crate::error::DeleteUsagePlanErrorKind::NotFoundError({
                        #[allow(unused_mut)]
                        let mut output = crate::error::not_found_error::Builder::default();
                        let _ = response;

                        let body_slice = response.body().as_ref();

                        let parsed_body: crate::error::NotFoundError = if body_slice.is_empty() {
                            // To enable JSON parsing to succeed, replace an empty body
                            // with an empty JSON body. If a member was required, it will fail slightly later
                            // during the operation construction phase.
                            serde_json::from_slice(b"{}")
                                .map_err(crate::error::DeleteUsagePlanError::unhandled)?
                        } else {
                            serde_json::from_slice(response.body().as_ref())
                                .map_err(crate::error::DeleteUsagePlanError::unhandled)?
                        };

                        output = output.set_message(parsed_body.message);
                        output.build()
                    }),
                },
                "TooManyRequestsException" => {
                    crate::error::DeleteUsagePlanError {
                        meta: generic,
                        kind: crate::error::DeleteUsagePlanErrorKind::TooManyRequestsError({
                            #[allow(unused_mut)]
                            let mut output =
                                crate::error::too_many_requests_error::Builder::default();
                            let _ = response;

                            let body_slice = response.body().as_ref();

                            let parsed_body: crate::error::TooManyRequestsError =
                                if body_slice.is_empty() {
                                    // To enable JSON parsing to succeed, replace an empty body
                                    // with an empty JSON body. If a member was required, it will fail slightly later
                                    // during the operation construction phase.
                                    serde_json::from_slice(b"{}")
                                        .map_err(crate::error::DeleteUsagePlanError::unhandled)?
                                } else {
                                    serde_json::from_slice(response.body().as_ref())
                                        .map_err(crate::error::DeleteUsagePlanError::unhandled)?
                                };

                            output = output.set_retry_after_seconds(
                        
                                                crate::http_serde::deser_header_delete_usage_plan_retry_after_seconds(response.headers())
                                                    .map_err(|_|crate::error::DeleteUsagePlanError::unhandled("Failed to parse retryAfterSeconds from header `Retry-After"))?
                                                
                    );
                            output = output.set_message(parsed_body.message);
                            output.build()
                        }),
                    }
                }
                "UnauthorizedException" => crate::error::DeleteUsagePlanError {
                    meta: generic,
                    kind: crate::error::DeleteUsagePlanErrorKind::UnauthorizedError({
                        #[allow(unused_mut)]
                        let mut output = crate::error::unauthorized_error::Builder::default();
                        let _ = response;

                        let body_slice = response.body().as_ref();

                        let parsed_body: crate::error::UnauthorizedError = if body_slice.is_empty()
                        {
                            // To enable JSON parsing to succeed, replace an empty body
                            // with an empty JSON body. If a member was required, it will fail slightly later
                            // during the operation construction phase.
                            serde_json::from_slice(b"{}")
                                .map_err(crate::error::DeleteUsagePlanError::unhandled)?
                        } else {
                            serde_json::from_slice(response.body().as_ref())
                                .map_err(crate::error::DeleteUsagePlanError::unhandled)?
                        };

                        output = output.set_message(parsed_body.message);
                        output.build()
                    }),
                },
                _ => crate::error::DeleteUsagePlanError::generic(generic),
            });
        }
        Ok({
            #[allow(unused_mut)]
            let mut output = crate::output::delete_usage_plan_output::Builder::default();
            let _ = response;
            output.build()
        })
    }
    pub fn parse_response(
        &self,
        response: &http::response::Response<impl AsRef<[u8]>>,
    ) -> Result<crate::output::DeleteUsagePlanOutput, crate::error::DeleteUsagePlanError> {
        Self::from_response(&response)
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}

impl smithy_http::response::ParseStrictResponse for DeleteUsagePlan {
    type Output = Result<crate::output::DeleteUsagePlanOutput, crate::error::DeleteUsagePlanError>;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        self.parse_response(response)
    }
}

/// <p>Deletes a usage plan key  and remove the underlying API key from the associated usage plan.</p>
#[derive(std::clone::Clone)]
pub struct DeleteUsagePlanKey {
    _private: (),
}
impl DeleteUsagePlanKey {
    /// Creates a new builder-style object to manufacture [`DeleteUsagePlanKeyInput`](crate::input::DeleteUsagePlanKeyInput)
    pub fn builder() -> crate::input::delete_usage_plan_key_input::Builder {
        crate::input::delete_usage_plan_key_input::Builder::default()
    }
    #[allow(clippy::unnecessary_wraps)]
    fn from_response(
        response: &http::response::Response<impl AsRef<[u8]>>,
    ) -> Result<crate::output::DeleteUsagePlanKeyOutput, crate::error::DeleteUsagePlanKeyError>
    {
        if crate::aws_json_errors::is_error(&response) && response.status().as_u16() != 202 {
            let body = serde_json::from_slice(response.body().as_ref())
                .unwrap_or_else(|_| serde_json::json!({}));
            let generic = crate::aws_json_errors::parse_generic_error(&response, &body);

            let error_code = match generic.code() {
                Some(code) => code,
                None => return Err(crate::error::DeleteUsagePlanKeyError::unhandled(generic)),
            };
            return Err(match error_code {
                "BadRequestException" => crate::error::DeleteUsagePlanKeyError {
                    meta: generic,
                    kind: crate::error::DeleteUsagePlanKeyErrorKind::BadRequestError({
                        #[allow(unused_mut)]
                        let mut output = crate::error::bad_request_error::Builder::default();
                        let _ = response;

                        let body_slice = response.body().as_ref();

                        let parsed_body: crate::error::BadRequestError = if body_slice.is_empty() {
                            // To enable JSON parsing to succeed, replace an empty body
                            // with an empty JSON body. If a member was required, it will fail slightly later
                            // during the operation construction phase.
                            serde_json::from_slice(b"{}")
                                .map_err(crate::error::DeleteUsagePlanKeyError::unhandled)?
                        } else {
                            serde_json::from_slice(response.body().as_ref())
                                .map_err(crate::error::DeleteUsagePlanKeyError::unhandled)?
                        };

                        output = output.set_message(parsed_body.message);
                        output.build()
                    }),
                },
                "ConflictException" => crate::error::DeleteUsagePlanKeyError {
                    meta: generic,
                    kind: crate::error::DeleteUsagePlanKeyErrorKind::ConflictError({
                        #[allow(unused_mut)]
                        let mut output = crate::error::conflict_error::Builder::default();
                        let _ = response;

                        let body_slice = response.body().as_ref();

                        let parsed_body: crate::error::ConflictError = if body_slice.is_empty() {
                            // To enable JSON parsing to succeed, replace an empty body
                            // with an empty JSON body. If a member was required, it will fail slightly later
                            // during the operation construction phase.
                            serde_json::from_slice(b"{}")
                                .map_err(crate::error::DeleteUsagePlanKeyError::unhandled)?
                        } else {
                            serde_json::from_slice(response.body().as_ref())
                                .map_err(crate::error::DeleteUsagePlanKeyError::unhandled)?
                        };

                        output = output.set_message(parsed_body.message);
                        output.build()
                    }),
                },
                "NotFoundException" => crate::error::DeleteUsagePlanKeyError {
                    meta: generic,
                    kind: crate::error::DeleteUsagePlanKeyErrorKind::NotFoundError({
                        #[allow(unused_mut)]
                        let mut output = crate::error::not_found_error::Builder::default();
                        let _ = response;

                        let body_slice = response.body().as_ref();

                        let parsed_body: crate::error::NotFoundError = if body_slice.is_empty() {
                            // To enable JSON parsing to succeed, replace an empty body
                            // with an empty JSON body. If a member was required, it will fail slightly later
                            // during the operation construction phase.
                            serde_json::from_slice(b"{}")
                                .map_err(crate::error::DeleteUsagePlanKeyError::unhandled)?
                        } else {
                            serde_json::from_slice(response.body().as_ref())
                                .map_err(crate::error::DeleteUsagePlanKeyError::unhandled)?
                        };

                        output = output.set_message(parsed_body.message);
                        output.build()
                    }),
                },
                "TooManyRequestsException" => crate::error::DeleteUsagePlanKeyError {
                    meta: generic,
                    kind: crate::error::DeleteUsagePlanKeyErrorKind::TooManyRequestsError({
                        #[allow(unused_mut)]
                        let mut output = crate::error::too_many_requests_error::Builder::default();
                        let _ = response;

                        let body_slice = response.body().as_ref();

                        let parsed_body: crate::error::TooManyRequestsError =
                            if body_slice.is_empty() {
                                // To enable JSON parsing to succeed, replace an empty body
                                // with an empty JSON body. If a member was required, it will fail slightly later
                                // during the operation construction phase.
                                serde_json::from_slice(b"{}")
                                    .map_err(crate::error::DeleteUsagePlanKeyError::unhandled)?
                            } else {
                                serde_json::from_slice(response.body().as_ref())
                                    .map_err(crate::error::DeleteUsagePlanKeyError::unhandled)?
                            };

                        output = output.set_retry_after_seconds(
                        
                                                crate::http_serde::deser_header_delete_usage_plan_key_retry_after_seconds(response.headers())
                                                    .map_err(|_|crate::error::DeleteUsagePlanKeyError::unhandled("Failed to parse retryAfterSeconds from header `Retry-After"))?
                                                
                    );
                        output = output.set_message(parsed_body.message);
                        output.build()
                    }),
                },
                "UnauthorizedException" => crate::error::DeleteUsagePlanKeyError {
                    meta: generic,
                    kind: crate::error::DeleteUsagePlanKeyErrorKind::UnauthorizedError({
                        #[allow(unused_mut)]
                        let mut output = crate::error::unauthorized_error::Builder::default();
                        let _ = response;

                        let body_slice = response.body().as_ref();

                        let parsed_body: crate::error::UnauthorizedError = if body_slice.is_empty()
                        {
                            // To enable JSON parsing to succeed, replace an empty body
                            // with an empty JSON body. If a member was required, it will fail slightly later
                            // during the operation construction phase.
                            serde_json::from_slice(b"{}")
                                .map_err(crate::error::DeleteUsagePlanKeyError::unhandled)?
                        } else {
                            serde_json::from_slice(response.body().as_ref())
                                .map_err(crate::error::DeleteUsagePlanKeyError::unhandled)?
                        };

                        output = output.set_message(parsed_body.message);
                        output.build()
                    }),
                },
                _ => crate::error::DeleteUsagePlanKeyError::generic(generic),
            });
        }
        Ok({
            #[allow(unused_mut)]
            let mut output = crate::output::delete_usage_plan_key_output::Builder::default();
            let _ = response;
            output.build()
        })
    }
    pub fn parse_response(
        &self,
        response: &http::response::Response<impl AsRef<[u8]>>,
    ) -> Result<crate::output::DeleteUsagePlanKeyOutput, crate::error::DeleteUsagePlanKeyError>
    {
        Self::from_response(&response)
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}

impl smithy_http::response::ParseStrictResponse for DeleteUsagePlanKey {
    type Output =
        Result<crate::output::DeleteUsagePlanKeyOutput, crate::error::DeleteUsagePlanKeyError>;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        self.parse_response(response)
    }
}

/// <p>Deletes an existing <a>VpcLink</a> of a specified identifier.</p>
#[derive(std::clone::Clone)]
pub struct DeleteVpcLink {
    _private: (),
}
impl DeleteVpcLink {
    /// Creates a new builder-style object to manufacture [`DeleteVpcLinkInput`](crate::input::DeleteVpcLinkInput)
    pub fn builder() -> crate::input::delete_vpc_link_input::Builder {
        crate::input::delete_vpc_link_input::Builder::default()
    }
    #[allow(clippy::unnecessary_wraps)]
    fn from_response(
        response: &http::response::Response<impl AsRef<[u8]>>,
    ) -> Result<crate::output::DeleteVpcLinkOutput, crate::error::DeleteVpcLinkError> {
        if crate::aws_json_errors::is_error(&response) && response.status().as_u16() != 202 {
            let body = serde_json::from_slice(response.body().as_ref())
                .unwrap_or_else(|_| serde_json::json!({}));
            let generic = crate::aws_json_errors::parse_generic_error(&response, &body);

            let error_code = match generic.code() {
                Some(code) => code,
                None => return Err(crate::error::DeleteVpcLinkError::unhandled(generic)),
            };
            return Err(match error_code {
                "BadRequestException" => crate::error::DeleteVpcLinkError {
                    meta: generic,
                    kind: crate::error::DeleteVpcLinkErrorKind::BadRequestError({
                        #[allow(unused_mut)]
                        let mut output = crate::error::bad_request_error::Builder::default();
                        let _ = response;

                        let body_slice = response.body().as_ref();

                        let parsed_body: crate::error::BadRequestError = if body_slice.is_empty() {
                            // To enable JSON parsing to succeed, replace an empty body
                            // with an empty JSON body. If a member was required, it will fail slightly later
                            // during the operation construction phase.
                            serde_json::from_slice(b"{}")
                                .map_err(crate::error::DeleteVpcLinkError::unhandled)?
                        } else {
                            serde_json::from_slice(response.body().as_ref())
                                .map_err(crate::error::DeleteVpcLinkError::unhandled)?
                        };

                        output = output.set_message(parsed_body.message);
                        output.build()
                    }),
                },
                "NotFoundException" => crate::error::DeleteVpcLinkError {
                    meta: generic,
                    kind: crate::error::DeleteVpcLinkErrorKind::NotFoundError({
                        #[allow(unused_mut)]
                        let mut output = crate::error::not_found_error::Builder::default();
                        let _ = response;

                        let body_slice = response.body().as_ref();

                        let parsed_body: crate::error::NotFoundError = if body_slice.is_empty() {
                            // To enable JSON parsing to succeed, replace an empty body
                            // with an empty JSON body. If a member was required, it will fail slightly later
                            // during the operation construction phase.
                            serde_json::from_slice(b"{}")
                                .map_err(crate::error::DeleteVpcLinkError::unhandled)?
                        } else {
                            serde_json::from_slice(response.body().as_ref())
                                .map_err(crate::error::DeleteVpcLinkError::unhandled)?
                        };

                        output = output.set_message(parsed_body.message);
                        output.build()
                    }),
                },
                "TooManyRequestsException" => {
                    crate::error::DeleteVpcLinkError {
                        meta: generic,
                        kind: crate::error::DeleteVpcLinkErrorKind::TooManyRequestsError({
                            #[allow(unused_mut)]
                            let mut output =
                                crate::error::too_many_requests_error::Builder::default();
                            let _ = response;

                            let body_slice = response.body().as_ref();

                            let parsed_body: crate::error::TooManyRequestsError =
                                if body_slice.is_empty() {
                                    // To enable JSON parsing to succeed, replace an empty body
                                    // with an empty JSON body. If a member was required, it will fail slightly later
                                    // during the operation construction phase.
                                    serde_json::from_slice(b"{}")
                                        .map_err(crate::error::DeleteVpcLinkError::unhandled)?
                                } else {
                                    serde_json::from_slice(response.body().as_ref())
                                        .map_err(crate::error::DeleteVpcLinkError::unhandled)?
                                };

                            output = output.set_retry_after_seconds(
                        
                                                crate::http_serde::deser_header_delete_vpc_link_retry_after_seconds(response.headers())
                                                    .map_err(|_|crate::error::DeleteVpcLinkError::unhandled("Failed to parse retryAfterSeconds from header `Retry-After"))?
                                                
                    );
                            output = output.set_message(parsed_body.message);
                            output.build()
                        }),
                    }
                }
                "UnauthorizedException" => crate::error::DeleteVpcLinkError {
                    meta: generic,
                    kind: crate::error::DeleteVpcLinkErrorKind::UnauthorizedError({
                        #[allow(unused_mut)]
                        let mut output = crate::error::unauthorized_error::Builder::default();
                        let _ = response;

                        let body_slice = response.body().as_ref();

                        let parsed_body: crate::error::UnauthorizedError = if body_slice.is_empty()
                        {
                            // To enable JSON parsing to succeed, replace an empty body
                            // with an empty JSON body. If a member was required, it will fail slightly later
                            // during the operation construction phase.
                            serde_json::from_slice(b"{}")
                                .map_err(crate::error::DeleteVpcLinkError::unhandled)?
                        } else {
                            serde_json::from_slice(response.body().as_ref())
                                .map_err(crate::error::DeleteVpcLinkError::unhandled)?
                        };

                        output = output.set_message(parsed_body.message);
                        output.build()
                    }),
                },
                _ => crate::error::DeleteVpcLinkError::generic(generic),
            });
        }
        Ok({
            #[allow(unused_mut)]
            let mut output = crate::output::delete_vpc_link_output::Builder::default();
            let _ = response;
            output.build()
        })
    }
    pub fn parse_response(
        &self,
        response: &http::response::Response<impl AsRef<[u8]>>,
    ) -> Result<crate::output::DeleteVpcLinkOutput, crate::error::DeleteVpcLinkError> {
        Self::from_response(&response)
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}

impl smithy_http::response::ParseStrictResponse for DeleteVpcLink {
    type Output = Result<crate::output::DeleteVpcLinkOutput, crate::error::DeleteVpcLinkError>;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        self.parse_response(response)
    }
}

/// <p>Flushes all authorizer cache entries on a stage.</p>
#[derive(std::clone::Clone)]
pub struct FlushStageAuthorizersCache {
    _private: (),
}
impl FlushStageAuthorizersCache {
    /// Creates a new builder-style object to manufacture [`FlushStageAuthorizersCacheInput`](crate::input::FlushStageAuthorizersCacheInput)
    pub fn builder() -> crate::input::flush_stage_authorizers_cache_input::Builder {
        crate::input::flush_stage_authorizers_cache_input::Builder::default()
    }
    #[allow(clippy::unnecessary_wraps)]
    fn from_response(
        response: &http::response::Response<impl AsRef<[u8]>>,
    ) -> Result<
        crate::output::FlushStageAuthorizersCacheOutput,
        crate::error::FlushStageAuthorizersCacheError,
    > {
        if crate::aws_json_errors::is_error(&response) && response.status().as_u16() != 202 {
            let body = serde_json::from_slice(response.body().as_ref())
                .unwrap_or_else(|_| serde_json::json!({}));
            let generic = crate::aws_json_errors::parse_generic_error(&response, &body);

            let error_code = match generic.code() {
                Some(code) => code,
                None => {
                    return Err(crate::error::FlushStageAuthorizersCacheError::unhandled(
                        generic,
                    ))
                }
            };
            return Err(match error_code {
                "BadRequestException" => crate::error::FlushStageAuthorizersCacheError {
                    meta: generic,
                    kind: crate::error::FlushStageAuthorizersCacheErrorKind::BadRequestError({
                        #[allow(unused_mut)]
                        let mut output = crate::error::bad_request_error::Builder::default();
                        let _ = response;

                        let body_slice = response.body().as_ref();

                        let parsed_body: crate::error::BadRequestError = if body_slice.is_empty() {
                            // To enable JSON parsing to succeed, replace an empty body
                            // with an empty JSON body. If a member was required, it will fail slightly later
                            // during the operation construction phase.
                            serde_json::from_slice(b"{}")
                                .map_err(crate::error::FlushStageAuthorizersCacheError::unhandled)?
                        } else {
                            serde_json::from_slice(response.body().as_ref())
                                .map_err(crate::error::FlushStageAuthorizersCacheError::unhandled)?
                        };

                        output = output.set_message(parsed_body.message);
                        output.build()
                    }),
                },
                "NotFoundException" => crate::error::FlushStageAuthorizersCacheError {
                    meta: generic,
                    kind: crate::error::FlushStageAuthorizersCacheErrorKind::NotFoundError({
                        #[allow(unused_mut)]
                        let mut output = crate::error::not_found_error::Builder::default();
                        let _ = response;

                        let body_slice = response.body().as_ref();

                        let parsed_body: crate::error::NotFoundError = if body_slice.is_empty() {
                            // To enable JSON parsing to succeed, replace an empty body
                            // with an empty JSON body. If a member was required, it will fail slightly later
                            // during the operation construction phase.
                            serde_json::from_slice(b"{}")
                                .map_err(crate::error::FlushStageAuthorizersCacheError::unhandled)?
                        } else {
                            serde_json::from_slice(response.body().as_ref())
                                .map_err(crate::error::FlushStageAuthorizersCacheError::unhandled)?
                        };

                        output = output.set_message(parsed_body.message);
                        output.build()
                    }),
                },
                "TooManyRequestsException" => {
                    crate::error::FlushStageAuthorizersCacheError {
                        meta: generic,
                        kind:
                            crate::error::FlushStageAuthorizersCacheErrorKind::TooManyRequestsError(
                                {
                                    #[allow(unused_mut)]
                                    let mut output =
                                        crate::error::too_many_requests_error::Builder::default();
                                    let _ = response;

                                    let body_slice = response.body().as_ref();

                                    let parsed_body: crate::error::TooManyRequestsError =
                                        if body_slice.is_empty() {
                                            // To enable JSON parsing to succeed, replace an empty body
                                            // with an empty JSON body. If a member was required, it will fail slightly later
                                            // during the operation construction phase.
                                            serde_json::from_slice(b"{}").map_err(crate::error::FlushStageAuthorizersCacheError::unhandled)?
                                        } else {
                                            serde_json::from_slice(response.body().as_ref()).map_err(crate::error::FlushStageAuthorizersCacheError::unhandled)?
                                        };

                                    output = output.set_retry_after_seconds(
                        
                                                crate::http_serde::deser_header_flush_stage_authorizers_cache_retry_after_seconds(response.headers())
                                                    .map_err(|_|crate::error::FlushStageAuthorizersCacheError::unhandled("Failed to parse retryAfterSeconds from header `Retry-After"))?
                                                
                    );
                                    output = output.set_message(parsed_body.message);
                                    output.build()
                                },
                            ),
                    }
                }
                "UnauthorizedException" => crate::error::FlushStageAuthorizersCacheError {
                    meta: generic,
                    kind: crate::error::FlushStageAuthorizersCacheErrorKind::UnauthorizedError({
                        #[allow(unused_mut)]
                        let mut output = crate::error::unauthorized_error::Builder::default();
                        let _ = response;

                        let body_slice = response.body().as_ref();

                        let parsed_body: crate::error::UnauthorizedError = if body_slice.is_empty()
                        {
                            // To enable JSON parsing to succeed, replace an empty body
                            // with an empty JSON body. If a member was required, it will fail slightly later
                            // during the operation construction phase.
                            serde_json::from_slice(b"{}")
                                .map_err(crate::error::FlushStageAuthorizersCacheError::unhandled)?
                        } else {
                            serde_json::from_slice(response.body().as_ref())
                                .map_err(crate::error::FlushStageAuthorizersCacheError::unhandled)?
                        };

                        output = output.set_message(parsed_body.message);
                        output.build()
                    }),
                },
                _ => crate::error::FlushStageAuthorizersCacheError::generic(generic),
            });
        }
        Ok({
            #[allow(unused_mut)]
            let mut output =
                crate::output::flush_stage_authorizers_cache_output::Builder::default();
            let _ = response;
            output.build()
        })
    }
    pub fn parse_response(
        &self,
        response: &http::response::Response<impl AsRef<[u8]>>,
    ) -> Result<
        crate::output::FlushStageAuthorizersCacheOutput,
        crate::error::FlushStageAuthorizersCacheError,
    > {
        Self::from_response(&response)
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}

impl smithy_http::response::ParseStrictResponse for FlushStageAuthorizersCache {
    type Output = Result<
        crate::output::FlushStageAuthorizersCacheOutput,
        crate::error::FlushStageAuthorizersCacheError,
    >;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        self.parse_response(response)
    }
}

/// <p>Flushes a stage's cache.</p>
#[derive(std::clone::Clone)]
pub struct FlushStageCache {
    _private: (),
}
impl FlushStageCache {
    /// Creates a new builder-style object to manufacture [`FlushStageCacheInput`](crate::input::FlushStageCacheInput)
    pub fn builder() -> crate::input::flush_stage_cache_input::Builder {
        crate::input::flush_stage_cache_input::Builder::default()
    }
    #[allow(clippy::unnecessary_wraps)]
    fn from_response(
        response: &http::response::Response<impl AsRef<[u8]>>,
    ) -> Result<crate::output::FlushStageCacheOutput, crate::error::FlushStageCacheError> {
        if crate::aws_json_errors::is_error(&response) && response.status().as_u16() != 202 {
            let body = serde_json::from_slice(response.body().as_ref())
                .unwrap_or_else(|_| serde_json::json!({}));
            let generic = crate::aws_json_errors::parse_generic_error(&response, &body);

            let error_code = match generic.code() {
                Some(code) => code,
                None => return Err(crate::error::FlushStageCacheError::unhandled(generic)),
            };
            return Err(match error_code {
                "BadRequestException" => crate::error::FlushStageCacheError {
                    meta: generic,
                    kind: crate::error::FlushStageCacheErrorKind::BadRequestError({
                        #[allow(unused_mut)]
                        let mut output = crate::error::bad_request_error::Builder::default();
                        let _ = response;

                        let body_slice = response.body().as_ref();

                        let parsed_body: crate::error::BadRequestError = if body_slice.is_empty() {
                            // To enable JSON parsing to succeed, replace an empty body
                            // with an empty JSON body. If a member was required, it will fail slightly later
                            // during the operation construction phase.
                            serde_json::from_slice(b"{}")
                                .map_err(crate::error::FlushStageCacheError::unhandled)?
                        } else {
                            serde_json::from_slice(response.body().as_ref())
                                .map_err(crate::error::FlushStageCacheError::unhandled)?
                        };

                        output = output.set_message(parsed_body.message);
                        output.build()
                    }),
                },
                "NotFoundException" => crate::error::FlushStageCacheError {
                    meta: generic,
                    kind: crate::error::FlushStageCacheErrorKind::NotFoundError({
                        #[allow(unused_mut)]
                        let mut output = crate::error::not_found_error::Builder::default();
                        let _ = response;

                        let body_slice = response.body().as_ref();

                        let parsed_body: crate::error::NotFoundError = if body_slice.is_empty() {
                            // To enable JSON parsing to succeed, replace an empty body
                            // with an empty JSON body. If a member was required, it will fail slightly later
                            // during the operation construction phase.
                            serde_json::from_slice(b"{}")
                                .map_err(crate::error::FlushStageCacheError::unhandled)?
                        } else {
                            serde_json::from_slice(response.body().as_ref())
                                .map_err(crate::error::FlushStageCacheError::unhandled)?
                        };

                        output = output.set_message(parsed_body.message);
                        output.build()
                    }),
                },
                "TooManyRequestsException" => {
                    crate::error::FlushStageCacheError {
                        meta: generic,
                        kind: crate::error::FlushStageCacheErrorKind::TooManyRequestsError({
                            #[allow(unused_mut)]
                            let mut output =
                                crate::error::too_many_requests_error::Builder::default();
                            let _ = response;

                            let body_slice = response.body().as_ref();

                            let parsed_body: crate::error::TooManyRequestsError =
                                if body_slice.is_empty() {
                                    // To enable JSON parsing to succeed, replace an empty body
                                    // with an empty JSON body. If a member was required, it will fail slightly later
                                    // during the operation construction phase.
                                    serde_json::from_slice(b"{}")
                                        .map_err(crate::error::FlushStageCacheError::unhandled)?
                                } else {
                                    serde_json::from_slice(response.body().as_ref())
                                        .map_err(crate::error::FlushStageCacheError::unhandled)?
                                };

                            output = output.set_retry_after_seconds(
                        
                                                crate::http_serde::deser_header_flush_stage_cache_retry_after_seconds(response.headers())
                                                    .map_err(|_|crate::error::FlushStageCacheError::unhandled("Failed to parse retryAfterSeconds from header `Retry-After"))?
                                                
                    );
                            output = output.set_message(parsed_body.message);
                            output.build()
                        }),
                    }
                }
                "UnauthorizedException" => crate::error::FlushStageCacheError {
                    meta: generic,
                    kind: crate::error::FlushStageCacheErrorKind::UnauthorizedError({
                        #[allow(unused_mut)]
                        let mut output = crate::error::unauthorized_error::Builder::default();
                        let _ = response;

                        let body_slice = response.body().as_ref();

                        let parsed_body: crate::error::UnauthorizedError = if body_slice.is_empty()
                        {
                            // To enable JSON parsing to succeed, replace an empty body
                            // with an empty JSON body. If a member was required, it will fail slightly later
                            // during the operation construction phase.
                            serde_json::from_slice(b"{}")
                                .map_err(crate::error::FlushStageCacheError::unhandled)?
                        } else {
                            serde_json::from_slice(response.body().as_ref())
                                .map_err(crate::error::FlushStageCacheError::unhandled)?
                        };

                        output = output.set_message(parsed_body.message);
                        output.build()
                    }),
                },
                _ => crate::error::FlushStageCacheError::generic(generic),
            });
        }
        Ok({
            #[allow(unused_mut)]
            let mut output = crate::output::flush_stage_cache_output::Builder::default();
            let _ = response;
            output.build()
        })
    }
    pub fn parse_response(
        &self,
        response: &http::response::Response<impl AsRef<[u8]>>,
    ) -> Result<crate::output::FlushStageCacheOutput, crate::error::FlushStageCacheError> {
        Self::from_response(&response)
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}

impl smithy_http::response::ParseStrictResponse for FlushStageCache {
    type Output = Result<crate::output::FlushStageCacheOutput, crate::error::FlushStageCacheError>;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        self.parse_response(response)
    }
}

/// <p>Generates a <a>ClientCertificate</a> resource.</p>
#[derive(std::clone::Clone)]
pub struct GenerateClientCertificate {
    _private: (),
}
impl GenerateClientCertificate {
    /// Creates a new builder-style object to manufacture [`GenerateClientCertificateInput`](crate::input::GenerateClientCertificateInput)
    pub fn builder() -> crate::input::generate_client_certificate_input::Builder {
        crate::input::generate_client_certificate_input::Builder::default()
    }
    #[allow(clippy::unnecessary_wraps)]
    fn from_response(
        response: &http::response::Response<impl AsRef<[u8]>>,
    ) -> Result<
        crate::output::GenerateClientCertificateOutput,
        crate::error::GenerateClientCertificateError,
    > {
        if crate::aws_json_errors::is_error(&response) && response.status().as_u16() != 201 {
            let body = serde_json::from_slice(response.body().as_ref())
                .unwrap_or_else(|_| serde_json::json!({}));
            let generic = crate::aws_json_errors::parse_generic_error(&response, &body);

            let error_code = match generic.code() {
                Some(code) => code,
                None => {
                    return Err(crate::error::GenerateClientCertificateError::unhandled(
                        generic,
                    ))
                }
            };
            return Err(match error_code {
                "LimitExceededException" => crate::error::GenerateClientCertificateError {
                    meta: generic,
                    kind: crate::error::GenerateClientCertificateErrorKind::LimitExceededError({
                        #[allow(unused_mut)]
                        let mut output = crate::error::limit_exceeded_error::Builder::default();
                        let _ = response;

                        let body_slice = response.body().as_ref();

                        let parsed_body: crate::error::LimitExceededError = if body_slice.is_empty()
                        {
                            // To enable JSON parsing to succeed, replace an empty body
                            // with an empty JSON body. If a member was required, it will fail slightly later
                            // during the operation construction phase.
                            serde_json::from_slice(b"{}")
                                .map_err(crate::error::GenerateClientCertificateError::unhandled)?
                        } else {
                            serde_json::from_slice(response.body().as_ref())
                                .map_err(crate::error::GenerateClientCertificateError::unhandled)?
                        };

                        output = output.set_retry_after_seconds(
                        
                                                crate::http_serde::deser_header_generate_client_certificate_retry_after_seconds(response.headers())
                                                    .map_err(|_|crate::error::GenerateClientCertificateError::unhandled("Failed to parse retryAfterSeconds from header `Retry-After"))?
                                                
                    );
                        output = output.set_message(parsed_body.message);
                        output.build()
                    }),
                },
                "TooManyRequestsException" => crate::error::GenerateClientCertificateError {
                    meta: generic,
                    kind: crate::error::GenerateClientCertificateErrorKind::TooManyRequestsError({
                        #[allow(unused_mut)]
                        let mut output = crate::error::too_many_requests_error::Builder::default();
                        let _ = response;

                        let body_slice = response.body().as_ref();

                        let parsed_body: crate::error::TooManyRequestsError = if body_slice
                            .is_empty()
                        {
                            // To enable JSON parsing to succeed, replace an empty body
                            // with an empty JSON body. If a member was required, it will fail slightly later
                            // during the operation construction phase.
                            serde_json::from_slice(b"{}")
                                .map_err(crate::error::GenerateClientCertificateError::unhandled)?
                        } else {
                            serde_json::from_slice(response.body().as_ref())
                                .map_err(crate::error::GenerateClientCertificateError::unhandled)?
                        };

                        output = output.set_retry_after_seconds(
                        
                                                crate::http_serde::deser_header_generate_client_certificate_retry_after_seconds(response.headers())
                                                    .map_err(|_|crate::error::GenerateClientCertificateError::unhandled("Failed to parse retryAfterSeconds from header `Retry-After"))?
                                                
                    );
                        output = output.set_message(parsed_body.message);
                        output.build()
                    }),
                },
                "UnauthorizedException" => crate::error::GenerateClientCertificateError {
                    meta: generic,
                    kind: crate::error::GenerateClientCertificateErrorKind::UnauthorizedError({
                        #[allow(unused_mut)]
                        let mut output = crate::error::unauthorized_error::Builder::default();
                        let _ = response;

                        let body_slice = response.body().as_ref();

                        let parsed_body: crate::error::UnauthorizedError = if body_slice.is_empty()
                        {
                            // To enable JSON parsing to succeed, replace an empty body
                            // with an empty JSON body. If a member was required, it will fail slightly later
                            // during the operation construction phase.
                            serde_json::from_slice(b"{}")
                                .map_err(crate::error::GenerateClientCertificateError::unhandled)?
                        } else {
                            serde_json::from_slice(response.body().as_ref())
                                .map_err(crate::error::GenerateClientCertificateError::unhandled)?
                        };

                        output = output.set_message(parsed_body.message);
                        output.build()
                    }),
                },
                _ => crate::error::GenerateClientCertificateError::generic(generic),
            });
        }
        Ok({
            #[allow(unused_mut)]
            let mut output = crate::output::generate_client_certificate_output::Builder::default();
            let _ = response;

            let body_slice = response.body().as_ref();

            let parsed_body: crate::serializer::GenerateClientCertificateOutputBody =
                if body_slice.is_empty() {
                    // To enable JSON parsing to succeed, replace an empty body
                    // with an empty JSON body. If a member was required, it will fail slightly later
                    // during the operation construction phase.
                    serde_json::from_slice(b"{}")
                        .map_err(crate::error::GenerateClientCertificateError::unhandled)?
                } else {
                    serde_json::from_slice(response.body().as_ref())
                        .map_err(crate::error::GenerateClientCertificateError::unhandled)?
                };

            output = output.set_client_certificate_id(parsed_body.client_certificate_id);
            output = output.set_description(parsed_body.description);
            output = output.set_pem_encoded_certificate(parsed_body.pem_encoded_certificate);
            output = output.set_created_date(parsed_body.created_date);
            output = output.set_expiration_date(parsed_body.expiration_date);
            output = output.set_tags(parsed_body.tags);
            output.build()
        })
    }
    pub fn parse_response(
        &self,
        response: &http::response::Response<impl AsRef<[u8]>>,
    ) -> Result<
        crate::output::GenerateClientCertificateOutput,
        crate::error::GenerateClientCertificateError,
    > {
        Self::from_response(&response)
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}

impl smithy_http::response::ParseStrictResponse for GenerateClientCertificate {
    type Output = Result<
        crate::output::GenerateClientCertificateOutput,
        crate::error::GenerateClientCertificateError,
    >;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        self.parse_response(response)
    }
}

/// <p>Gets information about the current <a>Account</a> resource.</p>
#[derive(std::clone::Clone)]
pub struct GetAccount {
    _private: (),
}
impl GetAccount {
    /// Creates a new builder-style object to manufacture [`GetAccountInput`](crate::input::GetAccountInput)
    pub fn builder() -> crate::input::get_account_input::Builder {
        crate::input::get_account_input::Builder::default()
    }
    #[allow(clippy::unnecessary_wraps)]
    fn from_response(
        response: &http::response::Response<impl AsRef<[u8]>>,
    ) -> Result<crate::output::GetAccountOutput, crate::error::GetAccountError> {
        if crate::aws_json_errors::is_error(&response) && response.status().as_u16() != 200 {
            let body = serde_json::from_slice(response.body().as_ref())
                .unwrap_or_else(|_| serde_json::json!({}));
            let generic = crate::aws_json_errors::parse_generic_error(&response, &body);

            let error_code = match generic.code() {
                Some(code) => code,
                None => return Err(crate::error::GetAccountError::unhandled(generic)),
            };
            return Err(match error_code {
                "NotFoundException" => crate::error::GetAccountError {
                    meta: generic,
                    kind: crate::error::GetAccountErrorKind::NotFoundError({
                        #[allow(unused_mut)]
                        let mut output = crate::error::not_found_error::Builder::default();
                        let _ = response;

                        let body_slice = response.body().as_ref();

                        let parsed_body: crate::error::NotFoundError = if body_slice.is_empty() {
                            // To enable JSON parsing to succeed, replace an empty body
                            // with an empty JSON body. If a member was required, it will fail slightly later
                            // during the operation construction phase.
                            serde_json::from_slice(b"{}")
                                .map_err(crate::error::GetAccountError::unhandled)?
                        } else {
                            serde_json::from_slice(response.body().as_ref())
                                .map_err(crate::error::GetAccountError::unhandled)?
                        };

                        output = output.set_message(parsed_body.message);
                        output.build()
                    }),
                },
                "TooManyRequestsException" => {
                    crate::error::GetAccountError {
                        meta: generic,
                        kind: crate::error::GetAccountErrorKind::TooManyRequestsError({
                            #[allow(unused_mut)]
                            let mut output =
                                crate::error::too_many_requests_error::Builder::default();
                            let _ = response;

                            let body_slice = response.body().as_ref();

                            let parsed_body: crate::error::TooManyRequestsError =
                                if body_slice.is_empty() {
                                    // To enable JSON parsing to succeed, replace an empty body
                                    // with an empty JSON body. If a member was required, it will fail slightly later
                                    // during the operation construction phase.
                                    serde_json::from_slice(b"{}")
                                        .map_err(crate::error::GetAccountError::unhandled)?
                                } else {
                                    serde_json::from_slice(response.body().as_ref())
                                        .map_err(crate::error::GetAccountError::unhandled)?
                                };

                            output = output.set_retry_after_seconds(
                        
                                                crate::http_serde::deser_header_get_account_retry_after_seconds(response.headers())
                                                    .map_err(|_|crate::error::GetAccountError::unhandled("Failed to parse retryAfterSeconds from header `Retry-After"))?
                                                
                    );
                            output = output.set_message(parsed_body.message);
                            output.build()
                        }),
                    }
                }
                "UnauthorizedException" => crate::error::GetAccountError {
                    meta: generic,
                    kind: crate::error::GetAccountErrorKind::UnauthorizedError({
                        #[allow(unused_mut)]
                        let mut output = crate::error::unauthorized_error::Builder::default();
                        let _ = response;

                        let body_slice = response.body().as_ref();

                        let parsed_body: crate::error::UnauthorizedError = if body_slice.is_empty()
                        {
                            // To enable JSON parsing to succeed, replace an empty body
                            // with an empty JSON body. If a member was required, it will fail slightly later
                            // during the operation construction phase.
                            serde_json::from_slice(b"{}")
                                .map_err(crate::error::GetAccountError::unhandled)?
                        } else {
                            serde_json::from_slice(response.body().as_ref())
                                .map_err(crate::error::GetAccountError::unhandled)?
                        };

                        output = output.set_message(parsed_body.message);
                        output.build()
                    }),
                },
                _ => crate::error::GetAccountError::generic(generic),
            });
        }
        Ok({
            #[allow(unused_mut)]
            let mut output = crate::output::get_account_output::Builder::default();
            let _ = response;

            let body_slice = response.body().as_ref();

            let parsed_body: crate::serializer::GetAccountOutputBody = if body_slice.is_empty() {
                // To enable JSON parsing to succeed, replace an empty body
                // with an empty JSON body. If a member was required, it will fail slightly later
                // during the operation construction phase.
                serde_json::from_slice(b"{}").map_err(crate::error::GetAccountError::unhandled)?
            } else {
                serde_json::from_slice(response.body().as_ref())
                    .map_err(crate::error::GetAccountError::unhandled)?
            };

            output = output.set_cloudwatch_role_arn(parsed_body.cloudwatch_role_arn);
            output = output.set_throttle_settings(parsed_body.throttle_settings);
            output = output.set_features(parsed_body.features);
            output = output.set_api_key_version(parsed_body.api_key_version);
            output.build()
        })
    }
    pub fn parse_response(
        &self,
        response: &http::response::Response<impl AsRef<[u8]>>,
    ) -> Result<crate::output::GetAccountOutput, crate::error::GetAccountError> {
        Self::from_response(&response)
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}

impl smithy_http::response::ParseStrictResponse for GetAccount {
    type Output = Result<crate::output::GetAccountOutput, crate::error::GetAccountError>;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        self.parse_response(response)
    }
}

/// <p>Gets information about the current <a>ApiKey</a> resource.</p>
#[derive(std::clone::Clone)]
pub struct GetApiKey {
    _private: (),
}
impl GetApiKey {
    /// Creates a new builder-style object to manufacture [`GetApiKeyInput`](crate::input::GetApiKeyInput)
    pub fn builder() -> crate::input::get_api_key_input::Builder {
        crate::input::get_api_key_input::Builder::default()
    }
    #[allow(clippy::unnecessary_wraps)]
    fn from_response(
        response: &http::response::Response<impl AsRef<[u8]>>,
    ) -> Result<crate::output::GetApiKeyOutput, crate::error::GetApiKeyError> {
        if crate::aws_json_errors::is_error(&response) && response.status().as_u16() != 200 {
            let body = serde_json::from_slice(response.body().as_ref())
                .unwrap_or_else(|_| serde_json::json!({}));
            let generic = crate::aws_json_errors::parse_generic_error(&response, &body);

            let error_code = match generic.code() {
                Some(code) => code,
                None => return Err(crate::error::GetApiKeyError::unhandled(generic)),
            };
            return Err(match error_code {
                "NotFoundException" => crate::error::GetApiKeyError {
                    meta: generic,
                    kind: crate::error::GetApiKeyErrorKind::NotFoundError({
                        #[allow(unused_mut)]
                        let mut output = crate::error::not_found_error::Builder::default();
                        let _ = response;

                        let body_slice = response.body().as_ref();

                        let parsed_body: crate::error::NotFoundError = if body_slice.is_empty() {
                            // To enable JSON parsing to succeed, replace an empty body
                            // with an empty JSON body. If a member was required, it will fail slightly later
                            // during the operation construction phase.
                            serde_json::from_slice(b"{}")
                                .map_err(crate::error::GetApiKeyError::unhandled)?
                        } else {
                            serde_json::from_slice(response.body().as_ref())
                                .map_err(crate::error::GetApiKeyError::unhandled)?
                        };

                        output = output.set_message(parsed_body.message);
                        output.build()
                    }),
                },
                "TooManyRequestsException" => {
                    crate::error::GetApiKeyError {
                        meta: generic,
                        kind: crate::error::GetApiKeyErrorKind::TooManyRequestsError({
                            #[allow(unused_mut)]
                            let mut output =
                                crate::error::too_many_requests_error::Builder::default();
                            let _ = response;

                            let body_slice = response.body().as_ref();

                            let parsed_body: crate::error::TooManyRequestsError =
                                if body_slice.is_empty() {
                                    // To enable JSON parsing to succeed, replace an empty body
                                    // with an empty JSON body. If a member was required, it will fail slightly later
                                    // during the operation construction phase.
                                    serde_json::from_slice(b"{}")
                                        .map_err(crate::error::GetApiKeyError::unhandled)?
                                } else {
                                    serde_json::from_slice(response.body().as_ref())
                                        .map_err(crate::error::GetApiKeyError::unhandled)?
                                };

                            output = output.set_retry_after_seconds(
                        
                                                crate::http_serde::deser_header_get_api_key_retry_after_seconds(response.headers())
                                                    .map_err(|_|crate::error::GetApiKeyError::unhandled("Failed to parse retryAfterSeconds from header `Retry-After"))?
                                                
                    );
                            output = output.set_message(parsed_body.message);
                            output.build()
                        }),
                    }
                }
                "UnauthorizedException" => crate::error::GetApiKeyError {
                    meta: generic,
                    kind: crate::error::GetApiKeyErrorKind::UnauthorizedError({
                        #[allow(unused_mut)]
                        let mut output = crate::error::unauthorized_error::Builder::default();
                        let _ = response;

                        let body_slice = response.body().as_ref();

                        let parsed_body: crate::error::UnauthorizedError = if body_slice.is_empty()
                        {
                            // To enable JSON parsing to succeed, replace an empty body
                            // with an empty JSON body. If a member was required, it will fail slightly later
                            // during the operation construction phase.
                            serde_json::from_slice(b"{}")
                                .map_err(crate::error::GetApiKeyError::unhandled)?
                        } else {
                            serde_json::from_slice(response.body().as_ref())
                                .map_err(crate::error::GetApiKeyError::unhandled)?
                        };

                        output = output.set_message(parsed_body.message);
                        output.build()
                    }),
                },
                _ => crate::error::GetApiKeyError::generic(generic),
            });
        }
        Ok({
            #[allow(unused_mut)]
            let mut output = crate::output::get_api_key_output::Builder::default();
            let _ = response;

            let body_slice = response.body().as_ref();

            let parsed_body: crate::serializer::GetApiKeyOutputBody = if body_slice.is_empty() {
                // To enable JSON parsing to succeed, replace an empty body
                // with an empty JSON body. If a member was required, it will fail slightly later
                // during the operation construction phase.
                serde_json::from_slice(b"{}").map_err(crate::error::GetApiKeyError::unhandled)?
            } else {
                serde_json::from_slice(response.body().as_ref())
                    .map_err(crate::error::GetApiKeyError::unhandled)?
            };

            output = output.set_id(parsed_body.id);
            output = output.set_value(parsed_body.value);
            output = output.set_name(parsed_body.name);
            output = output.set_customer_id(parsed_body.customer_id);
            output = output.set_description(parsed_body.description);
            output = output.set_enabled(parsed_body.enabled);
            output = output.set_created_date(parsed_body.created_date);
            output = output.set_last_updated_date(parsed_body.last_updated_date);
            output = output.set_stage_keys(parsed_body.stage_keys);
            output = output.set_tags(parsed_body.tags);
            output.build()
        })
    }
    pub fn parse_response(
        &self,
        response: &http::response::Response<impl AsRef<[u8]>>,
    ) -> Result<crate::output::GetApiKeyOutput, crate::error::GetApiKeyError> {
        Self::from_response(&response)
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}

impl smithy_http::response::ParseStrictResponse for GetApiKey {
    type Output = Result<crate::output::GetApiKeyOutput, crate::error::GetApiKeyError>;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        self.parse_response(response)
    }
}

/// <p>Gets information about the current <a>ApiKeys</a> resource.</p>
#[derive(std::clone::Clone)]
pub struct GetApiKeys {
    _private: (),
}
impl GetApiKeys {
    /// Creates a new builder-style object to manufacture [`GetApiKeysInput`](crate::input::GetApiKeysInput)
    pub fn builder() -> crate::input::get_api_keys_input::Builder {
        crate::input::get_api_keys_input::Builder::default()
    }
    #[allow(clippy::unnecessary_wraps)]
    fn from_response(
        response: &http::response::Response<impl AsRef<[u8]>>,
    ) -> Result<crate::output::GetApiKeysOutput, crate::error::GetApiKeysError> {
        if crate::aws_json_errors::is_error(&response) && response.status().as_u16() != 200 {
            let body = serde_json::from_slice(response.body().as_ref())
                .unwrap_or_else(|_| serde_json::json!({}));
            let generic = crate::aws_json_errors::parse_generic_error(&response, &body);

            let error_code = match generic.code() {
                Some(code) => code,
                None => return Err(crate::error::GetApiKeysError::unhandled(generic)),
            };
            return Err(match error_code {
                "BadRequestException" => crate::error::GetApiKeysError {
                    meta: generic,
                    kind: crate::error::GetApiKeysErrorKind::BadRequestError({
                        #[allow(unused_mut)]
                        let mut output = crate::error::bad_request_error::Builder::default();
                        let _ = response;

                        let body_slice = response.body().as_ref();

                        let parsed_body: crate::error::BadRequestError = if body_slice.is_empty() {
                            // To enable JSON parsing to succeed, replace an empty body
                            // with an empty JSON body. If a member was required, it will fail slightly later
                            // during the operation construction phase.
                            serde_json::from_slice(b"{}")
                                .map_err(crate::error::GetApiKeysError::unhandled)?
                        } else {
                            serde_json::from_slice(response.body().as_ref())
                                .map_err(crate::error::GetApiKeysError::unhandled)?
                        };

                        output = output.set_message(parsed_body.message);
                        output.build()
                    }),
                },
                "TooManyRequestsException" => {
                    crate::error::GetApiKeysError {
                        meta: generic,
                        kind: crate::error::GetApiKeysErrorKind::TooManyRequestsError({
                            #[allow(unused_mut)]
                            let mut output =
                                crate::error::too_many_requests_error::Builder::default();
                            let _ = response;

                            let body_slice = response.body().as_ref();

                            let parsed_body: crate::error::TooManyRequestsError =
                                if body_slice.is_empty() {
                                    // To enable JSON parsing to succeed, replace an empty body
                                    // with an empty JSON body. If a member was required, it will fail slightly later
                                    // during the operation construction phase.
                                    serde_json::from_slice(b"{}")
                                        .map_err(crate::error::GetApiKeysError::unhandled)?
                                } else {
                                    serde_json::from_slice(response.body().as_ref())
                                        .map_err(crate::error::GetApiKeysError::unhandled)?
                                };

                            output = output.set_retry_after_seconds(
                        
                                                crate::http_serde::deser_header_get_api_keys_retry_after_seconds(response.headers())
                                                    .map_err(|_|crate::error::GetApiKeysError::unhandled("Failed to parse retryAfterSeconds from header `Retry-After"))?
                                                
                    );
                            output = output.set_message(parsed_body.message);
                            output.build()
                        }),
                    }
                }
                "UnauthorizedException" => crate::error::GetApiKeysError {
                    meta: generic,
                    kind: crate::error::GetApiKeysErrorKind::UnauthorizedError({
                        #[allow(unused_mut)]
                        let mut output = crate::error::unauthorized_error::Builder::default();
                        let _ = response;

                        let body_slice = response.body().as_ref();

                        let parsed_body: crate::error::UnauthorizedError = if body_slice.is_empty()
                        {
                            // To enable JSON parsing to succeed, replace an empty body
                            // with an empty JSON body. If a member was required, it will fail slightly later
                            // during the operation construction phase.
                            serde_json::from_slice(b"{}")
                                .map_err(crate::error::GetApiKeysError::unhandled)?
                        } else {
                            serde_json::from_slice(response.body().as_ref())
                                .map_err(crate::error::GetApiKeysError::unhandled)?
                        };

                        output = output.set_message(parsed_body.message);
                        output.build()
                    }),
                },
                _ => crate::error::GetApiKeysError::generic(generic),
            });
        }
        Ok({
            #[allow(unused_mut)]
            let mut output = crate::output::get_api_keys_output::Builder::default();
            let _ = response;

            let body_slice = response.body().as_ref();

            let parsed_body: crate::serializer::GetApiKeysOutputBody = if body_slice.is_empty() {
                // To enable JSON parsing to succeed, replace an empty body
                // with an empty JSON body. If a member was required, it will fail slightly later
                // during the operation construction phase.
                serde_json::from_slice(b"{}").map_err(crate::error::GetApiKeysError::unhandled)?
            } else {
                serde_json::from_slice(response.body().as_ref())
                    .map_err(crate::error::GetApiKeysError::unhandled)?
            };

            output = output.set_warnings(parsed_body.warnings);
            output = output.set_items(parsed_body.items);
            output = output.set_position(parsed_body.position);
            output.build()
        })
    }
    pub fn parse_response(
        &self,
        response: &http::response::Response<impl AsRef<[u8]>>,
    ) -> Result<crate::output::GetApiKeysOutput, crate::error::GetApiKeysError> {
        Self::from_response(&response)
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}

impl smithy_http::response::ParseStrictResponse for GetApiKeys {
    type Output = Result<crate::output::GetApiKeysOutput, crate::error::GetApiKeysError>;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        self.parse_response(response)
    }
}

/// <p>Describe an existing <a>Authorizer</a> resource.</p>
/// <div class="seeAlso"><a href="https://docs.aws.amazon.com/cli/latest/reference/apigateway/get-authorizer.html">AWS CLI</a></div>
#[derive(std::clone::Clone)]
pub struct GetAuthorizer {
    _private: (),
}
impl GetAuthorizer {
    /// Creates a new builder-style object to manufacture [`GetAuthorizerInput`](crate::input::GetAuthorizerInput)
    pub fn builder() -> crate::input::get_authorizer_input::Builder {
        crate::input::get_authorizer_input::Builder::default()
    }
    #[allow(clippy::unnecessary_wraps)]
    fn from_response(
        response: &http::response::Response<impl AsRef<[u8]>>,
    ) -> Result<crate::output::GetAuthorizerOutput, crate::error::GetAuthorizerError> {
        if crate::aws_json_errors::is_error(&response) && response.status().as_u16() != 200 {
            let body = serde_json::from_slice(response.body().as_ref())
                .unwrap_or_else(|_| serde_json::json!({}));
            let generic = crate::aws_json_errors::parse_generic_error(&response, &body);

            let error_code = match generic.code() {
                Some(code) => code,
                None => return Err(crate::error::GetAuthorizerError::unhandled(generic)),
            };
            return Err(match error_code {
                "NotFoundException" => crate::error::GetAuthorizerError {
                    meta: generic,
                    kind: crate::error::GetAuthorizerErrorKind::NotFoundError({
                        #[allow(unused_mut)]
                        let mut output = crate::error::not_found_error::Builder::default();
                        let _ = response;

                        let body_slice = response.body().as_ref();

                        let parsed_body: crate::error::NotFoundError = if body_slice.is_empty() {
                            // To enable JSON parsing to succeed, replace an empty body
                            // with an empty JSON body. If a member was required, it will fail slightly later
                            // during the operation construction phase.
                            serde_json::from_slice(b"{}")
                                .map_err(crate::error::GetAuthorizerError::unhandled)?
                        } else {
                            serde_json::from_slice(response.body().as_ref())
                                .map_err(crate::error::GetAuthorizerError::unhandled)?
                        };

                        output = output.set_message(parsed_body.message);
                        output.build()
                    }),
                },
                "TooManyRequestsException" => {
                    crate::error::GetAuthorizerError {
                        meta: generic,
                        kind: crate::error::GetAuthorizerErrorKind::TooManyRequestsError({
                            #[allow(unused_mut)]
                            let mut output =
                                crate::error::too_many_requests_error::Builder::default();
                            let _ = response;

                            let body_slice = response.body().as_ref();

                            let parsed_body: crate::error::TooManyRequestsError =
                                if body_slice.is_empty() {
                                    // To enable JSON parsing to succeed, replace an empty body
                                    // with an empty JSON body. If a member was required, it will fail slightly later
                                    // during the operation construction phase.
                                    serde_json::from_slice(b"{}")
                                        .map_err(crate::error::GetAuthorizerError::unhandled)?
                                } else {
                                    serde_json::from_slice(response.body().as_ref())
                                        .map_err(crate::error::GetAuthorizerError::unhandled)?
                                };

                            output = output.set_retry_after_seconds(
                        
                                                crate::http_serde::deser_header_get_authorizer_retry_after_seconds(response.headers())
                                                    .map_err(|_|crate::error::GetAuthorizerError::unhandled("Failed to parse retryAfterSeconds from header `Retry-After"))?
                                                
                    );
                            output = output.set_message(parsed_body.message);
                            output.build()
                        }),
                    }
                }
                "UnauthorizedException" => crate::error::GetAuthorizerError {
                    meta: generic,
                    kind: crate::error::GetAuthorizerErrorKind::UnauthorizedError({
                        #[allow(unused_mut)]
                        let mut output = crate::error::unauthorized_error::Builder::default();
                        let _ = response;

                        let body_slice = response.body().as_ref();

                        let parsed_body: crate::error::UnauthorizedError = if body_slice.is_empty()
                        {
                            // To enable JSON parsing to succeed, replace an empty body
                            // with an empty JSON body. If a member was required, it will fail slightly later
                            // during the operation construction phase.
                            serde_json::from_slice(b"{}")
                                .map_err(crate::error::GetAuthorizerError::unhandled)?
                        } else {
                            serde_json::from_slice(response.body().as_ref())
                                .map_err(crate::error::GetAuthorizerError::unhandled)?
                        };

                        output = output.set_message(parsed_body.message);
                        output.build()
                    }),
                },
                _ => crate::error::GetAuthorizerError::generic(generic),
            });
        }
        Ok({
            #[allow(unused_mut)]
            let mut output = crate::output::get_authorizer_output::Builder::default();
            let _ = response;

            let body_slice = response.body().as_ref();

            let parsed_body: crate::serializer::GetAuthorizerOutputBody = if body_slice.is_empty() {
                // To enable JSON parsing to succeed, replace an empty body
                // with an empty JSON body. If a member was required, it will fail slightly later
                // during the operation construction phase.
                serde_json::from_slice(b"{}")
                    .map_err(crate::error::GetAuthorizerError::unhandled)?
            } else {
                serde_json::from_slice(response.body().as_ref())
                    .map_err(crate::error::GetAuthorizerError::unhandled)?
            };

            output = output.set_id(parsed_body.id);
            output = output.set_name(parsed_body.name);
            output = output.set_type(parsed_body.r#type);
            output = output.set_provider_ar_ns(parsed_body.provider_ar_ns);
            output = output.set_auth_type(parsed_body.auth_type);
            output = output.set_authorizer_uri(parsed_body.authorizer_uri);
            output = output.set_authorizer_credentials(parsed_body.authorizer_credentials);
            output = output.set_identity_source(parsed_body.identity_source);
            output = output
                .set_identity_validation_expression(parsed_body.identity_validation_expression);
            output = output
                .set_authorizer_result_ttl_in_seconds(parsed_body.authorizer_result_ttl_in_seconds);
            output.build()
        })
    }
    pub fn parse_response(
        &self,
        response: &http::response::Response<impl AsRef<[u8]>>,
    ) -> Result<crate::output::GetAuthorizerOutput, crate::error::GetAuthorizerError> {
        Self::from_response(&response)
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}

impl smithy_http::response::ParseStrictResponse for GetAuthorizer {
    type Output = Result<crate::output::GetAuthorizerOutput, crate::error::GetAuthorizerError>;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        self.parse_response(response)
    }
}

/// <p>Describe an existing <a>Authorizers</a> resource.</p>
/// <div class="seeAlso"><a href="https://docs.aws.amazon.com/cli/latest/reference/apigateway/get-authorizers.html">AWS CLI</a></div>
#[derive(std::clone::Clone)]
pub struct GetAuthorizers {
    _private: (),
}
impl GetAuthorizers {
    /// Creates a new builder-style object to manufacture [`GetAuthorizersInput`](crate::input::GetAuthorizersInput)
    pub fn builder() -> crate::input::get_authorizers_input::Builder {
        crate::input::get_authorizers_input::Builder::default()
    }
    #[allow(clippy::unnecessary_wraps)]
    fn from_response(
        response: &http::response::Response<impl AsRef<[u8]>>,
    ) -> Result<crate::output::GetAuthorizersOutput, crate::error::GetAuthorizersError> {
        if crate::aws_json_errors::is_error(&response) && response.status().as_u16() != 200 {
            let body = serde_json::from_slice(response.body().as_ref())
                .unwrap_or_else(|_| serde_json::json!({}));
            let generic = crate::aws_json_errors::parse_generic_error(&response, &body);

            let error_code = match generic.code() {
                Some(code) => code,
                None => return Err(crate::error::GetAuthorizersError::unhandled(generic)),
            };
            return Err(match error_code {
                "BadRequestException" => crate::error::GetAuthorizersError {
                    meta: generic,
                    kind: crate::error::GetAuthorizersErrorKind::BadRequestError({
                        #[allow(unused_mut)]
                        let mut output = crate::error::bad_request_error::Builder::default();
                        let _ = response;

                        let body_slice = response.body().as_ref();

                        let parsed_body: crate::error::BadRequestError = if body_slice.is_empty() {
                            // To enable JSON parsing to succeed, replace an empty body
                            // with an empty JSON body. If a member was required, it will fail slightly later
                            // during the operation construction phase.
                            serde_json::from_slice(b"{}")
                                .map_err(crate::error::GetAuthorizersError::unhandled)?
                        } else {
                            serde_json::from_slice(response.body().as_ref())
                                .map_err(crate::error::GetAuthorizersError::unhandled)?
                        };

                        output = output.set_message(parsed_body.message);
                        output.build()
                    }),
                },
                "NotFoundException" => crate::error::GetAuthorizersError {
                    meta: generic,
                    kind: crate::error::GetAuthorizersErrorKind::NotFoundError({
                        #[allow(unused_mut)]
                        let mut output = crate::error::not_found_error::Builder::default();
                        let _ = response;

                        let body_slice = response.body().as_ref();

                        let parsed_body: crate::error::NotFoundError = if body_slice.is_empty() {
                            // To enable JSON parsing to succeed, replace an empty body
                            // with an empty JSON body. If a member was required, it will fail slightly later
                            // during the operation construction phase.
                            serde_json::from_slice(b"{}")
                                .map_err(crate::error::GetAuthorizersError::unhandled)?
                        } else {
                            serde_json::from_slice(response.body().as_ref())
                                .map_err(crate::error::GetAuthorizersError::unhandled)?
                        };

                        output = output.set_message(parsed_body.message);
                        output.build()
                    }),
                },
                "TooManyRequestsException" => {
                    crate::error::GetAuthorizersError {
                        meta: generic,
                        kind: crate::error::GetAuthorizersErrorKind::TooManyRequestsError({
                            #[allow(unused_mut)]
                            let mut output =
                                crate::error::too_many_requests_error::Builder::default();
                            let _ = response;

                            let body_slice = response.body().as_ref();

                            let parsed_body: crate::error::TooManyRequestsError =
                                if body_slice.is_empty() {
                                    // To enable JSON parsing to succeed, replace an empty body
                                    // with an empty JSON body. If a member was required, it will fail slightly later
                                    // during the operation construction phase.
                                    serde_json::from_slice(b"{}")
                                        .map_err(crate::error::GetAuthorizersError::unhandled)?
                                } else {
                                    serde_json::from_slice(response.body().as_ref())
                                        .map_err(crate::error::GetAuthorizersError::unhandled)?
                                };

                            output = output.set_retry_after_seconds(
                        
                                                crate::http_serde::deser_header_get_authorizers_retry_after_seconds(response.headers())
                                                    .map_err(|_|crate::error::GetAuthorizersError::unhandled("Failed to parse retryAfterSeconds from header `Retry-After"))?
                                                
                    );
                            output = output.set_message(parsed_body.message);
                            output.build()
                        }),
                    }
                }
                "UnauthorizedException" => crate::error::GetAuthorizersError {
                    meta: generic,
                    kind: crate::error::GetAuthorizersErrorKind::UnauthorizedError({
                        #[allow(unused_mut)]
                        let mut output = crate::error::unauthorized_error::Builder::default();
                        let _ = response;

                        let body_slice = response.body().as_ref();

                        let parsed_body: crate::error::UnauthorizedError = if body_slice.is_empty()
                        {
                            // To enable JSON parsing to succeed, replace an empty body
                            // with an empty JSON body. If a member was required, it will fail slightly later
                            // during the operation construction phase.
                            serde_json::from_slice(b"{}")
                                .map_err(crate::error::GetAuthorizersError::unhandled)?
                        } else {
                            serde_json::from_slice(response.body().as_ref())
                                .map_err(crate::error::GetAuthorizersError::unhandled)?
                        };

                        output = output.set_message(parsed_body.message);
                        output.build()
                    }),
                },
                _ => crate::error::GetAuthorizersError::generic(generic),
            });
        }
        Ok({
            #[allow(unused_mut)]
            let mut output = crate::output::get_authorizers_output::Builder::default();
            let _ = response;

            let body_slice = response.body().as_ref();

            let parsed_body: crate::serializer::GetAuthorizersOutputBody = if body_slice.is_empty()
            {
                // To enable JSON parsing to succeed, replace an empty body
                // with an empty JSON body. If a member was required, it will fail slightly later
                // during the operation construction phase.
                serde_json::from_slice(b"{}")
                    .map_err(crate::error::GetAuthorizersError::unhandled)?
            } else {
                serde_json::from_slice(response.body().as_ref())
                    .map_err(crate::error::GetAuthorizersError::unhandled)?
            };

            output = output.set_items(parsed_body.items);
            output = output.set_position(parsed_body.position);
            output.build()
        })
    }
    pub fn parse_response(
        &self,
        response: &http::response::Response<impl AsRef<[u8]>>,
    ) -> Result<crate::output::GetAuthorizersOutput, crate::error::GetAuthorizersError> {
        Self::from_response(&response)
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}

impl smithy_http::response::ParseStrictResponse for GetAuthorizers {
    type Output = Result<crate::output::GetAuthorizersOutput, crate::error::GetAuthorizersError>;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        self.parse_response(response)
    }
}

/// <p>Describe a <a>BasePathMapping</a> resource.</p>
#[derive(std::clone::Clone)]
pub struct GetBasePathMapping {
    _private: (),
}
impl GetBasePathMapping {
    /// Creates a new builder-style object to manufacture [`GetBasePathMappingInput`](crate::input::GetBasePathMappingInput)
    pub fn builder() -> crate::input::get_base_path_mapping_input::Builder {
        crate::input::get_base_path_mapping_input::Builder::default()
    }
    #[allow(clippy::unnecessary_wraps)]
    fn from_response(
        response: &http::response::Response<impl AsRef<[u8]>>,
    ) -> Result<crate::output::GetBasePathMappingOutput, crate::error::GetBasePathMappingError>
    {
        if crate::aws_json_errors::is_error(&response) && response.status().as_u16() != 200 {
            let body = serde_json::from_slice(response.body().as_ref())
                .unwrap_or_else(|_| serde_json::json!({}));
            let generic = crate::aws_json_errors::parse_generic_error(&response, &body);

            let error_code = match generic.code() {
                Some(code) => code,
                None => return Err(crate::error::GetBasePathMappingError::unhandled(generic)),
            };
            return Err(match error_code {
                "NotFoundException" => crate::error::GetBasePathMappingError {
                    meta: generic,
                    kind: crate::error::GetBasePathMappingErrorKind::NotFoundError({
                        #[allow(unused_mut)]
                        let mut output = crate::error::not_found_error::Builder::default();
                        let _ = response;

                        let body_slice = response.body().as_ref();

                        let parsed_body: crate::error::NotFoundError = if body_slice.is_empty() {
                            // To enable JSON parsing to succeed, replace an empty body
                            // with an empty JSON body. If a member was required, it will fail slightly later
                            // during the operation construction phase.
                            serde_json::from_slice(b"{}")
                                .map_err(crate::error::GetBasePathMappingError::unhandled)?
                        } else {
                            serde_json::from_slice(response.body().as_ref())
                                .map_err(crate::error::GetBasePathMappingError::unhandled)?
                        };

                        output = output.set_message(parsed_body.message);
                        output.build()
                    }),
                },
                "TooManyRequestsException" => crate::error::GetBasePathMappingError {
                    meta: generic,
                    kind: crate::error::GetBasePathMappingErrorKind::TooManyRequestsError({
                        #[allow(unused_mut)]
                        let mut output = crate::error::too_many_requests_error::Builder::default();
                        let _ = response;

                        let body_slice = response.body().as_ref();

                        let parsed_body: crate::error::TooManyRequestsError =
                            if body_slice.is_empty() {
                                // To enable JSON parsing to succeed, replace an empty body
                                // with an empty JSON body. If a member was required, it will fail slightly later
                                // during the operation construction phase.
                                serde_json::from_slice(b"{}")
                                    .map_err(crate::error::GetBasePathMappingError::unhandled)?
                            } else {
                                serde_json::from_slice(response.body().as_ref())
                                    .map_err(crate::error::GetBasePathMappingError::unhandled)?
                            };

                        output = output.set_retry_after_seconds(
                        
                                                crate::http_serde::deser_header_get_base_path_mapping_retry_after_seconds(response.headers())
                                                    .map_err(|_|crate::error::GetBasePathMappingError::unhandled("Failed to parse retryAfterSeconds from header `Retry-After"))?
                                                
                    );
                        output = output.set_message(parsed_body.message);
                        output.build()
                    }),
                },
                "UnauthorizedException" => crate::error::GetBasePathMappingError {
                    meta: generic,
                    kind: crate::error::GetBasePathMappingErrorKind::UnauthorizedError({
                        #[allow(unused_mut)]
                        let mut output = crate::error::unauthorized_error::Builder::default();
                        let _ = response;

                        let body_slice = response.body().as_ref();

                        let parsed_body: crate::error::UnauthorizedError = if body_slice.is_empty()
                        {
                            // To enable JSON parsing to succeed, replace an empty body
                            // with an empty JSON body. If a member was required, it will fail slightly later
                            // during the operation construction phase.
                            serde_json::from_slice(b"{}")
                                .map_err(crate::error::GetBasePathMappingError::unhandled)?
                        } else {
                            serde_json::from_slice(response.body().as_ref())
                                .map_err(crate::error::GetBasePathMappingError::unhandled)?
                        };

                        output = output.set_message(parsed_body.message);
                        output.build()
                    }),
                },
                _ => crate::error::GetBasePathMappingError::generic(generic),
            });
        }
        Ok({
            #[allow(unused_mut)]
            let mut output = crate::output::get_base_path_mapping_output::Builder::default();
            let _ = response;

            let body_slice = response.body().as_ref();

            let parsed_body: crate::serializer::GetBasePathMappingOutputBody =
                if body_slice.is_empty() {
                    // To enable JSON parsing to succeed, replace an empty body
                    // with an empty JSON body. If a member was required, it will fail slightly later
                    // during the operation construction phase.
                    serde_json::from_slice(b"{}")
                        .map_err(crate::error::GetBasePathMappingError::unhandled)?
                } else {
                    serde_json::from_slice(response.body().as_ref())
                        .map_err(crate::error::GetBasePathMappingError::unhandled)?
                };

            output = output.set_base_path(parsed_body.base_path);
            output = output.set_rest_api_id(parsed_body.rest_api_id);
            output = output.set_stage(parsed_body.stage);
            output.build()
        })
    }
    pub fn parse_response(
        &self,
        response: &http::response::Response<impl AsRef<[u8]>>,
    ) -> Result<crate::output::GetBasePathMappingOutput, crate::error::GetBasePathMappingError>
    {
        Self::from_response(&response)
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}

impl smithy_http::response::ParseStrictResponse for GetBasePathMapping {
    type Output =
        Result<crate::output::GetBasePathMappingOutput, crate::error::GetBasePathMappingError>;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        self.parse_response(response)
    }
}

/// <p>Represents a collection of <a>BasePathMapping</a> resources.</p>
#[derive(std::clone::Clone)]
pub struct GetBasePathMappings {
    _private: (),
}
impl GetBasePathMappings {
    /// Creates a new builder-style object to manufacture [`GetBasePathMappingsInput`](crate::input::GetBasePathMappingsInput)
    pub fn builder() -> crate::input::get_base_path_mappings_input::Builder {
        crate::input::get_base_path_mappings_input::Builder::default()
    }
    #[allow(clippy::unnecessary_wraps)]
    fn from_response(
        response: &http::response::Response<impl AsRef<[u8]>>,
    ) -> Result<crate::output::GetBasePathMappingsOutput, crate::error::GetBasePathMappingsError>
    {
        if crate::aws_json_errors::is_error(&response) && response.status().as_u16() != 200 {
            let body = serde_json::from_slice(response.body().as_ref())
                .unwrap_or_else(|_| serde_json::json!({}));
            let generic = crate::aws_json_errors::parse_generic_error(&response, &body);

            let error_code = match generic.code() {
                Some(code) => code,
                None => return Err(crate::error::GetBasePathMappingsError::unhandled(generic)),
            };
            return Err(match error_code {
                "NotFoundException" => crate::error::GetBasePathMappingsError {
                    meta: generic,
                    kind: crate::error::GetBasePathMappingsErrorKind::NotFoundError({
                        #[allow(unused_mut)]
                        let mut output = crate::error::not_found_error::Builder::default();
                        let _ = response;

                        let body_slice = response.body().as_ref();

                        let parsed_body: crate::error::NotFoundError = if body_slice.is_empty() {
                            // To enable JSON parsing to succeed, replace an empty body
                            // with an empty JSON body. If a member was required, it will fail slightly later
                            // during the operation construction phase.
                            serde_json::from_slice(b"{}")
                                .map_err(crate::error::GetBasePathMappingsError::unhandled)?
                        } else {
                            serde_json::from_slice(response.body().as_ref())
                                .map_err(crate::error::GetBasePathMappingsError::unhandled)?
                        };

                        output = output.set_message(parsed_body.message);
                        output.build()
                    }),
                },
                "TooManyRequestsException" => crate::error::GetBasePathMappingsError {
                    meta: generic,
                    kind: crate::error::GetBasePathMappingsErrorKind::TooManyRequestsError({
                        #[allow(unused_mut)]
                        let mut output = crate::error::too_many_requests_error::Builder::default();
                        let _ = response;

                        let body_slice = response.body().as_ref();

                        let parsed_body: crate::error::TooManyRequestsError =
                            if body_slice.is_empty() {
                                // To enable JSON parsing to succeed, replace an empty body
                                // with an empty JSON body. If a member was required, it will fail slightly later
                                // during the operation construction phase.
                                serde_json::from_slice(b"{}")
                                    .map_err(crate::error::GetBasePathMappingsError::unhandled)?
                            } else {
                                serde_json::from_slice(response.body().as_ref())
                                    .map_err(crate::error::GetBasePathMappingsError::unhandled)?
                            };

                        output = output.set_retry_after_seconds(
                        
                                                crate::http_serde::deser_header_get_base_path_mappings_retry_after_seconds(response.headers())
                                                    .map_err(|_|crate::error::GetBasePathMappingsError::unhandled("Failed to parse retryAfterSeconds from header `Retry-After"))?
                                                
                    );
                        output = output.set_message(parsed_body.message);
                        output.build()
                    }),
                },
                "UnauthorizedException" => crate::error::GetBasePathMappingsError {
                    meta: generic,
                    kind: crate::error::GetBasePathMappingsErrorKind::UnauthorizedError({
                        #[allow(unused_mut)]
                        let mut output = crate::error::unauthorized_error::Builder::default();
                        let _ = response;

                        let body_slice = response.body().as_ref();

                        let parsed_body: crate::error::UnauthorizedError = if body_slice.is_empty()
                        {
                            // To enable JSON parsing to succeed, replace an empty body
                            // with an empty JSON body. If a member was required, it will fail slightly later
                            // during the operation construction phase.
                            serde_json::from_slice(b"{}")
                                .map_err(crate::error::GetBasePathMappingsError::unhandled)?
                        } else {
                            serde_json::from_slice(response.body().as_ref())
                                .map_err(crate::error::GetBasePathMappingsError::unhandled)?
                        };

                        output = output.set_message(parsed_body.message);
                        output.build()
                    }),
                },
                _ => crate::error::GetBasePathMappingsError::generic(generic),
            });
        }
        Ok({
            #[allow(unused_mut)]
            let mut output = crate::output::get_base_path_mappings_output::Builder::default();
            let _ = response;

            let body_slice = response.body().as_ref();

            let parsed_body: crate::serializer::GetBasePathMappingsOutputBody =
                if body_slice.is_empty() {
                    // To enable JSON parsing to succeed, replace an empty body
                    // with an empty JSON body. If a member was required, it will fail slightly later
                    // during the operation construction phase.
                    serde_json::from_slice(b"{}")
                        .map_err(crate::error::GetBasePathMappingsError::unhandled)?
                } else {
                    serde_json::from_slice(response.body().as_ref())
                        .map_err(crate::error::GetBasePathMappingsError::unhandled)?
                };

            output = output.set_items(parsed_body.items);
            output = output.set_position(parsed_body.position);
            output.build()
        })
    }
    pub fn parse_response(
        &self,
        response: &http::response::Response<impl AsRef<[u8]>>,
    ) -> Result<crate::output::GetBasePathMappingsOutput, crate::error::GetBasePathMappingsError>
    {
        Self::from_response(&response)
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}

impl smithy_http::response::ParseStrictResponse for GetBasePathMappings {
    type Output =
        Result<crate::output::GetBasePathMappingsOutput, crate::error::GetBasePathMappingsError>;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        self.parse_response(response)
    }
}

/// <p>Gets information about the current <a>ClientCertificate</a> resource.</p>
#[derive(std::clone::Clone)]
pub struct GetClientCertificate {
    _private: (),
}
impl GetClientCertificate {
    /// Creates a new builder-style object to manufacture [`GetClientCertificateInput`](crate::input::GetClientCertificateInput)
    pub fn builder() -> crate::input::get_client_certificate_input::Builder {
        crate::input::get_client_certificate_input::Builder::default()
    }
    #[allow(clippy::unnecessary_wraps)]
    fn from_response(
        response: &http::response::Response<impl AsRef<[u8]>>,
    ) -> Result<crate::output::GetClientCertificateOutput, crate::error::GetClientCertificateError>
    {
        if crate::aws_json_errors::is_error(&response) && response.status().as_u16() != 200 {
            let body = serde_json::from_slice(response.body().as_ref())
                .unwrap_or_else(|_| serde_json::json!({}));
            let generic = crate::aws_json_errors::parse_generic_error(&response, &body);

            let error_code = match generic.code() {
                Some(code) => code,
                None => return Err(crate::error::GetClientCertificateError::unhandled(generic)),
            };
            return Err(match error_code {
                "NotFoundException" => crate::error::GetClientCertificateError {
                    meta: generic,
                    kind: crate::error::GetClientCertificateErrorKind::NotFoundError({
                        #[allow(unused_mut)]
                        let mut output = crate::error::not_found_error::Builder::default();
                        let _ = response;

                        let body_slice = response.body().as_ref();

                        let parsed_body: crate::error::NotFoundError = if body_slice.is_empty() {
                            // To enable JSON parsing to succeed, replace an empty body
                            // with an empty JSON body. If a member was required, it will fail slightly later
                            // during the operation construction phase.
                            serde_json::from_slice(b"{}")
                                .map_err(crate::error::GetClientCertificateError::unhandled)?
                        } else {
                            serde_json::from_slice(response.body().as_ref())
                                .map_err(crate::error::GetClientCertificateError::unhandled)?
                        };

                        output = output.set_message(parsed_body.message);
                        output.build()
                    }),
                },
                "TooManyRequestsException" => crate::error::GetClientCertificateError {
                    meta: generic,
                    kind: crate::error::GetClientCertificateErrorKind::TooManyRequestsError({
                        #[allow(unused_mut)]
                        let mut output = crate::error::too_many_requests_error::Builder::default();
                        let _ = response;

                        let body_slice = response.body().as_ref();

                        let parsed_body: crate::error::TooManyRequestsError =
                            if body_slice.is_empty() {
                                // To enable JSON parsing to succeed, replace an empty body
                                // with an empty JSON body. If a member was required, it will fail slightly later
                                // during the operation construction phase.
                                serde_json::from_slice(b"{}")
                                    .map_err(crate::error::GetClientCertificateError::unhandled)?
                            } else {
                                serde_json::from_slice(response.body().as_ref())
                                    .map_err(crate::error::GetClientCertificateError::unhandled)?
                            };

                        output = output.set_retry_after_seconds(
                        
                                                crate::http_serde::deser_header_get_client_certificate_retry_after_seconds(response.headers())
                                                    .map_err(|_|crate::error::GetClientCertificateError::unhandled("Failed to parse retryAfterSeconds from header `Retry-After"))?
                                                
                    );
                        output = output.set_message(parsed_body.message);
                        output.build()
                    }),
                },
                "UnauthorizedException" => crate::error::GetClientCertificateError {
                    meta: generic,
                    kind: crate::error::GetClientCertificateErrorKind::UnauthorizedError({
                        #[allow(unused_mut)]
                        let mut output = crate::error::unauthorized_error::Builder::default();
                        let _ = response;

                        let body_slice = response.body().as_ref();

                        let parsed_body: crate::error::UnauthorizedError = if body_slice.is_empty()
                        {
                            // To enable JSON parsing to succeed, replace an empty body
                            // with an empty JSON body. If a member was required, it will fail slightly later
                            // during the operation construction phase.
                            serde_json::from_slice(b"{}")
                                .map_err(crate::error::GetClientCertificateError::unhandled)?
                        } else {
                            serde_json::from_slice(response.body().as_ref())
                                .map_err(crate::error::GetClientCertificateError::unhandled)?
                        };

                        output = output.set_message(parsed_body.message);
                        output.build()
                    }),
                },
                _ => crate::error::GetClientCertificateError::generic(generic),
            });
        }
        Ok({
            #[allow(unused_mut)]
            let mut output = crate::output::get_client_certificate_output::Builder::default();
            let _ = response;

            let body_slice = response.body().as_ref();

            let parsed_body: crate::serializer::GetClientCertificateOutputBody =
                if body_slice.is_empty() {
                    // To enable JSON parsing to succeed, replace an empty body
                    // with an empty JSON body. If a member was required, it will fail slightly later
                    // during the operation construction phase.
                    serde_json::from_slice(b"{}")
                        .map_err(crate::error::GetClientCertificateError::unhandled)?
                } else {
                    serde_json::from_slice(response.body().as_ref())
                        .map_err(crate::error::GetClientCertificateError::unhandled)?
                };

            output = output.set_client_certificate_id(parsed_body.client_certificate_id);
            output = output.set_description(parsed_body.description);
            output = output.set_pem_encoded_certificate(parsed_body.pem_encoded_certificate);
            output = output.set_created_date(parsed_body.created_date);
            output = output.set_expiration_date(parsed_body.expiration_date);
            output = output.set_tags(parsed_body.tags);
            output.build()
        })
    }
    pub fn parse_response(
        &self,
        response: &http::response::Response<impl AsRef<[u8]>>,
    ) -> Result<crate::output::GetClientCertificateOutput, crate::error::GetClientCertificateError>
    {
        Self::from_response(&response)
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}

impl smithy_http::response::ParseStrictResponse for GetClientCertificate {
    type Output =
        Result<crate::output::GetClientCertificateOutput, crate::error::GetClientCertificateError>;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        self.parse_response(response)
    }
}

/// <p>Gets a collection of <a>ClientCertificate</a> resources.</p>
#[derive(std::clone::Clone)]
pub struct GetClientCertificates {
    _private: (),
}
impl GetClientCertificates {
    /// Creates a new builder-style object to manufacture [`GetClientCertificatesInput`](crate::input::GetClientCertificatesInput)
    pub fn builder() -> crate::input::get_client_certificates_input::Builder {
        crate::input::get_client_certificates_input::Builder::default()
    }
    #[allow(clippy::unnecessary_wraps)]
    fn from_response(
        response: &http::response::Response<impl AsRef<[u8]>>,
    ) -> Result<crate::output::GetClientCertificatesOutput, crate::error::GetClientCertificatesError>
    {
        if crate::aws_json_errors::is_error(&response) && response.status().as_u16() != 200 {
            let body = serde_json::from_slice(response.body().as_ref())
                .unwrap_or_else(|_| serde_json::json!({}));
            let generic = crate::aws_json_errors::parse_generic_error(&response, &body);

            let error_code = match generic.code() {
                Some(code) => code,
                None => return Err(crate::error::GetClientCertificatesError::unhandled(generic)),
            };
            return Err(match error_code {
                "BadRequestException" => crate::error::GetClientCertificatesError {
                    meta: generic,
                    kind: crate::error::GetClientCertificatesErrorKind::BadRequestError({
                        #[allow(unused_mut)]
                        let mut output = crate::error::bad_request_error::Builder::default();
                        let _ = response;

                        let body_slice = response.body().as_ref();

                        let parsed_body: crate::error::BadRequestError = if body_slice.is_empty() {
                            // To enable JSON parsing to succeed, replace an empty body
                            // with an empty JSON body. If a member was required, it will fail slightly later
                            // during the operation construction phase.
                            serde_json::from_slice(b"{}")
                                .map_err(crate::error::GetClientCertificatesError::unhandled)?
                        } else {
                            serde_json::from_slice(response.body().as_ref())
                                .map_err(crate::error::GetClientCertificatesError::unhandled)?
                        };

                        output = output.set_message(parsed_body.message);
                        output.build()
                    }),
                },
                "TooManyRequestsException" => crate::error::GetClientCertificatesError {
                    meta: generic,
                    kind: crate::error::GetClientCertificatesErrorKind::TooManyRequestsError({
                        #[allow(unused_mut)]
                        let mut output = crate::error::too_many_requests_error::Builder::default();
                        let _ = response;

                        let body_slice = response.body().as_ref();

                        let parsed_body: crate::error::TooManyRequestsError =
                            if body_slice.is_empty() {
                                // To enable JSON parsing to succeed, replace an empty body
                                // with an empty JSON body. If a member was required, it will fail slightly later
                                // during the operation construction phase.
                                serde_json::from_slice(b"{}")
                                    .map_err(crate::error::GetClientCertificatesError::unhandled)?
                            } else {
                                serde_json::from_slice(response.body().as_ref())
                                    .map_err(crate::error::GetClientCertificatesError::unhandled)?
                            };

                        output = output.set_retry_after_seconds(
                        
                                                crate::http_serde::deser_header_get_client_certificates_retry_after_seconds(response.headers())
                                                    .map_err(|_|crate::error::GetClientCertificatesError::unhandled("Failed to parse retryAfterSeconds from header `Retry-After"))?
                                                
                    );
                        output = output.set_message(parsed_body.message);
                        output.build()
                    }),
                },
                "UnauthorizedException" => crate::error::GetClientCertificatesError {
                    meta: generic,
                    kind: crate::error::GetClientCertificatesErrorKind::UnauthorizedError({
                        #[allow(unused_mut)]
                        let mut output = crate::error::unauthorized_error::Builder::default();
                        let _ = response;

                        let body_slice = response.body().as_ref();

                        let parsed_body: crate::error::UnauthorizedError = if body_slice.is_empty()
                        {
                            // To enable JSON parsing to succeed, replace an empty body
                            // with an empty JSON body. If a member was required, it will fail slightly later
                            // during the operation construction phase.
                            serde_json::from_slice(b"{}")
                                .map_err(crate::error::GetClientCertificatesError::unhandled)?
                        } else {
                            serde_json::from_slice(response.body().as_ref())
                                .map_err(crate::error::GetClientCertificatesError::unhandled)?
                        };

                        output = output.set_message(parsed_body.message);
                        output.build()
                    }),
                },
                _ => crate::error::GetClientCertificatesError::generic(generic),
            });
        }
        Ok({
            #[allow(unused_mut)]
            let mut output = crate::output::get_client_certificates_output::Builder::default();
            let _ = response;

            let body_slice = response.body().as_ref();

            let parsed_body: crate::serializer::GetClientCertificatesOutputBody =
                if body_slice.is_empty() {
                    // To enable JSON parsing to succeed, replace an empty body
                    // with an empty JSON body. If a member was required, it will fail slightly later
                    // during the operation construction phase.
                    serde_json::from_slice(b"{}")
                        .map_err(crate::error::GetClientCertificatesError::unhandled)?
                } else {
                    serde_json::from_slice(response.body().as_ref())
                        .map_err(crate::error::GetClientCertificatesError::unhandled)?
                };

            output = output.set_items(parsed_body.items);
            output = output.set_position(parsed_body.position);
            output.build()
        })
    }
    pub fn parse_response(
        &self,
        response: &http::response::Response<impl AsRef<[u8]>>,
    ) -> Result<crate::output::GetClientCertificatesOutput, crate::error::GetClientCertificatesError>
    {
        Self::from_response(&response)
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}

impl smithy_http::response::ParseStrictResponse for GetClientCertificates {
    type Output = Result<
        crate::output::GetClientCertificatesOutput,
        crate::error::GetClientCertificatesError,
    >;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        self.parse_response(response)
    }
}

/// <p>Gets information about a <a>Deployment</a> resource.</p>
#[derive(std::clone::Clone)]
pub struct GetDeployment {
    _private: (),
}
impl GetDeployment {
    /// Creates a new builder-style object to manufacture [`GetDeploymentInput`](crate::input::GetDeploymentInput)
    pub fn builder() -> crate::input::get_deployment_input::Builder {
        crate::input::get_deployment_input::Builder::default()
    }
    #[allow(clippy::unnecessary_wraps)]
    fn from_response(
        response: &http::response::Response<impl AsRef<[u8]>>,
    ) -> Result<crate::output::GetDeploymentOutput, crate::error::GetDeploymentError> {
        if crate::aws_json_errors::is_error(&response) && response.status().as_u16() != 200 {
            let body = serde_json::from_slice(response.body().as_ref())
                .unwrap_or_else(|_| serde_json::json!({}));
            let generic = crate::aws_json_errors::parse_generic_error(&response, &body);

            let error_code = match generic.code() {
                Some(code) => code,
                None => return Err(crate::error::GetDeploymentError::unhandled(generic)),
            };
            return Err(match error_code {
                "NotFoundException" => crate::error::GetDeploymentError {
                    meta: generic,
                    kind: crate::error::GetDeploymentErrorKind::NotFoundError({
                        #[allow(unused_mut)]
                        let mut output = crate::error::not_found_error::Builder::default();
                        let _ = response;

                        let body_slice = response.body().as_ref();

                        let parsed_body: crate::error::NotFoundError = if body_slice.is_empty() {
                            // To enable JSON parsing to succeed, replace an empty body
                            // with an empty JSON body. If a member was required, it will fail slightly later
                            // during the operation construction phase.
                            serde_json::from_slice(b"{}")
                                .map_err(crate::error::GetDeploymentError::unhandled)?
                        } else {
                            serde_json::from_slice(response.body().as_ref())
                                .map_err(crate::error::GetDeploymentError::unhandled)?
                        };

                        output = output.set_message(parsed_body.message);
                        output.build()
                    }),
                },
                "ServiceUnavailableException" => {
                    crate::error::GetDeploymentError {
                        meta: generic,
                        kind: crate::error::GetDeploymentErrorKind::ServiceUnavailableError({
                            #[allow(unused_mut)]
                            let mut output =
                                crate::error::service_unavailable_error::Builder::default();
                            let _ = response;

                            let body_slice = response.body().as_ref();

                            let parsed_body: crate::error::ServiceUnavailableError =
                                if body_slice.is_empty() {
                                    // To enable JSON parsing to succeed, replace an empty body
                                    // with an empty JSON body. If a member was required, it will fail slightly later
                                    // during the operation construction phase.
                                    serde_json::from_slice(b"{}")
                                        .map_err(crate::error::GetDeploymentError::unhandled)?
                                } else {
                                    serde_json::from_slice(response.body().as_ref())
                                        .map_err(crate::error::GetDeploymentError::unhandled)?
                                };

                            output = output.set_retry_after_seconds(
                        
                                                crate::http_serde::deser_header_get_deployment_retry_after_seconds(response.headers())
                                                    .map_err(|_|crate::error::GetDeploymentError::unhandled("Failed to parse retryAfterSeconds from header `Retry-After"))?
                                                
                    );
                            output = output.set_message(parsed_body.message);
                            output.build()
                        }),
                    }
                }
                "TooManyRequestsException" => {
                    crate::error::GetDeploymentError {
                        meta: generic,
                        kind: crate::error::GetDeploymentErrorKind::TooManyRequestsError({
                            #[allow(unused_mut)]
                            let mut output =
                                crate::error::too_many_requests_error::Builder::default();
                            let _ = response;

                            let body_slice = response.body().as_ref();

                            let parsed_body: crate::error::TooManyRequestsError =
                                if body_slice.is_empty() {
                                    // To enable JSON parsing to succeed, replace an empty body
                                    // with an empty JSON body. If a member was required, it will fail slightly later
                                    // during the operation construction phase.
                                    serde_json::from_slice(b"{}")
                                        .map_err(crate::error::GetDeploymentError::unhandled)?
                                } else {
                                    serde_json::from_slice(response.body().as_ref())
                                        .map_err(crate::error::GetDeploymentError::unhandled)?
                                };

                            output = output.set_retry_after_seconds(
                        
                                                crate::http_serde::deser_header_get_deployment_retry_after_seconds(response.headers())
                                                    .map_err(|_|crate::error::GetDeploymentError::unhandled("Failed to parse retryAfterSeconds from header `Retry-After"))?
                                                
                    );
                            output = output.set_message(parsed_body.message);
                            output.build()
                        }),
                    }
                }
                "UnauthorizedException" => crate::error::GetDeploymentError {
                    meta: generic,
                    kind: crate::error::GetDeploymentErrorKind::UnauthorizedError({
                        #[allow(unused_mut)]
                        let mut output = crate::error::unauthorized_error::Builder::default();
                        let _ = response;

                        let body_slice = response.body().as_ref();

                        let parsed_body: crate::error::UnauthorizedError = if body_slice.is_empty()
                        {
                            // To enable JSON parsing to succeed, replace an empty body
                            // with an empty JSON body. If a member was required, it will fail slightly later
                            // during the operation construction phase.
                            serde_json::from_slice(b"{}")
                                .map_err(crate::error::GetDeploymentError::unhandled)?
                        } else {
                            serde_json::from_slice(response.body().as_ref())
                                .map_err(crate::error::GetDeploymentError::unhandled)?
                        };

                        output = output.set_message(parsed_body.message);
                        output.build()
                    }),
                },
                _ => crate::error::GetDeploymentError::generic(generic),
            });
        }
        Ok({
            #[allow(unused_mut)]
            let mut output = crate::output::get_deployment_output::Builder::default();
            let _ = response;

            let body_slice = response.body().as_ref();

            let parsed_body: crate::serializer::GetDeploymentOutputBody = if body_slice.is_empty() {
                // To enable JSON parsing to succeed, replace an empty body
                // with an empty JSON body. If a member was required, it will fail slightly later
                // during the operation construction phase.
                serde_json::from_slice(b"{}")
                    .map_err(crate::error::GetDeploymentError::unhandled)?
            } else {
                serde_json::from_slice(response.body().as_ref())
                    .map_err(crate::error::GetDeploymentError::unhandled)?
            };

            output = output.set_id(parsed_body.id);
            output = output.set_description(parsed_body.description);
            output = output.set_created_date(parsed_body.created_date);
            output = output.set_api_summary(parsed_body.api_summary);
            output.build()
        })
    }
    pub fn parse_response(
        &self,
        response: &http::response::Response<impl AsRef<[u8]>>,
    ) -> Result<crate::output::GetDeploymentOutput, crate::error::GetDeploymentError> {
        Self::from_response(&response)
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}

impl smithy_http::response::ParseStrictResponse for GetDeployment {
    type Output = Result<crate::output::GetDeploymentOutput, crate::error::GetDeploymentError>;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        self.parse_response(response)
    }
}

/// <p>Gets information about a <a>Deployments</a> collection.</p>
#[derive(std::clone::Clone)]
pub struct GetDeployments {
    _private: (),
}
impl GetDeployments {
    /// Creates a new builder-style object to manufacture [`GetDeploymentsInput`](crate::input::GetDeploymentsInput)
    pub fn builder() -> crate::input::get_deployments_input::Builder {
        crate::input::get_deployments_input::Builder::default()
    }
    #[allow(clippy::unnecessary_wraps)]
    fn from_response(
        response: &http::response::Response<impl AsRef<[u8]>>,
    ) -> Result<crate::output::GetDeploymentsOutput, crate::error::GetDeploymentsError> {
        if crate::aws_json_errors::is_error(&response) && response.status().as_u16() != 200 {
            let body = serde_json::from_slice(response.body().as_ref())
                .unwrap_or_else(|_| serde_json::json!({}));
            let generic = crate::aws_json_errors::parse_generic_error(&response, &body);

            let error_code = match generic.code() {
                Some(code) => code,
                None => return Err(crate::error::GetDeploymentsError::unhandled(generic)),
            };
            return Err(match error_code {
                "BadRequestException" => crate::error::GetDeploymentsError {
                    meta: generic,
                    kind: crate::error::GetDeploymentsErrorKind::BadRequestError({
                        #[allow(unused_mut)]
                        let mut output = crate::error::bad_request_error::Builder::default();
                        let _ = response;

                        let body_slice = response.body().as_ref();

                        let parsed_body: crate::error::BadRequestError = if body_slice.is_empty() {
                            // To enable JSON parsing to succeed, replace an empty body
                            // with an empty JSON body. If a member was required, it will fail slightly later
                            // during the operation construction phase.
                            serde_json::from_slice(b"{}")
                                .map_err(crate::error::GetDeploymentsError::unhandled)?
                        } else {
                            serde_json::from_slice(response.body().as_ref())
                                .map_err(crate::error::GetDeploymentsError::unhandled)?
                        };

                        output = output.set_message(parsed_body.message);
                        output.build()
                    }),
                },
                "NotFoundException" => crate::error::GetDeploymentsError {
                    meta: generic,
                    kind: crate::error::GetDeploymentsErrorKind::NotFoundError({
                        #[allow(unused_mut)]
                        let mut output = crate::error::not_found_error::Builder::default();
                        let _ = response;

                        let body_slice = response.body().as_ref();

                        let parsed_body: crate::error::NotFoundError = if body_slice.is_empty() {
                            // To enable JSON parsing to succeed, replace an empty body
                            // with an empty JSON body. If a member was required, it will fail slightly later
                            // during the operation construction phase.
                            serde_json::from_slice(b"{}")
                                .map_err(crate::error::GetDeploymentsError::unhandled)?
                        } else {
                            serde_json::from_slice(response.body().as_ref())
                                .map_err(crate::error::GetDeploymentsError::unhandled)?
                        };

                        output = output.set_message(parsed_body.message);
                        output.build()
                    }),
                },
                "ServiceUnavailableException" => {
                    crate::error::GetDeploymentsError {
                        meta: generic,
                        kind: crate::error::GetDeploymentsErrorKind::ServiceUnavailableError({
                            #[allow(unused_mut)]
                            let mut output =
                                crate::error::service_unavailable_error::Builder::default();
                            let _ = response;

                            let body_slice = response.body().as_ref();

                            let parsed_body: crate::error::ServiceUnavailableError =
                                if body_slice.is_empty() {
                                    // To enable JSON parsing to succeed, replace an empty body
                                    // with an empty JSON body. If a member was required, it will fail slightly later
                                    // during the operation construction phase.
                                    serde_json::from_slice(b"{}")
                                        .map_err(crate::error::GetDeploymentsError::unhandled)?
                                } else {
                                    serde_json::from_slice(response.body().as_ref())
                                        .map_err(crate::error::GetDeploymentsError::unhandled)?
                                };

                            output = output.set_retry_after_seconds(
                        
                                                crate::http_serde::deser_header_get_deployments_retry_after_seconds(response.headers())
                                                    .map_err(|_|crate::error::GetDeploymentsError::unhandled("Failed to parse retryAfterSeconds from header `Retry-After"))?
                                                
                    );
                            output = output.set_message(parsed_body.message);
                            output.build()
                        }),
                    }
                }
                "TooManyRequestsException" => {
                    crate::error::GetDeploymentsError {
                        meta: generic,
                        kind: crate::error::GetDeploymentsErrorKind::TooManyRequestsError({
                            #[allow(unused_mut)]
                            let mut output =
                                crate::error::too_many_requests_error::Builder::default();
                            let _ = response;

                            let body_slice = response.body().as_ref();

                            let parsed_body: crate::error::TooManyRequestsError =
                                if body_slice.is_empty() {
                                    // To enable JSON parsing to succeed, replace an empty body
                                    // with an empty JSON body. If a member was required, it will fail slightly later
                                    // during the operation construction phase.
                                    serde_json::from_slice(b"{}")
                                        .map_err(crate::error::GetDeploymentsError::unhandled)?
                                } else {
                                    serde_json::from_slice(response.body().as_ref())
                                        .map_err(crate::error::GetDeploymentsError::unhandled)?
                                };

                            output = output.set_retry_after_seconds(
                        
                                                crate::http_serde::deser_header_get_deployments_retry_after_seconds(response.headers())
                                                    .map_err(|_|crate::error::GetDeploymentsError::unhandled("Failed to parse retryAfterSeconds from header `Retry-After"))?
                                                
                    );
                            output = output.set_message(parsed_body.message);
                            output.build()
                        }),
                    }
                }
                "UnauthorizedException" => crate::error::GetDeploymentsError {
                    meta: generic,
                    kind: crate::error::GetDeploymentsErrorKind::UnauthorizedError({
                        #[allow(unused_mut)]
                        let mut output = crate::error::unauthorized_error::Builder::default();
                        let _ = response;

                        let body_slice = response.body().as_ref();

                        let parsed_body: crate::error::UnauthorizedError = if body_slice.is_empty()
                        {
                            // To enable JSON parsing to succeed, replace an empty body
                            // with an empty JSON body. If a member was required, it will fail slightly later
                            // during the operation construction phase.
                            serde_json::from_slice(b"{}")
                                .map_err(crate::error::GetDeploymentsError::unhandled)?
                        } else {
                            serde_json::from_slice(response.body().as_ref())
                                .map_err(crate::error::GetDeploymentsError::unhandled)?
                        };

                        output = output.set_message(parsed_body.message);
                        output.build()
                    }),
                },
                _ => crate::error::GetDeploymentsError::generic(generic),
            });
        }
        Ok({
            #[allow(unused_mut)]
            let mut output = crate::output::get_deployments_output::Builder::default();
            let _ = response;

            let body_slice = response.body().as_ref();

            let parsed_body: crate::serializer::GetDeploymentsOutputBody = if body_slice.is_empty()
            {
                // To enable JSON parsing to succeed, replace an empty body
                // with an empty JSON body. If a member was required, it will fail slightly later
                // during the operation construction phase.
                serde_json::from_slice(b"{}")
                    .map_err(crate::error::GetDeploymentsError::unhandled)?
            } else {
                serde_json::from_slice(response.body().as_ref())
                    .map_err(crate::error::GetDeploymentsError::unhandled)?
            };

            output = output.set_items(parsed_body.items);
            output = output.set_position(parsed_body.position);
            output.build()
        })
    }
    pub fn parse_response(
        &self,
        response: &http::response::Response<impl AsRef<[u8]>>,
    ) -> Result<crate::output::GetDeploymentsOutput, crate::error::GetDeploymentsError> {
        Self::from_response(&response)
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}

impl smithy_http::response::ParseStrictResponse for GetDeployments {
    type Output = Result<crate::output::GetDeploymentsOutput, crate::error::GetDeploymentsError>;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        self.parse_response(response)
    }
}

#[derive(std::clone::Clone)]
pub struct GetDocumentationPart {
    _private: (),
}
impl GetDocumentationPart {
    /// Creates a new builder-style object to manufacture [`GetDocumentationPartInput`](crate::input::GetDocumentationPartInput)
    pub fn builder() -> crate::input::get_documentation_part_input::Builder {
        crate::input::get_documentation_part_input::Builder::default()
    }
    #[allow(clippy::unnecessary_wraps)]
    fn from_response(
        response: &http::response::Response<impl AsRef<[u8]>>,
    ) -> Result<crate::output::GetDocumentationPartOutput, crate::error::GetDocumentationPartError>
    {
        if crate::aws_json_errors::is_error(&response) && response.status().as_u16() != 200 {
            let body = serde_json::from_slice(response.body().as_ref())
                .unwrap_or_else(|_| serde_json::json!({}));
            let generic = crate::aws_json_errors::parse_generic_error(&response, &body);

            let error_code = match generic.code() {
                Some(code) => code,
                None => return Err(crate::error::GetDocumentationPartError::unhandled(generic)),
            };
            return Err(match error_code {
                "NotFoundException" => crate::error::GetDocumentationPartError {
                    meta: generic,
                    kind: crate::error::GetDocumentationPartErrorKind::NotFoundError({
                        #[allow(unused_mut)]
                        let mut output = crate::error::not_found_error::Builder::default();
                        let _ = response;

                        let body_slice = response.body().as_ref();

                        let parsed_body: crate::error::NotFoundError = if body_slice.is_empty() {
                            // To enable JSON parsing to succeed, replace an empty body
                            // with an empty JSON body. If a member was required, it will fail slightly later
                            // during the operation construction phase.
                            serde_json::from_slice(b"{}")
                                .map_err(crate::error::GetDocumentationPartError::unhandled)?
                        } else {
                            serde_json::from_slice(response.body().as_ref())
                                .map_err(crate::error::GetDocumentationPartError::unhandled)?
                        };

                        output = output.set_message(parsed_body.message);
                        output.build()
                    }),
                },
                "TooManyRequestsException" => crate::error::GetDocumentationPartError {
                    meta: generic,
                    kind: crate::error::GetDocumentationPartErrorKind::TooManyRequestsError({
                        #[allow(unused_mut)]
                        let mut output = crate::error::too_many_requests_error::Builder::default();
                        let _ = response;

                        let body_slice = response.body().as_ref();

                        let parsed_body: crate::error::TooManyRequestsError =
                            if body_slice.is_empty() {
                                // To enable JSON parsing to succeed, replace an empty body
                                // with an empty JSON body. If a member was required, it will fail slightly later
                                // during the operation construction phase.
                                serde_json::from_slice(b"{}")
                                    .map_err(crate::error::GetDocumentationPartError::unhandled)?
                            } else {
                                serde_json::from_slice(response.body().as_ref())
                                    .map_err(crate::error::GetDocumentationPartError::unhandled)?
                            };

                        output = output.set_retry_after_seconds(
                        
                                                crate::http_serde::deser_header_get_documentation_part_retry_after_seconds(response.headers())
                                                    .map_err(|_|crate::error::GetDocumentationPartError::unhandled("Failed to parse retryAfterSeconds from header `Retry-After"))?
                                                
                    );
                        output = output.set_message(parsed_body.message);
                        output.build()
                    }),
                },
                "UnauthorizedException" => crate::error::GetDocumentationPartError {
                    meta: generic,
                    kind: crate::error::GetDocumentationPartErrorKind::UnauthorizedError({
                        #[allow(unused_mut)]
                        let mut output = crate::error::unauthorized_error::Builder::default();
                        let _ = response;

                        let body_slice = response.body().as_ref();

                        let parsed_body: crate::error::UnauthorizedError = if body_slice.is_empty()
                        {
                            // To enable JSON parsing to succeed, replace an empty body
                            // with an empty JSON body. If a member was required, it will fail slightly later
                            // during the operation construction phase.
                            serde_json::from_slice(b"{}")
                                .map_err(crate::error::GetDocumentationPartError::unhandled)?
                        } else {
                            serde_json::from_slice(response.body().as_ref())
                                .map_err(crate::error::GetDocumentationPartError::unhandled)?
                        };

                        output = output.set_message(parsed_body.message);
                        output.build()
                    }),
                },
                _ => crate::error::GetDocumentationPartError::generic(generic),
            });
        }
        Ok({
            #[allow(unused_mut)]
            let mut output = crate::output::get_documentation_part_output::Builder::default();
            let _ = response;

            let body_slice = response.body().as_ref();

            let parsed_body: crate::serializer::GetDocumentationPartOutputBody =
                if body_slice.is_empty() {
                    // To enable JSON parsing to succeed, replace an empty body
                    // with an empty JSON body. If a member was required, it will fail slightly later
                    // during the operation construction phase.
                    serde_json::from_slice(b"{}")
                        .map_err(crate::error::GetDocumentationPartError::unhandled)?
                } else {
                    serde_json::from_slice(response.body().as_ref())
                        .map_err(crate::error::GetDocumentationPartError::unhandled)?
                };

            output = output.set_id(parsed_body.id);
            output = output.set_location(parsed_body.location);
            output = output.set_properties(parsed_body.properties);
            output.build()
        })
    }
    pub fn parse_response(
        &self,
        response: &http::response::Response<impl AsRef<[u8]>>,
    ) -> Result<crate::output::GetDocumentationPartOutput, crate::error::GetDocumentationPartError>
    {
        Self::from_response(&response)
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}

impl smithy_http::response::ParseStrictResponse for GetDocumentationPart {
    type Output =
        Result<crate::output::GetDocumentationPartOutput, crate::error::GetDocumentationPartError>;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        self.parse_response(response)
    }
}

#[derive(std::clone::Clone)]
pub struct GetDocumentationParts {
    _private: (),
}
impl GetDocumentationParts {
    /// Creates a new builder-style object to manufacture [`GetDocumentationPartsInput`](crate::input::GetDocumentationPartsInput)
    pub fn builder() -> crate::input::get_documentation_parts_input::Builder {
        crate::input::get_documentation_parts_input::Builder::default()
    }
    #[allow(clippy::unnecessary_wraps)]
    fn from_response(
        response: &http::response::Response<impl AsRef<[u8]>>,
    ) -> Result<crate::output::GetDocumentationPartsOutput, crate::error::GetDocumentationPartsError>
    {
        if crate::aws_json_errors::is_error(&response) && response.status().as_u16() != 200 {
            let body = serde_json::from_slice(response.body().as_ref())
                .unwrap_or_else(|_| serde_json::json!({}));
            let generic = crate::aws_json_errors::parse_generic_error(&response, &body);

            let error_code = match generic.code() {
                Some(code) => code,
                None => return Err(crate::error::GetDocumentationPartsError::unhandled(generic)),
            };
            return Err(match error_code {
                "BadRequestException" => crate::error::GetDocumentationPartsError {
                    meta: generic,
                    kind: crate::error::GetDocumentationPartsErrorKind::BadRequestError({
                        #[allow(unused_mut)]
                        let mut output = crate::error::bad_request_error::Builder::default();
                        let _ = response;

                        let body_slice = response.body().as_ref();

                        let parsed_body: crate::error::BadRequestError = if body_slice.is_empty() {
                            // To enable JSON parsing to succeed, replace an empty body
                            // with an empty JSON body. If a member was required, it will fail slightly later
                            // during the operation construction phase.
                            serde_json::from_slice(b"{}")
                                .map_err(crate::error::GetDocumentationPartsError::unhandled)?
                        } else {
                            serde_json::from_slice(response.body().as_ref())
                                .map_err(crate::error::GetDocumentationPartsError::unhandled)?
                        };

                        output = output.set_message(parsed_body.message);
                        output.build()
                    }),
                },
                "NotFoundException" => crate::error::GetDocumentationPartsError {
                    meta: generic,
                    kind: crate::error::GetDocumentationPartsErrorKind::NotFoundError({
                        #[allow(unused_mut)]
                        let mut output = crate::error::not_found_error::Builder::default();
                        let _ = response;

                        let body_slice = response.body().as_ref();

                        let parsed_body: crate::error::NotFoundError = if body_slice.is_empty() {
                            // To enable JSON parsing to succeed, replace an empty body
                            // with an empty JSON body. If a member was required, it will fail slightly later
                            // during the operation construction phase.
                            serde_json::from_slice(b"{}")
                                .map_err(crate::error::GetDocumentationPartsError::unhandled)?
                        } else {
                            serde_json::from_slice(response.body().as_ref())
                                .map_err(crate::error::GetDocumentationPartsError::unhandled)?
                        };

                        output = output.set_message(parsed_body.message);
                        output.build()
                    }),
                },
                "TooManyRequestsException" => crate::error::GetDocumentationPartsError {
                    meta: generic,
                    kind: crate::error::GetDocumentationPartsErrorKind::TooManyRequestsError({
                        #[allow(unused_mut)]
                        let mut output = crate::error::too_many_requests_error::Builder::default();
                        let _ = response;

                        let body_slice = response.body().as_ref();

                        let parsed_body: crate::error::TooManyRequestsError =
                            if body_slice.is_empty() {
                                // To enable JSON parsing to succeed, replace an empty body
                                // with an empty JSON body. If a member was required, it will fail slightly later
                                // during the operation construction phase.
                                serde_json::from_slice(b"{}")
                                    .map_err(crate::error::GetDocumentationPartsError::unhandled)?
                            } else {
                                serde_json::from_slice(response.body().as_ref())
                                    .map_err(crate::error::GetDocumentationPartsError::unhandled)?
                            };

                        output = output.set_retry_after_seconds(
                        
                                                crate::http_serde::deser_header_get_documentation_parts_retry_after_seconds(response.headers())
                                                    .map_err(|_|crate::error::GetDocumentationPartsError::unhandled("Failed to parse retryAfterSeconds from header `Retry-After"))?
                                                
                    );
                        output = output.set_message(parsed_body.message);
                        output.build()
                    }),
                },
                "UnauthorizedException" => crate::error::GetDocumentationPartsError {
                    meta: generic,
                    kind: crate::error::GetDocumentationPartsErrorKind::UnauthorizedError({
                        #[allow(unused_mut)]
                        let mut output = crate::error::unauthorized_error::Builder::default();
                        let _ = response;

                        let body_slice = response.body().as_ref();

                        let parsed_body: crate::error::UnauthorizedError = if body_slice.is_empty()
                        {
                            // To enable JSON parsing to succeed, replace an empty body
                            // with an empty JSON body. If a member was required, it will fail slightly later
                            // during the operation construction phase.
                            serde_json::from_slice(b"{}")
                                .map_err(crate::error::GetDocumentationPartsError::unhandled)?
                        } else {
                            serde_json::from_slice(response.body().as_ref())
                                .map_err(crate::error::GetDocumentationPartsError::unhandled)?
                        };

                        output = output.set_message(parsed_body.message);
                        output.build()
                    }),
                },
                _ => crate::error::GetDocumentationPartsError::generic(generic),
            });
        }
        Ok({
            #[allow(unused_mut)]
            let mut output = crate::output::get_documentation_parts_output::Builder::default();
            let _ = response;

            let body_slice = response.body().as_ref();

            let parsed_body: crate::serializer::GetDocumentationPartsOutputBody =
                if body_slice.is_empty() {
                    // To enable JSON parsing to succeed, replace an empty body
                    // with an empty JSON body. If a member was required, it will fail slightly later
                    // during the operation construction phase.
                    serde_json::from_slice(b"{}")
                        .map_err(crate::error::GetDocumentationPartsError::unhandled)?
                } else {
                    serde_json::from_slice(response.body().as_ref())
                        .map_err(crate::error::GetDocumentationPartsError::unhandled)?
                };

            output = output.set_items(parsed_body.items);
            output = output.set_position(parsed_body.position);
            output.build()
        })
    }
    pub fn parse_response(
        &self,
        response: &http::response::Response<impl AsRef<[u8]>>,
    ) -> Result<crate::output::GetDocumentationPartsOutput, crate::error::GetDocumentationPartsError>
    {
        Self::from_response(&response)
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}

impl smithy_http::response::ParseStrictResponse for GetDocumentationParts {
    type Output = Result<
        crate::output::GetDocumentationPartsOutput,
        crate::error::GetDocumentationPartsError,
    >;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        self.parse_response(response)
    }
}

#[derive(std::clone::Clone)]
pub struct GetDocumentationVersion {
    _private: (),
}
impl GetDocumentationVersion {
    /// Creates a new builder-style object to manufacture [`GetDocumentationVersionInput`](crate::input::GetDocumentationVersionInput)
    pub fn builder() -> crate::input::get_documentation_version_input::Builder {
        crate::input::get_documentation_version_input::Builder::default()
    }
    #[allow(clippy::unnecessary_wraps)]
    fn from_response(
        response: &http::response::Response<impl AsRef<[u8]>>,
    ) -> Result<
        crate::output::GetDocumentationVersionOutput,
        crate::error::GetDocumentationVersionError,
    > {
        if crate::aws_json_errors::is_error(&response) && response.status().as_u16() != 200 {
            let body = serde_json::from_slice(response.body().as_ref())
                .unwrap_or_else(|_| serde_json::json!({}));
            let generic = crate::aws_json_errors::parse_generic_error(&response, &body);

            let error_code = match generic.code() {
                Some(code) => code,
                None => {
                    return Err(crate::error::GetDocumentationVersionError::unhandled(
                        generic,
                    ))
                }
            };
            return Err(match error_code {
                "NotFoundException" => crate::error::GetDocumentationVersionError {
                    meta: generic,
                    kind: crate::error::GetDocumentationVersionErrorKind::NotFoundError({
                        #[allow(unused_mut)]
                        let mut output = crate::error::not_found_error::Builder::default();
                        let _ = response;

                        let body_slice = response.body().as_ref();

                        let parsed_body: crate::error::NotFoundError = if body_slice.is_empty() {
                            // To enable JSON parsing to succeed, replace an empty body
                            // with an empty JSON body. If a member was required, it will fail slightly later
                            // during the operation construction phase.
                            serde_json::from_slice(b"{}")
                                .map_err(crate::error::GetDocumentationVersionError::unhandled)?
                        } else {
                            serde_json::from_slice(response.body().as_ref())
                                .map_err(crate::error::GetDocumentationVersionError::unhandled)?
                        };

                        output = output.set_message(parsed_body.message);
                        output.build()
                    }),
                },
                "TooManyRequestsException" => crate::error::GetDocumentationVersionError {
                    meta: generic,
                    kind: crate::error::GetDocumentationVersionErrorKind::TooManyRequestsError({
                        #[allow(unused_mut)]
                        let mut output = crate::error::too_many_requests_error::Builder::default();
                        let _ = response;

                        let body_slice = response.body().as_ref();

                        let parsed_body: crate::error::TooManyRequestsError = if body_slice
                            .is_empty()
                        {
                            // To enable JSON parsing to succeed, replace an empty body
                            // with an empty JSON body. If a member was required, it will fail slightly later
                            // during the operation construction phase.
                            serde_json::from_slice(b"{}")
                                .map_err(crate::error::GetDocumentationVersionError::unhandled)?
                        } else {
                            serde_json::from_slice(response.body().as_ref())
                                .map_err(crate::error::GetDocumentationVersionError::unhandled)?
                        };

                        output = output.set_retry_after_seconds(
                        
                                                crate::http_serde::deser_header_get_documentation_version_retry_after_seconds(response.headers())
                                                    .map_err(|_|crate::error::GetDocumentationVersionError::unhandled("Failed to parse retryAfterSeconds from header `Retry-After"))?
                                                
                    );
                        output = output.set_message(parsed_body.message);
                        output.build()
                    }),
                },
                "UnauthorizedException" => crate::error::GetDocumentationVersionError {
                    meta: generic,
                    kind: crate::error::GetDocumentationVersionErrorKind::UnauthorizedError({
                        #[allow(unused_mut)]
                        let mut output = crate::error::unauthorized_error::Builder::default();
                        let _ = response;

                        let body_slice = response.body().as_ref();

                        let parsed_body: crate::error::UnauthorizedError = if body_slice.is_empty()
                        {
                            // To enable JSON parsing to succeed, replace an empty body
                            // with an empty JSON body. If a member was required, it will fail slightly later
                            // during the operation construction phase.
                            serde_json::from_slice(b"{}")
                                .map_err(crate::error::GetDocumentationVersionError::unhandled)?
                        } else {
                            serde_json::from_slice(response.body().as_ref())
                                .map_err(crate::error::GetDocumentationVersionError::unhandled)?
                        };

                        output = output.set_message(parsed_body.message);
                        output.build()
                    }),
                },
                _ => crate::error::GetDocumentationVersionError::generic(generic),
            });
        }
        Ok({
            #[allow(unused_mut)]
            let mut output = crate::output::get_documentation_version_output::Builder::default();
            let _ = response;

            let body_slice = response.body().as_ref();

            let parsed_body: crate::serializer::GetDocumentationVersionOutputBody =
                if body_slice.is_empty() {
                    // To enable JSON parsing to succeed, replace an empty body
                    // with an empty JSON body. If a member was required, it will fail slightly later
                    // during the operation construction phase.
                    serde_json::from_slice(b"{}")
                        .map_err(crate::error::GetDocumentationVersionError::unhandled)?
                } else {
                    serde_json::from_slice(response.body().as_ref())
                        .map_err(crate::error::GetDocumentationVersionError::unhandled)?
                };

            output = output.set_version(parsed_body.version);
            output = output.set_created_date(parsed_body.created_date);
            output = output.set_description(parsed_body.description);
            output.build()
        })
    }
    pub fn parse_response(
        &self,
        response: &http::response::Response<impl AsRef<[u8]>>,
    ) -> Result<
        crate::output::GetDocumentationVersionOutput,
        crate::error::GetDocumentationVersionError,
    > {
        Self::from_response(&response)
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}

impl smithy_http::response::ParseStrictResponse for GetDocumentationVersion {
    type Output = Result<
        crate::output::GetDocumentationVersionOutput,
        crate::error::GetDocumentationVersionError,
    >;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        self.parse_response(response)
    }
}

#[derive(std::clone::Clone)]
pub struct GetDocumentationVersions {
    _private: (),
}
impl GetDocumentationVersions {
    /// Creates a new builder-style object to manufacture [`GetDocumentationVersionsInput`](crate::input::GetDocumentationVersionsInput)
    pub fn builder() -> crate::input::get_documentation_versions_input::Builder {
        crate::input::get_documentation_versions_input::Builder::default()
    }
    #[allow(clippy::unnecessary_wraps)]
    fn from_response(
        response: &http::response::Response<impl AsRef<[u8]>>,
    ) -> Result<
        crate::output::GetDocumentationVersionsOutput,
        crate::error::GetDocumentationVersionsError,
    > {
        if crate::aws_json_errors::is_error(&response) && response.status().as_u16() != 200 {
            let body = serde_json::from_slice(response.body().as_ref())
                .unwrap_or_else(|_| serde_json::json!({}));
            let generic = crate::aws_json_errors::parse_generic_error(&response, &body);

            let error_code = match generic.code() {
                Some(code) => code,
                None => {
                    return Err(crate::error::GetDocumentationVersionsError::unhandled(
                        generic,
                    ))
                }
            };
            return Err(match error_code {
                "BadRequestException" => crate::error::GetDocumentationVersionsError {
                    meta: generic,
                    kind: crate::error::GetDocumentationVersionsErrorKind::BadRequestError({
                        #[allow(unused_mut)]
                        let mut output = crate::error::bad_request_error::Builder::default();
                        let _ = response;

                        let body_slice = response.body().as_ref();

                        let parsed_body: crate::error::BadRequestError = if body_slice.is_empty() {
                            // To enable JSON parsing to succeed, replace an empty body
                            // with an empty JSON body. If a member was required, it will fail slightly later
                            // during the operation construction phase.
                            serde_json::from_slice(b"{}")
                                .map_err(crate::error::GetDocumentationVersionsError::unhandled)?
                        } else {
                            serde_json::from_slice(response.body().as_ref())
                                .map_err(crate::error::GetDocumentationVersionsError::unhandled)?
                        };

                        output = output.set_message(parsed_body.message);
                        output.build()
                    }),
                },
                "NotFoundException" => crate::error::GetDocumentationVersionsError {
                    meta: generic,
                    kind: crate::error::GetDocumentationVersionsErrorKind::NotFoundError({
                        #[allow(unused_mut)]
                        let mut output = crate::error::not_found_error::Builder::default();
                        let _ = response;

                        let body_slice = response.body().as_ref();

                        let parsed_body: crate::error::NotFoundError = if body_slice.is_empty() {
                            // To enable JSON parsing to succeed, replace an empty body
                            // with an empty JSON body. If a member was required, it will fail slightly later
                            // during the operation construction phase.
                            serde_json::from_slice(b"{}")
                                .map_err(crate::error::GetDocumentationVersionsError::unhandled)?
                        } else {
                            serde_json::from_slice(response.body().as_ref())
                                .map_err(crate::error::GetDocumentationVersionsError::unhandled)?
                        };

                        output = output.set_message(parsed_body.message);
                        output.build()
                    }),
                },
                "TooManyRequestsException" => crate::error::GetDocumentationVersionsError {
                    meta: generic,
                    kind: crate::error::GetDocumentationVersionsErrorKind::TooManyRequestsError({
                        #[allow(unused_mut)]
                        let mut output = crate::error::too_many_requests_error::Builder::default();
                        let _ = response;

                        let body_slice = response.body().as_ref();

                        let parsed_body: crate::error::TooManyRequestsError = if body_slice
                            .is_empty()
                        {
                            // To enable JSON parsing to succeed, replace an empty body
                            // with an empty JSON body. If a member was required, it will fail slightly later
                            // during the operation construction phase.
                            serde_json::from_slice(b"{}")
                                .map_err(crate::error::GetDocumentationVersionsError::unhandled)?
                        } else {
                            serde_json::from_slice(response.body().as_ref())
                                .map_err(crate::error::GetDocumentationVersionsError::unhandled)?
                        };

                        output = output.set_retry_after_seconds(
                        
                                                crate::http_serde::deser_header_get_documentation_versions_retry_after_seconds(response.headers())
                                                    .map_err(|_|crate::error::GetDocumentationVersionsError::unhandled("Failed to parse retryAfterSeconds from header `Retry-After"))?
                                                
                    );
                        output = output.set_message(parsed_body.message);
                        output.build()
                    }),
                },
                "UnauthorizedException" => crate::error::GetDocumentationVersionsError {
                    meta: generic,
                    kind: crate::error::GetDocumentationVersionsErrorKind::UnauthorizedError({
                        #[allow(unused_mut)]
                        let mut output = crate::error::unauthorized_error::Builder::default();
                        let _ = response;

                        let body_slice = response.body().as_ref();

                        let parsed_body: crate::error::UnauthorizedError = if body_slice.is_empty()
                        {
                            // To enable JSON parsing to succeed, replace an empty body
                            // with an empty JSON body. If a member was required, it will fail slightly later
                            // during the operation construction phase.
                            serde_json::from_slice(b"{}")
                                .map_err(crate::error::GetDocumentationVersionsError::unhandled)?
                        } else {
                            serde_json::from_slice(response.body().as_ref())
                                .map_err(crate::error::GetDocumentationVersionsError::unhandled)?
                        };

                        output = output.set_message(parsed_body.message);
                        output.build()
                    }),
                },
                _ => crate::error::GetDocumentationVersionsError::generic(generic),
            });
        }
        Ok({
            #[allow(unused_mut)]
            let mut output = crate::output::get_documentation_versions_output::Builder::default();
            let _ = response;

            let body_slice = response.body().as_ref();

            let parsed_body: crate::serializer::GetDocumentationVersionsOutputBody =
                if body_slice.is_empty() {
                    // To enable JSON parsing to succeed, replace an empty body
                    // with an empty JSON body. If a member was required, it will fail slightly later
                    // during the operation construction phase.
                    serde_json::from_slice(b"{}")
                        .map_err(crate::error::GetDocumentationVersionsError::unhandled)?
                } else {
                    serde_json::from_slice(response.body().as_ref())
                        .map_err(crate::error::GetDocumentationVersionsError::unhandled)?
                };

            output = output.set_items(parsed_body.items);
            output = output.set_position(parsed_body.position);
            output.build()
        })
    }
    pub fn parse_response(
        &self,
        response: &http::response::Response<impl AsRef<[u8]>>,
    ) -> Result<
        crate::output::GetDocumentationVersionsOutput,
        crate::error::GetDocumentationVersionsError,
    > {
        Self::from_response(&response)
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}

impl smithy_http::response::ParseStrictResponse for GetDocumentationVersions {
    type Output = Result<
        crate::output::GetDocumentationVersionsOutput,
        crate::error::GetDocumentationVersionsError,
    >;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        self.parse_response(response)
    }
}

/// <p>Represents a domain name that is contained in a simpler, more intuitive URL that can be called.</p>
#[derive(std::clone::Clone)]
pub struct GetDomainName {
    _private: (),
}
impl GetDomainName {
    /// Creates a new builder-style object to manufacture [`GetDomainNameInput`](crate::input::GetDomainNameInput)
    pub fn builder() -> crate::input::get_domain_name_input::Builder {
        crate::input::get_domain_name_input::Builder::default()
    }
    #[allow(clippy::unnecessary_wraps)]
    fn from_response(
        response: &http::response::Response<impl AsRef<[u8]>>,
    ) -> Result<crate::output::GetDomainNameOutput, crate::error::GetDomainNameError> {
        if crate::aws_json_errors::is_error(&response) && response.status().as_u16() != 200 {
            let body = serde_json::from_slice(response.body().as_ref())
                .unwrap_or_else(|_| serde_json::json!({}));
            let generic = crate::aws_json_errors::parse_generic_error(&response, &body);

            let error_code = match generic.code() {
                Some(code) => code,
                None => return Err(crate::error::GetDomainNameError::unhandled(generic)),
            };
            return Err(match error_code {
                "NotFoundException" => crate::error::GetDomainNameError {
                    meta: generic,
                    kind: crate::error::GetDomainNameErrorKind::NotFoundError({
                        #[allow(unused_mut)]
                        let mut output = crate::error::not_found_error::Builder::default();
                        let _ = response;

                        let body_slice = response.body().as_ref();

                        let parsed_body: crate::error::NotFoundError = if body_slice.is_empty() {
                            // To enable JSON parsing to succeed, replace an empty body
                            // with an empty JSON body. If a member was required, it will fail slightly later
                            // during the operation construction phase.
                            serde_json::from_slice(b"{}")
                                .map_err(crate::error::GetDomainNameError::unhandled)?
                        } else {
                            serde_json::from_slice(response.body().as_ref())
                                .map_err(crate::error::GetDomainNameError::unhandled)?
                        };

                        output = output.set_message(parsed_body.message);
                        output.build()
                    }),
                },
                "ServiceUnavailableException" => {
                    crate::error::GetDomainNameError {
                        meta: generic,
                        kind: crate::error::GetDomainNameErrorKind::ServiceUnavailableError({
                            #[allow(unused_mut)]
                            let mut output =
                                crate::error::service_unavailable_error::Builder::default();
                            let _ = response;

                            let body_slice = response.body().as_ref();

                            let parsed_body: crate::error::ServiceUnavailableError =
                                if body_slice.is_empty() {
                                    // To enable JSON parsing to succeed, replace an empty body
                                    // with an empty JSON body. If a member was required, it will fail slightly later
                                    // during the operation construction phase.
                                    serde_json::from_slice(b"{}")
                                        .map_err(crate::error::GetDomainNameError::unhandled)?
                                } else {
                                    serde_json::from_slice(response.body().as_ref())
                                        .map_err(crate::error::GetDomainNameError::unhandled)?
                                };

                            output = output.set_retry_after_seconds(
                        
                                                crate::http_serde::deser_header_get_domain_name_retry_after_seconds(response.headers())
                                                    .map_err(|_|crate::error::GetDomainNameError::unhandled("Failed to parse retryAfterSeconds from header `Retry-After"))?
                                                
                    );
                            output = output.set_message(parsed_body.message);
                            output.build()
                        }),
                    }
                }
                "TooManyRequestsException" => {
                    crate::error::GetDomainNameError {
                        meta: generic,
                        kind: crate::error::GetDomainNameErrorKind::TooManyRequestsError({
                            #[allow(unused_mut)]
                            let mut output =
                                crate::error::too_many_requests_error::Builder::default();
                            let _ = response;

                            let body_slice = response.body().as_ref();

                            let parsed_body: crate::error::TooManyRequestsError =
                                if body_slice.is_empty() {
                                    // To enable JSON parsing to succeed, replace an empty body
                                    // with an empty JSON body. If a member was required, it will fail slightly later
                                    // during the operation construction phase.
                                    serde_json::from_slice(b"{}")
                                        .map_err(crate::error::GetDomainNameError::unhandled)?
                                } else {
                                    serde_json::from_slice(response.body().as_ref())
                                        .map_err(crate::error::GetDomainNameError::unhandled)?
                                };

                            output = output.set_retry_after_seconds(
                        
                                                crate::http_serde::deser_header_get_domain_name_retry_after_seconds(response.headers())
                                                    .map_err(|_|crate::error::GetDomainNameError::unhandled("Failed to parse retryAfterSeconds from header `Retry-After"))?
                                                
                    );
                            output = output.set_message(parsed_body.message);
                            output.build()
                        }),
                    }
                }
                "UnauthorizedException" => crate::error::GetDomainNameError {
                    meta: generic,
                    kind: crate::error::GetDomainNameErrorKind::UnauthorizedError({
                        #[allow(unused_mut)]
                        let mut output = crate::error::unauthorized_error::Builder::default();
                        let _ = response;

                        let body_slice = response.body().as_ref();

                        let parsed_body: crate::error::UnauthorizedError = if body_slice.is_empty()
                        {
                            // To enable JSON parsing to succeed, replace an empty body
                            // with an empty JSON body. If a member was required, it will fail slightly later
                            // during the operation construction phase.
                            serde_json::from_slice(b"{}")
                                .map_err(crate::error::GetDomainNameError::unhandled)?
                        } else {
                            serde_json::from_slice(response.body().as_ref())
                                .map_err(crate::error::GetDomainNameError::unhandled)?
                        };

                        output = output.set_message(parsed_body.message);
                        output.build()
                    }),
                },
                _ => crate::error::GetDomainNameError::generic(generic),
            });
        }
        Ok({
            #[allow(unused_mut)]
            let mut output = crate::output::get_domain_name_output::Builder::default();
            let _ = response;

            let body_slice = response.body().as_ref();

            let parsed_body: crate::serializer::GetDomainNameOutputBody = if body_slice.is_empty() {
                // To enable JSON parsing to succeed, replace an empty body
                // with an empty JSON body. If a member was required, it will fail slightly later
                // during the operation construction phase.
                serde_json::from_slice(b"{}")
                    .map_err(crate::error::GetDomainNameError::unhandled)?
            } else {
                serde_json::from_slice(response.body().as_ref())
                    .map_err(crate::error::GetDomainNameError::unhandled)?
            };

            output = output.set_domain_name(parsed_body.domain_name);
            output = output.set_certificate_name(parsed_body.certificate_name);
            output = output.set_certificate_arn(parsed_body.certificate_arn);
            output = output.set_certificate_upload_date(parsed_body.certificate_upload_date);
            output = output.set_regional_domain_name(parsed_body.regional_domain_name);
            output = output.set_regional_hosted_zone_id(parsed_body.regional_hosted_zone_id);
            output = output.set_regional_certificate_name(parsed_body.regional_certificate_name);
            output = output.set_regional_certificate_arn(parsed_body.regional_certificate_arn);
            output = output.set_distribution_domain_name(parsed_body.distribution_domain_name);
            output =
                output.set_distribution_hosted_zone_id(parsed_body.distribution_hosted_zone_id);
            output = output.set_endpoint_configuration(parsed_body.endpoint_configuration);
            output = output.set_domain_name_status(parsed_body.domain_name_status);
            output = output.set_domain_name_status_message(parsed_body.domain_name_status_message);
            output = output.set_security_policy(parsed_body.security_policy);
            output = output.set_tags(parsed_body.tags);
            output = output.set_mutual_tls_authentication(parsed_body.mutual_tls_authentication);
            output.build()
        })
    }
    pub fn parse_response(
        &self,
        response: &http::response::Response<impl AsRef<[u8]>>,
    ) -> Result<crate::output::GetDomainNameOutput, crate::error::GetDomainNameError> {
        Self::from_response(&response)
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}

impl smithy_http::response::ParseStrictResponse for GetDomainName {
    type Output = Result<crate::output::GetDomainNameOutput, crate::error::GetDomainNameError>;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        self.parse_response(response)
    }
}

/// <p>Represents a collection of <a>DomainName</a> resources.</p>
#[derive(std::clone::Clone)]
pub struct GetDomainNames {
    _private: (),
}
impl GetDomainNames {
    /// Creates a new builder-style object to manufacture [`GetDomainNamesInput`](crate::input::GetDomainNamesInput)
    pub fn builder() -> crate::input::get_domain_names_input::Builder {
        crate::input::get_domain_names_input::Builder::default()
    }
    #[allow(clippy::unnecessary_wraps)]
    fn from_response(
        response: &http::response::Response<impl AsRef<[u8]>>,
    ) -> Result<crate::output::GetDomainNamesOutput, crate::error::GetDomainNamesError> {
        if crate::aws_json_errors::is_error(&response) && response.status().as_u16() != 200 {
            let body = serde_json::from_slice(response.body().as_ref())
                .unwrap_or_else(|_| serde_json::json!({}));
            let generic = crate::aws_json_errors::parse_generic_error(&response, &body);

            let error_code = match generic.code() {
                Some(code) => code,
                None => return Err(crate::error::GetDomainNamesError::unhandled(generic)),
            };
            return Err(match error_code {
                "BadRequestException" => crate::error::GetDomainNamesError {
                    meta: generic,
                    kind: crate::error::GetDomainNamesErrorKind::BadRequestError({
                        #[allow(unused_mut)]
                        let mut output = crate::error::bad_request_error::Builder::default();
                        let _ = response;

                        let body_slice = response.body().as_ref();

                        let parsed_body: crate::error::BadRequestError = if body_slice.is_empty() {
                            // To enable JSON parsing to succeed, replace an empty body
                            // with an empty JSON body. If a member was required, it will fail slightly later
                            // during the operation construction phase.
                            serde_json::from_slice(b"{}")
                                .map_err(crate::error::GetDomainNamesError::unhandled)?
                        } else {
                            serde_json::from_slice(response.body().as_ref())
                                .map_err(crate::error::GetDomainNamesError::unhandled)?
                        };

                        output = output.set_message(parsed_body.message);
                        output.build()
                    }),
                },
                "TooManyRequestsException" => {
                    crate::error::GetDomainNamesError {
                        meta: generic,
                        kind: crate::error::GetDomainNamesErrorKind::TooManyRequestsError({
                            #[allow(unused_mut)]
                            let mut output =
                                crate::error::too_many_requests_error::Builder::default();
                            let _ = response;

                            let body_slice = response.body().as_ref();

                            let parsed_body: crate::error::TooManyRequestsError =
                                if body_slice.is_empty() {
                                    // To enable JSON parsing to succeed, replace an empty body
                                    // with an empty JSON body. If a member was required, it will fail slightly later
                                    // during the operation construction phase.
                                    serde_json::from_slice(b"{}")
                                        .map_err(crate::error::GetDomainNamesError::unhandled)?
                                } else {
                                    serde_json::from_slice(response.body().as_ref())
                                        .map_err(crate::error::GetDomainNamesError::unhandled)?
                                };

                            output = output.set_retry_after_seconds(
                        
                                                crate::http_serde::deser_header_get_domain_names_retry_after_seconds(response.headers())
                                                    .map_err(|_|crate::error::GetDomainNamesError::unhandled("Failed to parse retryAfterSeconds from header `Retry-After"))?
                                                
                    );
                            output = output.set_message(parsed_body.message);
                            output.build()
                        }),
                    }
                }
                "UnauthorizedException" => crate::error::GetDomainNamesError {
                    meta: generic,
                    kind: crate::error::GetDomainNamesErrorKind::UnauthorizedError({
                        #[allow(unused_mut)]
                        let mut output = crate::error::unauthorized_error::Builder::default();
                        let _ = response;

                        let body_slice = response.body().as_ref();

                        let parsed_body: crate::error::UnauthorizedError = if body_slice.is_empty()
                        {
                            // To enable JSON parsing to succeed, replace an empty body
                            // with an empty JSON body. If a member was required, it will fail slightly later
                            // during the operation construction phase.
                            serde_json::from_slice(b"{}")
                                .map_err(crate::error::GetDomainNamesError::unhandled)?
                        } else {
                            serde_json::from_slice(response.body().as_ref())
                                .map_err(crate::error::GetDomainNamesError::unhandled)?
                        };

                        output = output.set_message(parsed_body.message);
                        output.build()
                    }),
                },
                _ => crate::error::GetDomainNamesError::generic(generic),
            });
        }
        Ok({
            #[allow(unused_mut)]
            let mut output = crate::output::get_domain_names_output::Builder::default();
            let _ = response;

            let body_slice = response.body().as_ref();

            let parsed_body: crate::serializer::GetDomainNamesOutputBody = if body_slice.is_empty()
            {
                // To enable JSON parsing to succeed, replace an empty body
                // with an empty JSON body. If a member was required, it will fail slightly later
                // during the operation construction phase.
                serde_json::from_slice(b"{}")
                    .map_err(crate::error::GetDomainNamesError::unhandled)?
            } else {
                serde_json::from_slice(response.body().as_ref())
                    .map_err(crate::error::GetDomainNamesError::unhandled)?
            };

            output = output.set_items(parsed_body.items);
            output = output.set_position(parsed_body.position);
            output.build()
        })
    }
    pub fn parse_response(
        &self,
        response: &http::response::Response<impl AsRef<[u8]>>,
    ) -> Result<crate::output::GetDomainNamesOutput, crate::error::GetDomainNamesError> {
        Self::from_response(&response)
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}

impl smithy_http::response::ParseStrictResponse for GetDomainNames {
    type Output = Result<crate::output::GetDomainNamesOutput, crate::error::GetDomainNamesError>;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        self.parse_response(response)
    }
}

/// <p>Exports a deployed version of a <a>RestApi</a> in a specified format.</p>
#[derive(std::clone::Clone)]
pub struct GetExport {
    _private: (),
}
impl GetExport {
    /// Creates a new builder-style object to manufacture [`GetExportInput`](crate::input::GetExportInput)
    pub fn builder() -> crate::input::get_export_input::Builder {
        crate::input::get_export_input::Builder::default()
    }
    #[allow(clippy::unnecessary_wraps)]
    fn from_response(
        response: &http::response::Response<impl AsRef<[u8]>>,
    ) -> Result<crate::output::GetExportOutput, crate::error::GetExportError> {
        if crate::aws_json_errors::is_error(&response) && response.status().as_u16() != 200 {
            let body = serde_json::from_slice(response.body().as_ref())
                .unwrap_or_else(|_| serde_json::json!({}));
            let generic = crate::aws_json_errors::parse_generic_error(&response, &body);

            let error_code = match generic.code() {
                Some(code) => code,
                None => return Err(crate::error::GetExportError::unhandled(generic)),
            };
            return Err(match error_code {
                "BadRequestException" => crate::error::GetExportError {
                    meta: generic,
                    kind: crate::error::GetExportErrorKind::BadRequestError({
                        #[allow(unused_mut)]
                        let mut output = crate::error::bad_request_error::Builder::default();
                        let _ = response;

                        let body_slice = response.body().as_ref();

                        let parsed_body: crate::error::BadRequestError = if body_slice.is_empty() {
                            // To enable JSON parsing to succeed, replace an empty body
                            // with an empty JSON body. If a member was required, it will fail slightly later
                            // during the operation construction phase.
                            serde_json::from_slice(b"{}")
                                .map_err(crate::error::GetExportError::unhandled)?
                        } else {
                            serde_json::from_slice(response.body().as_ref())
                                .map_err(crate::error::GetExportError::unhandled)?
                        };

                        output = output.set_message(parsed_body.message);
                        output.build()
                    }),
                },
                "ConflictException" => crate::error::GetExportError {
                    meta: generic,
                    kind: crate::error::GetExportErrorKind::ConflictError({
                        #[allow(unused_mut)]
                        let mut output = crate::error::conflict_error::Builder::default();
                        let _ = response;

                        let body_slice = response.body().as_ref();

                        let parsed_body: crate::error::ConflictError = if body_slice.is_empty() {
                            // To enable JSON parsing to succeed, replace an empty body
                            // with an empty JSON body. If a member was required, it will fail slightly later
                            // during the operation construction phase.
                            serde_json::from_slice(b"{}")
                                .map_err(crate::error::GetExportError::unhandled)?
                        } else {
                            serde_json::from_slice(response.body().as_ref())
                                .map_err(crate::error::GetExportError::unhandled)?
                        };

                        output = output.set_message(parsed_body.message);
                        output.build()
                    }),
                },
                "NotFoundException" => crate::error::GetExportError {
                    meta: generic,
                    kind: crate::error::GetExportErrorKind::NotFoundError({
                        #[allow(unused_mut)]
                        let mut output = crate::error::not_found_error::Builder::default();
                        let _ = response;

                        let body_slice = response.body().as_ref();

                        let parsed_body: crate::error::NotFoundError = if body_slice.is_empty() {
                            // To enable JSON parsing to succeed, replace an empty body
                            // with an empty JSON body. If a member was required, it will fail slightly later
                            // during the operation construction phase.
                            serde_json::from_slice(b"{}")
                                .map_err(crate::error::GetExportError::unhandled)?
                        } else {
                            serde_json::from_slice(response.body().as_ref())
                                .map_err(crate::error::GetExportError::unhandled)?
                        };

                        output = output.set_message(parsed_body.message);
                        output.build()
                    }),
                },
                "TooManyRequestsException" => {
                    crate::error::GetExportError {
                        meta: generic,
                        kind: crate::error::GetExportErrorKind::TooManyRequestsError({
                            #[allow(unused_mut)]
                            let mut output =
                                crate::error::too_many_requests_error::Builder::default();
                            let _ = response;

                            let body_slice = response.body().as_ref();

                            let parsed_body: crate::error::TooManyRequestsError =
                                if body_slice.is_empty() {
                                    // To enable JSON parsing to succeed, replace an empty body
                                    // with an empty JSON body. If a member was required, it will fail slightly later
                                    // during the operation construction phase.
                                    serde_json::from_slice(b"{}")
                                        .map_err(crate::error::GetExportError::unhandled)?
                                } else {
                                    serde_json::from_slice(response.body().as_ref())
                                        .map_err(crate::error::GetExportError::unhandled)?
                                };

                            output = output.set_retry_after_seconds(
                        
                                                crate::http_serde::deser_header_get_export_retry_after_seconds(response.headers())
                                                    .map_err(|_|crate::error::GetExportError::unhandled("Failed to parse retryAfterSeconds from header `Retry-After"))?
                                                
                    );
                            output = output.set_message(parsed_body.message);
                            output.build()
                        }),
                    }
                }
                "UnauthorizedException" => crate::error::GetExportError {
                    meta: generic,
                    kind: crate::error::GetExportErrorKind::UnauthorizedError({
                        #[allow(unused_mut)]
                        let mut output = crate::error::unauthorized_error::Builder::default();
                        let _ = response;

                        let body_slice = response.body().as_ref();

                        let parsed_body: crate::error::UnauthorizedError = if body_slice.is_empty()
                        {
                            // To enable JSON parsing to succeed, replace an empty body
                            // with an empty JSON body. If a member was required, it will fail slightly later
                            // during the operation construction phase.
                            serde_json::from_slice(b"{}")
                                .map_err(crate::error::GetExportError::unhandled)?
                        } else {
                            serde_json::from_slice(response.body().as_ref())
                                .map_err(crate::error::GetExportError::unhandled)?
                        };

                        output = output.set_message(parsed_body.message);
                        output.build()
                    }),
                },
                _ => crate::error::GetExportError::generic(generic),
            });
        }
        Ok({
            #[allow(unused_mut)]
            let mut output = crate::output::get_export_output::Builder::default();
            let _ = response;
            output = output.set_content_type(
                crate::http_serde::deser_header_get_export_content_type(response.headers())
                    .map_err(|_| {
                        crate::error::GetExportError::unhandled(
                            "Failed to parse contentType from header `Content-Type",
                        )
                    })?,
            );
            output = output.set_content_disposition(
                crate::http_serde::deser_header_get_export_content_disposition(response.headers())
                    .map_err(|_| {
                        crate::error::GetExportError::unhandled(
                            "Failed to parse contentDisposition from header `Content-Disposition",
                        )
                    })?,
            );
            output = output.set_body(crate::http_serde::deser_payload_get_export_body(
                response.body().as_ref(),
            )?);
            output.build()
        })
    }
    pub fn parse_response(
        &self,
        response: &http::response::Response<impl AsRef<[u8]>>,
    ) -> Result<crate::output::GetExportOutput, crate::error::GetExportError> {
        Self::from_response(&response)
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}

impl smithy_http::response::ParseStrictResponse for GetExport {
    type Output = Result<crate::output::GetExportOutput, crate::error::GetExportError>;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        self.parse_response(response)
    }
}

/// <p>Gets a <a>GatewayResponse</a> of a specified response type on the given <a>RestApi</a>.</p>
#[derive(std::clone::Clone)]
pub struct GetGatewayResponse {
    _private: (),
}
impl GetGatewayResponse {
    /// Creates a new builder-style object to manufacture [`GetGatewayResponseInput`](crate::input::GetGatewayResponseInput)
    pub fn builder() -> crate::input::get_gateway_response_input::Builder {
        crate::input::get_gateway_response_input::Builder::default()
    }
    #[allow(clippy::unnecessary_wraps)]
    fn from_response(
        response: &http::response::Response<impl AsRef<[u8]>>,
    ) -> Result<crate::output::GetGatewayResponseOutput, crate::error::GetGatewayResponseError>
    {
        if crate::aws_json_errors::is_error(&response) && response.status().as_u16() != 200 {
            let body = serde_json::from_slice(response.body().as_ref())
                .unwrap_or_else(|_| serde_json::json!({}));
            let generic = crate::aws_json_errors::parse_generic_error(&response, &body);

            let error_code = match generic.code() {
                Some(code) => code,
                None => return Err(crate::error::GetGatewayResponseError::unhandled(generic)),
            };
            return Err(match error_code {
                "NotFoundException" => crate::error::GetGatewayResponseError {
                    meta: generic,
                    kind: crate::error::GetGatewayResponseErrorKind::NotFoundError({
                        #[allow(unused_mut)]
                        let mut output = crate::error::not_found_error::Builder::default();
                        let _ = response;

                        let body_slice = response.body().as_ref();

                        let parsed_body: crate::error::NotFoundError = if body_slice.is_empty() {
                            // To enable JSON parsing to succeed, replace an empty body
                            // with an empty JSON body. If a member was required, it will fail slightly later
                            // during the operation construction phase.
                            serde_json::from_slice(b"{}")
                                .map_err(crate::error::GetGatewayResponseError::unhandled)?
                        } else {
                            serde_json::from_slice(response.body().as_ref())
                                .map_err(crate::error::GetGatewayResponseError::unhandled)?
                        };

                        output = output.set_message(parsed_body.message);
                        output.build()
                    }),
                },
                "TooManyRequestsException" => crate::error::GetGatewayResponseError {
                    meta: generic,
                    kind: crate::error::GetGatewayResponseErrorKind::TooManyRequestsError({
                        #[allow(unused_mut)]
                        let mut output = crate::error::too_many_requests_error::Builder::default();
                        let _ = response;

                        let body_slice = response.body().as_ref();

                        let parsed_body: crate::error::TooManyRequestsError =
                            if body_slice.is_empty() {
                                // To enable JSON parsing to succeed, replace an empty body
                                // with an empty JSON body. If a member was required, it will fail slightly later
                                // during the operation construction phase.
                                serde_json::from_slice(b"{}")
                                    .map_err(crate::error::GetGatewayResponseError::unhandled)?
                            } else {
                                serde_json::from_slice(response.body().as_ref())
                                    .map_err(crate::error::GetGatewayResponseError::unhandled)?
                            };

                        output = output.set_retry_after_seconds(
                        
                                                crate::http_serde::deser_header_get_gateway_response_retry_after_seconds(response.headers())
                                                    .map_err(|_|crate::error::GetGatewayResponseError::unhandled("Failed to parse retryAfterSeconds from header `Retry-After"))?
                                                
                    );
                        output = output.set_message(parsed_body.message);
                        output.build()
                    }),
                },
                "UnauthorizedException" => crate::error::GetGatewayResponseError {
                    meta: generic,
                    kind: crate::error::GetGatewayResponseErrorKind::UnauthorizedError({
                        #[allow(unused_mut)]
                        let mut output = crate::error::unauthorized_error::Builder::default();
                        let _ = response;

                        let body_slice = response.body().as_ref();

                        let parsed_body: crate::error::UnauthorizedError = if body_slice.is_empty()
                        {
                            // To enable JSON parsing to succeed, replace an empty body
                            // with an empty JSON body. If a member was required, it will fail slightly later
                            // during the operation construction phase.
                            serde_json::from_slice(b"{}")
                                .map_err(crate::error::GetGatewayResponseError::unhandled)?
                        } else {
                            serde_json::from_slice(response.body().as_ref())
                                .map_err(crate::error::GetGatewayResponseError::unhandled)?
                        };

                        output = output.set_message(parsed_body.message);
                        output.build()
                    }),
                },
                _ => crate::error::GetGatewayResponseError::generic(generic),
            });
        }
        Ok({
            #[allow(unused_mut)]
            let mut output = crate::output::get_gateway_response_output::Builder::default();
            let _ = response;

            let body_slice = response.body().as_ref();

            let parsed_body: crate::serializer::GetGatewayResponseOutputBody =
                if body_slice.is_empty() {
                    // To enable JSON parsing to succeed, replace an empty body
                    // with an empty JSON body. If a member was required, it will fail slightly later
                    // during the operation construction phase.
                    serde_json::from_slice(b"{}")
                        .map_err(crate::error::GetGatewayResponseError::unhandled)?
                } else {
                    serde_json::from_slice(response.body().as_ref())
                        .map_err(crate::error::GetGatewayResponseError::unhandled)?
                };

            output = output.set_response_type(parsed_body.response_type);
            output = output.set_status_code(parsed_body.status_code);
            output = output.set_response_parameters(parsed_body.response_parameters);
            output = output.set_response_templates(parsed_body.response_templates);
            output = output.set_default_response(parsed_body.default_response);
            output.build()
        })
    }
    pub fn parse_response(
        &self,
        response: &http::response::Response<impl AsRef<[u8]>>,
    ) -> Result<crate::output::GetGatewayResponseOutput, crate::error::GetGatewayResponseError>
    {
        Self::from_response(&response)
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}

impl smithy_http::response::ParseStrictResponse for GetGatewayResponse {
    type Output =
        Result<crate::output::GetGatewayResponseOutput, crate::error::GetGatewayResponseError>;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        self.parse_response(response)
    }
}

/// <p>Gets the <a>GatewayResponses</a> collection on the given <a>RestApi</a>. If an API developer has not added any definitions for gateway responses, the result will be the API Gateway-generated default <a>GatewayResponses</a> collection for the supported response types.</p>
#[derive(std::clone::Clone)]
pub struct GetGatewayResponses {
    _private: (),
}
impl GetGatewayResponses {
    /// Creates a new builder-style object to manufacture [`GetGatewayResponsesInput`](crate::input::GetGatewayResponsesInput)
    pub fn builder() -> crate::input::get_gateway_responses_input::Builder {
        crate::input::get_gateway_responses_input::Builder::default()
    }
    #[allow(clippy::unnecessary_wraps)]
    fn from_response(
        response: &http::response::Response<impl AsRef<[u8]>>,
    ) -> Result<crate::output::GetGatewayResponsesOutput, crate::error::GetGatewayResponsesError>
    {
        if crate::aws_json_errors::is_error(&response) && response.status().as_u16() != 200 {
            let body = serde_json::from_slice(response.body().as_ref())
                .unwrap_or_else(|_| serde_json::json!({}));
            let generic = crate::aws_json_errors::parse_generic_error(&response, &body);

            let error_code = match generic.code() {
                Some(code) => code,
                None => return Err(crate::error::GetGatewayResponsesError::unhandled(generic)),
            };
            return Err(match error_code {
                "BadRequestException" => crate::error::GetGatewayResponsesError {
                    meta: generic,
                    kind: crate::error::GetGatewayResponsesErrorKind::BadRequestError({
                        #[allow(unused_mut)]
                        let mut output = crate::error::bad_request_error::Builder::default();
                        let _ = response;

                        let body_slice = response.body().as_ref();

                        let parsed_body: crate::error::BadRequestError = if body_slice.is_empty() {
                            // To enable JSON parsing to succeed, replace an empty body
                            // with an empty JSON body. If a member was required, it will fail slightly later
                            // during the operation construction phase.
                            serde_json::from_slice(b"{}")
                                .map_err(crate::error::GetGatewayResponsesError::unhandled)?
                        } else {
                            serde_json::from_slice(response.body().as_ref())
                                .map_err(crate::error::GetGatewayResponsesError::unhandled)?
                        };

                        output = output.set_message(parsed_body.message);
                        output.build()
                    }),
                },
                "NotFoundException" => crate::error::GetGatewayResponsesError {
                    meta: generic,
                    kind: crate::error::GetGatewayResponsesErrorKind::NotFoundError({
                        #[allow(unused_mut)]
                        let mut output = crate::error::not_found_error::Builder::default();
                        let _ = response;

                        let body_slice = response.body().as_ref();

                        let parsed_body: crate::error::NotFoundError = if body_slice.is_empty() {
                            // To enable JSON parsing to succeed, replace an empty body
                            // with an empty JSON body. If a member was required, it will fail slightly later
                            // during the operation construction phase.
                            serde_json::from_slice(b"{}")
                                .map_err(crate::error::GetGatewayResponsesError::unhandled)?
                        } else {
                            serde_json::from_slice(response.body().as_ref())
                                .map_err(crate::error::GetGatewayResponsesError::unhandled)?
                        };

                        output = output.set_message(parsed_body.message);
                        output.build()
                    }),
                },
                "TooManyRequestsException" => crate::error::GetGatewayResponsesError {
                    meta: generic,
                    kind: crate::error::GetGatewayResponsesErrorKind::TooManyRequestsError({
                        #[allow(unused_mut)]
                        let mut output = crate::error::too_many_requests_error::Builder::default();
                        let _ = response;

                        let body_slice = response.body().as_ref();

                        let parsed_body: crate::error::TooManyRequestsError =
                            if body_slice.is_empty() {
                                // To enable JSON parsing to succeed, replace an empty body
                                // with an empty JSON body. If a member was required, it will fail slightly later
                                // during the operation construction phase.
                                serde_json::from_slice(b"{}")
                                    .map_err(crate::error::GetGatewayResponsesError::unhandled)?
                            } else {
                                serde_json::from_slice(response.body().as_ref())
                                    .map_err(crate::error::GetGatewayResponsesError::unhandled)?
                            };

                        output = output.set_retry_after_seconds(
                        
                                                crate::http_serde::deser_header_get_gateway_responses_retry_after_seconds(response.headers())
                                                    .map_err(|_|crate::error::GetGatewayResponsesError::unhandled("Failed to parse retryAfterSeconds from header `Retry-After"))?
                                                
                    );
                        output = output.set_message(parsed_body.message);
                        output.build()
                    }),
                },
                "UnauthorizedException" => crate::error::GetGatewayResponsesError {
                    meta: generic,
                    kind: crate::error::GetGatewayResponsesErrorKind::UnauthorizedError({
                        #[allow(unused_mut)]
                        let mut output = crate::error::unauthorized_error::Builder::default();
                        let _ = response;

                        let body_slice = response.body().as_ref();

                        let parsed_body: crate::error::UnauthorizedError = if body_slice.is_empty()
                        {
                            // To enable JSON parsing to succeed, replace an empty body
                            // with an empty JSON body. If a member was required, it will fail slightly later
                            // during the operation construction phase.
                            serde_json::from_slice(b"{}")
                                .map_err(crate::error::GetGatewayResponsesError::unhandled)?
                        } else {
                            serde_json::from_slice(response.body().as_ref())
                                .map_err(crate::error::GetGatewayResponsesError::unhandled)?
                        };

                        output = output.set_message(parsed_body.message);
                        output.build()
                    }),
                },
                _ => crate::error::GetGatewayResponsesError::generic(generic),
            });
        }
        Ok({
            #[allow(unused_mut)]
            let mut output = crate::output::get_gateway_responses_output::Builder::default();
            let _ = response;

            let body_slice = response.body().as_ref();

            let parsed_body: crate::serializer::GetGatewayResponsesOutputBody =
                if body_slice.is_empty() {
                    // To enable JSON parsing to succeed, replace an empty body
                    // with an empty JSON body. If a member was required, it will fail slightly later
                    // during the operation construction phase.
                    serde_json::from_slice(b"{}")
                        .map_err(crate::error::GetGatewayResponsesError::unhandled)?
                } else {
                    serde_json::from_slice(response.body().as_ref())
                        .map_err(crate::error::GetGatewayResponsesError::unhandled)?
                };

            output = output.set_items(parsed_body.items);
            output = output.set_position(parsed_body.position);
            output.build()
        })
    }
    pub fn parse_response(
        &self,
        response: &http::response::Response<impl AsRef<[u8]>>,
    ) -> Result<crate::output::GetGatewayResponsesOutput, crate::error::GetGatewayResponsesError>
    {
        Self::from_response(&response)
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}

impl smithy_http::response::ParseStrictResponse for GetGatewayResponses {
    type Output =
        Result<crate::output::GetGatewayResponsesOutput, crate::error::GetGatewayResponsesError>;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        self.parse_response(response)
    }
}

/// <p>Get the integration settings.</p>
#[derive(std::clone::Clone)]
pub struct GetIntegration {
    _private: (),
}
impl GetIntegration {
    /// Creates a new builder-style object to manufacture [`GetIntegrationInput`](crate::input::GetIntegrationInput)
    pub fn builder() -> crate::input::get_integration_input::Builder {
        crate::input::get_integration_input::Builder::default()
    }
    #[allow(clippy::unnecessary_wraps)]
    fn from_response(
        response: &http::response::Response<impl AsRef<[u8]>>,
    ) -> Result<crate::output::GetIntegrationOutput, crate::error::GetIntegrationError> {
        if crate::aws_json_errors::is_error(&response) && response.status().as_u16() != 200 {
            let body = serde_json::from_slice(response.body().as_ref())
                .unwrap_or_else(|_| serde_json::json!({}));
            let generic = crate::aws_json_errors::parse_generic_error(&response, &body);

            let error_code = match generic.code() {
                Some(code) => code,
                None => return Err(crate::error::GetIntegrationError::unhandled(generic)),
            };
            return Err(match error_code {
                "NotFoundException" => crate::error::GetIntegrationError {
                    meta: generic,
                    kind: crate::error::GetIntegrationErrorKind::NotFoundError({
                        #[allow(unused_mut)]
                        let mut output = crate::error::not_found_error::Builder::default();
                        let _ = response;

                        let body_slice = response.body().as_ref();

                        let parsed_body: crate::error::NotFoundError = if body_slice.is_empty() {
                            // To enable JSON parsing to succeed, replace an empty body
                            // with an empty JSON body. If a member was required, it will fail slightly later
                            // during the operation construction phase.
                            serde_json::from_slice(b"{}")
                                .map_err(crate::error::GetIntegrationError::unhandled)?
                        } else {
                            serde_json::from_slice(response.body().as_ref())
                                .map_err(crate::error::GetIntegrationError::unhandled)?
                        };

                        output = output.set_message(parsed_body.message);
                        output.build()
                    }),
                },
                "TooManyRequestsException" => {
                    crate::error::GetIntegrationError {
                        meta: generic,
                        kind: crate::error::GetIntegrationErrorKind::TooManyRequestsError({
                            #[allow(unused_mut)]
                            let mut output =
                                crate::error::too_many_requests_error::Builder::default();
                            let _ = response;

                            let body_slice = response.body().as_ref();

                            let parsed_body: crate::error::TooManyRequestsError =
                                if body_slice.is_empty() {
                                    // To enable JSON parsing to succeed, replace an empty body
                                    // with an empty JSON body. If a member was required, it will fail slightly later
                                    // during the operation construction phase.
                                    serde_json::from_slice(b"{}")
                                        .map_err(crate::error::GetIntegrationError::unhandled)?
                                } else {
                                    serde_json::from_slice(response.body().as_ref())
                                        .map_err(crate::error::GetIntegrationError::unhandled)?
                                };

                            output = output.set_retry_after_seconds(
                        
                                                crate::http_serde::deser_header_get_integration_retry_after_seconds(response.headers())
                                                    .map_err(|_|crate::error::GetIntegrationError::unhandled("Failed to parse retryAfterSeconds from header `Retry-After"))?
                                                
                    );
                            output = output.set_message(parsed_body.message);
                            output.build()
                        }),
                    }
                }
                "UnauthorizedException" => crate::error::GetIntegrationError {
                    meta: generic,
                    kind: crate::error::GetIntegrationErrorKind::UnauthorizedError({
                        #[allow(unused_mut)]
                        let mut output = crate::error::unauthorized_error::Builder::default();
                        let _ = response;

                        let body_slice = response.body().as_ref();

                        let parsed_body: crate::error::UnauthorizedError = if body_slice.is_empty()
                        {
                            // To enable JSON parsing to succeed, replace an empty body
                            // with an empty JSON body. If a member was required, it will fail slightly later
                            // during the operation construction phase.
                            serde_json::from_slice(b"{}")
                                .map_err(crate::error::GetIntegrationError::unhandled)?
                        } else {
                            serde_json::from_slice(response.body().as_ref())
                                .map_err(crate::error::GetIntegrationError::unhandled)?
                        };

                        output = output.set_message(parsed_body.message);
                        output.build()
                    }),
                },
                _ => crate::error::GetIntegrationError::generic(generic),
            });
        }
        Ok({
            #[allow(unused_mut)]
            let mut output = crate::output::get_integration_output::Builder::default();
            let _ = response;

            let body_slice = response.body().as_ref();

            let parsed_body: crate::serializer::GetIntegrationOutputBody = if body_slice.is_empty()
            {
                // To enable JSON parsing to succeed, replace an empty body
                // with an empty JSON body. If a member was required, it will fail slightly later
                // during the operation construction phase.
                serde_json::from_slice(b"{}")
                    .map_err(crate::error::GetIntegrationError::unhandled)?
            } else {
                serde_json::from_slice(response.body().as_ref())
                    .map_err(crate::error::GetIntegrationError::unhandled)?
            };

            output = output.set_type(parsed_body.r#type);
            output = output.set_http_method(parsed_body.http_method);
            output = output.set_uri(parsed_body.uri);
            output = output.set_connection_type(parsed_body.connection_type);
            output = output.set_connection_id(parsed_body.connection_id);
            output = output.set_credentials(parsed_body.credentials);
            output = output.set_request_parameters(parsed_body.request_parameters);
            output = output.set_request_templates(parsed_body.request_templates);
            output = output.set_passthrough_behavior(parsed_body.passthrough_behavior);
            output = output.set_content_handling(parsed_body.content_handling);
            output = output.set_timeout_in_millis(parsed_body.timeout_in_millis);
            output = output.set_cache_namespace(parsed_body.cache_namespace);
            output = output.set_cache_key_parameters(parsed_body.cache_key_parameters);
            output = output.set_integration_responses(parsed_body.integration_responses);
            output = output.set_tls_config(parsed_body.tls_config);
            output.build()
        })
    }
    pub fn parse_response(
        &self,
        response: &http::response::Response<impl AsRef<[u8]>>,
    ) -> Result<crate::output::GetIntegrationOutput, crate::error::GetIntegrationError> {
        Self::from_response(&response)
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}

impl smithy_http::response::ParseStrictResponse for GetIntegration {
    type Output = Result<crate::output::GetIntegrationOutput, crate::error::GetIntegrationError>;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        self.parse_response(response)
    }
}

/// <p>Represents a get integration response.</p>
#[derive(std::clone::Clone)]
pub struct GetIntegrationResponse {
    _private: (),
}
impl GetIntegrationResponse {
    /// Creates a new builder-style object to manufacture [`GetIntegrationResponseInput`](crate::input::GetIntegrationResponseInput)
    pub fn builder() -> crate::input::get_integration_response_input::Builder {
        crate::input::get_integration_response_input::Builder::default()
    }
    #[allow(clippy::unnecessary_wraps)]
    fn from_response(
        response: &http::response::Response<impl AsRef<[u8]>>,
    ) -> Result<
        crate::output::GetIntegrationResponseOutput,
        crate::error::GetIntegrationResponseError,
    > {
        if crate::aws_json_errors::is_error(&response) && response.status().as_u16() != 200 {
            let body = serde_json::from_slice(response.body().as_ref())
                .unwrap_or_else(|_| serde_json::json!({}));
            let generic = crate::aws_json_errors::parse_generic_error(&response, &body);

            let error_code = match generic.code() {
                Some(code) => code,
                None => {
                    return Err(crate::error::GetIntegrationResponseError::unhandled(
                        generic,
                    ))
                }
            };
            return Err(match error_code {
                "NotFoundException" => crate::error::GetIntegrationResponseError {
                    meta: generic,
                    kind: crate::error::GetIntegrationResponseErrorKind::NotFoundError({
                        #[allow(unused_mut)]
                        let mut output = crate::error::not_found_error::Builder::default();
                        let _ = response;

                        let body_slice = response.body().as_ref();

                        let parsed_body: crate::error::NotFoundError = if body_slice.is_empty() {
                            // To enable JSON parsing to succeed, replace an empty body
                            // with an empty JSON body. If a member was required, it will fail slightly later
                            // during the operation construction phase.
                            serde_json::from_slice(b"{}")
                                .map_err(crate::error::GetIntegrationResponseError::unhandled)?
                        } else {
                            serde_json::from_slice(response.body().as_ref())
                                .map_err(crate::error::GetIntegrationResponseError::unhandled)?
                        };

                        output = output.set_message(parsed_body.message);
                        output.build()
                    }),
                },
                "TooManyRequestsException" => crate::error::GetIntegrationResponseError {
                    meta: generic,
                    kind: crate::error::GetIntegrationResponseErrorKind::TooManyRequestsError({
                        #[allow(unused_mut)]
                        let mut output = crate::error::too_many_requests_error::Builder::default();
                        let _ = response;

                        let body_slice = response.body().as_ref();

                        let parsed_body: crate::error::TooManyRequestsError =
                            if body_slice.is_empty() {
                                // To enable JSON parsing to succeed, replace an empty body
                                // with an empty JSON body. If a member was required, it will fail slightly later
                                // during the operation construction phase.
                                serde_json::from_slice(b"{}")
                                    .map_err(crate::error::GetIntegrationResponseError::unhandled)?
                            } else {
                                serde_json::from_slice(response.body().as_ref())
                                    .map_err(crate::error::GetIntegrationResponseError::unhandled)?
                            };

                        output = output.set_retry_after_seconds(
                        
                                                crate::http_serde::deser_header_get_integration_response_retry_after_seconds(response.headers())
                                                    .map_err(|_|crate::error::GetIntegrationResponseError::unhandled("Failed to parse retryAfterSeconds from header `Retry-After"))?
                                                
                    );
                        output = output.set_message(parsed_body.message);
                        output.build()
                    }),
                },
                "UnauthorizedException" => crate::error::GetIntegrationResponseError {
                    meta: generic,
                    kind: crate::error::GetIntegrationResponseErrorKind::UnauthorizedError({
                        #[allow(unused_mut)]
                        let mut output = crate::error::unauthorized_error::Builder::default();
                        let _ = response;

                        let body_slice = response.body().as_ref();

                        let parsed_body: crate::error::UnauthorizedError = if body_slice.is_empty()
                        {
                            // To enable JSON parsing to succeed, replace an empty body
                            // with an empty JSON body. If a member was required, it will fail slightly later
                            // during the operation construction phase.
                            serde_json::from_slice(b"{}")
                                .map_err(crate::error::GetIntegrationResponseError::unhandled)?
                        } else {
                            serde_json::from_slice(response.body().as_ref())
                                .map_err(crate::error::GetIntegrationResponseError::unhandled)?
                        };

                        output = output.set_message(parsed_body.message);
                        output.build()
                    }),
                },
                _ => crate::error::GetIntegrationResponseError::generic(generic),
            });
        }
        Ok({
            #[allow(unused_mut)]
            let mut output = crate::output::get_integration_response_output::Builder::default();
            let _ = response;

            let body_slice = response.body().as_ref();

            let parsed_body: crate::serializer::GetIntegrationResponseOutputBody =
                if body_slice.is_empty() {
                    // To enable JSON parsing to succeed, replace an empty body
                    // with an empty JSON body. If a member was required, it will fail slightly later
                    // during the operation construction phase.
                    serde_json::from_slice(b"{}")
                        .map_err(crate::error::GetIntegrationResponseError::unhandled)?
                } else {
                    serde_json::from_slice(response.body().as_ref())
                        .map_err(crate::error::GetIntegrationResponseError::unhandled)?
                };

            output = output.set_status_code(parsed_body.status_code);
            output = output.set_selection_pattern(parsed_body.selection_pattern);
            output = output.set_response_parameters(parsed_body.response_parameters);
            output = output.set_response_templates(parsed_body.response_templates);
            output = output.set_content_handling(parsed_body.content_handling);
            output.build()
        })
    }
    pub fn parse_response(
        &self,
        response: &http::response::Response<impl AsRef<[u8]>>,
    ) -> Result<
        crate::output::GetIntegrationResponseOutput,
        crate::error::GetIntegrationResponseError,
    > {
        Self::from_response(&response)
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}

impl smithy_http::response::ParseStrictResponse for GetIntegrationResponse {
    type Output = Result<
        crate::output::GetIntegrationResponseOutput,
        crate::error::GetIntegrationResponseError,
    >;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        self.parse_response(response)
    }
}

/// <p>Describe an existing <a>Method</a> resource.</p>
#[derive(std::clone::Clone)]
pub struct GetMethod {
    _private: (),
}
impl GetMethod {
    /// Creates a new builder-style object to manufacture [`GetMethodInput`](crate::input::GetMethodInput)
    pub fn builder() -> crate::input::get_method_input::Builder {
        crate::input::get_method_input::Builder::default()
    }
    #[allow(clippy::unnecessary_wraps)]
    fn from_response(
        response: &http::response::Response<impl AsRef<[u8]>>,
    ) -> Result<crate::output::GetMethodOutput, crate::error::GetMethodError> {
        if crate::aws_json_errors::is_error(&response) && response.status().as_u16() != 200 {
            let body = serde_json::from_slice(response.body().as_ref())
                .unwrap_or_else(|_| serde_json::json!({}));
            let generic = crate::aws_json_errors::parse_generic_error(&response, &body);

            let error_code = match generic.code() {
                Some(code) => code,
                None => return Err(crate::error::GetMethodError::unhandled(generic)),
            };
            return Err(match error_code {
                "NotFoundException" => crate::error::GetMethodError {
                    meta: generic,
                    kind: crate::error::GetMethodErrorKind::NotFoundError({
                        #[allow(unused_mut)]
                        let mut output = crate::error::not_found_error::Builder::default();
                        let _ = response;

                        let body_slice = response.body().as_ref();

                        let parsed_body: crate::error::NotFoundError = if body_slice.is_empty() {
                            // To enable JSON parsing to succeed, replace an empty body
                            // with an empty JSON body. If a member was required, it will fail slightly later
                            // during the operation construction phase.
                            serde_json::from_slice(b"{}")
                                .map_err(crate::error::GetMethodError::unhandled)?
                        } else {
                            serde_json::from_slice(response.body().as_ref())
                                .map_err(crate::error::GetMethodError::unhandled)?
                        };

                        output = output.set_message(parsed_body.message);
                        output.build()
                    }),
                },
                "TooManyRequestsException" => {
                    crate::error::GetMethodError {
                        meta: generic,
                        kind: crate::error::GetMethodErrorKind::TooManyRequestsError({
                            #[allow(unused_mut)]
                            let mut output =
                                crate::error::too_many_requests_error::Builder::default();
                            let _ = response;

                            let body_slice = response.body().as_ref();

                            let parsed_body: crate::error::TooManyRequestsError =
                                if body_slice.is_empty() {
                                    // To enable JSON parsing to succeed, replace an empty body
                                    // with an empty JSON body. If a member was required, it will fail slightly later
                                    // during the operation construction phase.
                                    serde_json::from_slice(b"{}")
                                        .map_err(crate::error::GetMethodError::unhandled)?
                                } else {
                                    serde_json::from_slice(response.body().as_ref())
                                        .map_err(crate::error::GetMethodError::unhandled)?
                                };

                            output = output.set_retry_after_seconds(
                        
                                                crate::http_serde::deser_header_get_method_retry_after_seconds(response.headers())
                                                    .map_err(|_|crate::error::GetMethodError::unhandled("Failed to parse retryAfterSeconds from header `Retry-After"))?
                                                
                    );
                            output = output.set_message(parsed_body.message);
                            output.build()
                        }),
                    }
                }
                "UnauthorizedException" => crate::error::GetMethodError {
                    meta: generic,
                    kind: crate::error::GetMethodErrorKind::UnauthorizedError({
                        #[allow(unused_mut)]
                        let mut output = crate::error::unauthorized_error::Builder::default();
                        let _ = response;

                        let body_slice = response.body().as_ref();

                        let parsed_body: crate::error::UnauthorizedError = if body_slice.is_empty()
                        {
                            // To enable JSON parsing to succeed, replace an empty body
                            // with an empty JSON body. If a member was required, it will fail slightly later
                            // during the operation construction phase.
                            serde_json::from_slice(b"{}")
                                .map_err(crate::error::GetMethodError::unhandled)?
                        } else {
                            serde_json::from_slice(response.body().as_ref())
                                .map_err(crate::error::GetMethodError::unhandled)?
                        };

                        output = output.set_message(parsed_body.message);
                        output.build()
                    }),
                },
                _ => crate::error::GetMethodError::generic(generic),
            });
        }
        Ok({
            #[allow(unused_mut)]
            let mut output = crate::output::get_method_output::Builder::default();
            let _ = response;

            let body_slice = response.body().as_ref();

            let parsed_body: crate::serializer::GetMethodOutputBody = if body_slice.is_empty() {
                // To enable JSON parsing to succeed, replace an empty body
                // with an empty JSON body. If a member was required, it will fail slightly later
                // during the operation construction phase.
                serde_json::from_slice(b"{}").map_err(crate::error::GetMethodError::unhandled)?
            } else {
                serde_json::from_slice(response.body().as_ref())
                    .map_err(crate::error::GetMethodError::unhandled)?
            };

            output = output.set_http_method(parsed_body.http_method);
            output = output.set_authorization_type(parsed_body.authorization_type);
            output = output.set_authorizer_id(parsed_body.authorizer_id);
            output = output.set_api_key_required(parsed_body.api_key_required);
            output = output.set_request_validator_id(parsed_body.request_validator_id);
            output = output.set_operation_name(parsed_body.operation_name);
            output = output.set_request_parameters(parsed_body.request_parameters);
            output = output.set_request_models(parsed_body.request_models);
            output = output.set_method_responses(parsed_body.method_responses);
            output = output.set_method_integration(parsed_body.method_integration);
            output = output.set_authorization_scopes(parsed_body.authorization_scopes);
            output.build()
        })
    }
    pub fn parse_response(
        &self,
        response: &http::response::Response<impl AsRef<[u8]>>,
    ) -> Result<crate::output::GetMethodOutput, crate::error::GetMethodError> {
        Self::from_response(&response)
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}

impl smithy_http::response::ParseStrictResponse for GetMethod {
    type Output = Result<crate::output::GetMethodOutput, crate::error::GetMethodError>;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        self.parse_response(response)
    }
}

/// <p>Describes a <a>MethodResponse</a> resource.</p>
#[derive(std::clone::Clone)]
pub struct GetMethodResponse {
    _private: (),
}
impl GetMethodResponse {
    /// Creates a new builder-style object to manufacture [`GetMethodResponseInput`](crate::input::GetMethodResponseInput)
    pub fn builder() -> crate::input::get_method_response_input::Builder {
        crate::input::get_method_response_input::Builder::default()
    }
    #[allow(clippy::unnecessary_wraps)]
    fn from_response(
        response: &http::response::Response<impl AsRef<[u8]>>,
    ) -> Result<crate::output::GetMethodResponseOutput, crate::error::GetMethodResponseError> {
        if crate::aws_json_errors::is_error(&response) && response.status().as_u16() != 200 {
            let body = serde_json::from_slice(response.body().as_ref())
                .unwrap_or_else(|_| serde_json::json!({}));
            let generic = crate::aws_json_errors::parse_generic_error(&response, &body);

            let error_code = match generic.code() {
                Some(code) => code,
                None => return Err(crate::error::GetMethodResponseError::unhandled(generic)),
            };
            return Err(match error_code {
                "NotFoundException" => crate::error::GetMethodResponseError {
                    meta: generic,
                    kind: crate::error::GetMethodResponseErrorKind::NotFoundError({
                        #[allow(unused_mut)]
                        let mut output = crate::error::not_found_error::Builder::default();
                        let _ = response;

                        let body_slice = response.body().as_ref();

                        let parsed_body: crate::error::NotFoundError = if body_slice.is_empty() {
                            // To enable JSON parsing to succeed, replace an empty body
                            // with an empty JSON body. If a member was required, it will fail slightly later
                            // during the operation construction phase.
                            serde_json::from_slice(b"{}")
                                .map_err(crate::error::GetMethodResponseError::unhandled)?
                        } else {
                            serde_json::from_slice(response.body().as_ref())
                                .map_err(crate::error::GetMethodResponseError::unhandled)?
                        };

                        output = output.set_message(parsed_body.message);
                        output.build()
                    }),
                },
                "TooManyRequestsException" => crate::error::GetMethodResponseError {
                    meta: generic,
                    kind: crate::error::GetMethodResponseErrorKind::TooManyRequestsError({
                        #[allow(unused_mut)]
                        let mut output = crate::error::too_many_requests_error::Builder::default();
                        let _ = response;

                        let body_slice = response.body().as_ref();

                        let parsed_body: crate::error::TooManyRequestsError =
                            if body_slice.is_empty() {
                                // To enable JSON parsing to succeed, replace an empty body
                                // with an empty JSON body. If a member was required, it will fail slightly later
                                // during the operation construction phase.
                                serde_json::from_slice(b"{}")
                                    .map_err(crate::error::GetMethodResponseError::unhandled)?
                            } else {
                                serde_json::from_slice(response.body().as_ref())
                                    .map_err(crate::error::GetMethodResponseError::unhandled)?
                            };

                        output = output.set_retry_after_seconds(
                        
                                                crate::http_serde::deser_header_get_method_response_retry_after_seconds(response.headers())
                                                    .map_err(|_|crate::error::GetMethodResponseError::unhandled("Failed to parse retryAfterSeconds from header `Retry-After"))?
                                                
                    );
                        output = output.set_message(parsed_body.message);
                        output.build()
                    }),
                },
                "UnauthorizedException" => crate::error::GetMethodResponseError {
                    meta: generic,
                    kind: crate::error::GetMethodResponseErrorKind::UnauthorizedError({
                        #[allow(unused_mut)]
                        let mut output = crate::error::unauthorized_error::Builder::default();
                        let _ = response;

                        let body_slice = response.body().as_ref();

                        let parsed_body: crate::error::UnauthorizedError = if body_slice.is_empty()
                        {
                            // To enable JSON parsing to succeed, replace an empty body
                            // with an empty JSON body. If a member was required, it will fail slightly later
                            // during the operation construction phase.
                            serde_json::from_slice(b"{}")
                                .map_err(crate::error::GetMethodResponseError::unhandled)?
                        } else {
                            serde_json::from_slice(response.body().as_ref())
                                .map_err(crate::error::GetMethodResponseError::unhandled)?
                        };

                        output = output.set_message(parsed_body.message);
                        output.build()
                    }),
                },
                _ => crate::error::GetMethodResponseError::generic(generic),
            });
        }
        Ok({
            #[allow(unused_mut)]
            let mut output = crate::output::get_method_response_output::Builder::default();
            let _ = response;

            let body_slice = response.body().as_ref();

            let parsed_body: crate::serializer::GetMethodResponseOutputBody =
                if body_slice.is_empty() {
                    // To enable JSON parsing to succeed, replace an empty body
                    // with an empty JSON body. If a member was required, it will fail slightly later
                    // during the operation construction phase.
                    serde_json::from_slice(b"{}")
                        .map_err(crate::error::GetMethodResponseError::unhandled)?
                } else {
                    serde_json::from_slice(response.body().as_ref())
                        .map_err(crate::error::GetMethodResponseError::unhandled)?
                };

            output = output.set_status_code(parsed_body.status_code);
            output = output.set_response_parameters(parsed_body.response_parameters);
            output = output.set_response_models(parsed_body.response_models);
            output.build()
        })
    }
    pub fn parse_response(
        &self,
        response: &http::response::Response<impl AsRef<[u8]>>,
    ) -> Result<crate::output::GetMethodResponseOutput, crate::error::GetMethodResponseError> {
        Self::from_response(&response)
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}

impl smithy_http::response::ParseStrictResponse for GetMethodResponse {
    type Output =
        Result<crate::output::GetMethodResponseOutput, crate::error::GetMethodResponseError>;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        self.parse_response(response)
    }
}

/// <p>Describes an existing model defined for a <a>RestApi</a> resource.</p>
#[derive(std::clone::Clone)]
pub struct GetModel {
    _private: (),
}
impl GetModel {
    /// Creates a new builder-style object to manufacture [`GetModelInput`](crate::input::GetModelInput)
    pub fn builder() -> crate::input::get_model_input::Builder {
        crate::input::get_model_input::Builder::default()
    }
    #[allow(clippy::unnecessary_wraps)]
    fn from_response(
        response: &http::response::Response<impl AsRef<[u8]>>,
    ) -> Result<crate::output::GetModelOutput, crate::error::GetModelError> {
        if crate::aws_json_errors::is_error(&response) && response.status().as_u16() != 200 {
            let body = serde_json::from_slice(response.body().as_ref())
                .unwrap_or_else(|_| serde_json::json!({}));
            let generic = crate::aws_json_errors::parse_generic_error(&response, &body);

            let error_code = match generic.code() {
                Some(code) => code,
                None => return Err(crate::error::GetModelError::unhandled(generic)),
            };
            return Err(match error_code {
                "NotFoundException" => crate::error::GetModelError {
                    meta: generic,
                    kind: crate::error::GetModelErrorKind::NotFoundError({
                        #[allow(unused_mut)]
                        let mut output = crate::error::not_found_error::Builder::default();
                        let _ = response;

                        let body_slice = response.body().as_ref();

                        let parsed_body: crate::error::NotFoundError = if body_slice.is_empty() {
                            // To enable JSON parsing to succeed, replace an empty body
                            // with an empty JSON body. If a member was required, it will fail slightly later
                            // during the operation construction phase.
                            serde_json::from_slice(b"{}")
                                .map_err(crate::error::GetModelError::unhandled)?
                        } else {
                            serde_json::from_slice(response.body().as_ref())
                                .map_err(crate::error::GetModelError::unhandled)?
                        };

                        output = output.set_message(parsed_body.message);
                        output.build()
                    }),
                },
                "TooManyRequestsException" => {
                    crate::error::GetModelError {
                        meta: generic,
                        kind: crate::error::GetModelErrorKind::TooManyRequestsError({
                            #[allow(unused_mut)]
                            let mut output =
                                crate::error::too_many_requests_error::Builder::default();
                            let _ = response;

                            let body_slice = response.body().as_ref();

                            let parsed_body: crate::error::TooManyRequestsError =
                                if body_slice.is_empty() {
                                    // To enable JSON parsing to succeed, replace an empty body
                                    // with an empty JSON body. If a member was required, it will fail slightly later
                                    // during the operation construction phase.
                                    serde_json::from_slice(b"{}")
                                        .map_err(crate::error::GetModelError::unhandled)?
                                } else {
                                    serde_json::from_slice(response.body().as_ref())
                                        .map_err(crate::error::GetModelError::unhandled)?
                                };

                            output = output.set_retry_after_seconds(
                        
                                                crate::http_serde::deser_header_get_model_retry_after_seconds(response.headers())
                                                    .map_err(|_|crate::error::GetModelError::unhandled("Failed to parse retryAfterSeconds from header `Retry-After"))?
                                                
                    );
                            output = output.set_message(parsed_body.message);
                            output.build()
                        }),
                    }
                }
                "UnauthorizedException" => crate::error::GetModelError {
                    meta: generic,
                    kind: crate::error::GetModelErrorKind::UnauthorizedError({
                        #[allow(unused_mut)]
                        let mut output = crate::error::unauthorized_error::Builder::default();
                        let _ = response;

                        let body_slice = response.body().as_ref();

                        let parsed_body: crate::error::UnauthorizedError = if body_slice.is_empty()
                        {
                            // To enable JSON parsing to succeed, replace an empty body
                            // with an empty JSON body. If a member was required, it will fail slightly later
                            // during the operation construction phase.
                            serde_json::from_slice(b"{}")
                                .map_err(crate::error::GetModelError::unhandled)?
                        } else {
                            serde_json::from_slice(response.body().as_ref())
                                .map_err(crate::error::GetModelError::unhandled)?
                        };

                        output = output.set_message(parsed_body.message);
                        output.build()
                    }),
                },
                _ => crate::error::GetModelError::generic(generic),
            });
        }
        Ok({
            #[allow(unused_mut)]
            let mut output = crate::output::get_model_output::Builder::default();
            let _ = response;

            let body_slice = response.body().as_ref();

            let parsed_body: crate::serializer::GetModelOutputBody = if body_slice.is_empty() {
                // To enable JSON parsing to succeed, replace an empty body
                // with an empty JSON body. If a member was required, it will fail slightly later
                // during the operation construction phase.
                serde_json::from_slice(b"{}").map_err(crate::error::GetModelError::unhandled)?
            } else {
                serde_json::from_slice(response.body().as_ref())
                    .map_err(crate::error::GetModelError::unhandled)?
            };

            output = output.set_id(parsed_body.id);
            output = output.set_name(parsed_body.name);
            output = output.set_description(parsed_body.description);
            output = output.set_schema(parsed_body.schema);
            output = output.set_content_type(parsed_body.content_type);
            output.build()
        })
    }
    pub fn parse_response(
        &self,
        response: &http::response::Response<impl AsRef<[u8]>>,
    ) -> Result<crate::output::GetModelOutput, crate::error::GetModelError> {
        Self::from_response(&response)
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}

impl smithy_http::response::ParseStrictResponse for GetModel {
    type Output = Result<crate::output::GetModelOutput, crate::error::GetModelError>;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        self.parse_response(response)
    }
}

/// <p>Describes existing <a>Models</a> defined for a <a>RestApi</a> resource.</p>
#[derive(std::clone::Clone)]
pub struct GetModels {
    _private: (),
}
impl GetModels {
    /// Creates a new builder-style object to manufacture [`GetModelsInput`](crate::input::GetModelsInput)
    pub fn builder() -> crate::input::get_models_input::Builder {
        crate::input::get_models_input::Builder::default()
    }
    #[allow(clippy::unnecessary_wraps)]
    fn from_response(
        response: &http::response::Response<impl AsRef<[u8]>>,
    ) -> Result<crate::output::GetModelsOutput, crate::error::GetModelsError> {
        if crate::aws_json_errors::is_error(&response) && response.status().as_u16() != 200 {
            let body = serde_json::from_slice(response.body().as_ref())
                .unwrap_or_else(|_| serde_json::json!({}));
            let generic = crate::aws_json_errors::parse_generic_error(&response, &body);

            let error_code = match generic.code() {
                Some(code) => code,
                None => return Err(crate::error::GetModelsError::unhandled(generic)),
            };
            return Err(match error_code {
                "BadRequestException" => crate::error::GetModelsError {
                    meta: generic,
                    kind: crate::error::GetModelsErrorKind::BadRequestError({
                        #[allow(unused_mut)]
                        let mut output = crate::error::bad_request_error::Builder::default();
                        let _ = response;

                        let body_slice = response.body().as_ref();

                        let parsed_body: crate::error::BadRequestError = if body_slice.is_empty() {
                            // To enable JSON parsing to succeed, replace an empty body
                            // with an empty JSON body. If a member was required, it will fail slightly later
                            // during the operation construction phase.
                            serde_json::from_slice(b"{}")
                                .map_err(crate::error::GetModelsError::unhandled)?
                        } else {
                            serde_json::from_slice(response.body().as_ref())
                                .map_err(crate::error::GetModelsError::unhandled)?
                        };

                        output = output.set_message(parsed_body.message);
                        output.build()
                    }),
                },
                "NotFoundException" => crate::error::GetModelsError {
                    meta: generic,
                    kind: crate::error::GetModelsErrorKind::NotFoundError({
                        #[allow(unused_mut)]
                        let mut output = crate::error::not_found_error::Builder::default();
                        let _ = response;

                        let body_slice = response.body().as_ref();

                        let parsed_body: crate::error::NotFoundError = if body_slice.is_empty() {
                            // To enable JSON parsing to succeed, replace an empty body
                            // with an empty JSON body. If a member was required, it will fail slightly later
                            // during the operation construction phase.
                            serde_json::from_slice(b"{}")
                                .map_err(crate::error::GetModelsError::unhandled)?
                        } else {
                            serde_json::from_slice(response.body().as_ref())
                                .map_err(crate::error::GetModelsError::unhandled)?
                        };

                        output = output.set_message(parsed_body.message);
                        output.build()
                    }),
                },
                "TooManyRequestsException" => {
                    crate::error::GetModelsError {
                        meta: generic,
                        kind: crate::error::GetModelsErrorKind::TooManyRequestsError({
                            #[allow(unused_mut)]
                            let mut output =
                                crate::error::too_many_requests_error::Builder::default();
                            let _ = response;

                            let body_slice = response.body().as_ref();

                            let parsed_body: crate::error::TooManyRequestsError =
                                if body_slice.is_empty() {
                                    // To enable JSON parsing to succeed, replace an empty body
                                    // with an empty JSON body. If a member was required, it will fail slightly later
                                    // during the operation construction phase.
                                    serde_json::from_slice(b"{}")
                                        .map_err(crate::error::GetModelsError::unhandled)?
                                } else {
                                    serde_json::from_slice(response.body().as_ref())
                                        .map_err(crate::error::GetModelsError::unhandled)?
                                };

                            output = output.set_retry_after_seconds(
                        
                                                crate::http_serde::deser_header_get_models_retry_after_seconds(response.headers())
                                                    .map_err(|_|crate::error::GetModelsError::unhandled("Failed to parse retryAfterSeconds from header `Retry-After"))?
                                                
                    );
                            output = output.set_message(parsed_body.message);
                            output.build()
                        }),
                    }
                }
                "UnauthorizedException" => crate::error::GetModelsError {
                    meta: generic,
                    kind: crate::error::GetModelsErrorKind::UnauthorizedError({
                        #[allow(unused_mut)]
                        let mut output = crate::error::unauthorized_error::Builder::default();
                        let _ = response;

                        let body_slice = response.body().as_ref();

                        let parsed_body: crate::error::UnauthorizedError = if body_slice.is_empty()
                        {
                            // To enable JSON parsing to succeed, replace an empty body
                            // with an empty JSON body. If a member was required, it will fail slightly later
                            // during the operation construction phase.
                            serde_json::from_slice(b"{}")
                                .map_err(crate::error::GetModelsError::unhandled)?
                        } else {
                            serde_json::from_slice(response.body().as_ref())
                                .map_err(crate::error::GetModelsError::unhandled)?
                        };

                        output = output.set_message(parsed_body.message);
                        output.build()
                    }),
                },
                _ => crate::error::GetModelsError::generic(generic),
            });
        }
        Ok({
            #[allow(unused_mut)]
            let mut output = crate::output::get_models_output::Builder::default();
            let _ = response;

            let body_slice = response.body().as_ref();

            let parsed_body: crate::serializer::GetModelsOutputBody = if body_slice.is_empty() {
                // To enable JSON parsing to succeed, replace an empty body
                // with an empty JSON body. If a member was required, it will fail slightly later
                // during the operation construction phase.
                serde_json::from_slice(b"{}").map_err(crate::error::GetModelsError::unhandled)?
            } else {
                serde_json::from_slice(response.body().as_ref())
                    .map_err(crate::error::GetModelsError::unhandled)?
            };

            output = output.set_items(parsed_body.items);
            output = output.set_position(parsed_body.position);
            output.build()
        })
    }
    pub fn parse_response(
        &self,
        response: &http::response::Response<impl AsRef<[u8]>>,
    ) -> Result<crate::output::GetModelsOutput, crate::error::GetModelsError> {
        Self::from_response(&response)
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}

impl smithy_http::response::ParseStrictResponse for GetModels {
    type Output = Result<crate::output::GetModelsOutput, crate::error::GetModelsError>;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        self.parse_response(response)
    }
}

/// <p>Generates a sample mapping template that can be used to transform a payload into the structure of a model.</p>
#[derive(std::clone::Clone)]
pub struct GetModelTemplate {
    _private: (),
}
impl GetModelTemplate {
    /// Creates a new builder-style object to manufacture [`GetModelTemplateInput`](crate::input::GetModelTemplateInput)
    pub fn builder() -> crate::input::get_model_template_input::Builder {
        crate::input::get_model_template_input::Builder::default()
    }
    #[allow(clippy::unnecessary_wraps)]
    fn from_response(
        response: &http::response::Response<impl AsRef<[u8]>>,
    ) -> Result<crate::output::GetModelTemplateOutput, crate::error::GetModelTemplateError> {
        if crate::aws_json_errors::is_error(&response) && response.status().as_u16() != 200 {
            let body = serde_json::from_slice(response.body().as_ref())
                .unwrap_or_else(|_| serde_json::json!({}));
            let generic = crate::aws_json_errors::parse_generic_error(&response, &body);

            let error_code = match generic.code() {
                Some(code) => code,
                None => return Err(crate::error::GetModelTemplateError::unhandled(generic)),
            };
            return Err(match error_code {
                "BadRequestException" => crate::error::GetModelTemplateError {
                    meta: generic,
                    kind: crate::error::GetModelTemplateErrorKind::BadRequestError({
                        #[allow(unused_mut)]
                        let mut output = crate::error::bad_request_error::Builder::default();
                        let _ = response;

                        let body_slice = response.body().as_ref();

                        let parsed_body: crate::error::BadRequestError = if body_slice.is_empty() {
                            // To enable JSON parsing to succeed, replace an empty body
                            // with an empty JSON body. If a member was required, it will fail slightly later
                            // during the operation construction phase.
                            serde_json::from_slice(b"{}")
                                .map_err(crate::error::GetModelTemplateError::unhandled)?
                        } else {
                            serde_json::from_slice(response.body().as_ref())
                                .map_err(crate::error::GetModelTemplateError::unhandled)?
                        };

                        output = output.set_message(parsed_body.message);
                        output.build()
                    }),
                },
                "NotFoundException" => crate::error::GetModelTemplateError {
                    meta: generic,
                    kind: crate::error::GetModelTemplateErrorKind::NotFoundError({
                        #[allow(unused_mut)]
                        let mut output = crate::error::not_found_error::Builder::default();
                        let _ = response;

                        let body_slice = response.body().as_ref();

                        let parsed_body: crate::error::NotFoundError = if body_slice.is_empty() {
                            // To enable JSON parsing to succeed, replace an empty body
                            // with an empty JSON body. If a member was required, it will fail slightly later
                            // during the operation construction phase.
                            serde_json::from_slice(b"{}")
                                .map_err(crate::error::GetModelTemplateError::unhandled)?
                        } else {
                            serde_json::from_slice(response.body().as_ref())
                                .map_err(crate::error::GetModelTemplateError::unhandled)?
                        };

                        output = output.set_message(parsed_body.message);
                        output.build()
                    }),
                },
                "TooManyRequestsException" => {
                    crate::error::GetModelTemplateError {
                        meta: generic,
                        kind: crate::error::GetModelTemplateErrorKind::TooManyRequestsError({
                            #[allow(unused_mut)]
                            let mut output =
                                crate::error::too_many_requests_error::Builder::default();
                            let _ = response;

                            let body_slice = response.body().as_ref();

                            let parsed_body: crate::error::TooManyRequestsError =
                                if body_slice.is_empty() {
                                    // To enable JSON parsing to succeed, replace an empty body
                                    // with an empty JSON body. If a member was required, it will fail slightly later
                                    // during the operation construction phase.
                                    serde_json::from_slice(b"{}")
                                        .map_err(crate::error::GetModelTemplateError::unhandled)?
                                } else {
                                    serde_json::from_slice(response.body().as_ref())
                                        .map_err(crate::error::GetModelTemplateError::unhandled)?
                                };

                            output = output.set_retry_after_seconds(
                        
                                                crate::http_serde::deser_header_get_model_template_retry_after_seconds(response.headers())
                                                    .map_err(|_|crate::error::GetModelTemplateError::unhandled("Failed to parse retryAfterSeconds from header `Retry-After"))?
                                                
                    );
                            output = output.set_message(parsed_body.message);
                            output.build()
                        }),
                    }
                }
                "UnauthorizedException" => crate::error::GetModelTemplateError {
                    meta: generic,
                    kind: crate::error::GetModelTemplateErrorKind::UnauthorizedError({
                        #[allow(unused_mut)]
                        let mut output = crate::error::unauthorized_error::Builder::default();
                        let _ = response;

                        let body_slice = response.body().as_ref();

                        let parsed_body: crate::error::UnauthorizedError = if body_slice.is_empty()
                        {
                            // To enable JSON parsing to succeed, replace an empty body
                            // with an empty JSON body. If a member was required, it will fail slightly later
                            // during the operation construction phase.
                            serde_json::from_slice(b"{}")
                                .map_err(crate::error::GetModelTemplateError::unhandled)?
                        } else {
                            serde_json::from_slice(response.body().as_ref())
                                .map_err(crate::error::GetModelTemplateError::unhandled)?
                        };

                        output = output.set_message(parsed_body.message);
                        output.build()
                    }),
                },
                _ => crate::error::GetModelTemplateError::generic(generic),
            });
        }
        Ok({
            #[allow(unused_mut)]
            let mut output = crate::output::get_model_template_output::Builder::default();
            let _ = response;

            let body_slice = response.body().as_ref();

            let parsed_body: crate::serializer::GetModelTemplateOutputBody =
                if body_slice.is_empty() {
                    // To enable JSON parsing to succeed, replace an empty body
                    // with an empty JSON body. If a member was required, it will fail slightly later
                    // during the operation construction phase.
                    serde_json::from_slice(b"{}")
                        .map_err(crate::error::GetModelTemplateError::unhandled)?
                } else {
                    serde_json::from_slice(response.body().as_ref())
                        .map_err(crate::error::GetModelTemplateError::unhandled)?
                };

            output = output.set_value(parsed_body.value);
            output.build()
        })
    }
    pub fn parse_response(
        &self,
        response: &http::response::Response<impl AsRef<[u8]>>,
    ) -> Result<crate::output::GetModelTemplateOutput, crate::error::GetModelTemplateError> {
        Self::from_response(&response)
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}

impl smithy_http::response::ParseStrictResponse for GetModelTemplate {
    type Output =
        Result<crate::output::GetModelTemplateOutput, crate::error::GetModelTemplateError>;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        self.parse_response(response)
    }
}

/// <p>Gets a <a>RequestValidator</a> of a given <a>RestApi</a>.</p>
#[derive(std::clone::Clone)]
pub struct GetRequestValidator {
    _private: (),
}
impl GetRequestValidator {
    /// Creates a new builder-style object to manufacture [`GetRequestValidatorInput`](crate::input::GetRequestValidatorInput)
    pub fn builder() -> crate::input::get_request_validator_input::Builder {
        crate::input::get_request_validator_input::Builder::default()
    }
    #[allow(clippy::unnecessary_wraps)]
    fn from_response(
        response: &http::response::Response<impl AsRef<[u8]>>,
    ) -> Result<crate::output::GetRequestValidatorOutput, crate::error::GetRequestValidatorError>
    {
        if crate::aws_json_errors::is_error(&response) && response.status().as_u16() != 200 {
            let body = serde_json::from_slice(response.body().as_ref())
                .unwrap_or_else(|_| serde_json::json!({}));
            let generic = crate::aws_json_errors::parse_generic_error(&response, &body);

            let error_code = match generic.code() {
                Some(code) => code,
                None => return Err(crate::error::GetRequestValidatorError::unhandled(generic)),
            };
            return Err(match error_code {
                "NotFoundException" => crate::error::GetRequestValidatorError {
                    meta: generic,
                    kind: crate::error::GetRequestValidatorErrorKind::NotFoundError({
                        #[allow(unused_mut)]
                        let mut output = crate::error::not_found_error::Builder::default();
                        let _ = response;

                        let body_slice = response.body().as_ref();

                        let parsed_body: crate::error::NotFoundError = if body_slice.is_empty() {
                            // To enable JSON parsing to succeed, replace an empty body
                            // with an empty JSON body. If a member was required, it will fail slightly later
                            // during the operation construction phase.
                            serde_json::from_slice(b"{}")
                                .map_err(crate::error::GetRequestValidatorError::unhandled)?
                        } else {
                            serde_json::from_slice(response.body().as_ref())
                                .map_err(crate::error::GetRequestValidatorError::unhandled)?
                        };

                        output = output.set_message(parsed_body.message);
                        output.build()
                    }),
                },
                "TooManyRequestsException" => crate::error::GetRequestValidatorError {
                    meta: generic,
                    kind: crate::error::GetRequestValidatorErrorKind::TooManyRequestsError({
                        #[allow(unused_mut)]
                        let mut output = crate::error::too_many_requests_error::Builder::default();
                        let _ = response;

                        let body_slice = response.body().as_ref();

                        let parsed_body: crate::error::TooManyRequestsError =
                            if body_slice.is_empty() {
                                // To enable JSON parsing to succeed, replace an empty body
                                // with an empty JSON body. If a member was required, it will fail slightly later
                                // during the operation construction phase.
                                serde_json::from_slice(b"{}")
                                    .map_err(crate::error::GetRequestValidatorError::unhandled)?
                            } else {
                                serde_json::from_slice(response.body().as_ref())
                                    .map_err(crate::error::GetRequestValidatorError::unhandled)?
                            };

                        output = output.set_retry_after_seconds(
                        
                                                crate::http_serde::deser_header_get_request_validator_retry_after_seconds(response.headers())
                                                    .map_err(|_|crate::error::GetRequestValidatorError::unhandled("Failed to parse retryAfterSeconds from header `Retry-After"))?
                                                
                    );
                        output = output.set_message(parsed_body.message);
                        output.build()
                    }),
                },
                "UnauthorizedException" => crate::error::GetRequestValidatorError {
                    meta: generic,
                    kind: crate::error::GetRequestValidatorErrorKind::UnauthorizedError({
                        #[allow(unused_mut)]
                        let mut output = crate::error::unauthorized_error::Builder::default();
                        let _ = response;

                        let body_slice = response.body().as_ref();

                        let parsed_body: crate::error::UnauthorizedError = if body_slice.is_empty()
                        {
                            // To enable JSON parsing to succeed, replace an empty body
                            // with an empty JSON body. If a member was required, it will fail slightly later
                            // during the operation construction phase.
                            serde_json::from_slice(b"{}")
                                .map_err(crate::error::GetRequestValidatorError::unhandled)?
                        } else {
                            serde_json::from_slice(response.body().as_ref())
                                .map_err(crate::error::GetRequestValidatorError::unhandled)?
                        };

                        output = output.set_message(parsed_body.message);
                        output.build()
                    }),
                },
                _ => crate::error::GetRequestValidatorError::generic(generic),
            });
        }
        Ok({
            #[allow(unused_mut)]
            let mut output = crate::output::get_request_validator_output::Builder::default();
            let _ = response;

            let body_slice = response.body().as_ref();

            let parsed_body: crate::serializer::GetRequestValidatorOutputBody =
                if body_slice.is_empty() {
                    // To enable JSON parsing to succeed, replace an empty body
                    // with an empty JSON body. If a member was required, it will fail slightly later
                    // during the operation construction phase.
                    serde_json::from_slice(b"{}")
                        .map_err(crate::error::GetRequestValidatorError::unhandled)?
                } else {
                    serde_json::from_slice(response.body().as_ref())
                        .map_err(crate::error::GetRequestValidatorError::unhandled)?
                };

            output = output.set_id(parsed_body.id);
            output = output.set_name(parsed_body.name);
            output = output.set_validate_request_body(parsed_body.validate_request_body);
            output =
                output.set_validate_request_parameters(parsed_body.validate_request_parameters);
            output.build()
        })
    }
    pub fn parse_response(
        &self,
        response: &http::response::Response<impl AsRef<[u8]>>,
    ) -> Result<crate::output::GetRequestValidatorOutput, crate::error::GetRequestValidatorError>
    {
        Self::from_response(&response)
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}

impl smithy_http::response::ParseStrictResponse for GetRequestValidator {
    type Output =
        Result<crate::output::GetRequestValidatorOutput, crate::error::GetRequestValidatorError>;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        self.parse_response(response)
    }
}

/// <p>Gets the <a>RequestValidators</a> collection of a given <a>RestApi</a>.</p>
#[derive(std::clone::Clone)]
pub struct GetRequestValidators {
    _private: (),
}
impl GetRequestValidators {
    /// Creates a new builder-style object to manufacture [`GetRequestValidatorsInput`](crate::input::GetRequestValidatorsInput)
    pub fn builder() -> crate::input::get_request_validators_input::Builder {
        crate::input::get_request_validators_input::Builder::default()
    }
    #[allow(clippy::unnecessary_wraps)]
    fn from_response(
        response: &http::response::Response<impl AsRef<[u8]>>,
    ) -> Result<crate::output::GetRequestValidatorsOutput, crate::error::GetRequestValidatorsError>
    {
        if crate::aws_json_errors::is_error(&response) && response.status().as_u16() != 200 {
            let body = serde_json::from_slice(response.body().as_ref())
                .unwrap_or_else(|_| serde_json::json!({}));
            let generic = crate::aws_json_errors::parse_generic_error(&response, &body);

            let error_code = match generic.code() {
                Some(code) => code,
                None => return Err(crate::error::GetRequestValidatorsError::unhandled(generic)),
            };
            return Err(match error_code {
                "BadRequestException" => crate::error::GetRequestValidatorsError {
                    meta: generic,
                    kind: crate::error::GetRequestValidatorsErrorKind::BadRequestError({
                        #[allow(unused_mut)]
                        let mut output = crate::error::bad_request_error::Builder::default();
                        let _ = response;

                        let body_slice = response.body().as_ref();

                        let parsed_body: crate::error::BadRequestError = if body_slice.is_empty() {
                            // To enable JSON parsing to succeed, replace an empty body
                            // with an empty JSON body. If a member was required, it will fail slightly later
                            // during the operation construction phase.
                            serde_json::from_slice(b"{}")
                                .map_err(crate::error::GetRequestValidatorsError::unhandled)?
                        } else {
                            serde_json::from_slice(response.body().as_ref())
                                .map_err(crate::error::GetRequestValidatorsError::unhandled)?
                        };

                        output = output.set_message(parsed_body.message);
                        output.build()
                    }),
                },
                "NotFoundException" => crate::error::GetRequestValidatorsError {
                    meta: generic,
                    kind: crate::error::GetRequestValidatorsErrorKind::NotFoundError({
                        #[allow(unused_mut)]
                        let mut output = crate::error::not_found_error::Builder::default();
                        let _ = response;

                        let body_slice = response.body().as_ref();

                        let parsed_body: crate::error::NotFoundError = if body_slice.is_empty() {
                            // To enable JSON parsing to succeed, replace an empty body
                            // with an empty JSON body. If a member was required, it will fail slightly later
                            // during the operation construction phase.
                            serde_json::from_slice(b"{}")
                                .map_err(crate::error::GetRequestValidatorsError::unhandled)?
                        } else {
                            serde_json::from_slice(response.body().as_ref())
                                .map_err(crate::error::GetRequestValidatorsError::unhandled)?
                        };

                        output = output.set_message(parsed_body.message);
                        output.build()
                    }),
                },
                "TooManyRequestsException" => crate::error::GetRequestValidatorsError {
                    meta: generic,
                    kind: crate::error::GetRequestValidatorsErrorKind::TooManyRequestsError({
                        #[allow(unused_mut)]
                        let mut output = crate::error::too_many_requests_error::Builder::default();
                        let _ = response;

                        let body_slice = response.body().as_ref();

                        let parsed_body: crate::error::TooManyRequestsError =
                            if body_slice.is_empty() {
                                // To enable JSON parsing to succeed, replace an empty body
                                // with an empty JSON body. If a member was required, it will fail slightly later
                                // during the operation construction phase.
                                serde_json::from_slice(b"{}")
                                    .map_err(crate::error::GetRequestValidatorsError::unhandled)?
                            } else {
                                serde_json::from_slice(response.body().as_ref())
                                    .map_err(crate::error::GetRequestValidatorsError::unhandled)?
                            };

                        output = output.set_retry_after_seconds(
                        
                                                crate::http_serde::deser_header_get_request_validators_retry_after_seconds(response.headers())
                                                    .map_err(|_|crate::error::GetRequestValidatorsError::unhandled("Failed to parse retryAfterSeconds from header `Retry-After"))?
                                                
                    );
                        output = output.set_message(parsed_body.message);
                        output.build()
                    }),
                },
                "UnauthorizedException" => crate::error::GetRequestValidatorsError {
                    meta: generic,
                    kind: crate::error::GetRequestValidatorsErrorKind::UnauthorizedError({
                        #[allow(unused_mut)]
                        let mut output = crate::error::unauthorized_error::Builder::default();
                        let _ = response;

                        let body_slice = response.body().as_ref();

                        let parsed_body: crate::error::UnauthorizedError = if body_slice.is_empty()
                        {
                            // To enable JSON parsing to succeed, replace an empty body
                            // with an empty JSON body. If a member was required, it will fail slightly later
                            // during the operation construction phase.
                            serde_json::from_slice(b"{}")
                                .map_err(crate::error::GetRequestValidatorsError::unhandled)?
                        } else {
                            serde_json::from_slice(response.body().as_ref())
                                .map_err(crate::error::GetRequestValidatorsError::unhandled)?
                        };

                        output = output.set_message(parsed_body.message);
                        output.build()
                    }),
                },
                _ => crate::error::GetRequestValidatorsError::generic(generic),
            });
        }
        Ok({
            #[allow(unused_mut)]
            let mut output = crate::output::get_request_validators_output::Builder::default();
            let _ = response;

            let body_slice = response.body().as_ref();

            let parsed_body: crate::serializer::GetRequestValidatorsOutputBody =
                if body_slice.is_empty() {
                    // To enable JSON parsing to succeed, replace an empty body
                    // with an empty JSON body. If a member was required, it will fail slightly later
                    // during the operation construction phase.
                    serde_json::from_slice(b"{}")
                        .map_err(crate::error::GetRequestValidatorsError::unhandled)?
                } else {
                    serde_json::from_slice(response.body().as_ref())
                        .map_err(crate::error::GetRequestValidatorsError::unhandled)?
                };

            output = output.set_items(parsed_body.items);
            output = output.set_position(parsed_body.position);
            output.build()
        })
    }
    pub fn parse_response(
        &self,
        response: &http::response::Response<impl AsRef<[u8]>>,
    ) -> Result<crate::output::GetRequestValidatorsOutput, crate::error::GetRequestValidatorsError>
    {
        Self::from_response(&response)
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}

impl smithy_http::response::ParseStrictResponse for GetRequestValidators {
    type Output =
        Result<crate::output::GetRequestValidatorsOutput, crate::error::GetRequestValidatorsError>;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        self.parse_response(response)
    }
}

/// <p>Lists information about a resource.</p>
#[derive(std::clone::Clone)]
pub struct GetResource {
    _private: (),
}
impl GetResource {
    /// Creates a new builder-style object to manufacture [`GetResourceInput`](crate::input::GetResourceInput)
    pub fn builder() -> crate::input::get_resource_input::Builder {
        crate::input::get_resource_input::Builder::default()
    }
    #[allow(clippy::unnecessary_wraps)]
    fn from_response(
        response: &http::response::Response<impl AsRef<[u8]>>,
    ) -> Result<crate::output::GetResourceOutput, crate::error::GetResourceError> {
        if crate::aws_json_errors::is_error(&response) && response.status().as_u16() != 200 {
            let body = serde_json::from_slice(response.body().as_ref())
                .unwrap_or_else(|_| serde_json::json!({}));
            let generic = crate::aws_json_errors::parse_generic_error(&response, &body);

            let error_code = match generic.code() {
                Some(code) => code,
                None => return Err(crate::error::GetResourceError::unhandled(generic)),
            };
            return Err(match error_code {
                "NotFoundException" => crate::error::GetResourceError {
                    meta: generic,
                    kind: crate::error::GetResourceErrorKind::NotFoundError({
                        #[allow(unused_mut)]
                        let mut output = crate::error::not_found_error::Builder::default();
                        let _ = response;

                        let body_slice = response.body().as_ref();

                        let parsed_body: crate::error::NotFoundError = if body_slice.is_empty() {
                            // To enable JSON parsing to succeed, replace an empty body
                            // with an empty JSON body. If a member was required, it will fail slightly later
                            // during the operation construction phase.
                            serde_json::from_slice(b"{}")
                                .map_err(crate::error::GetResourceError::unhandled)?
                        } else {
                            serde_json::from_slice(response.body().as_ref())
                                .map_err(crate::error::GetResourceError::unhandled)?
                        };

                        output = output.set_message(parsed_body.message);
                        output.build()
                    }),
                },
                "TooManyRequestsException" => {
                    crate::error::GetResourceError {
                        meta: generic,
                        kind: crate::error::GetResourceErrorKind::TooManyRequestsError({
                            #[allow(unused_mut)]
                            let mut output =
                                crate::error::too_many_requests_error::Builder::default();
                            let _ = response;

                            let body_slice = response.body().as_ref();

                            let parsed_body: crate::error::TooManyRequestsError =
                                if body_slice.is_empty() {
                                    // To enable JSON parsing to succeed, replace an empty body
                                    // with an empty JSON body. If a member was required, it will fail slightly later
                                    // during the operation construction phase.
                                    serde_json::from_slice(b"{}")
                                        .map_err(crate::error::GetResourceError::unhandled)?
                                } else {
                                    serde_json::from_slice(response.body().as_ref())
                                        .map_err(crate::error::GetResourceError::unhandled)?
                                };

                            output = output.set_retry_after_seconds(
                        
                                                crate::http_serde::deser_header_get_resource_retry_after_seconds(response.headers())
                                                    .map_err(|_|crate::error::GetResourceError::unhandled("Failed to parse retryAfterSeconds from header `Retry-After"))?
                                                
                    );
                            output = output.set_message(parsed_body.message);
                            output.build()
                        }),
                    }
                }
                "UnauthorizedException" => crate::error::GetResourceError {
                    meta: generic,
                    kind: crate::error::GetResourceErrorKind::UnauthorizedError({
                        #[allow(unused_mut)]
                        let mut output = crate::error::unauthorized_error::Builder::default();
                        let _ = response;

                        let body_slice = response.body().as_ref();

                        let parsed_body: crate::error::UnauthorizedError = if body_slice.is_empty()
                        {
                            // To enable JSON parsing to succeed, replace an empty body
                            // with an empty JSON body. If a member was required, it will fail slightly later
                            // during the operation construction phase.
                            serde_json::from_slice(b"{}")
                                .map_err(crate::error::GetResourceError::unhandled)?
                        } else {
                            serde_json::from_slice(response.body().as_ref())
                                .map_err(crate::error::GetResourceError::unhandled)?
                        };

                        output = output.set_message(parsed_body.message);
                        output.build()
                    }),
                },
                _ => crate::error::GetResourceError::generic(generic),
            });
        }
        Ok({
            #[allow(unused_mut)]
            let mut output = crate::output::get_resource_output::Builder::default();
            let _ = response;

            let body_slice = response.body().as_ref();

            let parsed_body: crate::serializer::GetResourceOutputBody = if body_slice.is_empty() {
                // To enable JSON parsing to succeed, replace an empty body
                // with an empty JSON body. If a member was required, it will fail slightly later
                // during the operation construction phase.
                serde_json::from_slice(b"{}").map_err(crate::error::GetResourceError::unhandled)?
            } else {
                serde_json::from_slice(response.body().as_ref())
                    .map_err(crate::error::GetResourceError::unhandled)?
            };

            output = output.set_id(parsed_body.id);
            output = output.set_parent_id(parsed_body.parent_id);
            output = output.set_path_part(parsed_body.path_part);
            output = output.set_path(parsed_body.path);
            output = output.set_resource_methods(parsed_body.resource_methods);
            output.build()
        })
    }
    pub fn parse_response(
        &self,
        response: &http::response::Response<impl AsRef<[u8]>>,
    ) -> Result<crate::output::GetResourceOutput, crate::error::GetResourceError> {
        Self::from_response(&response)
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}

impl smithy_http::response::ParseStrictResponse for GetResource {
    type Output = Result<crate::output::GetResourceOutput, crate::error::GetResourceError>;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        self.parse_response(response)
    }
}

/// <p>Lists information about a collection of <a>Resource</a> resources.</p>
#[derive(std::clone::Clone)]
pub struct GetResources {
    _private: (),
}
impl GetResources {
    /// Creates a new builder-style object to manufacture [`GetResourcesInput`](crate::input::GetResourcesInput)
    pub fn builder() -> crate::input::get_resources_input::Builder {
        crate::input::get_resources_input::Builder::default()
    }
    #[allow(clippy::unnecessary_wraps)]
    fn from_response(
        response: &http::response::Response<impl AsRef<[u8]>>,
    ) -> Result<crate::output::GetResourcesOutput, crate::error::GetResourcesError> {
        if crate::aws_json_errors::is_error(&response) && response.status().as_u16() != 200 {
            let body = serde_json::from_slice(response.body().as_ref())
                .unwrap_or_else(|_| serde_json::json!({}));
            let generic = crate::aws_json_errors::parse_generic_error(&response, &body);

            let error_code = match generic.code() {
                Some(code) => code,
                None => return Err(crate::error::GetResourcesError::unhandled(generic)),
            };
            return Err(match error_code {
                "BadRequestException" => crate::error::GetResourcesError {
                    meta: generic,
                    kind: crate::error::GetResourcesErrorKind::BadRequestError({
                        #[allow(unused_mut)]
                        let mut output = crate::error::bad_request_error::Builder::default();
                        let _ = response;

                        let body_slice = response.body().as_ref();

                        let parsed_body: crate::error::BadRequestError = if body_slice.is_empty() {
                            // To enable JSON parsing to succeed, replace an empty body
                            // with an empty JSON body. If a member was required, it will fail slightly later
                            // during the operation construction phase.
                            serde_json::from_slice(b"{}")
                                .map_err(crate::error::GetResourcesError::unhandled)?
                        } else {
                            serde_json::from_slice(response.body().as_ref())
                                .map_err(crate::error::GetResourcesError::unhandled)?
                        };

                        output = output.set_message(parsed_body.message);
                        output.build()
                    }),
                },
                "NotFoundException" => crate::error::GetResourcesError {
                    meta: generic,
                    kind: crate::error::GetResourcesErrorKind::NotFoundError({
                        #[allow(unused_mut)]
                        let mut output = crate::error::not_found_error::Builder::default();
                        let _ = response;

                        let body_slice = response.body().as_ref();

                        let parsed_body: crate::error::NotFoundError = if body_slice.is_empty() {
                            // To enable JSON parsing to succeed, replace an empty body
                            // with an empty JSON body. If a member was required, it will fail slightly later
                            // during the operation construction phase.
                            serde_json::from_slice(b"{}")
                                .map_err(crate::error::GetResourcesError::unhandled)?
                        } else {
                            serde_json::from_slice(response.body().as_ref())
                                .map_err(crate::error::GetResourcesError::unhandled)?
                        };

                        output = output.set_message(parsed_body.message);
                        output.build()
                    }),
                },
                "TooManyRequestsException" => {
                    crate::error::GetResourcesError {
                        meta: generic,
                        kind: crate::error::GetResourcesErrorKind::TooManyRequestsError({
                            #[allow(unused_mut)]
                            let mut output =
                                crate::error::too_many_requests_error::Builder::default();
                            let _ = response;

                            let body_slice = response.body().as_ref();

                            let parsed_body: crate::error::TooManyRequestsError =
                                if body_slice.is_empty() {
                                    // To enable JSON parsing to succeed, replace an empty body
                                    // with an empty JSON body. If a member was required, it will fail slightly later
                                    // during the operation construction phase.
                                    serde_json::from_slice(b"{}")
                                        .map_err(crate::error::GetResourcesError::unhandled)?
                                } else {
                                    serde_json::from_slice(response.body().as_ref())
                                        .map_err(crate::error::GetResourcesError::unhandled)?
                                };

                            output = output.set_retry_after_seconds(
                        
                                                crate::http_serde::deser_header_get_resources_retry_after_seconds(response.headers())
                                                    .map_err(|_|crate::error::GetResourcesError::unhandled("Failed to parse retryAfterSeconds from header `Retry-After"))?
                                                
                    );
                            output = output.set_message(parsed_body.message);
                            output.build()
                        }),
                    }
                }
                "UnauthorizedException" => crate::error::GetResourcesError {
                    meta: generic,
                    kind: crate::error::GetResourcesErrorKind::UnauthorizedError({
                        #[allow(unused_mut)]
                        let mut output = crate::error::unauthorized_error::Builder::default();
                        let _ = response;

                        let body_slice = response.body().as_ref();

                        let parsed_body: crate::error::UnauthorizedError = if body_slice.is_empty()
                        {
                            // To enable JSON parsing to succeed, replace an empty body
                            // with an empty JSON body. If a member was required, it will fail slightly later
                            // during the operation construction phase.
                            serde_json::from_slice(b"{}")
                                .map_err(crate::error::GetResourcesError::unhandled)?
                        } else {
                            serde_json::from_slice(response.body().as_ref())
                                .map_err(crate::error::GetResourcesError::unhandled)?
                        };

                        output = output.set_message(parsed_body.message);
                        output.build()
                    }),
                },
                _ => crate::error::GetResourcesError::generic(generic),
            });
        }
        Ok({
            #[allow(unused_mut)]
            let mut output = crate::output::get_resources_output::Builder::default();
            let _ = response;

            let body_slice = response.body().as_ref();

            let parsed_body: crate::serializer::GetResourcesOutputBody = if body_slice.is_empty() {
                // To enable JSON parsing to succeed, replace an empty body
                // with an empty JSON body. If a member was required, it will fail slightly later
                // during the operation construction phase.
                serde_json::from_slice(b"{}").map_err(crate::error::GetResourcesError::unhandled)?
            } else {
                serde_json::from_slice(response.body().as_ref())
                    .map_err(crate::error::GetResourcesError::unhandled)?
            };

            output = output.set_items(parsed_body.items);
            output = output.set_position(parsed_body.position);
            output.build()
        })
    }
    pub fn parse_response(
        &self,
        response: &http::response::Response<impl AsRef<[u8]>>,
    ) -> Result<crate::output::GetResourcesOutput, crate::error::GetResourcesError> {
        Self::from_response(&response)
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}

impl smithy_http::response::ParseStrictResponse for GetResources {
    type Output = Result<crate::output::GetResourcesOutput, crate::error::GetResourcesError>;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        self.parse_response(response)
    }
}

/// <p>Lists the <a>RestApi</a> resource in the collection.</p>
#[derive(std::clone::Clone)]
pub struct GetRestApi {
    _private: (),
}
impl GetRestApi {
    /// Creates a new builder-style object to manufacture [`GetRestApiInput`](crate::input::GetRestApiInput)
    pub fn builder() -> crate::input::get_rest_api_input::Builder {
        crate::input::get_rest_api_input::Builder::default()
    }
    #[allow(clippy::unnecessary_wraps)]
    fn from_response(
        response: &http::response::Response<impl AsRef<[u8]>>,
    ) -> Result<crate::output::GetRestApiOutput, crate::error::GetRestApiError> {
        if crate::aws_json_errors::is_error(&response) && response.status().as_u16() != 200 {
            let body = serde_json::from_slice(response.body().as_ref())
                .unwrap_or_else(|_| serde_json::json!({}));
            let generic = crate::aws_json_errors::parse_generic_error(&response, &body);

            let error_code = match generic.code() {
                Some(code) => code,
                None => return Err(crate::error::GetRestApiError::unhandled(generic)),
            };
            return Err(match error_code {
                "NotFoundException" => crate::error::GetRestApiError {
                    meta: generic,
                    kind: crate::error::GetRestApiErrorKind::NotFoundError({
                        #[allow(unused_mut)]
                        let mut output = crate::error::not_found_error::Builder::default();
                        let _ = response;

                        let body_slice = response.body().as_ref();

                        let parsed_body: crate::error::NotFoundError = if body_slice.is_empty() {
                            // To enable JSON parsing to succeed, replace an empty body
                            // with an empty JSON body. If a member was required, it will fail slightly later
                            // during the operation construction phase.
                            serde_json::from_slice(b"{}")
                                .map_err(crate::error::GetRestApiError::unhandled)?
                        } else {
                            serde_json::from_slice(response.body().as_ref())
                                .map_err(crate::error::GetRestApiError::unhandled)?
                        };

                        output = output.set_message(parsed_body.message);
                        output.build()
                    }),
                },
                "TooManyRequestsException" => {
                    crate::error::GetRestApiError {
                        meta: generic,
                        kind: crate::error::GetRestApiErrorKind::TooManyRequestsError({
                            #[allow(unused_mut)]
                            let mut output =
                                crate::error::too_many_requests_error::Builder::default();
                            let _ = response;

                            let body_slice = response.body().as_ref();

                            let parsed_body: crate::error::TooManyRequestsError =
                                if body_slice.is_empty() {
                                    // To enable JSON parsing to succeed, replace an empty body
                                    // with an empty JSON body. If a member was required, it will fail slightly later
                                    // during the operation construction phase.
                                    serde_json::from_slice(b"{}")
                                        .map_err(crate::error::GetRestApiError::unhandled)?
                                } else {
                                    serde_json::from_slice(response.body().as_ref())
                                        .map_err(crate::error::GetRestApiError::unhandled)?
                                };

                            output = output.set_retry_after_seconds(
                        
                                                crate::http_serde::deser_header_get_rest_api_retry_after_seconds(response.headers())
                                                    .map_err(|_|crate::error::GetRestApiError::unhandled("Failed to parse retryAfterSeconds from header `Retry-After"))?
                                                
                    );
                            output = output.set_message(parsed_body.message);
                            output.build()
                        }),
                    }
                }
                "UnauthorizedException" => crate::error::GetRestApiError {
                    meta: generic,
                    kind: crate::error::GetRestApiErrorKind::UnauthorizedError({
                        #[allow(unused_mut)]
                        let mut output = crate::error::unauthorized_error::Builder::default();
                        let _ = response;

                        let body_slice = response.body().as_ref();

                        let parsed_body: crate::error::UnauthorizedError = if body_slice.is_empty()
                        {
                            // To enable JSON parsing to succeed, replace an empty body
                            // with an empty JSON body. If a member was required, it will fail slightly later
                            // during the operation construction phase.
                            serde_json::from_slice(b"{}")
                                .map_err(crate::error::GetRestApiError::unhandled)?
                        } else {
                            serde_json::from_slice(response.body().as_ref())
                                .map_err(crate::error::GetRestApiError::unhandled)?
                        };

                        output = output.set_message(parsed_body.message);
                        output.build()
                    }),
                },
                _ => crate::error::GetRestApiError::generic(generic),
            });
        }
        Ok({
            #[allow(unused_mut)]
            let mut output = crate::output::get_rest_api_output::Builder::default();
            let _ = response;

            let body_slice = response.body().as_ref();

            let parsed_body: crate::serializer::GetRestApiOutputBody = if body_slice.is_empty() {
                // To enable JSON parsing to succeed, replace an empty body
                // with an empty JSON body. If a member was required, it will fail slightly later
                // during the operation construction phase.
                serde_json::from_slice(b"{}").map_err(crate::error::GetRestApiError::unhandled)?
            } else {
                serde_json::from_slice(response.body().as_ref())
                    .map_err(crate::error::GetRestApiError::unhandled)?
            };

            output = output.set_id(parsed_body.id);
            output = output.set_name(parsed_body.name);
            output = output.set_description(parsed_body.description);
            output = output.set_created_date(parsed_body.created_date);
            output = output.set_version(parsed_body.version);
            output = output.set_warnings(parsed_body.warnings);
            output = output.set_binary_media_types(parsed_body.binary_media_types);
            output = output.set_minimum_compression_size(parsed_body.minimum_compression_size);
            output = output.set_api_key_source(parsed_body.api_key_source);
            output = output.set_endpoint_configuration(parsed_body.endpoint_configuration);
            output = output.set_policy(parsed_body.policy);
            output = output.set_tags(parsed_body.tags);
            output =
                output.set_disable_execute_api_endpoint(parsed_body.disable_execute_api_endpoint);
            output.build()
        })
    }
    pub fn parse_response(
        &self,
        response: &http::response::Response<impl AsRef<[u8]>>,
    ) -> Result<crate::output::GetRestApiOutput, crate::error::GetRestApiError> {
        Self::from_response(&response)
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}

impl smithy_http::response::ParseStrictResponse for GetRestApi {
    type Output = Result<crate::output::GetRestApiOutput, crate::error::GetRestApiError>;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        self.parse_response(response)
    }
}

/// <p>Lists the <a>RestApis</a> resources for your collection.</p>
#[derive(std::clone::Clone)]
pub struct GetRestApis {
    _private: (),
}
impl GetRestApis {
    /// Creates a new builder-style object to manufacture [`GetRestApisInput`](crate::input::GetRestApisInput)
    pub fn builder() -> crate::input::get_rest_apis_input::Builder {
        crate::input::get_rest_apis_input::Builder::default()
    }
    #[allow(clippy::unnecessary_wraps)]
    fn from_response(
        response: &http::response::Response<impl AsRef<[u8]>>,
    ) -> Result<crate::output::GetRestApisOutput, crate::error::GetRestApisError> {
        if crate::aws_json_errors::is_error(&response) && response.status().as_u16() != 200 {
            let body = serde_json::from_slice(response.body().as_ref())
                .unwrap_or_else(|_| serde_json::json!({}));
            let generic = crate::aws_json_errors::parse_generic_error(&response, &body);

            let error_code = match generic.code() {
                Some(code) => code,
                None => return Err(crate::error::GetRestApisError::unhandled(generic)),
            };
            return Err(match error_code {
                "BadRequestException" => crate::error::GetRestApisError {
                    meta: generic,
                    kind: crate::error::GetRestApisErrorKind::BadRequestError({
                        #[allow(unused_mut)]
                        let mut output = crate::error::bad_request_error::Builder::default();
                        let _ = response;

                        let body_slice = response.body().as_ref();

                        let parsed_body: crate::error::BadRequestError = if body_slice.is_empty() {
                            // To enable JSON parsing to succeed, replace an empty body
                            // with an empty JSON body. If a member was required, it will fail slightly later
                            // during the operation construction phase.
                            serde_json::from_slice(b"{}")
                                .map_err(crate::error::GetRestApisError::unhandled)?
                        } else {
                            serde_json::from_slice(response.body().as_ref())
                                .map_err(crate::error::GetRestApisError::unhandled)?
                        };

                        output = output.set_message(parsed_body.message);
                        output.build()
                    }),
                },
                "TooManyRequestsException" => {
                    crate::error::GetRestApisError {
                        meta: generic,
                        kind: crate::error::GetRestApisErrorKind::TooManyRequestsError({
                            #[allow(unused_mut)]
                            let mut output =
                                crate::error::too_many_requests_error::Builder::default();
                            let _ = response;

                            let body_slice = response.body().as_ref();

                            let parsed_body: crate::error::TooManyRequestsError =
                                if body_slice.is_empty() {
                                    // To enable JSON parsing to succeed, replace an empty body
                                    // with an empty JSON body. If a member was required, it will fail slightly later
                                    // during the operation construction phase.
                                    serde_json::from_slice(b"{}")
                                        .map_err(crate::error::GetRestApisError::unhandled)?
                                } else {
                                    serde_json::from_slice(response.body().as_ref())
                                        .map_err(crate::error::GetRestApisError::unhandled)?
                                };

                            output = output.set_retry_after_seconds(
                        
                                                crate::http_serde::deser_header_get_rest_apis_retry_after_seconds(response.headers())
                                                    .map_err(|_|crate::error::GetRestApisError::unhandled("Failed to parse retryAfterSeconds from header `Retry-After"))?
                                                
                    );
                            output = output.set_message(parsed_body.message);
                            output.build()
                        }),
                    }
                }
                "UnauthorizedException" => crate::error::GetRestApisError {
                    meta: generic,
                    kind: crate::error::GetRestApisErrorKind::UnauthorizedError({
                        #[allow(unused_mut)]
                        let mut output = crate::error::unauthorized_error::Builder::default();
                        let _ = response;

                        let body_slice = response.body().as_ref();

                        let parsed_body: crate::error::UnauthorizedError = if body_slice.is_empty()
                        {
                            // To enable JSON parsing to succeed, replace an empty body
                            // with an empty JSON body. If a member was required, it will fail slightly later
                            // during the operation construction phase.
                            serde_json::from_slice(b"{}")
                                .map_err(crate::error::GetRestApisError::unhandled)?
                        } else {
                            serde_json::from_slice(response.body().as_ref())
                                .map_err(crate::error::GetRestApisError::unhandled)?
                        };

                        output = output.set_message(parsed_body.message);
                        output.build()
                    }),
                },
                _ => crate::error::GetRestApisError::generic(generic),
            });
        }
        Ok({
            #[allow(unused_mut)]
            let mut output = crate::output::get_rest_apis_output::Builder::default();
            let _ = response;

            let body_slice = response.body().as_ref();

            let parsed_body: crate::serializer::GetRestApisOutputBody = if body_slice.is_empty() {
                // To enable JSON parsing to succeed, replace an empty body
                // with an empty JSON body. If a member was required, it will fail slightly later
                // during the operation construction phase.
                serde_json::from_slice(b"{}").map_err(crate::error::GetRestApisError::unhandled)?
            } else {
                serde_json::from_slice(response.body().as_ref())
                    .map_err(crate::error::GetRestApisError::unhandled)?
            };

            output = output.set_items(parsed_body.items);
            output = output.set_position(parsed_body.position);
            output.build()
        })
    }
    pub fn parse_response(
        &self,
        response: &http::response::Response<impl AsRef<[u8]>>,
    ) -> Result<crate::output::GetRestApisOutput, crate::error::GetRestApisError> {
        Self::from_response(&response)
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}

impl smithy_http::response::ParseStrictResponse for GetRestApis {
    type Output = Result<crate::output::GetRestApisOutput, crate::error::GetRestApisError>;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        self.parse_response(response)
    }
}

/// <p>Generates a client SDK for a <a>RestApi</a> and <a>Stage</a>.</p>
#[derive(std::clone::Clone)]
pub struct GetSdk {
    _private: (),
}
impl GetSdk {
    /// Creates a new builder-style object to manufacture [`GetSdkInput`](crate::input::GetSdkInput)
    pub fn builder() -> crate::input::get_sdk_input::Builder {
        crate::input::get_sdk_input::Builder::default()
    }
    #[allow(clippy::unnecessary_wraps)]
    fn from_response(
        response: &http::response::Response<impl AsRef<[u8]>>,
    ) -> Result<crate::output::GetSdkOutput, crate::error::GetSdkError> {
        if crate::aws_json_errors::is_error(&response) && response.status().as_u16() != 200 {
            let body = serde_json::from_slice(response.body().as_ref())
                .unwrap_or_else(|_| serde_json::json!({}));
            let generic = crate::aws_json_errors::parse_generic_error(&response, &body);

            let error_code = match generic.code() {
                Some(code) => code,
                None => return Err(crate::error::GetSdkError::unhandled(generic)),
            };
            return Err(match error_code {
                "BadRequestException" => crate::error::GetSdkError {
                    meta: generic,
                    kind: crate::error::GetSdkErrorKind::BadRequestError({
                        #[allow(unused_mut)]
                        let mut output = crate::error::bad_request_error::Builder::default();
                        let _ = response;

                        let body_slice = response.body().as_ref();

                        let parsed_body: crate::error::BadRequestError = if body_slice.is_empty() {
                            // To enable JSON parsing to succeed, replace an empty body
                            // with an empty JSON body. If a member was required, it will fail slightly later
                            // during the operation construction phase.
                            serde_json::from_slice(b"{}")
                                .map_err(crate::error::GetSdkError::unhandled)?
                        } else {
                            serde_json::from_slice(response.body().as_ref())
                                .map_err(crate::error::GetSdkError::unhandled)?
                        };

                        output = output.set_message(parsed_body.message);
                        output.build()
                    }),
                },
                "ConflictException" => crate::error::GetSdkError {
                    meta: generic,
                    kind: crate::error::GetSdkErrorKind::ConflictError({
                        #[allow(unused_mut)]
                        let mut output = crate::error::conflict_error::Builder::default();
                        let _ = response;

                        let body_slice = response.body().as_ref();

                        let parsed_body: crate::error::ConflictError = if body_slice.is_empty() {
                            // To enable JSON parsing to succeed, replace an empty body
                            // with an empty JSON body. If a member was required, it will fail slightly later
                            // during the operation construction phase.
                            serde_json::from_slice(b"{}")
                                .map_err(crate::error::GetSdkError::unhandled)?
                        } else {
                            serde_json::from_slice(response.body().as_ref())
                                .map_err(crate::error::GetSdkError::unhandled)?
                        };

                        output = output.set_message(parsed_body.message);
                        output.build()
                    }),
                },
                "NotFoundException" => crate::error::GetSdkError {
                    meta: generic,
                    kind: crate::error::GetSdkErrorKind::NotFoundError({
                        #[allow(unused_mut)]
                        let mut output = crate::error::not_found_error::Builder::default();
                        let _ = response;

                        let body_slice = response.body().as_ref();

                        let parsed_body: crate::error::NotFoundError = if body_slice.is_empty() {
                            // To enable JSON parsing to succeed, replace an empty body
                            // with an empty JSON body. If a member was required, it will fail slightly later
                            // during the operation construction phase.
                            serde_json::from_slice(b"{}")
                                .map_err(crate::error::GetSdkError::unhandled)?
                        } else {
                            serde_json::from_slice(response.body().as_ref())
                                .map_err(crate::error::GetSdkError::unhandled)?
                        };

                        output = output.set_message(parsed_body.message);
                        output.build()
                    }),
                },
                "TooManyRequestsException" => {
                    crate::error::GetSdkError {
                        meta: generic,
                        kind: crate::error::GetSdkErrorKind::TooManyRequestsError({
                            #[allow(unused_mut)]
                            let mut output =
                                crate::error::too_many_requests_error::Builder::default();
                            let _ = response;

                            let body_slice = response.body().as_ref();

                            let parsed_body: crate::error::TooManyRequestsError =
                                if body_slice.is_empty() {
                                    // To enable JSON parsing to succeed, replace an empty body
                                    // with an empty JSON body. If a member was required, it will fail slightly later
                                    // during the operation construction phase.
                                    serde_json::from_slice(b"{}")
                                        .map_err(crate::error::GetSdkError::unhandled)?
                                } else {
                                    serde_json::from_slice(response.body().as_ref())
                                        .map_err(crate::error::GetSdkError::unhandled)?
                                };

                            output = output.set_retry_after_seconds(
                        
                                                crate::http_serde::deser_header_get_sdk_retry_after_seconds(response.headers())
                                                    .map_err(|_|crate::error::GetSdkError::unhandled("Failed to parse retryAfterSeconds from header `Retry-After"))?
                                                
                    );
                            output = output.set_message(parsed_body.message);
                            output.build()
                        }),
                    }
                }
                "UnauthorizedException" => crate::error::GetSdkError {
                    meta: generic,
                    kind: crate::error::GetSdkErrorKind::UnauthorizedError({
                        #[allow(unused_mut)]
                        let mut output = crate::error::unauthorized_error::Builder::default();
                        let _ = response;

                        let body_slice = response.body().as_ref();

                        let parsed_body: crate::error::UnauthorizedError = if body_slice.is_empty()
                        {
                            // To enable JSON parsing to succeed, replace an empty body
                            // with an empty JSON body. If a member was required, it will fail slightly later
                            // during the operation construction phase.
                            serde_json::from_slice(b"{}")
                                .map_err(crate::error::GetSdkError::unhandled)?
                        } else {
                            serde_json::from_slice(response.body().as_ref())
                                .map_err(crate::error::GetSdkError::unhandled)?
                        };

                        output = output.set_message(parsed_body.message);
                        output.build()
                    }),
                },
                _ => crate::error::GetSdkError::generic(generic),
            });
        }
        Ok({
            #[allow(unused_mut)]
            let mut output = crate::output::get_sdk_output::Builder::default();
            let _ = response;
            output = output.set_content_type(
                crate::http_serde::deser_header_get_sdk_content_type(response.headers()).map_err(
                    |_| {
                        crate::error::GetSdkError::unhandled(
                            "Failed to parse contentType from header `Content-Type",
                        )
                    },
                )?,
            );
            output = output.set_content_disposition(
                crate::http_serde::deser_header_get_sdk_content_disposition(response.headers())
                    .map_err(|_| {
                        crate::error::GetSdkError::unhandled(
                            "Failed to parse contentDisposition from header `Content-Disposition",
                        )
                    })?,
            );
            output = output.set_body(crate::http_serde::deser_payload_get_sdk_body(
                response.body().as_ref(),
            )?);
            output.build()
        })
    }
    pub fn parse_response(
        &self,
        response: &http::response::Response<impl AsRef<[u8]>>,
    ) -> Result<crate::output::GetSdkOutput, crate::error::GetSdkError> {
        Self::from_response(&response)
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}

impl smithy_http::response::ParseStrictResponse for GetSdk {
    type Output = Result<crate::output::GetSdkOutput, crate::error::GetSdkError>;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        self.parse_response(response)
    }
}

#[derive(std::clone::Clone)]
pub struct GetSdkType {
    _private: (),
}
impl GetSdkType {
    /// Creates a new builder-style object to manufacture [`GetSdkTypeInput`](crate::input::GetSdkTypeInput)
    pub fn builder() -> crate::input::get_sdk_type_input::Builder {
        crate::input::get_sdk_type_input::Builder::default()
    }
    #[allow(clippy::unnecessary_wraps)]
    fn from_response(
        response: &http::response::Response<impl AsRef<[u8]>>,
    ) -> Result<crate::output::GetSdkTypeOutput, crate::error::GetSdkTypeError> {
        if crate::aws_json_errors::is_error(&response) && response.status().as_u16() != 200 {
            let body = serde_json::from_slice(response.body().as_ref())
                .unwrap_or_else(|_| serde_json::json!({}));
            let generic = crate::aws_json_errors::parse_generic_error(&response, &body);

            let error_code = match generic.code() {
                Some(code) => code,
                None => return Err(crate::error::GetSdkTypeError::unhandled(generic)),
            };
            return Err(match error_code {
                "NotFoundException" => crate::error::GetSdkTypeError {
                    meta: generic,
                    kind: crate::error::GetSdkTypeErrorKind::NotFoundError({
                        #[allow(unused_mut)]
                        let mut output = crate::error::not_found_error::Builder::default();
                        let _ = response;

                        let body_slice = response.body().as_ref();

                        let parsed_body: crate::error::NotFoundError = if body_slice.is_empty() {
                            // To enable JSON parsing to succeed, replace an empty body
                            // with an empty JSON body. If a member was required, it will fail slightly later
                            // during the operation construction phase.
                            serde_json::from_slice(b"{}")
                                .map_err(crate::error::GetSdkTypeError::unhandled)?
                        } else {
                            serde_json::from_slice(response.body().as_ref())
                                .map_err(crate::error::GetSdkTypeError::unhandled)?
                        };

                        output = output.set_message(parsed_body.message);
                        output.build()
                    }),
                },
                "TooManyRequestsException" => {
                    crate::error::GetSdkTypeError {
                        meta: generic,
                        kind: crate::error::GetSdkTypeErrorKind::TooManyRequestsError({
                            #[allow(unused_mut)]
                            let mut output =
                                crate::error::too_many_requests_error::Builder::default();
                            let _ = response;

                            let body_slice = response.body().as_ref();

                            let parsed_body: crate::error::TooManyRequestsError =
                                if body_slice.is_empty() {
                                    // To enable JSON parsing to succeed, replace an empty body
                                    // with an empty JSON body. If a member was required, it will fail slightly later
                                    // during the operation construction phase.
                                    serde_json::from_slice(b"{}")
                                        .map_err(crate::error::GetSdkTypeError::unhandled)?
                                } else {
                                    serde_json::from_slice(response.body().as_ref())
                                        .map_err(crate::error::GetSdkTypeError::unhandled)?
                                };

                            output = output.set_retry_after_seconds(
                        
                                                crate::http_serde::deser_header_get_sdk_type_retry_after_seconds(response.headers())
                                                    .map_err(|_|crate::error::GetSdkTypeError::unhandled("Failed to parse retryAfterSeconds from header `Retry-After"))?
                                                
                    );
                            output = output.set_message(parsed_body.message);
                            output.build()
                        }),
                    }
                }
                "UnauthorizedException" => crate::error::GetSdkTypeError {
                    meta: generic,
                    kind: crate::error::GetSdkTypeErrorKind::UnauthorizedError({
                        #[allow(unused_mut)]
                        let mut output = crate::error::unauthorized_error::Builder::default();
                        let _ = response;

                        let body_slice = response.body().as_ref();

                        let parsed_body: crate::error::UnauthorizedError = if body_slice.is_empty()
                        {
                            // To enable JSON parsing to succeed, replace an empty body
                            // with an empty JSON body. If a member was required, it will fail slightly later
                            // during the operation construction phase.
                            serde_json::from_slice(b"{}")
                                .map_err(crate::error::GetSdkTypeError::unhandled)?
                        } else {
                            serde_json::from_slice(response.body().as_ref())
                                .map_err(crate::error::GetSdkTypeError::unhandled)?
                        };

                        output = output.set_message(parsed_body.message);
                        output.build()
                    }),
                },
                _ => crate::error::GetSdkTypeError::generic(generic),
            });
        }
        Ok({
            #[allow(unused_mut)]
            let mut output = crate::output::get_sdk_type_output::Builder::default();
            let _ = response;

            let body_slice = response.body().as_ref();

            let parsed_body: crate::serializer::GetSdkTypeOutputBody = if body_slice.is_empty() {
                // To enable JSON parsing to succeed, replace an empty body
                // with an empty JSON body. If a member was required, it will fail slightly later
                // during the operation construction phase.
                serde_json::from_slice(b"{}").map_err(crate::error::GetSdkTypeError::unhandled)?
            } else {
                serde_json::from_slice(response.body().as_ref())
                    .map_err(crate::error::GetSdkTypeError::unhandled)?
            };

            output = output.set_id(parsed_body.id);
            output = output.set_friendly_name(parsed_body.friendly_name);
            output = output.set_description(parsed_body.description);
            output = output.set_configuration_properties(parsed_body.configuration_properties);
            output.build()
        })
    }
    pub fn parse_response(
        &self,
        response: &http::response::Response<impl AsRef<[u8]>>,
    ) -> Result<crate::output::GetSdkTypeOutput, crate::error::GetSdkTypeError> {
        Self::from_response(&response)
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}

impl smithy_http::response::ParseStrictResponse for GetSdkType {
    type Output = Result<crate::output::GetSdkTypeOutput, crate::error::GetSdkTypeError>;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        self.parse_response(response)
    }
}

#[derive(std::clone::Clone)]
pub struct GetSdkTypes {
    _private: (),
}
impl GetSdkTypes {
    /// Creates a new builder-style object to manufacture [`GetSdkTypesInput`](crate::input::GetSdkTypesInput)
    pub fn builder() -> crate::input::get_sdk_types_input::Builder {
        crate::input::get_sdk_types_input::Builder::default()
    }
    #[allow(clippy::unnecessary_wraps)]
    fn from_response(
        response: &http::response::Response<impl AsRef<[u8]>>,
    ) -> Result<crate::output::GetSdkTypesOutput, crate::error::GetSdkTypesError> {
        if crate::aws_json_errors::is_error(&response) && response.status().as_u16() != 200 {
            let body = serde_json::from_slice(response.body().as_ref())
                .unwrap_or_else(|_| serde_json::json!({}));
            let generic = crate::aws_json_errors::parse_generic_error(&response, &body);

            let error_code = match generic.code() {
                Some(code) => code,
                None => return Err(crate::error::GetSdkTypesError::unhandled(generic)),
            };
            return Err(match error_code {
                "TooManyRequestsException" => {
                    crate::error::GetSdkTypesError {
                        meta: generic,
                        kind: crate::error::GetSdkTypesErrorKind::TooManyRequestsError({
                            #[allow(unused_mut)]
                            let mut output =
                                crate::error::too_many_requests_error::Builder::default();
                            let _ = response;

                            let body_slice = response.body().as_ref();

                            let parsed_body: crate::error::TooManyRequestsError =
                                if body_slice.is_empty() {
                                    // To enable JSON parsing to succeed, replace an empty body
                                    // with an empty JSON body. If a member was required, it will fail slightly later
                                    // during the operation construction phase.
                                    serde_json::from_slice(b"{}")
                                        .map_err(crate::error::GetSdkTypesError::unhandled)?
                                } else {
                                    serde_json::from_slice(response.body().as_ref())
                                        .map_err(crate::error::GetSdkTypesError::unhandled)?
                                };

                            output = output.set_retry_after_seconds(
                        
                                                crate::http_serde::deser_header_get_sdk_types_retry_after_seconds(response.headers())
                                                    .map_err(|_|crate::error::GetSdkTypesError::unhandled("Failed to parse retryAfterSeconds from header `Retry-After"))?
                                                
                    );
                            output = output.set_message(parsed_body.message);
                            output.build()
                        }),
                    }
                }
                "UnauthorizedException" => crate::error::GetSdkTypesError {
                    meta: generic,
                    kind: crate::error::GetSdkTypesErrorKind::UnauthorizedError({
                        #[allow(unused_mut)]
                        let mut output = crate::error::unauthorized_error::Builder::default();
                        let _ = response;

                        let body_slice = response.body().as_ref();

                        let parsed_body: crate::error::UnauthorizedError = if body_slice.is_empty()
                        {
                            // To enable JSON parsing to succeed, replace an empty body
                            // with an empty JSON body. If a member was required, it will fail slightly later
                            // during the operation construction phase.
                            serde_json::from_slice(b"{}")
                                .map_err(crate::error::GetSdkTypesError::unhandled)?
                        } else {
                            serde_json::from_slice(response.body().as_ref())
                                .map_err(crate::error::GetSdkTypesError::unhandled)?
                        };

                        output = output.set_message(parsed_body.message);
                        output.build()
                    }),
                },
                _ => crate::error::GetSdkTypesError::generic(generic),
            });
        }
        Ok({
            #[allow(unused_mut)]
            let mut output = crate::output::get_sdk_types_output::Builder::default();
            let _ = response;

            let body_slice = response.body().as_ref();

            let parsed_body: crate::serializer::GetSdkTypesOutputBody = if body_slice.is_empty() {
                // To enable JSON parsing to succeed, replace an empty body
                // with an empty JSON body. If a member was required, it will fail slightly later
                // during the operation construction phase.
                serde_json::from_slice(b"{}").map_err(crate::error::GetSdkTypesError::unhandled)?
            } else {
                serde_json::from_slice(response.body().as_ref())
                    .map_err(crate::error::GetSdkTypesError::unhandled)?
            };

            output = output.set_items(parsed_body.items);
            output.build()
        })
    }
    pub fn parse_response(
        &self,
        response: &http::response::Response<impl AsRef<[u8]>>,
    ) -> Result<crate::output::GetSdkTypesOutput, crate::error::GetSdkTypesError> {
        Self::from_response(&response)
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}

impl smithy_http::response::ParseStrictResponse for GetSdkTypes {
    type Output = Result<crate::output::GetSdkTypesOutput, crate::error::GetSdkTypesError>;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        self.parse_response(response)
    }
}

/// <p>Gets information about a <a>Stage</a> resource.</p>
#[derive(std::clone::Clone)]
pub struct GetStage {
    _private: (),
}
impl GetStage {
    /// Creates a new builder-style object to manufacture [`GetStageInput`](crate::input::GetStageInput)
    pub fn builder() -> crate::input::get_stage_input::Builder {
        crate::input::get_stage_input::Builder::default()
    }
    #[allow(clippy::unnecessary_wraps)]
    fn from_response(
        response: &http::response::Response<impl AsRef<[u8]>>,
    ) -> Result<crate::output::GetStageOutput, crate::error::GetStageError> {
        if crate::aws_json_errors::is_error(&response) && response.status().as_u16() != 200 {
            let body = serde_json::from_slice(response.body().as_ref())
                .unwrap_or_else(|_| serde_json::json!({}));
            let generic = crate::aws_json_errors::parse_generic_error(&response, &body);

            let error_code = match generic.code() {
                Some(code) => code,
                None => return Err(crate::error::GetStageError::unhandled(generic)),
            };
            return Err(match error_code {
                "NotFoundException" => crate::error::GetStageError {
                    meta: generic,
                    kind: crate::error::GetStageErrorKind::NotFoundError({
                        #[allow(unused_mut)]
                        let mut output = crate::error::not_found_error::Builder::default();
                        let _ = response;

                        let body_slice = response.body().as_ref();

                        let parsed_body: crate::error::NotFoundError = if body_slice.is_empty() {
                            // To enable JSON parsing to succeed, replace an empty body
                            // with an empty JSON body. If a member was required, it will fail slightly later
                            // during the operation construction phase.
                            serde_json::from_slice(b"{}")
                                .map_err(crate::error::GetStageError::unhandled)?
                        } else {
                            serde_json::from_slice(response.body().as_ref())
                                .map_err(crate::error::GetStageError::unhandled)?
                        };

                        output = output.set_message(parsed_body.message);
                        output.build()
                    }),
                },
                "TooManyRequestsException" => {
                    crate::error::GetStageError {
                        meta: generic,
                        kind: crate::error::GetStageErrorKind::TooManyRequestsError({
                            #[allow(unused_mut)]
                            let mut output =
                                crate::error::too_many_requests_error::Builder::default();
                            let _ = response;

                            let body_slice = response.body().as_ref();

                            let parsed_body: crate::error::TooManyRequestsError =
                                if body_slice.is_empty() {
                                    // To enable JSON parsing to succeed, replace an empty body
                                    // with an empty JSON body. If a member was required, it will fail slightly later
                                    // during the operation construction phase.
                                    serde_json::from_slice(b"{}")
                                        .map_err(crate::error::GetStageError::unhandled)?
                                } else {
                                    serde_json::from_slice(response.body().as_ref())
                                        .map_err(crate::error::GetStageError::unhandled)?
                                };

                            output = output.set_retry_after_seconds(
                        
                                                crate::http_serde::deser_header_get_stage_retry_after_seconds(response.headers())
                                                    .map_err(|_|crate::error::GetStageError::unhandled("Failed to parse retryAfterSeconds from header `Retry-After"))?
                                                
                    );
                            output = output.set_message(parsed_body.message);
                            output.build()
                        }),
                    }
                }
                "UnauthorizedException" => crate::error::GetStageError {
                    meta: generic,
                    kind: crate::error::GetStageErrorKind::UnauthorizedError({
                        #[allow(unused_mut)]
                        let mut output = crate::error::unauthorized_error::Builder::default();
                        let _ = response;

                        let body_slice = response.body().as_ref();

                        let parsed_body: crate::error::UnauthorizedError = if body_slice.is_empty()
                        {
                            // To enable JSON parsing to succeed, replace an empty body
                            // with an empty JSON body. If a member was required, it will fail slightly later
                            // during the operation construction phase.
                            serde_json::from_slice(b"{}")
                                .map_err(crate::error::GetStageError::unhandled)?
                        } else {
                            serde_json::from_slice(response.body().as_ref())
                                .map_err(crate::error::GetStageError::unhandled)?
                        };

                        output = output.set_message(parsed_body.message);
                        output.build()
                    }),
                },
                _ => crate::error::GetStageError::generic(generic),
            });
        }
        Ok({
            #[allow(unused_mut)]
            let mut output = crate::output::get_stage_output::Builder::default();
            let _ = response;

            let body_slice = response.body().as_ref();

            let parsed_body: crate::serializer::GetStageOutputBody = if body_slice.is_empty() {
                // To enable JSON parsing to succeed, replace an empty body
                // with an empty JSON body. If a member was required, it will fail slightly later
                // during the operation construction phase.
                serde_json::from_slice(b"{}").map_err(crate::error::GetStageError::unhandled)?
            } else {
                serde_json::from_slice(response.body().as_ref())
                    .map_err(crate::error::GetStageError::unhandled)?
            };

            output = output.set_deployment_id(parsed_body.deployment_id);
            output = output.set_client_certificate_id(parsed_body.client_certificate_id);
            output = output.set_stage_name(parsed_body.stage_name);
            output = output.set_description(parsed_body.description);
            output = output.set_cache_cluster_enabled(parsed_body.cache_cluster_enabled);
            output = output.set_cache_cluster_size(parsed_body.cache_cluster_size);
            output = output.set_cache_cluster_status(parsed_body.cache_cluster_status);
            output = output.set_method_settings(parsed_body.method_settings);
            output = output.set_variables(parsed_body.variables);
            output = output.set_documentation_version(parsed_body.documentation_version);
            output = output.set_access_log_settings(parsed_body.access_log_settings);
            output = output.set_canary_settings(parsed_body.canary_settings);
            output = output.set_tracing_enabled(parsed_body.tracing_enabled);
            output = output.set_web_acl_arn(parsed_body.web_acl_arn);
            output = output.set_tags(parsed_body.tags);
            output = output.set_created_date(parsed_body.created_date);
            output = output.set_last_updated_date(parsed_body.last_updated_date);
            output.build()
        })
    }
    pub fn parse_response(
        &self,
        response: &http::response::Response<impl AsRef<[u8]>>,
    ) -> Result<crate::output::GetStageOutput, crate::error::GetStageError> {
        Self::from_response(&response)
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}

impl smithy_http::response::ParseStrictResponse for GetStage {
    type Output = Result<crate::output::GetStageOutput, crate::error::GetStageError>;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        self.parse_response(response)
    }
}

/// <p>Gets information about one or more <a>Stage</a> resources.</p>
#[derive(std::clone::Clone)]
pub struct GetStages {
    _private: (),
}
impl GetStages {
    /// Creates a new builder-style object to manufacture [`GetStagesInput`](crate::input::GetStagesInput)
    pub fn builder() -> crate::input::get_stages_input::Builder {
        crate::input::get_stages_input::Builder::default()
    }
    #[allow(clippy::unnecessary_wraps)]
    fn from_response(
        response: &http::response::Response<impl AsRef<[u8]>>,
    ) -> Result<crate::output::GetStagesOutput, crate::error::GetStagesError> {
        if crate::aws_json_errors::is_error(&response) && response.status().as_u16() != 200 {
            let body = serde_json::from_slice(response.body().as_ref())
                .unwrap_or_else(|_| serde_json::json!({}));
            let generic = crate::aws_json_errors::parse_generic_error(&response, &body);

            let error_code = match generic.code() {
                Some(code) => code,
                None => return Err(crate::error::GetStagesError::unhandled(generic)),
            };
            return Err(match error_code {
                "NotFoundException" => crate::error::GetStagesError {
                    meta: generic,
                    kind: crate::error::GetStagesErrorKind::NotFoundError({
                        #[allow(unused_mut)]
                        let mut output = crate::error::not_found_error::Builder::default();
                        let _ = response;

                        let body_slice = response.body().as_ref();

                        let parsed_body: crate::error::NotFoundError = if body_slice.is_empty() {
                            // To enable JSON parsing to succeed, replace an empty body
                            // with an empty JSON body. If a member was required, it will fail slightly later
                            // during the operation construction phase.
                            serde_json::from_slice(b"{}")
                                .map_err(crate::error::GetStagesError::unhandled)?
                        } else {
                            serde_json::from_slice(response.body().as_ref())
                                .map_err(crate::error::GetStagesError::unhandled)?
                        };

                        output = output.set_message(parsed_body.message);
                        output.build()
                    }),
                },
                "TooManyRequestsException" => {
                    crate::error::GetStagesError {
                        meta: generic,
                        kind: crate::error::GetStagesErrorKind::TooManyRequestsError({
                            #[allow(unused_mut)]
                            let mut output =
                                crate::error::too_many_requests_error::Builder::default();
                            let _ = response;

                            let body_slice = response.body().as_ref();

                            let parsed_body: crate::error::TooManyRequestsError =
                                if body_slice.is_empty() {
                                    // To enable JSON parsing to succeed, replace an empty body
                                    // with an empty JSON body. If a member was required, it will fail slightly later
                                    // during the operation construction phase.
                                    serde_json::from_slice(b"{}")
                                        .map_err(crate::error::GetStagesError::unhandled)?
                                } else {
                                    serde_json::from_slice(response.body().as_ref())
                                        .map_err(crate::error::GetStagesError::unhandled)?
                                };

                            output = output.set_retry_after_seconds(
                        
                                                crate::http_serde::deser_header_get_stages_retry_after_seconds(response.headers())
                                                    .map_err(|_|crate::error::GetStagesError::unhandled("Failed to parse retryAfterSeconds from header `Retry-After"))?
                                                
                    );
                            output = output.set_message(parsed_body.message);
                            output.build()
                        }),
                    }
                }
                "UnauthorizedException" => crate::error::GetStagesError {
                    meta: generic,
                    kind: crate::error::GetStagesErrorKind::UnauthorizedError({
                        #[allow(unused_mut)]
                        let mut output = crate::error::unauthorized_error::Builder::default();
                        let _ = response;

                        let body_slice = response.body().as_ref();

                        let parsed_body: crate::error::UnauthorizedError = if body_slice.is_empty()
                        {
                            // To enable JSON parsing to succeed, replace an empty body
                            // with an empty JSON body. If a member was required, it will fail slightly later
                            // during the operation construction phase.
                            serde_json::from_slice(b"{}")
                                .map_err(crate::error::GetStagesError::unhandled)?
                        } else {
                            serde_json::from_slice(response.body().as_ref())
                                .map_err(crate::error::GetStagesError::unhandled)?
                        };

                        output = output.set_message(parsed_body.message);
                        output.build()
                    }),
                },
                _ => crate::error::GetStagesError::generic(generic),
            });
        }
        Ok({
            #[allow(unused_mut)]
            let mut output = crate::output::get_stages_output::Builder::default();
            let _ = response;

            let body_slice = response.body().as_ref();

            let parsed_body: crate::serializer::GetStagesOutputBody = if body_slice.is_empty() {
                // To enable JSON parsing to succeed, replace an empty body
                // with an empty JSON body. If a member was required, it will fail slightly later
                // during the operation construction phase.
                serde_json::from_slice(b"{}").map_err(crate::error::GetStagesError::unhandled)?
            } else {
                serde_json::from_slice(response.body().as_ref())
                    .map_err(crate::error::GetStagesError::unhandled)?
            };

            output = output.set_item(parsed_body.item);
            output.build()
        })
    }
    pub fn parse_response(
        &self,
        response: &http::response::Response<impl AsRef<[u8]>>,
    ) -> Result<crate::output::GetStagesOutput, crate::error::GetStagesError> {
        Self::from_response(&response)
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}

impl smithy_http::response::ParseStrictResponse for GetStages {
    type Output = Result<crate::output::GetStagesOutput, crate::error::GetStagesError>;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        self.parse_response(response)
    }
}

/// <p>Gets the <a>Tags</a> collection for a given resource.</p>
#[derive(std::clone::Clone)]
pub struct GetTags {
    _private: (),
}
impl GetTags {
    /// Creates a new builder-style object to manufacture [`GetTagsInput`](crate::input::GetTagsInput)
    pub fn builder() -> crate::input::get_tags_input::Builder {
        crate::input::get_tags_input::Builder::default()
    }
    #[allow(clippy::unnecessary_wraps)]
    fn from_response(
        response: &http::response::Response<impl AsRef<[u8]>>,
    ) -> Result<crate::output::GetTagsOutput, crate::error::GetTagsError> {
        if crate::aws_json_errors::is_error(&response) && response.status().as_u16() != 200 {
            let body = serde_json::from_slice(response.body().as_ref())
                .unwrap_or_else(|_| serde_json::json!({}));
            let generic = crate::aws_json_errors::parse_generic_error(&response, &body);

            let error_code = match generic.code() {
                Some(code) => code,
                None => return Err(crate::error::GetTagsError::unhandled(generic)),
            };
            return Err(match error_code {
                "BadRequestException" => crate::error::GetTagsError {
                    meta: generic,
                    kind: crate::error::GetTagsErrorKind::BadRequestError({
                        #[allow(unused_mut)]
                        let mut output = crate::error::bad_request_error::Builder::default();
                        let _ = response;

                        let body_slice = response.body().as_ref();

                        let parsed_body: crate::error::BadRequestError = if body_slice.is_empty() {
                            // To enable JSON parsing to succeed, replace an empty body
                            // with an empty JSON body. If a member was required, it will fail slightly later
                            // during the operation construction phase.
                            serde_json::from_slice(b"{}")
                                .map_err(crate::error::GetTagsError::unhandled)?
                        } else {
                            serde_json::from_slice(response.body().as_ref())
                                .map_err(crate::error::GetTagsError::unhandled)?
                        };

                        output = output.set_message(parsed_body.message);
                        output.build()
                    }),
                },
                "LimitExceededException" => {
                    crate::error::GetTagsError {
                        meta: generic,
                        kind: crate::error::GetTagsErrorKind::LimitExceededError({
                            #[allow(unused_mut)]
                            let mut output = crate::error::limit_exceeded_error::Builder::default();
                            let _ = response;

                            let body_slice = response.body().as_ref();

                            let parsed_body: crate::error::LimitExceededError =
                                if body_slice.is_empty() {
                                    // To enable JSON parsing to succeed, replace an empty body
                                    // with an empty JSON body. If a member was required, it will fail slightly later
                                    // during the operation construction phase.
                                    serde_json::from_slice(b"{}")
                                        .map_err(crate::error::GetTagsError::unhandled)?
                                } else {
                                    serde_json::from_slice(response.body().as_ref())
                                        .map_err(crate::error::GetTagsError::unhandled)?
                                };

                            output = output.set_retry_after_seconds(
                        
                                                crate::http_serde::deser_header_get_tags_retry_after_seconds(response.headers())
                                                    .map_err(|_|crate::error::GetTagsError::unhandled("Failed to parse retryAfterSeconds from header `Retry-After"))?
                                                
                    );
                            output = output.set_message(parsed_body.message);
                            output.build()
                        }),
                    }
                }
                "NotFoundException" => crate::error::GetTagsError {
                    meta: generic,
                    kind: crate::error::GetTagsErrorKind::NotFoundError({
                        #[allow(unused_mut)]
                        let mut output = crate::error::not_found_error::Builder::default();
                        let _ = response;

                        let body_slice = response.body().as_ref();

                        let parsed_body: crate::error::NotFoundError = if body_slice.is_empty() {
                            // To enable JSON parsing to succeed, replace an empty body
                            // with an empty JSON body. If a member was required, it will fail slightly later
                            // during the operation construction phase.
                            serde_json::from_slice(b"{}")
                                .map_err(crate::error::GetTagsError::unhandled)?
                        } else {
                            serde_json::from_slice(response.body().as_ref())
                                .map_err(crate::error::GetTagsError::unhandled)?
                        };

                        output = output.set_message(parsed_body.message);
                        output.build()
                    }),
                },
                "TooManyRequestsException" => {
                    crate::error::GetTagsError {
                        meta: generic,
                        kind: crate::error::GetTagsErrorKind::TooManyRequestsError({
                            #[allow(unused_mut)]
                            let mut output =
                                crate::error::too_many_requests_error::Builder::default();
                            let _ = response;

                            let body_slice = response.body().as_ref();

                            let parsed_body: crate::error::TooManyRequestsError =
                                if body_slice.is_empty() {
                                    // To enable JSON parsing to succeed, replace an empty body
                                    // with an empty JSON body. If a member was required, it will fail slightly later
                                    // during the operation construction phase.
                                    serde_json::from_slice(b"{}")
                                        .map_err(crate::error::GetTagsError::unhandled)?
                                } else {
                                    serde_json::from_slice(response.body().as_ref())
                                        .map_err(crate::error::GetTagsError::unhandled)?
                                };

                            output = output.set_retry_after_seconds(
                        
                                                crate::http_serde::deser_header_get_tags_retry_after_seconds(response.headers())
                                                    .map_err(|_|crate::error::GetTagsError::unhandled("Failed to parse retryAfterSeconds from header `Retry-After"))?
                                                
                    );
                            output = output.set_message(parsed_body.message);
                            output.build()
                        }),
                    }
                }
                "UnauthorizedException" => crate::error::GetTagsError {
                    meta: generic,
                    kind: crate::error::GetTagsErrorKind::UnauthorizedError({
                        #[allow(unused_mut)]
                        let mut output = crate::error::unauthorized_error::Builder::default();
                        let _ = response;

                        let body_slice = response.body().as_ref();

                        let parsed_body: crate::error::UnauthorizedError = if body_slice.is_empty()
                        {
                            // To enable JSON parsing to succeed, replace an empty body
                            // with an empty JSON body. If a member was required, it will fail slightly later
                            // during the operation construction phase.
                            serde_json::from_slice(b"{}")
                                .map_err(crate::error::GetTagsError::unhandled)?
                        } else {
                            serde_json::from_slice(response.body().as_ref())
                                .map_err(crate::error::GetTagsError::unhandled)?
                        };

                        output = output.set_message(parsed_body.message);
                        output.build()
                    }),
                },
                _ => crate::error::GetTagsError::generic(generic),
            });
        }
        Ok({
            #[allow(unused_mut)]
            let mut output = crate::output::get_tags_output::Builder::default();
            let _ = response;

            let body_slice = response.body().as_ref();

            let parsed_body: crate::serializer::GetTagsOutputBody = if body_slice.is_empty() {
                // To enable JSON parsing to succeed, replace an empty body
                // with an empty JSON body. If a member was required, it will fail slightly later
                // during the operation construction phase.
                serde_json::from_slice(b"{}").map_err(crate::error::GetTagsError::unhandled)?
            } else {
                serde_json::from_slice(response.body().as_ref())
                    .map_err(crate::error::GetTagsError::unhandled)?
            };

            output = output.set_tags(parsed_body.tags);
            output.build()
        })
    }
    pub fn parse_response(
        &self,
        response: &http::response::Response<impl AsRef<[u8]>>,
    ) -> Result<crate::output::GetTagsOutput, crate::error::GetTagsError> {
        Self::from_response(&response)
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}

impl smithy_http::response::ParseStrictResponse for GetTags {
    type Output = Result<crate::output::GetTagsOutput, crate::error::GetTagsError>;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        self.parse_response(response)
    }
}

/// <p>Gets the usage data of a usage plan in a specified time interval.</p>
#[derive(std::clone::Clone)]
pub struct GetUsage {
    _private: (),
}
impl GetUsage {
    /// Creates a new builder-style object to manufacture [`GetUsageInput`](crate::input::GetUsageInput)
    pub fn builder() -> crate::input::get_usage_input::Builder {
        crate::input::get_usage_input::Builder::default()
    }
    #[allow(clippy::unnecessary_wraps)]
    fn from_response(
        response: &http::response::Response<impl AsRef<[u8]>>,
    ) -> Result<crate::output::GetUsageOutput, crate::error::GetUsageError> {
        if crate::aws_json_errors::is_error(&response) && response.status().as_u16() != 200 {
            let body = serde_json::from_slice(response.body().as_ref())
                .unwrap_or_else(|_| serde_json::json!({}));
            let generic = crate::aws_json_errors::parse_generic_error(&response, &body);

            let error_code = match generic.code() {
                Some(code) => code,
                None => return Err(crate::error::GetUsageError::unhandled(generic)),
            };
            return Err(match error_code {
                "BadRequestException" => crate::error::GetUsageError {
                    meta: generic,
                    kind: crate::error::GetUsageErrorKind::BadRequestError({
                        #[allow(unused_mut)]
                        let mut output = crate::error::bad_request_error::Builder::default();
                        let _ = response;

                        let body_slice = response.body().as_ref();

                        let parsed_body: crate::error::BadRequestError = if body_slice.is_empty() {
                            // To enable JSON parsing to succeed, replace an empty body
                            // with an empty JSON body. If a member was required, it will fail slightly later
                            // during the operation construction phase.
                            serde_json::from_slice(b"{}")
                                .map_err(crate::error::GetUsageError::unhandled)?
                        } else {
                            serde_json::from_slice(response.body().as_ref())
                                .map_err(crate::error::GetUsageError::unhandled)?
                        };

                        output = output.set_message(parsed_body.message);
                        output.build()
                    }),
                },
                "NotFoundException" => crate::error::GetUsageError {
                    meta: generic,
                    kind: crate::error::GetUsageErrorKind::NotFoundError({
                        #[allow(unused_mut)]
                        let mut output = crate::error::not_found_error::Builder::default();
                        let _ = response;

                        let body_slice = response.body().as_ref();

                        let parsed_body: crate::error::NotFoundError = if body_slice.is_empty() {
                            // To enable JSON parsing to succeed, replace an empty body
                            // with an empty JSON body. If a member was required, it will fail slightly later
                            // during the operation construction phase.
                            serde_json::from_slice(b"{}")
                                .map_err(crate::error::GetUsageError::unhandled)?
                        } else {
                            serde_json::from_slice(response.body().as_ref())
                                .map_err(crate::error::GetUsageError::unhandled)?
                        };

                        output = output.set_message(parsed_body.message);
                        output.build()
                    }),
                },
                "TooManyRequestsException" => {
                    crate::error::GetUsageError {
                        meta: generic,
                        kind: crate::error::GetUsageErrorKind::TooManyRequestsError({
                            #[allow(unused_mut)]
                            let mut output =
                                crate::error::too_many_requests_error::Builder::default();
                            let _ = response;

                            let body_slice = response.body().as_ref();

                            let parsed_body: crate::error::TooManyRequestsError =
                                if body_slice.is_empty() {
                                    // To enable JSON parsing to succeed, replace an empty body
                                    // with an empty JSON body. If a member was required, it will fail slightly later
                                    // during the operation construction phase.
                                    serde_json::from_slice(b"{}")
                                        .map_err(crate::error::GetUsageError::unhandled)?
                                } else {
                                    serde_json::from_slice(response.body().as_ref())
                                        .map_err(crate::error::GetUsageError::unhandled)?
                                };

                            output = output.set_retry_after_seconds(
                        
                                                crate::http_serde::deser_header_get_usage_retry_after_seconds(response.headers())
                                                    .map_err(|_|crate::error::GetUsageError::unhandled("Failed to parse retryAfterSeconds from header `Retry-After"))?
                                                
                    );
                            output = output.set_message(parsed_body.message);
                            output.build()
                        }),
                    }
                }
                "UnauthorizedException" => crate::error::GetUsageError {
                    meta: generic,
                    kind: crate::error::GetUsageErrorKind::UnauthorizedError({
                        #[allow(unused_mut)]
                        let mut output = crate::error::unauthorized_error::Builder::default();
                        let _ = response;

                        let body_slice = response.body().as_ref();

                        let parsed_body: crate::error::UnauthorizedError = if body_slice.is_empty()
                        {
                            // To enable JSON parsing to succeed, replace an empty body
                            // with an empty JSON body. If a member was required, it will fail slightly later
                            // during the operation construction phase.
                            serde_json::from_slice(b"{}")
                                .map_err(crate::error::GetUsageError::unhandled)?
                        } else {
                            serde_json::from_slice(response.body().as_ref())
                                .map_err(crate::error::GetUsageError::unhandled)?
                        };

                        output = output.set_message(parsed_body.message);
                        output.build()
                    }),
                },
                _ => crate::error::GetUsageError::generic(generic),
            });
        }
        Ok({
            #[allow(unused_mut)]
            let mut output = crate::output::get_usage_output::Builder::default();
            let _ = response;

            let body_slice = response.body().as_ref();

            let parsed_body: crate::serializer::GetUsageOutputBody = if body_slice.is_empty() {
                // To enable JSON parsing to succeed, replace an empty body
                // with an empty JSON body. If a member was required, it will fail slightly later
                // during the operation construction phase.
                serde_json::from_slice(b"{}").map_err(crate::error::GetUsageError::unhandled)?
            } else {
                serde_json::from_slice(response.body().as_ref())
                    .map_err(crate::error::GetUsageError::unhandled)?
            };

            output = output.set_usage_plan_id(parsed_body.usage_plan_id);
            output = output.set_start_date(parsed_body.start_date);
            output = output.set_end_date(parsed_body.end_date);
            output = output.set_items(parsed_body.items);
            output = output.set_position(parsed_body.position);
            output.build()
        })
    }
    pub fn parse_response(
        &self,
        response: &http::response::Response<impl AsRef<[u8]>>,
    ) -> Result<crate::output::GetUsageOutput, crate::error::GetUsageError> {
        Self::from_response(&response)
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}

impl smithy_http::response::ParseStrictResponse for GetUsage {
    type Output = Result<crate::output::GetUsageOutput, crate::error::GetUsageError>;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        self.parse_response(response)
    }
}

/// <p>Gets a usage plan of a given plan identifier.</p>
#[derive(std::clone::Clone)]
pub struct GetUsagePlan {
    _private: (),
}
impl GetUsagePlan {
    /// Creates a new builder-style object to manufacture [`GetUsagePlanInput`](crate::input::GetUsagePlanInput)
    pub fn builder() -> crate::input::get_usage_plan_input::Builder {
        crate::input::get_usage_plan_input::Builder::default()
    }
    #[allow(clippy::unnecessary_wraps)]
    fn from_response(
        response: &http::response::Response<impl AsRef<[u8]>>,
    ) -> Result<crate::output::GetUsagePlanOutput, crate::error::GetUsagePlanError> {
        if crate::aws_json_errors::is_error(&response) && response.status().as_u16() != 200 {
            let body = serde_json::from_slice(response.body().as_ref())
                .unwrap_or_else(|_| serde_json::json!({}));
            let generic = crate::aws_json_errors::parse_generic_error(&response, &body);

            let error_code = match generic.code() {
                Some(code) => code,
                None => return Err(crate::error::GetUsagePlanError::unhandled(generic)),
            };
            return Err(match error_code {
                "BadRequestException" => crate::error::GetUsagePlanError {
                    meta: generic,
                    kind: crate::error::GetUsagePlanErrorKind::BadRequestError({
                        #[allow(unused_mut)]
                        let mut output = crate::error::bad_request_error::Builder::default();
                        let _ = response;

                        let body_slice = response.body().as_ref();

                        let parsed_body: crate::error::BadRequestError = if body_slice.is_empty() {
                            // To enable JSON parsing to succeed, replace an empty body
                            // with an empty JSON body. If a member was required, it will fail slightly later
                            // during the operation construction phase.
                            serde_json::from_slice(b"{}")
                                .map_err(crate::error::GetUsagePlanError::unhandled)?
                        } else {
                            serde_json::from_slice(response.body().as_ref())
                                .map_err(crate::error::GetUsagePlanError::unhandled)?
                        };

                        output = output.set_message(parsed_body.message);
                        output.build()
                    }),
                },
                "NotFoundException" => crate::error::GetUsagePlanError {
                    meta: generic,
                    kind: crate::error::GetUsagePlanErrorKind::NotFoundError({
                        #[allow(unused_mut)]
                        let mut output = crate::error::not_found_error::Builder::default();
                        let _ = response;

                        let body_slice = response.body().as_ref();

                        let parsed_body: crate::error::NotFoundError = if body_slice.is_empty() {
                            // To enable JSON parsing to succeed, replace an empty body
                            // with an empty JSON body. If a member was required, it will fail slightly later
                            // during the operation construction phase.
                            serde_json::from_slice(b"{}")
                                .map_err(crate::error::GetUsagePlanError::unhandled)?
                        } else {
                            serde_json::from_slice(response.body().as_ref())
                                .map_err(crate::error::GetUsagePlanError::unhandled)?
                        };

                        output = output.set_message(parsed_body.message);
                        output.build()
                    }),
                },
                "TooManyRequestsException" => {
                    crate::error::GetUsagePlanError {
                        meta: generic,
                        kind: crate::error::GetUsagePlanErrorKind::TooManyRequestsError({
                            #[allow(unused_mut)]
                            let mut output =
                                crate::error::too_many_requests_error::Builder::default();
                            let _ = response;

                            let body_slice = response.body().as_ref();

                            let parsed_body: crate::error::TooManyRequestsError =
                                if body_slice.is_empty() {
                                    // To enable JSON parsing to succeed, replace an empty body
                                    // with an empty JSON body. If a member was required, it will fail slightly later
                                    // during the operation construction phase.
                                    serde_json::from_slice(b"{}")
                                        .map_err(crate::error::GetUsagePlanError::unhandled)?
                                } else {
                                    serde_json::from_slice(response.body().as_ref())
                                        .map_err(crate::error::GetUsagePlanError::unhandled)?
                                };

                            output = output.set_retry_after_seconds(
                        
                                                crate::http_serde::deser_header_get_usage_plan_retry_after_seconds(response.headers())
                                                    .map_err(|_|crate::error::GetUsagePlanError::unhandled("Failed to parse retryAfterSeconds from header `Retry-After"))?
                                                
                    );
                            output = output.set_message(parsed_body.message);
                            output.build()
                        }),
                    }
                }
                "UnauthorizedException" => crate::error::GetUsagePlanError {
                    meta: generic,
                    kind: crate::error::GetUsagePlanErrorKind::UnauthorizedError({
                        #[allow(unused_mut)]
                        let mut output = crate::error::unauthorized_error::Builder::default();
                        let _ = response;

                        let body_slice = response.body().as_ref();

                        let parsed_body: crate::error::UnauthorizedError = if body_slice.is_empty()
                        {
                            // To enable JSON parsing to succeed, replace an empty body
                            // with an empty JSON body. If a member was required, it will fail slightly later
                            // during the operation construction phase.
                            serde_json::from_slice(b"{}")
                                .map_err(crate::error::GetUsagePlanError::unhandled)?
                        } else {
                            serde_json::from_slice(response.body().as_ref())
                                .map_err(crate::error::GetUsagePlanError::unhandled)?
                        };

                        output = output.set_message(parsed_body.message);
                        output.build()
                    }),
                },
                _ => crate::error::GetUsagePlanError::generic(generic),
            });
        }
        Ok({
            #[allow(unused_mut)]
            let mut output = crate::output::get_usage_plan_output::Builder::default();
            let _ = response;

            let body_slice = response.body().as_ref();

            let parsed_body: crate::serializer::GetUsagePlanOutputBody = if body_slice.is_empty() {
                // To enable JSON parsing to succeed, replace an empty body
                // with an empty JSON body. If a member was required, it will fail slightly later
                // during the operation construction phase.
                serde_json::from_slice(b"{}").map_err(crate::error::GetUsagePlanError::unhandled)?
            } else {
                serde_json::from_slice(response.body().as_ref())
                    .map_err(crate::error::GetUsagePlanError::unhandled)?
            };

            output = output.set_id(parsed_body.id);
            output = output.set_name(parsed_body.name);
            output = output.set_description(parsed_body.description);
            output = output.set_api_stages(parsed_body.api_stages);
            output = output.set_throttle(parsed_body.throttle);
            output = output.set_quota(parsed_body.quota);
            output = output.set_product_code(parsed_body.product_code);
            output = output.set_tags(parsed_body.tags);
            output.build()
        })
    }
    pub fn parse_response(
        &self,
        response: &http::response::Response<impl AsRef<[u8]>>,
    ) -> Result<crate::output::GetUsagePlanOutput, crate::error::GetUsagePlanError> {
        Self::from_response(&response)
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}

impl smithy_http::response::ParseStrictResponse for GetUsagePlan {
    type Output = Result<crate::output::GetUsagePlanOutput, crate::error::GetUsagePlanError>;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        self.parse_response(response)
    }
}

/// <p>Gets a usage plan key of a given key identifier.</p>
#[derive(std::clone::Clone)]
pub struct GetUsagePlanKey {
    _private: (),
}
impl GetUsagePlanKey {
    /// Creates a new builder-style object to manufacture [`GetUsagePlanKeyInput`](crate::input::GetUsagePlanKeyInput)
    pub fn builder() -> crate::input::get_usage_plan_key_input::Builder {
        crate::input::get_usage_plan_key_input::Builder::default()
    }
    #[allow(clippy::unnecessary_wraps)]
    fn from_response(
        response: &http::response::Response<impl AsRef<[u8]>>,
    ) -> Result<crate::output::GetUsagePlanKeyOutput, crate::error::GetUsagePlanKeyError> {
        if crate::aws_json_errors::is_error(&response) && response.status().as_u16() != 200 {
            let body = serde_json::from_slice(response.body().as_ref())
                .unwrap_or_else(|_| serde_json::json!({}));
            let generic = crate::aws_json_errors::parse_generic_error(&response, &body);

            let error_code = match generic.code() {
                Some(code) => code,
                None => return Err(crate::error::GetUsagePlanKeyError::unhandled(generic)),
            };
            return Err(match error_code {
                "BadRequestException" => crate::error::GetUsagePlanKeyError {
                    meta: generic,
                    kind: crate::error::GetUsagePlanKeyErrorKind::BadRequestError({
                        #[allow(unused_mut)]
                        let mut output = crate::error::bad_request_error::Builder::default();
                        let _ = response;

                        let body_slice = response.body().as_ref();

                        let parsed_body: crate::error::BadRequestError = if body_slice.is_empty() {
                            // To enable JSON parsing to succeed, replace an empty body
                            // with an empty JSON body. If a member was required, it will fail slightly later
                            // during the operation construction phase.
                            serde_json::from_slice(b"{}")
                                .map_err(crate::error::GetUsagePlanKeyError::unhandled)?
                        } else {
                            serde_json::from_slice(response.body().as_ref())
                                .map_err(crate::error::GetUsagePlanKeyError::unhandled)?
                        };

                        output = output.set_message(parsed_body.message);
                        output.build()
                    }),
                },
                "NotFoundException" => crate::error::GetUsagePlanKeyError {
                    meta: generic,
                    kind: crate::error::GetUsagePlanKeyErrorKind::NotFoundError({
                        #[allow(unused_mut)]
                        let mut output = crate::error::not_found_error::Builder::default();
                        let _ = response;

                        let body_slice = response.body().as_ref();

                        let parsed_body: crate::error::NotFoundError = if body_slice.is_empty() {
                            // To enable JSON parsing to succeed, replace an empty body
                            // with an empty JSON body. If a member was required, it will fail slightly later
                            // during the operation construction phase.
                            serde_json::from_slice(b"{}")
                                .map_err(crate::error::GetUsagePlanKeyError::unhandled)?
                        } else {
                            serde_json::from_slice(response.body().as_ref())
                                .map_err(crate::error::GetUsagePlanKeyError::unhandled)?
                        };

                        output = output.set_message(parsed_body.message);
                        output.build()
                    }),
                },
                "TooManyRequestsException" => {
                    crate::error::GetUsagePlanKeyError {
                        meta: generic,
                        kind: crate::error::GetUsagePlanKeyErrorKind::TooManyRequestsError({
                            #[allow(unused_mut)]
                            let mut output =
                                crate::error::too_many_requests_error::Builder::default();
                            let _ = response;

                            let body_slice = response.body().as_ref();

                            let parsed_body: crate::error::TooManyRequestsError =
                                if body_slice.is_empty() {
                                    // To enable JSON parsing to succeed, replace an empty body
                                    // with an empty JSON body. If a member was required, it will fail slightly later
                                    // during the operation construction phase.
                                    serde_json::from_slice(b"{}")
                                        .map_err(crate::error::GetUsagePlanKeyError::unhandled)?
                                } else {
                                    serde_json::from_slice(response.body().as_ref())
                                        .map_err(crate::error::GetUsagePlanKeyError::unhandled)?
                                };

                            output = output.set_retry_after_seconds(
                        
                                                crate::http_serde::deser_header_get_usage_plan_key_retry_after_seconds(response.headers())
                                                    .map_err(|_|crate::error::GetUsagePlanKeyError::unhandled("Failed to parse retryAfterSeconds from header `Retry-After"))?
                                                
                    );
                            output = output.set_message(parsed_body.message);
                            output.build()
                        }),
                    }
                }
                "UnauthorizedException" => crate::error::GetUsagePlanKeyError {
                    meta: generic,
                    kind: crate::error::GetUsagePlanKeyErrorKind::UnauthorizedError({
                        #[allow(unused_mut)]
                        let mut output = crate::error::unauthorized_error::Builder::default();
                        let _ = response;

                        let body_slice = response.body().as_ref();

                        let parsed_body: crate::error::UnauthorizedError = if body_slice.is_empty()
                        {
                            // To enable JSON parsing to succeed, replace an empty body
                            // with an empty JSON body. If a member was required, it will fail slightly later
                            // during the operation construction phase.
                            serde_json::from_slice(b"{}")
                                .map_err(crate::error::GetUsagePlanKeyError::unhandled)?
                        } else {
                            serde_json::from_slice(response.body().as_ref())
                                .map_err(crate::error::GetUsagePlanKeyError::unhandled)?
                        };

                        output = output.set_message(parsed_body.message);
                        output.build()
                    }),
                },
                _ => crate::error::GetUsagePlanKeyError::generic(generic),
            });
        }
        Ok({
            #[allow(unused_mut)]
            let mut output = crate::output::get_usage_plan_key_output::Builder::default();
            let _ = response;

            let body_slice = response.body().as_ref();

            let parsed_body: crate::serializer::GetUsagePlanKeyOutputBody = if body_slice.is_empty()
            {
                // To enable JSON parsing to succeed, replace an empty body
                // with an empty JSON body. If a member was required, it will fail slightly later
                // during the operation construction phase.
                serde_json::from_slice(b"{}")
                    .map_err(crate::error::GetUsagePlanKeyError::unhandled)?
            } else {
                serde_json::from_slice(response.body().as_ref())
                    .map_err(crate::error::GetUsagePlanKeyError::unhandled)?
            };

            output = output.set_id(parsed_body.id);
            output = output.set_type(parsed_body.r#type);
            output = output.set_value(parsed_body.value);
            output = output.set_name(parsed_body.name);
            output.build()
        })
    }
    pub fn parse_response(
        &self,
        response: &http::response::Response<impl AsRef<[u8]>>,
    ) -> Result<crate::output::GetUsagePlanKeyOutput, crate::error::GetUsagePlanKeyError> {
        Self::from_response(&response)
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}

impl smithy_http::response::ParseStrictResponse for GetUsagePlanKey {
    type Output = Result<crate::output::GetUsagePlanKeyOutput, crate::error::GetUsagePlanKeyError>;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        self.parse_response(response)
    }
}

/// <p>Gets all the usage plan keys representing the API keys added to a specified usage plan.</p>
#[derive(std::clone::Clone)]
pub struct GetUsagePlanKeys {
    _private: (),
}
impl GetUsagePlanKeys {
    /// Creates a new builder-style object to manufacture [`GetUsagePlanKeysInput`](crate::input::GetUsagePlanKeysInput)
    pub fn builder() -> crate::input::get_usage_plan_keys_input::Builder {
        crate::input::get_usage_plan_keys_input::Builder::default()
    }
    #[allow(clippy::unnecessary_wraps)]
    fn from_response(
        response: &http::response::Response<impl AsRef<[u8]>>,
    ) -> Result<crate::output::GetUsagePlanKeysOutput, crate::error::GetUsagePlanKeysError> {
        if crate::aws_json_errors::is_error(&response) && response.status().as_u16() != 200 {
            let body = serde_json::from_slice(response.body().as_ref())
                .unwrap_or_else(|_| serde_json::json!({}));
            let generic = crate::aws_json_errors::parse_generic_error(&response, &body);

            let error_code = match generic.code() {
                Some(code) => code,
                None => return Err(crate::error::GetUsagePlanKeysError::unhandled(generic)),
            };
            return Err(match error_code {
                "BadRequestException" => crate::error::GetUsagePlanKeysError {
                    meta: generic,
                    kind: crate::error::GetUsagePlanKeysErrorKind::BadRequestError({
                        #[allow(unused_mut)]
                        let mut output = crate::error::bad_request_error::Builder::default();
                        let _ = response;

                        let body_slice = response.body().as_ref();

                        let parsed_body: crate::error::BadRequestError = if body_slice.is_empty() {
                            // To enable JSON parsing to succeed, replace an empty body
                            // with an empty JSON body. If a member was required, it will fail slightly later
                            // during the operation construction phase.
                            serde_json::from_slice(b"{}")
                                .map_err(crate::error::GetUsagePlanKeysError::unhandled)?
                        } else {
                            serde_json::from_slice(response.body().as_ref())
                                .map_err(crate::error::GetUsagePlanKeysError::unhandled)?
                        };

                        output = output.set_message(parsed_body.message);
                        output.build()
                    }),
                },
                "NotFoundException" => crate::error::GetUsagePlanKeysError {
                    meta: generic,
                    kind: crate::error::GetUsagePlanKeysErrorKind::NotFoundError({
                        #[allow(unused_mut)]
                        let mut output = crate::error::not_found_error::Builder::default();
                        let _ = response;

                        let body_slice = response.body().as_ref();

                        let parsed_body: crate::error::NotFoundError = if body_slice.is_empty() {
                            // To enable JSON parsing to succeed, replace an empty body
                            // with an empty JSON body. If a member was required, it will fail slightly later
                            // during the operation construction phase.
                            serde_json::from_slice(b"{}")
                                .map_err(crate::error::GetUsagePlanKeysError::unhandled)?
                        } else {
                            serde_json::from_slice(response.body().as_ref())
                                .map_err(crate::error::GetUsagePlanKeysError::unhandled)?
                        };

                        output = output.set_message(parsed_body.message);
                        output.build()
                    }),
                },
                "TooManyRequestsException" => crate::error::GetUsagePlanKeysError {
                    meta: generic,
                    kind: crate::error::GetUsagePlanKeysErrorKind::TooManyRequestsError({
                        #[allow(unused_mut)]
                        let mut output = crate::error::too_many_requests_error::Builder::default();
                        let _ = response;

                        let body_slice = response.body().as_ref();

                        let parsed_body: crate::error::TooManyRequestsError =
                            if body_slice.is_empty() {
                                // To enable JSON parsing to succeed, replace an empty body
                                // with an empty JSON body. If a member was required, it will fail slightly later
                                // during the operation construction phase.
                                serde_json::from_slice(b"{}")
                                    .map_err(crate::error::GetUsagePlanKeysError::unhandled)?
                            } else {
                                serde_json::from_slice(response.body().as_ref())
                                    .map_err(crate::error::GetUsagePlanKeysError::unhandled)?
                            };

                        output = output.set_retry_after_seconds(
                        
                                                crate::http_serde::deser_header_get_usage_plan_keys_retry_after_seconds(response.headers())
                                                    .map_err(|_|crate::error::GetUsagePlanKeysError::unhandled("Failed to parse retryAfterSeconds from header `Retry-After"))?
                                                
                    );
                        output = output.set_message(parsed_body.message);
                        output.build()
                    }),
                },
                "UnauthorizedException" => crate::error::GetUsagePlanKeysError {
                    meta: generic,
                    kind: crate::error::GetUsagePlanKeysErrorKind::UnauthorizedError({
                        #[allow(unused_mut)]
                        let mut output = crate::error::unauthorized_error::Builder::default();
                        let _ = response;

                        let body_slice = response.body().as_ref();

                        let parsed_body: crate::error::UnauthorizedError = if body_slice.is_empty()
                        {
                            // To enable JSON parsing to succeed, replace an empty body
                            // with an empty JSON body. If a member was required, it will fail slightly later
                            // during the operation construction phase.
                            serde_json::from_slice(b"{}")
                                .map_err(crate::error::GetUsagePlanKeysError::unhandled)?
                        } else {
                            serde_json::from_slice(response.body().as_ref())
                                .map_err(crate::error::GetUsagePlanKeysError::unhandled)?
                        };

                        output = output.set_message(parsed_body.message);
                        output.build()
                    }),
                },
                _ => crate::error::GetUsagePlanKeysError::generic(generic),
            });
        }
        Ok({
            #[allow(unused_mut)]
            let mut output = crate::output::get_usage_plan_keys_output::Builder::default();
            let _ = response;

            let body_slice = response.body().as_ref();

            let parsed_body: crate::serializer::GetUsagePlanKeysOutputBody =
                if body_slice.is_empty() {
                    // To enable JSON parsing to succeed, replace an empty body
                    // with an empty JSON body. If a member was required, it will fail slightly later
                    // during the operation construction phase.
                    serde_json::from_slice(b"{}")
                        .map_err(crate::error::GetUsagePlanKeysError::unhandled)?
                } else {
                    serde_json::from_slice(response.body().as_ref())
                        .map_err(crate::error::GetUsagePlanKeysError::unhandled)?
                };

            output = output.set_items(parsed_body.items);
            output = output.set_position(parsed_body.position);
            output.build()
        })
    }
    pub fn parse_response(
        &self,
        response: &http::response::Response<impl AsRef<[u8]>>,
    ) -> Result<crate::output::GetUsagePlanKeysOutput, crate::error::GetUsagePlanKeysError> {
        Self::from_response(&response)
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}

impl smithy_http::response::ParseStrictResponse for GetUsagePlanKeys {
    type Output =
        Result<crate::output::GetUsagePlanKeysOutput, crate::error::GetUsagePlanKeysError>;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        self.parse_response(response)
    }
}

/// <p>Gets all the usage plans of the caller's account.</p>
#[derive(std::clone::Clone)]
pub struct GetUsagePlans {
    _private: (),
}
impl GetUsagePlans {
    /// Creates a new builder-style object to manufacture [`GetUsagePlansInput`](crate::input::GetUsagePlansInput)
    pub fn builder() -> crate::input::get_usage_plans_input::Builder {
        crate::input::get_usage_plans_input::Builder::default()
    }
    #[allow(clippy::unnecessary_wraps)]
    fn from_response(
        response: &http::response::Response<impl AsRef<[u8]>>,
    ) -> Result<crate::output::GetUsagePlansOutput, crate::error::GetUsagePlansError> {
        if crate::aws_json_errors::is_error(&response) && response.status().as_u16() != 200 {
            let body = serde_json::from_slice(response.body().as_ref())
                .unwrap_or_else(|_| serde_json::json!({}));
            let generic = crate::aws_json_errors::parse_generic_error(&response, &body);

            let error_code = match generic.code() {
                Some(code) => code,
                None => return Err(crate::error::GetUsagePlansError::unhandled(generic)),
            };
            return Err(match error_code {
                "BadRequestException" => crate::error::GetUsagePlansError {
                    meta: generic,
                    kind: crate::error::GetUsagePlansErrorKind::BadRequestError({
                        #[allow(unused_mut)]
                        let mut output = crate::error::bad_request_error::Builder::default();
                        let _ = response;

                        let body_slice = response.body().as_ref();

                        let parsed_body: crate::error::BadRequestError = if body_slice.is_empty() {
                            // To enable JSON parsing to succeed, replace an empty body
                            // with an empty JSON body. If a member was required, it will fail slightly later
                            // during the operation construction phase.
                            serde_json::from_slice(b"{}")
                                .map_err(crate::error::GetUsagePlansError::unhandled)?
                        } else {
                            serde_json::from_slice(response.body().as_ref())
                                .map_err(crate::error::GetUsagePlansError::unhandled)?
                        };

                        output = output.set_message(parsed_body.message);
                        output.build()
                    }),
                },
                "ConflictException" => crate::error::GetUsagePlansError {
                    meta: generic,
                    kind: crate::error::GetUsagePlansErrorKind::ConflictError({
                        #[allow(unused_mut)]
                        let mut output = crate::error::conflict_error::Builder::default();
                        let _ = response;

                        let body_slice = response.body().as_ref();

                        let parsed_body: crate::error::ConflictError = if body_slice.is_empty() {
                            // To enable JSON parsing to succeed, replace an empty body
                            // with an empty JSON body. If a member was required, it will fail slightly later
                            // during the operation construction phase.
                            serde_json::from_slice(b"{}")
                                .map_err(crate::error::GetUsagePlansError::unhandled)?
                        } else {
                            serde_json::from_slice(response.body().as_ref())
                                .map_err(crate::error::GetUsagePlansError::unhandled)?
                        };

                        output = output.set_message(parsed_body.message);
                        output.build()
                    }),
                },
                "NotFoundException" => crate::error::GetUsagePlansError {
                    meta: generic,
                    kind: crate::error::GetUsagePlansErrorKind::NotFoundError({
                        #[allow(unused_mut)]
                        let mut output = crate::error::not_found_error::Builder::default();
                        let _ = response;

                        let body_slice = response.body().as_ref();

                        let parsed_body: crate::error::NotFoundError = if body_slice.is_empty() {
                            // To enable JSON parsing to succeed, replace an empty body
                            // with an empty JSON body. If a member was required, it will fail slightly later
                            // during the operation construction phase.
                            serde_json::from_slice(b"{}")
                                .map_err(crate::error::GetUsagePlansError::unhandled)?
                        } else {
                            serde_json::from_slice(response.body().as_ref())
                                .map_err(crate::error::GetUsagePlansError::unhandled)?
                        };

                        output = output.set_message(parsed_body.message);
                        output.build()
                    }),
                },
                "TooManyRequestsException" => {
                    crate::error::GetUsagePlansError {
                        meta: generic,
                        kind: crate::error::GetUsagePlansErrorKind::TooManyRequestsError({
                            #[allow(unused_mut)]
                            let mut output =
                                crate::error::too_many_requests_error::Builder::default();
                            let _ = response;

                            let body_slice = response.body().as_ref();

                            let parsed_body: crate::error::TooManyRequestsError =
                                if body_slice.is_empty() {
                                    // To enable JSON parsing to succeed, replace an empty body
                                    // with an empty JSON body. If a member was required, it will fail slightly later
                                    // during the operation construction phase.
                                    serde_json::from_slice(b"{}")
                                        .map_err(crate::error::GetUsagePlansError::unhandled)?
                                } else {
                                    serde_json::from_slice(response.body().as_ref())
                                        .map_err(crate::error::GetUsagePlansError::unhandled)?
                                };

                            output = output.set_retry_after_seconds(
                        
                                                crate::http_serde::deser_header_get_usage_plans_retry_after_seconds(response.headers())
                                                    .map_err(|_|crate::error::GetUsagePlansError::unhandled("Failed to parse retryAfterSeconds from header `Retry-After"))?
                                                
                    );
                            output = output.set_message(parsed_body.message);
                            output.build()
                        }),
                    }
                }
                "UnauthorizedException" => crate::error::GetUsagePlansError {
                    meta: generic,
                    kind: crate::error::GetUsagePlansErrorKind::UnauthorizedError({
                        #[allow(unused_mut)]
                        let mut output = crate::error::unauthorized_error::Builder::default();
                        let _ = response;

                        let body_slice = response.body().as_ref();

                        let parsed_body: crate::error::UnauthorizedError = if body_slice.is_empty()
                        {
                            // To enable JSON parsing to succeed, replace an empty body
                            // with an empty JSON body. If a member was required, it will fail slightly later
                            // during the operation construction phase.
                            serde_json::from_slice(b"{}")
                                .map_err(crate::error::GetUsagePlansError::unhandled)?
                        } else {
                            serde_json::from_slice(response.body().as_ref())
                                .map_err(crate::error::GetUsagePlansError::unhandled)?
                        };

                        output = output.set_message(parsed_body.message);
                        output.build()
                    }),
                },
                _ => crate::error::GetUsagePlansError::generic(generic),
            });
        }
        Ok({
            #[allow(unused_mut)]
            let mut output = crate::output::get_usage_plans_output::Builder::default();
            let _ = response;

            let body_slice = response.body().as_ref();

            let parsed_body: crate::serializer::GetUsagePlansOutputBody = if body_slice.is_empty() {
                // To enable JSON parsing to succeed, replace an empty body
                // with an empty JSON body. If a member was required, it will fail slightly later
                // during the operation construction phase.
                serde_json::from_slice(b"{}")
                    .map_err(crate::error::GetUsagePlansError::unhandled)?
            } else {
                serde_json::from_slice(response.body().as_ref())
                    .map_err(crate::error::GetUsagePlansError::unhandled)?
            };

            output = output.set_items(parsed_body.items);
            output = output.set_position(parsed_body.position);
            output.build()
        })
    }
    pub fn parse_response(
        &self,
        response: &http::response::Response<impl AsRef<[u8]>>,
    ) -> Result<crate::output::GetUsagePlansOutput, crate::error::GetUsagePlansError> {
        Self::from_response(&response)
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}

impl smithy_http::response::ParseStrictResponse for GetUsagePlans {
    type Output = Result<crate::output::GetUsagePlansOutput, crate::error::GetUsagePlansError>;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        self.parse_response(response)
    }
}

/// <p>Gets a specified VPC link under the caller's account in a region.</p>
#[derive(std::clone::Clone)]
pub struct GetVpcLink {
    _private: (),
}
impl GetVpcLink {
    /// Creates a new builder-style object to manufacture [`GetVpcLinkInput`](crate::input::GetVpcLinkInput)
    pub fn builder() -> crate::input::get_vpc_link_input::Builder {
        crate::input::get_vpc_link_input::Builder::default()
    }
    #[allow(clippy::unnecessary_wraps)]
    fn from_response(
        response: &http::response::Response<impl AsRef<[u8]>>,
    ) -> Result<crate::output::GetVpcLinkOutput, crate::error::GetVpcLinkError> {
        if crate::aws_json_errors::is_error(&response) && response.status().as_u16() != 200 {
            let body = serde_json::from_slice(response.body().as_ref())
                .unwrap_or_else(|_| serde_json::json!({}));
            let generic = crate::aws_json_errors::parse_generic_error(&response, &body);

            let error_code = match generic.code() {
                Some(code) => code,
                None => return Err(crate::error::GetVpcLinkError::unhandled(generic)),
            };
            return Err(match error_code {
                "NotFoundException" => crate::error::GetVpcLinkError {
                    meta: generic,
                    kind: crate::error::GetVpcLinkErrorKind::NotFoundError({
                        #[allow(unused_mut)]
                        let mut output = crate::error::not_found_error::Builder::default();
                        let _ = response;

                        let body_slice = response.body().as_ref();

                        let parsed_body: crate::error::NotFoundError = if body_slice.is_empty() {
                            // To enable JSON parsing to succeed, replace an empty body
                            // with an empty JSON body. If a member was required, it will fail slightly later
                            // during the operation construction phase.
                            serde_json::from_slice(b"{}")
                                .map_err(crate::error::GetVpcLinkError::unhandled)?
                        } else {
                            serde_json::from_slice(response.body().as_ref())
                                .map_err(crate::error::GetVpcLinkError::unhandled)?
                        };

                        output = output.set_message(parsed_body.message);
                        output.build()
                    }),
                },
                "TooManyRequestsException" => {
                    crate::error::GetVpcLinkError {
                        meta: generic,
                        kind: crate::error::GetVpcLinkErrorKind::TooManyRequestsError({
                            #[allow(unused_mut)]
                            let mut output =
                                crate::error::too_many_requests_error::Builder::default();
                            let _ = response;

                            let body_slice = response.body().as_ref();

                            let parsed_body: crate::error::TooManyRequestsError =
                                if body_slice.is_empty() {
                                    // To enable JSON parsing to succeed, replace an empty body
                                    // with an empty JSON body. If a member was required, it will fail slightly later
                                    // during the operation construction phase.
                                    serde_json::from_slice(b"{}")
                                        .map_err(crate::error::GetVpcLinkError::unhandled)?
                                } else {
                                    serde_json::from_slice(response.body().as_ref())
                                        .map_err(crate::error::GetVpcLinkError::unhandled)?
                                };

                            output = output.set_retry_after_seconds(
                        
                                                crate::http_serde::deser_header_get_vpc_link_retry_after_seconds(response.headers())
                                                    .map_err(|_|crate::error::GetVpcLinkError::unhandled("Failed to parse retryAfterSeconds from header `Retry-After"))?
                                                
                    );
                            output = output.set_message(parsed_body.message);
                            output.build()
                        }),
                    }
                }
                "UnauthorizedException" => crate::error::GetVpcLinkError {
                    meta: generic,
                    kind: crate::error::GetVpcLinkErrorKind::UnauthorizedError({
                        #[allow(unused_mut)]
                        let mut output = crate::error::unauthorized_error::Builder::default();
                        let _ = response;

                        let body_slice = response.body().as_ref();

                        let parsed_body: crate::error::UnauthorizedError = if body_slice.is_empty()
                        {
                            // To enable JSON parsing to succeed, replace an empty body
                            // with an empty JSON body. If a member was required, it will fail slightly later
                            // during the operation construction phase.
                            serde_json::from_slice(b"{}")
                                .map_err(crate::error::GetVpcLinkError::unhandled)?
                        } else {
                            serde_json::from_slice(response.body().as_ref())
                                .map_err(crate::error::GetVpcLinkError::unhandled)?
                        };

                        output = output.set_message(parsed_body.message);
                        output.build()
                    }),
                },
                _ => crate::error::GetVpcLinkError::generic(generic),
            });
        }
        Ok({
            #[allow(unused_mut)]
            let mut output = crate::output::get_vpc_link_output::Builder::default();
            let _ = response;

            let body_slice = response.body().as_ref();

            let parsed_body: crate::serializer::GetVpcLinkOutputBody = if body_slice.is_empty() {
                // To enable JSON parsing to succeed, replace an empty body
                // with an empty JSON body. If a member was required, it will fail slightly later
                // during the operation construction phase.
                serde_json::from_slice(b"{}").map_err(crate::error::GetVpcLinkError::unhandled)?
            } else {
                serde_json::from_slice(response.body().as_ref())
                    .map_err(crate::error::GetVpcLinkError::unhandled)?
            };

            output = output.set_id(parsed_body.id);
            output = output.set_name(parsed_body.name);
            output = output.set_description(parsed_body.description);
            output = output.set_target_arns(parsed_body.target_arns);
            output = output.set_status(parsed_body.status);
            output = output.set_status_message(parsed_body.status_message);
            output = output.set_tags(parsed_body.tags);
            output.build()
        })
    }
    pub fn parse_response(
        &self,
        response: &http::response::Response<impl AsRef<[u8]>>,
    ) -> Result<crate::output::GetVpcLinkOutput, crate::error::GetVpcLinkError> {
        Self::from_response(&response)
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}

impl smithy_http::response::ParseStrictResponse for GetVpcLink {
    type Output = Result<crate::output::GetVpcLinkOutput, crate::error::GetVpcLinkError>;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        self.parse_response(response)
    }
}

/// <p>Gets the <a>VpcLinks</a> collection under the caller's account in a selected region.</p>
#[derive(std::clone::Clone)]
pub struct GetVpcLinks {
    _private: (),
}
impl GetVpcLinks {
    /// Creates a new builder-style object to manufacture [`GetVpcLinksInput`](crate::input::GetVpcLinksInput)
    pub fn builder() -> crate::input::get_vpc_links_input::Builder {
        crate::input::get_vpc_links_input::Builder::default()
    }
    #[allow(clippy::unnecessary_wraps)]
    fn from_response(
        response: &http::response::Response<impl AsRef<[u8]>>,
    ) -> Result<crate::output::GetVpcLinksOutput, crate::error::GetVpcLinksError> {
        if crate::aws_json_errors::is_error(&response) && response.status().as_u16() != 200 {
            let body = serde_json::from_slice(response.body().as_ref())
                .unwrap_or_else(|_| serde_json::json!({}));
            let generic = crate::aws_json_errors::parse_generic_error(&response, &body);

            let error_code = match generic.code() {
                Some(code) => code,
                None => return Err(crate::error::GetVpcLinksError::unhandled(generic)),
            };
            return Err(match error_code {
                "BadRequestException" => crate::error::GetVpcLinksError {
                    meta: generic,
                    kind: crate::error::GetVpcLinksErrorKind::BadRequestError({
                        #[allow(unused_mut)]
                        let mut output = crate::error::bad_request_error::Builder::default();
                        let _ = response;

                        let body_slice = response.body().as_ref();

                        let parsed_body: crate::error::BadRequestError = if body_slice.is_empty() {
                            // To enable JSON parsing to succeed, replace an empty body
                            // with an empty JSON body. If a member was required, it will fail slightly later
                            // during the operation construction phase.
                            serde_json::from_slice(b"{}")
                                .map_err(crate::error::GetVpcLinksError::unhandled)?
                        } else {
                            serde_json::from_slice(response.body().as_ref())
                                .map_err(crate::error::GetVpcLinksError::unhandled)?
                        };

                        output = output.set_message(parsed_body.message);
                        output.build()
                    }),
                },
                "TooManyRequestsException" => {
                    crate::error::GetVpcLinksError {
                        meta: generic,
                        kind: crate::error::GetVpcLinksErrorKind::TooManyRequestsError({
                            #[allow(unused_mut)]
                            let mut output =
                                crate::error::too_many_requests_error::Builder::default();
                            let _ = response;

                            let body_slice = response.body().as_ref();

                            let parsed_body: crate::error::TooManyRequestsError =
                                if body_slice.is_empty() {
                                    // To enable JSON parsing to succeed, replace an empty body
                                    // with an empty JSON body. If a member was required, it will fail slightly later
                                    // during the operation construction phase.
                                    serde_json::from_slice(b"{}")
                                        .map_err(crate::error::GetVpcLinksError::unhandled)?
                                } else {
                                    serde_json::from_slice(response.body().as_ref())
                                        .map_err(crate::error::GetVpcLinksError::unhandled)?
                                };

                            output = output.set_retry_after_seconds(
                        
                                                crate::http_serde::deser_header_get_vpc_links_retry_after_seconds(response.headers())
                                                    .map_err(|_|crate::error::GetVpcLinksError::unhandled("Failed to parse retryAfterSeconds from header `Retry-After"))?
                                                
                    );
                            output = output.set_message(parsed_body.message);
                            output.build()
                        }),
                    }
                }
                "UnauthorizedException" => crate::error::GetVpcLinksError {
                    meta: generic,
                    kind: crate::error::GetVpcLinksErrorKind::UnauthorizedError({
                        #[allow(unused_mut)]
                        let mut output = crate::error::unauthorized_error::Builder::default();
                        let _ = response;

                        let body_slice = response.body().as_ref();

                        let parsed_body: crate::error::UnauthorizedError = if body_slice.is_empty()
                        {
                            // To enable JSON parsing to succeed, replace an empty body
                            // with an empty JSON body. If a member was required, it will fail slightly later
                            // during the operation construction phase.
                            serde_json::from_slice(b"{}")
                                .map_err(crate::error::GetVpcLinksError::unhandled)?
                        } else {
                            serde_json::from_slice(response.body().as_ref())
                                .map_err(crate::error::GetVpcLinksError::unhandled)?
                        };

                        output = output.set_message(parsed_body.message);
                        output.build()
                    }),
                },
                _ => crate::error::GetVpcLinksError::generic(generic),
            });
        }
        Ok({
            #[allow(unused_mut)]
            let mut output = crate::output::get_vpc_links_output::Builder::default();
            let _ = response;

            let body_slice = response.body().as_ref();

            let parsed_body: crate::serializer::GetVpcLinksOutputBody = if body_slice.is_empty() {
                // To enable JSON parsing to succeed, replace an empty body
                // with an empty JSON body. If a member was required, it will fail slightly later
                // during the operation construction phase.
                serde_json::from_slice(b"{}").map_err(crate::error::GetVpcLinksError::unhandled)?
            } else {
                serde_json::from_slice(response.body().as_ref())
                    .map_err(crate::error::GetVpcLinksError::unhandled)?
            };

            output = output.set_items(parsed_body.items);
            output = output.set_position(parsed_body.position);
            output.build()
        })
    }
    pub fn parse_response(
        &self,
        response: &http::response::Response<impl AsRef<[u8]>>,
    ) -> Result<crate::output::GetVpcLinksOutput, crate::error::GetVpcLinksError> {
        Self::from_response(&response)
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}

impl smithy_http::response::ParseStrictResponse for GetVpcLinks {
    type Output = Result<crate::output::GetVpcLinksOutput, crate::error::GetVpcLinksError>;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        self.parse_response(response)
    }
}

/// <p>Import API keys from an external source, such as a CSV-formatted file.</p>
#[derive(std::clone::Clone)]
pub struct ImportApiKeys {
    _private: (),
}
impl ImportApiKeys {
    /// Creates a new builder-style object to manufacture [`ImportApiKeysInput`](crate::input::ImportApiKeysInput)
    pub fn builder() -> crate::input::import_api_keys_input::Builder {
        crate::input::import_api_keys_input::Builder::default()
    }
    #[allow(clippy::unnecessary_wraps)]
    fn from_response(
        response: &http::response::Response<impl AsRef<[u8]>>,
    ) -> Result<crate::output::ImportApiKeysOutput, crate::error::ImportApiKeysError> {
        if crate::aws_json_errors::is_error(&response) && response.status().as_u16() != 201 {
            let body = serde_json::from_slice(response.body().as_ref())
                .unwrap_or_else(|_| serde_json::json!({}));
            let generic = crate::aws_json_errors::parse_generic_error(&response, &body);

            let error_code = match generic.code() {
                Some(code) => code,
                None => return Err(crate::error::ImportApiKeysError::unhandled(generic)),
            };
            return Err(match error_code {
                "BadRequestException" => crate::error::ImportApiKeysError {
                    meta: generic,
                    kind: crate::error::ImportApiKeysErrorKind::BadRequestError({
                        #[allow(unused_mut)]
                        let mut output = crate::error::bad_request_error::Builder::default();
                        let _ = response;

                        let body_slice = response.body().as_ref();

                        let parsed_body: crate::error::BadRequestError = if body_slice.is_empty() {
                            // To enable JSON parsing to succeed, replace an empty body
                            // with an empty JSON body. If a member was required, it will fail slightly later
                            // during the operation construction phase.
                            serde_json::from_slice(b"{}")
                                .map_err(crate::error::ImportApiKeysError::unhandled)?
                        } else {
                            serde_json::from_slice(response.body().as_ref())
                                .map_err(crate::error::ImportApiKeysError::unhandled)?
                        };

                        output = output.set_message(parsed_body.message);
                        output.build()
                    }),
                },
                "ConflictException" => crate::error::ImportApiKeysError {
                    meta: generic,
                    kind: crate::error::ImportApiKeysErrorKind::ConflictError({
                        #[allow(unused_mut)]
                        let mut output = crate::error::conflict_error::Builder::default();
                        let _ = response;

                        let body_slice = response.body().as_ref();

                        let parsed_body: crate::error::ConflictError = if body_slice.is_empty() {
                            // To enable JSON parsing to succeed, replace an empty body
                            // with an empty JSON body. If a member was required, it will fail slightly later
                            // during the operation construction phase.
                            serde_json::from_slice(b"{}")
                                .map_err(crate::error::ImportApiKeysError::unhandled)?
                        } else {
                            serde_json::from_slice(response.body().as_ref())
                                .map_err(crate::error::ImportApiKeysError::unhandled)?
                        };

                        output = output.set_message(parsed_body.message);
                        output.build()
                    }),
                },
                "LimitExceededException" => {
                    crate::error::ImportApiKeysError {
                        meta: generic,
                        kind: crate::error::ImportApiKeysErrorKind::LimitExceededError({
                            #[allow(unused_mut)]
                            let mut output = crate::error::limit_exceeded_error::Builder::default();
                            let _ = response;

                            let body_slice = response.body().as_ref();

                            let parsed_body: crate::error::LimitExceededError =
                                if body_slice.is_empty() {
                                    // To enable JSON parsing to succeed, replace an empty body
                                    // with an empty JSON body. If a member was required, it will fail slightly later
                                    // during the operation construction phase.
                                    serde_json::from_slice(b"{}")
                                        .map_err(crate::error::ImportApiKeysError::unhandled)?
                                } else {
                                    serde_json::from_slice(response.body().as_ref())
                                        .map_err(crate::error::ImportApiKeysError::unhandled)?
                                };

                            output = output.set_retry_after_seconds(
                        
                                                crate::http_serde::deser_header_import_api_keys_retry_after_seconds(response.headers())
                                                    .map_err(|_|crate::error::ImportApiKeysError::unhandled("Failed to parse retryAfterSeconds from header `Retry-After"))?
                                                
                    );
                            output = output.set_message(parsed_body.message);
                            output.build()
                        }),
                    }
                }
                "NotFoundException" => crate::error::ImportApiKeysError {
                    meta: generic,
                    kind: crate::error::ImportApiKeysErrorKind::NotFoundError({
                        #[allow(unused_mut)]
                        let mut output = crate::error::not_found_error::Builder::default();
                        let _ = response;

                        let body_slice = response.body().as_ref();

                        let parsed_body: crate::error::NotFoundError = if body_slice.is_empty() {
                            // To enable JSON parsing to succeed, replace an empty body
                            // with an empty JSON body. If a member was required, it will fail slightly later
                            // during the operation construction phase.
                            serde_json::from_slice(b"{}")
                                .map_err(crate::error::ImportApiKeysError::unhandled)?
                        } else {
                            serde_json::from_slice(response.body().as_ref())
                                .map_err(crate::error::ImportApiKeysError::unhandled)?
                        };

                        output = output.set_message(parsed_body.message);
                        output.build()
                    }),
                },
                "TooManyRequestsException" => {
                    crate::error::ImportApiKeysError {
                        meta: generic,
                        kind: crate::error::ImportApiKeysErrorKind::TooManyRequestsError({
                            #[allow(unused_mut)]
                            let mut output =
                                crate::error::too_many_requests_error::Builder::default();
                            let _ = response;

                            let body_slice = response.body().as_ref();

                            let parsed_body: crate::error::TooManyRequestsError =
                                if body_slice.is_empty() {
                                    // To enable JSON parsing to succeed, replace an empty body
                                    // with an empty JSON body. If a member was required, it will fail slightly later
                                    // during the operation construction phase.
                                    serde_json::from_slice(b"{}")
                                        .map_err(crate::error::ImportApiKeysError::unhandled)?
                                } else {
                                    serde_json::from_slice(response.body().as_ref())
                                        .map_err(crate::error::ImportApiKeysError::unhandled)?
                                };

                            output = output.set_retry_after_seconds(
                        
                                                crate::http_serde::deser_header_import_api_keys_retry_after_seconds(response.headers())
                                                    .map_err(|_|crate::error::ImportApiKeysError::unhandled("Failed to parse retryAfterSeconds from header `Retry-After"))?
                                                
                    );
                            output = output.set_message(parsed_body.message);
                            output.build()
                        }),
                    }
                }
                "UnauthorizedException" => crate::error::ImportApiKeysError {
                    meta: generic,
                    kind: crate::error::ImportApiKeysErrorKind::UnauthorizedError({
                        #[allow(unused_mut)]
                        let mut output = crate::error::unauthorized_error::Builder::default();
                        let _ = response;

                        let body_slice = response.body().as_ref();

                        let parsed_body: crate::error::UnauthorizedError = if body_slice.is_empty()
                        {
                            // To enable JSON parsing to succeed, replace an empty body
                            // with an empty JSON body. If a member was required, it will fail slightly later
                            // during the operation construction phase.
                            serde_json::from_slice(b"{}")
                                .map_err(crate::error::ImportApiKeysError::unhandled)?
                        } else {
                            serde_json::from_slice(response.body().as_ref())
                                .map_err(crate::error::ImportApiKeysError::unhandled)?
                        };

                        output = output.set_message(parsed_body.message);
                        output.build()
                    }),
                },
                _ => crate::error::ImportApiKeysError::generic(generic),
            });
        }
        Ok({
            #[allow(unused_mut)]
            let mut output = crate::output::import_api_keys_output::Builder::default();
            let _ = response;

            let body_slice = response.body().as_ref();

            let parsed_body: crate::serializer::ImportApiKeysOutputBody = if body_slice.is_empty() {
                // To enable JSON parsing to succeed, replace an empty body
                // with an empty JSON body. If a member was required, it will fail slightly later
                // during the operation construction phase.
                serde_json::from_slice(b"{}")
                    .map_err(crate::error::ImportApiKeysError::unhandled)?
            } else {
                serde_json::from_slice(response.body().as_ref())
                    .map_err(crate::error::ImportApiKeysError::unhandled)?
            };

            output = output.set_ids(parsed_body.ids);
            output = output.set_warnings(parsed_body.warnings);
            output.build()
        })
    }
    pub fn parse_response(
        &self,
        response: &http::response::Response<impl AsRef<[u8]>>,
    ) -> Result<crate::output::ImportApiKeysOutput, crate::error::ImportApiKeysError> {
        Self::from_response(&response)
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}

impl smithy_http::response::ParseStrictResponse for ImportApiKeys {
    type Output = Result<crate::output::ImportApiKeysOutput, crate::error::ImportApiKeysError>;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        self.parse_response(response)
    }
}

#[derive(std::clone::Clone)]
pub struct ImportDocumentationParts {
    _private: (),
}
impl ImportDocumentationParts {
    /// Creates a new builder-style object to manufacture [`ImportDocumentationPartsInput`](crate::input::ImportDocumentationPartsInput)
    pub fn builder() -> crate::input::import_documentation_parts_input::Builder {
        crate::input::import_documentation_parts_input::Builder::default()
    }
    #[allow(clippy::unnecessary_wraps)]
    fn from_response(
        response: &http::response::Response<impl AsRef<[u8]>>,
    ) -> Result<
        crate::output::ImportDocumentationPartsOutput,
        crate::error::ImportDocumentationPartsError,
    > {
        if crate::aws_json_errors::is_error(&response) && response.status().as_u16() != 200 {
            let body = serde_json::from_slice(response.body().as_ref())
                .unwrap_or_else(|_| serde_json::json!({}));
            let generic = crate::aws_json_errors::parse_generic_error(&response, &body);

            let error_code = match generic.code() {
                Some(code) => code,
                None => {
                    return Err(crate::error::ImportDocumentationPartsError::unhandled(
                        generic,
                    ))
                }
            };
            return Err(match error_code {
                "BadRequestException" => crate::error::ImportDocumentationPartsError {
                    meta: generic,
                    kind: crate::error::ImportDocumentationPartsErrorKind::BadRequestError({
                        #[allow(unused_mut)]
                        let mut output = crate::error::bad_request_error::Builder::default();
                        let _ = response;

                        let body_slice = response.body().as_ref();

                        let parsed_body: crate::error::BadRequestError = if body_slice.is_empty() {
                            // To enable JSON parsing to succeed, replace an empty body
                            // with an empty JSON body. If a member was required, it will fail slightly later
                            // during the operation construction phase.
                            serde_json::from_slice(b"{}")
                                .map_err(crate::error::ImportDocumentationPartsError::unhandled)?
                        } else {
                            serde_json::from_slice(response.body().as_ref())
                                .map_err(crate::error::ImportDocumentationPartsError::unhandled)?
                        };

                        output = output.set_message(parsed_body.message);
                        output.build()
                    }),
                },
                "LimitExceededException" => crate::error::ImportDocumentationPartsError {
                    meta: generic,
                    kind: crate::error::ImportDocumentationPartsErrorKind::LimitExceededError({
                        #[allow(unused_mut)]
                        let mut output = crate::error::limit_exceeded_error::Builder::default();
                        let _ = response;

                        let body_slice = response.body().as_ref();

                        let parsed_body: crate::error::LimitExceededError = if body_slice.is_empty()
                        {
                            // To enable JSON parsing to succeed, replace an empty body
                            // with an empty JSON body. If a member was required, it will fail slightly later
                            // during the operation construction phase.
                            serde_json::from_slice(b"{}")
                                .map_err(crate::error::ImportDocumentationPartsError::unhandled)?
                        } else {
                            serde_json::from_slice(response.body().as_ref())
                                .map_err(crate::error::ImportDocumentationPartsError::unhandled)?
                        };

                        output = output.set_retry_after_seconds(
                        
                                                crate::http_serde::deser_header_import_documentation_parts_retry_after_seconds(response.headers())
                                                    .map_err(|_|crate::error::ImportDocumentationPartsError::unhandled("Failed to parse retryAfterSeconds from header `Retry-After"))?
                                                
                    );
                        output = output.set_message(parsed_body.message);
                        output.build()
                    }),
                },
                "NotFoundException" => crate::error::ImportDocumentationPartsError {
                    meta: generic,
                    kind: crate::error::ImportDocumentationPartsErrorKind::NotFoundError({
                        #[allow(unused_mut)]
                        let mut output = crate::error::not_found_error::Builder::default();
                        let _ = response;

                        let body_slice = response.body().as_ref();

                        let parsed_body: crate::error::NotFoundError = if body_slice.is_empty() {
                            // To enable JSON parsing to succeed, replace an empty body
                            // with an empty JSON body. If a member was required, it will fail slightly later
                            // during the operation construction phase.
                            serde_json::from_slice(b"{}")
                                .map_err(crate::error::ImportDocumentationPartsError::unhandled)?
                        } else {
                            serde_json::from_slice(response.body().as_ref())
                                .map_err(crate::error::ImportDocumentationPartsError::unhandled)?
                        };

                        output = output.set_message(parsed_body.message);
                        output.build()
                    }),
                },
                "TooManyRequestsException" => crate::error::ImportDocumentationPartsError {
                    meta: generic,
                    kind: crate::error::ImportDocumentationPartsErrorKind::TooManyRequestsError({
                        #[allow(unused_mut)]
                        let mut output = crate::error::too_many_requests_error::Builder::default();
                        let _ = response;

                        let body_slice = response.body().as_ref();

                        let parsed_body: crate::error::TooManyRequestsError = if body_slice
                            .is_empty()
                        {
                            // To enable JSON parsing to succeed, replace an empty body
                            // with an empty JSON body. If a member was required, it will fail slightly later
                            // during the operation construction phase.
                            serde_json::from_slice(b"{}")
                                .map_err(crate::error::ImportDocumentationPartsError::unhandled)?
                        } else {
                            serde_json::from_slice(response.body().as_ref())
                                .map_err(crate::error::ImportDocumentationPartsError::unhandled)?
                        };

                        output = output.set_retry_after_seconds(
                        
                                                crate::http_serde::deser_header_import_documentation_parts_retry_after_seconds(response.headers())
                                                    .map_err(|_|crate::error::ImportDocumentationPartsError::unhandled("Failed to parse retryAfterSeconds from header `Retry-After"))?
                                                
                    );
                        output = output.set_message(parsed_body.message);
                        output.build()
                    }),
                },
                "UnauthorizedException" => crate::error::ImportDocumentationPartsError {
                    meta: generic,
                    kind: crate::error::ImportDocumentationPartsErrorKind::UnauthorizedError({
                        #[allow(unused_mut)]
                        let mut output = crate::error::unauthorized_error::Builder::default();
                        let _ = response;

                        let body_slice = response.body().as_ref();

                        let parsed_body: crate::error::UnauthorizedError = if body_slice.is_empty()
                        {
                            // To enable JSON parsing to succeed, replace an empty body
                            // with an empty JSON body. If a member was required, it will fail slightly later
                            // during the operation construction phase.
                            serde_json::from_slice(b"{}")
                                .map_err(crate::error::ImportDocumentationPartsError::unhandled)?
                        } else {
                            serde_json::from_slice(response.body().as_ref())
                                .map_err(crate::error::ImportDocumentationPartsError::unhandled)?
                        };

                        output = output.set_message(parsed_body.message);
                        output.build()
                    }),
                },
                _ => crate::error::ImportDocumentationPartsError::generic(generic),
            });
        }
        Ok({
            #[allow(unused_mut)]
            let mut output = crate::output::import_documentation_parts_output::Builder::default();
            let _ = response;

            let body_slice = response.body().as_ref();

            let parsed_body: crate::serializer::ImportDocumentationPartsOutputBody =
                if body_slice.is_empty() {
                    // To enable JSON parsing to succeed, replace an empty body
                    // with an empty JSON body. If a member was required, it will fail slightly later
                    // during the operation construction phase.
                    serde_json::from_slice(b"{}")
                        .map_err(crate::error::ImportDocumentationPartsError::unhandled)?
                } else {
                    serde_json::from_slice(response.body().as_ref())
                        .map_err(crate::error::ImportDocumentationPartsError::unhandled)?
                };

            output = output.set_ids(parsed_body.ids);
            output = output.set_warnings(parsed_body.warnings);
            output.build()
        })
    }
    pub fn parse_response(
        &self,
        response: &http::response::Response<impl AsRef<[u8]>>,
    ) -> Result<
        crate::output::ImportDocumentationPartsOutput,
        crate::error::ImportDocumentationPartsError,
    > {
        Self::from_response(&response)
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}

impl smithy_http::response::ParseStrictResponse for ImportDocumentationParts {
    type Output = Result<
        crate::output::ImportDocumentationPartsOutput,
        crate::error::ImportDocumentationPartsError,
    >;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        self.parse_response(response)
    }
}

/// <p>A feature of the API Gateway control service for creating a new API from an external API definition file.</p>
#[derive(std::clone::Clone)]
pub struct ImportRestApi {
    _private: (),
}
impl ImportRestApi {
    /// Creates a new builder-style object to manufacture [`ImportRestApiInput`](crate::input::ImportRestApiInput)
    pub fn builder() -> crate::input::import_rest_api_input::Builder {
        crate::input::import_rest_api_input::Builder::default()
    }
    #[allow(clippy::unnecessary_wraps)]
    fn from_response(
        response: &http::response::Response<impl AsRef<[u8]>>,
    ) -> Result<crate::output::ImportRestApiOutput, crate::error::ImportRestApiError> {
        if crate::aws_json_errors::is_error(&response) && response.status().as_u16() != 201 {
            let body = serde_json::from_slice(response.body().as_ref())
                .unwrap_or_else(|_| serde_json::json!({}));
            let generic = crate::aws_json_errors::parse_generic_error(&response, &body);

            let error_code = match generic.code() {
                Some(code) => code,
                None => return Err(crate::error::ImportRestApiError::unhandled(generic)),
            };
            return Err(match error_code {
                "BadRequestException" => crate::error::ImportRestApiError {
                    meta: generic,
                    kind: crate::error::ImportRestApiErrorKind::BadRequestError({
                        #[allow(unused_mut)]
                        let mut output = crate::error::bad_request_error::Builder::default();
                        let _ = response;

                        let body_slice = response.body().as_ref();

                        let parsed_body: crate::error::BadRequestError = if body_slice.is_empty() {
                            // To enable JSON parsing to succeed, replace an empty body
                            // with an empty JSON body. If a member was required, it will fail slightly later
                            // during the operation construction phase.
                            serde_json::from_slice(b"{}")
                                .map_err(crate::error::ImportRestApiError::unhandled)?
                        } else {
                            serde_json::from_slice(response.body().as_ref())
                                .map_err(crate::error::ImportRestApiError::unhandled)?
                        };

                        output = output.set_message(parsed_body.message);
                        output.build()
                    }),
                },
                "ConflictException" => crate::error::ImportRestApiError {
                    meta: generic,
                    kind: crate::error::ImportRestApiErrorKind::ConflictError({
                        #[allow(unused_mut)]
                        let mut output = crate::error::conflict_error::Builder::default();
                        let _ = response;

                        let body_slice = response.body().as_ref();

                        let parsed_body: crate::error::ConflictError = if body_slice.is_empty() {
                            // To enable JSON parsing to succeed, replace an empty body
                            // with an empty JSON body. If a member was required, it will fail slightly later
                            // during the operation construction phase.
                            serde_json::from_slice(b"{}")
                                .map_err(crate::error::ImportRestApiError::unhandled)?
                        } else {
                            serde_json::from_slice(response.body().as_ref())
                                .map_err(crate::error::ImportRestApiError::unhandled)?
                        };

                        output = output.set_message(parsed_body.message);
                        output.build()
                    }),
                },
                "LimitExceededException" => {
                    crate::error::ImportRestApiError {
                        meta: generic,
                        kind: crate::error::ImportRestApiErrorKind::LimitExceededError({
                            #[allow(unused_mut)]
                            let mut output = crate::error::limit_exceeded_error::Builder::default();
                            let _ = response;

                            let body_slice = response.body().as_ref();

                            let parsed_body: crate::error::LimitExceededError =
                                if body_slice.is_empty() {
                                    // To enable JSON parsing to succeed, replace an empty body
                                    // with an empty JSON body. If a member was required, it will fail slightly later
                                    // during the operation construction phase.
                                    serde_json::from_slice(b"{}")
                                        .map_err(crate::error::ImportRestApiError::unhandled)?
                                } else {
                                    serde_json::from_slice(response.body().as_ref())
                                        .map_err(crate::error::ImportRestApiError::unhandled)?
                                };

                            output = output.set_retry_after_seconds(
                        
                                                crate::http_serde::deser_header_import_rest_api_retry_after_seconds(response.headers())
                                                    .map_err(|_|crate::error::ImportRestApiError::unhandled("Failed to parse retryAfterSeconds from header `Retry-After"))?
                                                
                    );
                            output = output.set_message(parsed_body.message);
                            output.build()
                        }),
                    }
                }
                "TooManyRequestsException" => {
                    crate::error::ImportRestApiError {
                        meta: generic,
                        kind: crate::error::ImportRestApiErrorKind::TooManyRequestsError({
                            #[allow(unused_mut)]
                            let mut output =
                                crate::error::too_many_requests_error::Builder::default();
                            let _ = response;

                            let body_slice = response.body().as_ref();

                            let parsed_body: crate::error::TooManyRequestsError =
                                if body_slice.is_empty() {
                                    // To enable JSON parsing to succeed, replace an empty body
                                    // with an empty JSON body. If a member was required, it will fail slightly later
                                    // during the operation construction phase.
                                    serde_json::from_slice(b"{}")
                                        .map_err(crate::error::ImportRestApiError::unhandled)?
                                } else {
                                    serde_json::from_slice(response.body().as_ref())
                                        .map_err(crate::error::ImportRestApiError::unhandled)?
                                };

                            output = output.set_retry_after_seconds(
                        
                                                crate::http_serde::deser_header_import_rest_api_retry_after_seconds(response.headers())
                                                    .map_err(|_|crate::error::ImportRestApiError::unhandled("Failed to parse retryAfterSeconds from header `Retry-After"))?
                                                
                    );
                            output = output.set_message(parsed_body.message);
                            output.build()
                        }),
                    }
                }
                "UnauthorizedException" => crate::error::ImportRestApiError {
                    meta: generic,
                    kind: crate::error::ImportRestApiErrorKind::UnauthorizedError({
                        #[allow(unused_mut)]
                        let mut output = crate::error::unauthorized_error::Builder::default();
                        let _ = response;

                        let body_slice = response.body().as_ref();

                        let parsed_body: crate::error::UnauthorizedError = if body_slice.is_empty()
                        {
                            // To enable JSON parsing to succeed, replace an empty body
                            // with an empty JSON body. If a member was required, it will fail slightly later
                            // during the operation construction phase.
                            serde_json::from_slice(b"{}")
                                .map_err(crate::error::ImportRestApiError::unhandled)?
                        } else {
                            serde_json::from_slice(response.body().as_ref())
                                .map_err(crate::error::ImportRestApiError::unhandled)?
                        };

                        output = output.set_message(parsed_body.message);
                        output.build()
                    }),
                },
                _ => crate::error::ImportRestApiError::generic(generic),
            });
        }
        Ok({
            #[allow(unused_mut)]
            let mut output = crate::output::import_rest_api_output::Builder::default();
            let _ = response;

            let body_slice = response.body().as_ref();

            let parsed_body: crate::serializer::ImportRestApiOutputBody = if body_slice.is_empty() {
                // To enable JSON parsing to succeed, replace an empty body
                // with an empty JSON body. If a member was required, it will fail slightly later
                // during the operation construction phase.
                serde_json::from_slice(b"{}")
                    .map_err(crate::error::ImportRestApiError::unhandled)?
            } else {
                serde_json::from_slice(response.body().as_ref())
                    .map_err(crate::error::ImportRestApiError::unhandled)?
            };

            output = output.set_id(parsed_body.id);
            output = output.set_name(parsed_body.name);
            output = output.set_description(parsed_body.description);
            output = output.set_created_date(parsed_body.created_date);
            output = output.set_version(parsed_body.version);
            output = output.set_warnings(parsed_body.warnings);
            output = output.set_binary_media_types(parsed_body.binary_media_types);
            output = output.set_minimum_compression_size(parsed_body.minimum_compression_size);
            output = output.set_api_key_source(parsed_body.api_key_source);
            output = output.set_endpoint_configuration(parsed_body.endpoint_configuration);
            output = output.set_policy(parsed_body.policy);
            output = output.set_tags(parsed_body.tags);
            output =
                output.set_disable_execute_api_endpoint(parsed_body.disable_execute_api_endpoint);
            output.build()
        })
    }
    pub fn parse_response(
        &self,
        response: &http::response::Response<impl AsRef<[u8]>>,
    ) -> Result<crate::output::ImportRestApiOutput, crate::error::ImportRestApiError> {
        Self::from_response(&response)
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}

impl smithy_http::response::ParseStrictResponse for ImportRestApi {
    type Output = Result<crate::output::ImportRestApiOutput, crate::error::ImportRestApiError>;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        self.parse_response(response)
    }
}

/// <p>Creates a customization of a <a>GatewayResponse</a> of a specified response type and status code on the given <a>RestApi</a>.</p>
#[derive(std::clone::Clone)]
pub struct PutGatewayResponse {
    _private: (),
}
impl PutGatewayResponse {
    /// Creates a new builder-style object to manufacture [`PutGatewayResponseInput`](crate::input::PutGatewayResponseInput)
    pub fn builder() -> crate::input::put_gateway_response_input::Builder {
        crate::input::put_gateway_response_input::Builder::default()
    }
    #[allow(clippy::unnecessary_wraps)]
    fn from_response(
        response: &http::response::Response<impl AsRef<[u8]>>,
    ) -> Result<crate::output::PutGatewayResponseOutput, crate::error::PutGatewayResponseError>
    {
        if crate::aws_json_errors::is_error(&response) && response.status().as_u16() != 201 {
            let body = serde_json::from_slice(response.body().as_ref())
                .unwrap_or_else(|_| serde_json::json!({}));
            let generic = crate::aws_json_errors::parse_generic_error(&response, &body);

            let error_code = match generic.code() {
                Some(code) => code,
                None => return Err(crate::error::PutGatewayResponseError::unhandled(generic)),
            };
            return Err(match error_code {
                "BadRequestException" => crate::error::PutGatewayResponseError {
                    meta: generic,
                    kind: crate::error::PutGatewayResponseErrorKind::BadRequestError({
                        #[allow(unused_mut)]
                        let mut output = crate::error::bad_request_error::Builder::default();
                        let _ = response;

                        let body_slice = response.body().as_ref();

                        let parsed_body: crate::error::BadRequestError = if body_slice.is_empty() {
                            // To enable JSON parsing to succeed, replace an empty body
                            // with an empty JSON body. If a member was required, it will fail slightly later
                            // during the operation construction phase.
                            serde_json::from_slice(b"{}")
                                .map_err(crate::error::PutGatewayResponseError::unhandled)?
                        } else {
                            serde_json::from_slice(response.body().as_ref())
                                .map_err(crate::error::PutGatewayResponseError::unhandled)?
                        };

                        output = output.set_message(parsed_body.message);
                        output.build()
                    }),
                },
                "LimitExceededException" => crate::error::PutGatewayResponseError {
                    meta: generic,
                    kind: crate::error::PutGatewayResponseErrorKind::LimitExceededError({
                        #[allow(unused_mut)]
                        let mut output = crate::error::limit_exceeded_error::Builder::default();
                        let _ = response;

                        let body_slice = response.body().as_ref();

                        let parsed_body: crate::error::LimitExceededError = if body_slice.is_empty()
                        {
                            // To enable JSON parsing to succeed, replace an empty body
                            // with an empty JSON body. If a member was required, it will fail slightly later
                            // during the operation construction phase.
                            serde_json::from_slice(b"{}")
                                .map_err(crate::error::PutGatewayResponseError::unhandled)?
                        } else {
                            serde_json::from_slice(response.body().as_ref())
                                .map_err(crate::error::PutGatewayResponseError::unhandled)?
                        };

                        output = output.set_retry_after_seconds(
                        
                                                crate::http_serde::deser_header_put_gateway_response_retry_after_seconds(response.headers())
                                                    .map_err(|_|crate::error::PutGatewayResponseError::unhandled("Failed to parse retryAfterSeconds from header `Retry-After"))?
                                                
                    );
                        output = output.set_message(parsed_body.message);
                        output.build()
                    }),
                },
                "NotFoundException" => crate::error::PutGatewayResponseError {
                    meta: generic,
                    kind: crate::error::PutGatewayResponseErrorKind::NotFoundError({
                        #[allow(unused_mut)]
                        let mut output = crate::error::not_found_error::Builder::default();
                        let _ = response;

                        let body_slice = response.body().as_ref();

                        let parsed_body: crate::error::NotFoundError = if body_slice.is_empty() {
                            // To enable JSON parsing to succeed, replace an empty body
                            // with an empty JSON body. If a member was required, it will fail slightly later
                            // during the operation construction phase.
                            serde_json::from_slice(b"{}")
                                .map_err(crate::error::PutGatewayResponseError::unhandled)?
                        } else {
                            serde_json::from_slice(response.body().as_ref())
                                .map_err(crate::error::PutGatewayResponseError::unhandled)?
                        };

                        output = output.set_message(parsed_body.message);
                        output.build()
                    }),
                },
                "TooManyRequestsException" => crate::error::PutGatewayResponseError {
                    meta: generic,
                    kind: crate::error::PutGatewayResponseErrorKind::TooManyRequestsError({
                        #[allow(unused_mut)]
                        let mut output = crate::error::too_many_requests_error::Builder::default();
                        let _ = response;

                        let body_slice = response.body().as_ref();

                        let parsed_body: crate::error::TooManyRequestsError =
                            if body_slice.is_empty() {
                                // To enable JSON parsing to succeed, replace an empty body
                                // with an empty JSON body. If a member was required, it will fail slightly later
                                // during the operation construction phase.
                                serde_json::from_slice(b"{}")
                                    .map_err(crate::error::PutGatewayResponseError::unhandled)?
                            } else {
                                serde_json::from_slice(response.body().as_ref())
                                    .map_err(crate::error::PutGatewayResponseError::unhandled)?
                            };

                        output = output.set_retry_after_seconds(
                        
                                                crate::http_serde::deser_header_put_gateway_response_retry_after_seconds(response.headers())
                                                    .map_err(|_|crate::error::PutGatewayResponseError::unhandled("Failed to parse retryAfterSeconds from header `Retry-After"))?
                                                
                    );
                        output = output.set_message(parsed_body.message);
                        output.build()
                    }),
                },
                "UnauthorizedException" => crate::error::PutGatewayResponseError {
                    meta: generic,
                    kind: crate::error::PutGatewayResponseErrorKind::UnauthorizedError({
                        #[allow(unused_mut)]
                        let mut output = crate::error::unauthorized_error::Builder::default();
                        let _ = response;

                        let body_slice = response.body().as_ref();

                        let parsed_body: crate::error::UnauthorizedError = if body_slice.is_empty()
                        {
                            // To enable JSON parsing to succeed, replace an empty body
                            // with an empty JSON body. If a member was required, it will fail slightly later
                            // during the operation construction phase.
                            serde_json::from_slice(b"{}")
                                .map_err(crate::error::PutGatewayResponseError::unhandled)?
                        } else {
                            serde_json::from_slice(response.body().as_ref())
                                .map_err(crate::error::PutGatewayResponseError::unhandled)?
                        };

                        output = output.set_message(parsed_body.message);
                        output.build()
                    }),
                },
                _ => crate::error::PutGatewayResponseError::generic(generic),
            });
        }
        Ok({
            #[allow(unused_mut)]
            let mut output = crate::output::put_gateway_response_output::Builder::default();
            let _ = response;

            let body_slice = response.body().as_ref();

            let parsed_body: crate::serializer::PutGatewayResponseOutputBody =
                if body_slice.is_empty() {
                    // To enable JSON parsing to succeed, replace an empty body
                    // with an empty JSON body. If a member was required, it will fail slightly later
                    // during the operation construction phase.
                    serde_json::from_slice(b"{}")
                        .map_err(crate::error::PutGatewayResponseError::unhandled)?
                } else {
                    serde_json::from_slice(response.body().as_ref())
                        .map_err(crate::error::PutGatewayResponseError::unhandled)?
                };

            output = output.set_response_type(parsed_body.response_type);
            output = output.set_status_code(parsed_body.status_code);
            output = output.set_response_parameters(parsed_body.response_parameters);
            output = output.set_response_templates(parsed_body.response_templates);
            output = output.set_default_response(parsed_body.default_response);
            output.build()
        })
    }
    pub fn parse_response(
        &self,
        response: &http::response::Response<impl AsRef<[u8]>>,
    ) -> Result<crate::output::PutGatewayResponseOutput, crate::error::PutGatewayResponseError>
    {
        Self::from_response(&response)
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}

impl smithy_http::response::ParseStrictResponse for PutGatewayResponse {
    type Output =
        Result<crate::output::PutGatewayResponseOutput, crate::error::PutGatewayResponseError>;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        self.parse_response(response)
    }
}

/// <p>Sets up a method's integration.</p>
#[derive(std::clone::Clone)]
pub struct PutIntegration {
    _private: (),
}
impl PutIntegration {
    /// Creates a new builder-style object to manufacture [`PutIntegrationInput`](crate::input::PutIntegrationInput)
    pub fn builder() -> crate::input::put_integration_input::Builder {
        crate::input::put_integration_input::Builder::default()
    }
    #[allow(clippy::unnecessary_wraps)]
    fn from_response(
        response: &http::response::Response<impl AsRef<[u8]>>,
    ) -> Result<crate::output::PutIntegrationOutput, crate::error::PutIntegrationError> {
        if crate::aws_json_errors::is_error(&response) && response.status().as_u16() != 201 {
            let body = serde_json::from_slice(response.body().as_ref())
                .unwrap_or_else(|_| serde_json::json!({}));
            let generic = crate::aws_json_errors::parse_generic_error(&response, &body);

            let error_code = match generic.code() {
                Some(code) => code,
                None => return Err(crate::error::PutIntegrationError::unhandled(generic)),
            };
            return Err(match error_code {
                "BadRequestException" => crate::error::PutIntegrationError {
                    meta: generic,
                    kind: crate::error::PutIntegrationErrorKind::BadRequestError({
                        #[allow(unused_mut)]
                        let mut output = crate::error::bad_request_error::Builder::default();
                        let _ = response;

                        let body_slice = response.body().as_ref();

                        let parsed_body: crate::error::BadRequestError = if body_slice.is_empty() {
                            // To enable JSON parsing to succeed, replace an empty body
                            // with an empty JSON body. If a member was required, it will fail slightly later
                            // during the operation construction phase.
                            serde_json::from_slice(b"{}")
                                .map_err(crate::error::PutIntegrationError::unhandled)?
                        } else {
                            serde_json::from_slice(response.body().as_ref())
                                .map_err(crate::error::PutIntegrationError::unhandled)?
                        };

                        output = output.set_message(parsed_body.message);
                        output.build()
                    }),
                },
                "ConflictException" => crate::error::PutIntegrationError {
                    meta: generic,
                    kind: crate::error::PutIntegrationErrorKind::ConflictError({
                        #[allow(unused_mut)]
                        let mut output = crate::error::conflict_error::Builder::default();
                        let _ = response;

                        let body_slice = response.body().as_ref();

                        let parsed_body: crate::error::ConflictError = if body_slice.is_empty() {
                            // To enable JSON parsing to succeed, replace an empty body
                            // with an empty JSON body. If a member was required, it will fail slightly later
                            // during the operation construction phase.
                            serde_json::from_slice(b"{}")
                                .map_err(crate::error::PutIntegrationError::unhandled)?
                        } else {
                            serde_json::from_slice(response.body().as_ref())
                                .map_err(crate::error::PutIntegrationError::unhandled)?
                        };

                        output = output.set_message(parsed_body.message);
                        output.build()
                    }),
                },
                "NotFoundException" => crate::error::PutIntegrationError {
                    meta: generic,
                    kind: crate::error::PutIntegrationErrorKind::NotFoundError({
                        #[allow(unused_mut)]
                        let mut output = crate::error::not_found_error::Builder::default();
                        let _ = response;

                        let body_slice = response.body().as_ref();

                        let parsed_body: crate::error::NotFoundError = if body_slice.is_empty() {
                            // To enable JSON parsing to succeed, replace an empty body
                            // with an empty JSON body. If a member was required, it will fail slightly later
                            // during the operation construction phase.
                            serde_json::from_slice(b"{}")
                                .map_err(crate::error::PutIntegrationError::unhandled)?
                        } else {
                            serde_json::from_slice(response.body().as_ref())
                                .map_err(crate::error::PutIntegrationError::unhandled)?
                        };

                        output = output.set_message(parsed_body.message);
                        output.build()
                    }),
                },
                "TooManyRequestsException" => {
                    crate::error::PutIntegrationError {
                        meta: generic,
                        kind: crate::error::PutIntegrationErrorKind::TooManyRequestsError({
                            #[allow(unused_mut)]
                            let mut output =
                                crate::error::too_many_requests_error::Builder::default();
                            let _ = response;

                            let body_slice = response.body().as_ref();

                            let parsed_body: crate::error::TooManyRequestsError =
                                if body_slice.is_empty() {
                                    // To enable JSON parsing to succeed, replace an empty body
                                    // with an empty JSON body. If a member was required, it will fail slightly later
                                    // during the operation construction phase.
                                    serde_json::from_slice(b"{}")
                                        .map_err(crate::error::PutIntegrationError::unhandled)?
                                } else {
                                    serde_json::from_slice(response.body().as_ref())
                                        .map_err(crate::error::PutIntegrationError::unhandled)?
                                };

                            output = output.set_retry_after_seconds(
                        
                                                crate::http_serde::deser_header_put_integration_retry_after_seconds(response.headers())
                                                    .map_err(|_|crate::error::PutIntegrationError::unhandled("Failed to parse retryAfterSeconds from header `Retry-After"))?
                                                
                    );
                            output = output.set_message(parsed_body.message);
                            output.build()
                        }),
                    }
                }
                "UnauthorizedException" => crate::error::PutIntegrationError {
                    meta: generic,
                    kind: crate::error::PutIntegrationErrorKind::UnauthorizedError({
                        #[allow(unused_mut)]
                        let mut output = crate::error::unauthorized_error::Builder::default();
                        let _ = response;

                        let body_slice = response.body().as_ref();

                        let parsed_body: crate::error::UnauthorizedError = if body_slice.is_empty()
                        {
                            // To enable JSON parsing to succeed, replace an empty body
                            // with an empty JSON body. If a member was required, it will fail slightly later
                            // during the operation construction phase.
                            serde_json::from_slice(b"{}")
                                .map_err(crate::error::PutIntegrationError::unhandled)?
                        } else {
                            serde_json::from_slice(response.body().as_ref())
                                .map_err(crate::error::PutIntegrationError::unhandled)?
                        };

                        output = output.set_message(parsed_body.message);
                        output.build()
                    }),
                },
                _ => crate::error::PutIntegrationError::generic(generic),
            });
        }
        Ok({
            #[allow(unused_mut)]
            let mut output = crate::output::put_integration_output::Builder::default();
            let _ = response;

            let body_slice = response.body().as_ref();

            let parsed_body: crate::serializer::PutIntegrationOutputBody = if body_slice.is_empty()
            {
                // To enable JSON parsing to succeed, replace an empty body
                // with an empty JSON body. If a member was required, it will fail slightly later
                // during the operation construction phase.
                serde_json::from_slice(b"{}")
                    .map_err(crate::error::PutIntegrationError::unhandled)?
            } else {
                serde_json::from_slice(response.body().as_ref())
                    .map_err(crate::error::PutIntegrationError::unhandled)?
            };

            output = output.set_type(parsed_body.r#type);
            output = output.set_http_method(parsed_body.http_method);
            output = output.set_uri(parsed_body.uri);
            output = output.set_connection_type(parsed_body.connection_type);
            output = output.set_connection_id(parsed_body.connection_id);
            output = output.set_credentials(parsed_body.credentials);
            output = output.set_request_parameters(parsed_body.request_parameters);
            output = output.set_request_templates(parsed_body.request_templates);
            output = output.set_passthrough_behavior(parsed_body.passthrough_behavior);
            output = output.set_content_handling(parsed_body.content_handling);
            output = output.set_timeout_in_millis(parsed_body.timeout_in_millis);
            output = output.set_cache_namespace(parsed_body.cache_namespace);
            output = output.set_cache_key_parameters(parsed_body.cache_key_parameters);
            output = output.set_integration_responses(parsed_body.integration_responses);
            output = output.set_tls_config(parsed_body.tls_config);
            output.build()
        })
    }
    pub fn parse_response(
        &self,
        response: &http::response::Response<impl AsRef<[u8]>>,
    ) -> Result<crate::output::PutIntegrationOutput, crate::error::PutIntegrationError> {
        Self::from_response(&response)
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}

impl smithy_http::response::ParseStrictResponse for PutIntegration {
    type Output = Result<crate::output::PutIntegrationOutput, crate::error::PutIntegrationError>;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        self.parse_response(response)
    }
}

/// <p>Represents a put integration.</p>
#[derive(std::clone::Clone)]
pub struct PutIntegrationResponse {
    _private: (),
}
impl PutIntegrationResponse {
    /// Creates a new builder-style object to manufacture [`PutIntegrationResponseInput`](crate::input::PutIntegrationResponseInput)
    pub fn builder() -> crate::input::put_integration_response_input::Builder {
        crate::input::put_integration_response_input::Builder::default()
    }
    #[allow(clippy::unnecessary_wraps)]
    fn from_response(
        response: &http::response::Response<impl AsRef<[u8]>>,
    ) -> Result<
        crate::output::PutIntegrationResponseOutput,
        crate::error::PutIntegrationResponseError,
    > {
        if crate::aws_json_errors::is_error(&response) && response.status().as_u16() != 201 {
            let body = serde_json::from_slice(response.body().as_ref())
                .unwrap_or_else(|_| serde_json::json!({}));
            let generic = crate::aws_json_errors::parse_generic_error(&response, &body);

            let error_code = match generic.code() {
                Some(code) => code,
                None => {
                    return Err(crate::error::PutIntegrationResponseError::unhandled(
                        generic,
                    ))
                }
            };
            return Err(match error_code {
                "BadRequestException" => crate::error::PutIntegrationResponseError {
                    meta: generic,
                    kind: crate::error::PutIntegrationResponseErrorKind::BadRequestError({
                        #[allow(unused_mut)]
                        let mut output = crate::error::bad_request_error::Builder::default();
                        let _ = response;

                        let body_slice = response.body().as_ref();

                        let parsed_body: crate::error::BadRequestError = if body_slice.is_empty() {
                            // To enable JSON parsing to succeed, replace an empty body
                            // with an empty JSON body. If a member was required, it will fail slightly later
                            // during the operation construction phase.
                            serde_json::from_slice(b"{}")
                                .map_err(crate::error::PutIntegrationResponseError::unhandled)?
                        } else {
                            serde_json::from_slice(response.body().as_ref())
                                .map_err(crate::error::PutIntegrationResponseError::unhandled)?
                        };

                        output = output.set_message(parsed_body.message);
                        output.build()
                    }),
                },
                "ConflictException" => crate::error::PutIntegrationResponseError {
                    meta: generic,
                    kind: crate::error::PutIntegrationResponseErrorKind::ConflictError({
                        #[allow(unused_mut)]
                        let mut output = crate::error::conflict_error::Builder::default();
                        let _ = response;

                        let body_slice = response.body().as_ref();

                        let parsed_body: crate::error::ConflictError = if body_slice.is_empty() {
                            // To enable JSON parsing to succeed, replace an empty body
                            // with an empty JSON body. If a member was required, it will fail slightly later
                            // during the operation construction phase.
                            serde_json::from_slice(b"{}")
                                .map_err(crate::error::PutIntegrationResponseError::unhandled)?
                        } else {
                            serde_json::from_slice(response.body().as_ref())
                                .map_err(crate::error::PutIntegrationResponseError::unhandled)?
                        };

                        output = output.set_message(parsed_body.message);
                        output.build()
                    }),
                },
                "LimitExceededException" => crate::error::PutIntegrationResponseError {
                    meta: generic,
                    kind: crate::error::PutIntegrationResponseErrorKind::LimitExceededError({
                        #[allow(unused_mut)]
                        let mut output = crate::error::limit_exceeded_error::Builder::default();
                        let _ = response;

                        let body_slice = response.body().as_ref();

                        let parsed_body: crate::error::LimitExceededError = if body_slice.is_empty()
                        {
                            // To enable JSON parsing to succeed, replace an empty body
                            // with an empty JSON body. If a member was required, it will fail slightly later
                            // during the operation construction phase.
                            serde_json::from_slice(b"{}")
                                .map_err(crate::error::PutIntegrationResponseError::unhandled)?
                        } else {
                            serde_json::from_slice(response.body().as_ref())
                                .map_err(crate::error::PutIntegrationResponseError::unhandled)?
                        };

                        output = output.set_retry_after_seconds(
                        
                                                crate::http_serde::deser_header_put_integration_response_retry_after_seconds(response.headers())
                                                    .map_err(|_|crate::error::PutIntegrationResponseError::unhandled("Failed to parse retryAfterSeconds from header `Retry-After"))?
                                                
                    );
                        output = output.set_message(parsed_body.message);
                        output.build()
                    }),
                },
                "NotFoundException" => crate::error::PutIntegrationResponseError {
                    meta: generic,
                    kind: crate::error::PutIntegrationResponseErrorKind::NotFoundError({
                        #[allow(unused_mut)]
                        let mut output = crate::error::not_found_error::Builder::default();
                        let _ = response;

                        let body_slice = response.body().as_ref();

                        let parsed_body: crate::error::NotFoundError = if body_slice.is_empty() {
                            // To enable JSON parsing to succeed, replace an empty body
                            // with an empty JSON body. If a member was required, it will fail slightly later
                            // during the operation construction phase.
                            serde_json::from_slice(b"{}")
                                .map_err(crate::error::PutIntegrationResponseError::unhandled)?
                        } else {
                            serde_json::from_slice(response.body().as_ref())
                                .map_err(crate::error::PutIntegrationResponseError::unhandled)?
                        };

                        output = output.set_message(parsed_body.message);
                        output.build()
                    }),
                },
                "TooManyRequestsException" => crate::error::PutIntegrationResponseError {
                    meta: generic,
                    kind: crate::error::PutIntegrationResponseErrorKind::TooManyRequestsError({
                        #[allow(unused_mut)]
                        let mut output = crate::error::too_many_requests_error::Builder::default();
                        let _ = response;

                        let body_slice = response.body().as_ref();

                        let parsed_body: crate::error::TooManyRequestsError =
                            if body_slice.is_empty() {
                                // To enable JSON parsing to succeed, replace an empty body
                                // with an empty JSON body. If a member was required, it will fail slightly later
                                // during the operation construction phase.
                                serde_json::from_slice(b"{}")
                                    .map_err(crate::error::PutIntegrationResponseError::unhandled)?
                            } else {
                                serde_json::from_slice(response.body().as_ref())
                                    .map_err(crate::error::PutIntegrationResponseError::unhandled)?
                            };

                        output = output.set_retry_after_seconds(
                        
                                                crate::http_serde::deser_header_put_integration_response_retry_after_seconds(response.headers())
                                                    .map_err(|_|crate::error::PutIntegrationResponseError::unhandled("Failed to parse retryAfterSeconds from header `Retry-After"))?
                                                
                    );
                        output = output.set_message(parsed_body.message);
                        output.build()
                    }),
                },
                "UnauthorizedException" => crate::error::PutIntegrationResponseError {
                    meta: generic,
                    kind: crate::error::PutIntegrationResponseErrorKind::UnauthorizedError({
                        #[allow(unused_mut)]
                        let mut output = crate::error::unauthorized_error::Builder::default();
                        let _ = response;

                        let body_slice = response.body().as_ref();

                        let parsed_body: crate::error::UnauthorizedError = if body_slice.is_empty()
                        {
                            // To enable JSON parsing to succeed, replace an empty body
                            // with an empty JSON body. If a member was required, it will fail slightly later
                            // during the operation construction phase.
                            serde_json::from_slice(b"{}")
                                .map_err(crate::error::PutIntegrationResponseError::unhandled)?
                        } else {
                            serde_json::from_slice(response.body().as_ref())
                                .map_err(crate::error::PutIntegrationResponseError::unhandled)?
                        };

                        output = output.set_message(parsed_body.message);
                        output.build()
                    }),
                },
                _ => crate::error::PutIntegrationResponseError::generic(generic),
            });
        }
        Ok({
            #[allow(unused_mut)]
            let mut output = crate::output::put_integration_response_output::Builder::default();
            let _ = response;

            let body_slice = response.body().as_ref();

            let parsed_body: crate::serializer::PutIntegrationResponseOutputBody =
                if body_slice.is_empty() {
                    // To enable JSON parsing to succeed, replace an empty body
                    // with an empty JSON body. If a member was required, it will fail slightly later
                    // during the operation construction phase.
                    serde_json::from_slice(b"{}")
                        .map_err(crate::error::PutIntegrationResponseError::unhandled)?
                } else {
                    serde_json::from_slice(response.body().as_ref())
                        .map_err(crate::error::PutIntegrationResponseError::unhandled)?
                };

            output = output.set_status_code(parsed_body.status_code);
            output = output.set_selection_pattern(parsed_body.selection_pattern);
            output = output.set_response_parameters(parsed_body.response_parameters);
            output = output.set_response_templates(parsed_body.response_templates);
            output = output.set_content_handling(parsed_body.content_handling);
            output.build()
        })
    }
    pub fn parse_response(
        &self,
        response: &http::response::Response<impl AsRef<[u8]>>,
    ) -> Result<
        crate::output::PutIntegrationResponseOutput,
        crate::error::PutIntegrationResponseError,
    > {
        Self::from_response(&response)
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}

impl smithy_http::response::ParseStrictResponse for PutIntegrationResponse {
    type Output = Result<
        crate::output::PutIntegrationResponseOutput,
        crate::error::PutIntegrationResponseError,
    >;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        self.parse_response(response)
    }
}

/// <p>Add a method to an existing <a>Resource</a> resource.</p>
#[derive(std::clone::Clone)]
pub struct PutMethod {
    _private: (),
}
impl PutMethod {
    /// Creates a new builder-style object to manufacture [`PutMethodInput`](crate::input::PutMethodInput)
    pub fn builder() -> crate::input::put_method_input::Builder {
        crate::input::put_method_input::Builder::default()
    }
    #[allow(clippy::unnecessary_wraps)]
    fn from_response(
        response: &http::response::Response<impl AsRef<[u8]>>,
    ) -> Result<crate::output::PutMethodOutput, crate::error::PutMethodError> {
        if crate::aws_json_errors::is_error(&response) && response.status().as_u16() != 201 {
            let body = serde_json::from_slice(response.body().as_ref())
                .unwrap_or_else(|_| serde_json::json!({}));
            let generic = crate::aws_json_errors::parse_generic_error(&response, &body);

            let error_code = match generic.code() {
                Some(code) => code,
                None => return Err(crate::error::PutMethodError::unhandled(generic)),
            };
            return Err(match error_code {
                "BadRequestException" => crate::error::PutMethodError {
                    meta: generic,
                    kind: crate::error::PutMethodErrorKind::BadRequestError({
                        #[allow(unused_mut)]
                        let mut output = crate::error::bad_request_error::Builder::default();
                        let _ = response;

                        let body_slice = response.body().as_ref();

                        let parsed_body: crate::error::BadRequestError = if body_slice.is_empty() {
                            // To enable JSON parsing to succeed, replace an empty body
                            // with an empty JSON body. If a member was required, it will fail slightly later
                            // during the operation construction phase.
                            serde_json::from_slice(b"{}")
                                .map_err(crate::error::PutMethodError::unhandled)?
                        } else {
                            serde_json::from_slice(response.body().as_ref())
                                .map_err(crate::error::PutMethodError::unhandled)?
                        };

                        output = output.set_message(parsed_body.message);
                        output.build()
                    }),
                },
                "ConflictException" => crate::error::PutMethodError {
                    meta: generic,
                    kind: crate::error::PutMethodErrorKind::ConflictError({
                        #[allow(unused_mut)]
                        let mut output = crate::error::conflict_error::Builder::default();
                        let _ = response;

                        let body_slice = response.body().as_ref();

                        let parsed_body: crate::error::ConflictError = if body_slice.is_empty() {
                            // To enable JSON parsing to succeed, replace an empty body
                            // with an empty JSON body. If a member was required, it will fail slightly later
                            // during the operation construction phase.
                            serde_json::from_slice(b"{}")
                                .map_err(crate::error::PutMethodError::unhandled)?
                        } else {
                            serde_json::from_slice(response.body().as_ref())
                                .map_err(crate::error::PutMethodError::unhandled)?
                        };

                        output = output.set_message(parsed_body.message);
                        output.build()
                    }),
                },
                "LimitExceededException" => {
                    crate::error::PutMethodError {
                        meta: generic,
                        kind: crate::error::PutMethodErrorKind::LimitExceededError({
                            #[allow(unused_mut)]
                            let mut output = crate::error::limit_exceeded_error::Builder::default();
                            let _ = response;

                            let body_slice = response.body().as_ref();

                            let parsed_body: crate::error::LimitExceededError =
                                if body_slice.is_empty() {
                                    // To enable JSON parsing to succeed, replace an empty body
                                    // with an empty JSON body. If a member was required, it will fail slightly later
                                    // during the operation construction phase.
                                    serde_json::from_slice(b"{}")
                                        .map_err(crate::error::PutMethodError::unhandled)?
                                } else {
                                    serde_json::from_slice(response.body().as_ref())
                                        .map_err(crate::error::PutMethodError::unhandled)?
                                };

                            output = output.set_retry_after_seconds(
                        
                                                crate::http_serde::deser_header_put_method_retry_after_seconds(response.headers())
                                                    .map_err(|_|crate::error::PutMethodError::unhandled("Failed to parse retryAfterSeconds from header `Retry-After"))?
                                                
                    );
                            output = output.set_message(parsed_body.message);
                            output.build()
                        }),
                    }
                }
                "NotFoundException" => crate::error::PutMethodError {
                    meta: generic,
                    kind: crate::error::PutMethodErrorKind::NotFoundError({
                        #[allow(unused_mut)]
                        let mut output = crate::error::not_found_error::Builder::default();
                        let _ = response;

                        let body_slice = response.body().as_ref();

                        let parsed_body: crate::error::NotFoundError = if body_slice.is_empty() {
                            // To enable JSON parsing to succeed, replace an empty body
                            // with an empty JSON body. If a member was required, it will fail slightly later
                            // during the operation construction phase.
                            serde_json::from_slice(b"{}")
                                .map_err(crate::error::PutMethodError::unhandled)?
                        } else {
                            serde_json::from_slice(response.body().as_ref())
                                .map_err(crate::error::PutMethodError::unhandled)?
                        };

                        output = output.set_message(parsed_body.message);
                        output.build()
                    }),
                },
                "TooManyRequestsException" => {
                    crate::error::PutMethodError {
                        meta: generic,
                        kind: crate::error::PutMethodErrorKind::TooManyRequestsError({
                            #[allow(unused_mut)]
                            let mut output =
                                crate::error::too_many_requests_error::Builder::default();
                            let _ = response;

                            let body_slice = response.body().as_ref();

                            let parsed_body: crate::error::TooManyRequestsError =
                                if body_slice.is_empty() {
                                    // To enable JSON parsing to succeed, replace an empty body
                                    // with an empty JSON body. If a member was required, it will fail slightly later
                                    // during the operation construction phase.
                                    serde_json::from_slice(b"{}")
                                        .map_err(crate::error::PutMethodError::unhandled)?
                                } else {
                                    serde_json::from_slice(response.body().as_ref())
                                        .map_err(crate::error::PutMethodError::unhandled)?
                                };

                            output = output.set_retry_after_seconds(
                        
                                                crate::http_serde::deser_header_put_method_retry_after_seconds(response.headers())
                                                    .map_err(|_|crate::error::PutMethodError::unhandled("Failed to parse retryAfterSeconds from header `Retry-After"))?
                                                
                    );
                            output = output.set_message(parsed_body.message);
                            output.build()
                        }),
                    }
                }
                "UnauthorizedException" => crate::error::PutMethodError {
                    meta: generic,
                    kind: crate::error::PutMethodErrorKind::UnauthorizedError({
                        #[allow(unused_mut)]
                        let mut output = crate::error::unauthorized_error::Builder::default();
                        let _ = response;

                        let body_slice = response.body().as_ref();

                        let parsed_body: crate::error::UnauthorizedError = if body_slice.is_empty()
                        {
                            // To enable JSON parsing to succeed, replace an empty body
                            // with an empty JSON body. If a member was required, it will fail slightly later
                            // during the operation construction phase.
                            serde_json::from_slice(b"{}")
                                .map_err(crate::error::PutMethodError::unhandled)?
                        } else {
                            serde_json::from_slice(response.body().as_ref())
                                .map_err(crate::error::PutMethodError::unhandled)?
                        };

                        output = output.set_message(parsed_body.message);
                        output.build()
                    }),
                },
                _ => crate::error::PutMethodError::generic(generic),
            });
        }
        Ok({
            #[allow(unused_mut)]
            let mut output = crate::output::put_method_output::Builder::default();
            let _ = response;

            let body_slice = response.body().as_ref();

            let parsed_body: crate::serializer::PutMethodOutputBody = if body_slice.is_empty() {
                // To enable JSON parsing to succeed, replace an empty body
                // with an empty JSON body. If a member was required, it will fail slightly later
                // during the operation construction phase.
                serde_json::from_slice(b"{}").map_err(crate::error::PutMethodError::unhandled)?
            } else {
                serde_json::from_slice(response.body().as_ref())
                    .map_err(crate::error::PutMethodError::unhandled)?
            };

            output = output.set_http_method(parsed_body.http_method);
            output = output.set_authorization_type(parsed_body.authorization_type);
            output = output.set_authorizer_id(parsed_body.authorizer_id);
            output = output.set_api_key_required(parsed_body.api_key_required);
            output = output.set_request_validator_id(parsed_body.request_validator_id);
            output = output.set_operation_name(parsed_body.operation_name);
            output = output.set_request_parameters(parsed_body.request_parameters);
            output = output.set_request_models(parsed_body.request_models);
            output = output.set_method_responses(parsed_body.method_responses);
            output = output.set_method_integration(parsed_body.method_integration);
            output = output.set_authorization_scopes(parsed_body.authorization_scopes);
            output.build()
        })
    }
    pub fn parse_response(
        &self,
        response: &http::response::Response<impl AsRef<[u8]>>,
    ) -> Result<crate::output::PutMethodOutput, crate::error::PutMethodError> {
        Self::from_response(&response)
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}

impl smithy_http::response::ParseStrictResponse for PutMethod {
    type Output = Result<crate::output::PutMethodOutput, crate::error::PutMethodError>;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        self.parse_response(response)
    }
}

/// <p>Adds a <a>MethodResponse</a> to an existing <a>Method</a> resource.</p>
#[derive(std::clone::Clone)]
pub struct PutMethodResponse {
    _private: (),
}
impl PutMethodResponse {
    /// Creates a new builder-style object to manufacture [`PutMethodResponseInput`](crate::input::PutMethodResponseInput)
    pub fn builder() -> crate::input::put_method_response_input::Builder {
        crate::input::put_method_response_input::Builder::default()
    }
    #[allow(clippy::unnecessary_wraps)]
    fn from_response(
        response: &http::response::Response<impl AsRef<[u8]>>,
    ) -> Result<crate::output::PutMethodResponseOutput, crate::error::PutMethodResponseError> {
        if crate::aws_json_errors::is_error(&response) && response.status().as_u16() != 201 {
            let body = serde_json::from_slice(response.body().as_ref())
                .unwrap_or_else(|_| serde_json::json!({}));
            let generic = crate::aws_json_errors::parse_generic_error(&response, &body);

            let error_code = match generic.code() {
                Some(code) => code,
                None => return Err(crate::error::PutMethodResponseError::unhandled(generic)),
            };
            return Err(match error_code {
                "BadRequestException" => crate::error::PutMethodResponseError {
                    meta: generic,
                    kind: crate::error::PutMethodResponseErrorKind::BadRequestError({
                        #[allow(unused_mut)]
                        let mut output = crate::error::bad_request_error::Builder::default();
                        let _ = response;

                        let body_slice = response.body().as_ref();

                        let parsed_body: crate::error::BadRequestError = if body_slice.is_empty() {
                            // To enable JSON parsing to succeed, replace an empty body
                            // with an empty JSON body. If a member was required, it will fail slightly later
                            // during the operation construction phase.
                            serde_json::from_slice(b"{}")
                                .map_err(crate::error::PutMethodResponseError::unhandled)?
                        } else {
                            serde_json::from_slice(response.body().as_ref())
                                .map_err(crate::error::PutMethodResponseError::unhandled)?
                        };

                        output = output.set_message(parsed_body.message);
                        output.build()
                    }),
                },
                "ConflictException" => crate::error::PutMethodResponseError {
                    meta: generic,
                    kind: crate::error::PutMethodResponseErrorKind::ConflictError({
                        #[allow(unused_mut)]
                        let mut output = crate::error::conflict_error::Builder::default();
                        let _ = response;

                        let body_slice = response.body().as_ref();

                        let parsed_body: crate::error::ConflictError = if body_slice.is_empty() {
                            // To enable JSON parsing to succeed, replace an empty body
                            // with an empty JSON body. If a member was required, it will fail slightly later
                            // during the operation construction phase.
                            serde_json::from_slice(b"{}")
                                .map_err(crate::error::PutMethodResponseError::unhandled)?
                        } else {
                            serde_json::from_slice(response.body().as_ref())
                                .map_err(crate::error::PutMethodResponseError::unhandled)?
                        };

                        output = output.set_message(parsed_body.message);
                        output.build()
                    }),
                },
                "LimitExceededException" => crate::error::PutMethodResponseError {
                    meta: generic,
                    kind: crate::error::PutMethodResponseErrorKind::LimitExceededError({
                        #[allow(unused_mut)]
                        let mut output = crate::error::limit_exceeded_error::Builder::default();
                        let _ = response;

                        let body_slice = response.body().as_ref();

                        let parsed_body: crate::error::LimitExceededError = if body_slice.is_empty()
                        {
                            // To enable JSON parsing to succeed, replace an empty body
                            // with an empty JSON body. If a member was required, it will fail slightly later
                            // during the operation construction phase.
                            serde_json::from_slice(b"{}")
                                .map_err(crate::error::PutMethodResponseError::unhandled)?
                        } else {
                            serde_json::from_slice(response.body().as_ref())
                                .map_err(crate::error::PutMethodResponseError::unhandled)?
                        };

                        output = output.set_retry_after_seconds(
                        
                                                crate::http_serde::deser_header_put_method_response_retry_after_seconds(response.headers())
                                                    .map_err(|_|crate::error::PutMethodResponseError::unhandled("Failed to parse retryAfterSeconds from header `Retry-After"))?
                                                
                    );
                        output = output.set_message(parsed_body.message);
                        output.build()
                    }),
                },
                "NotFoundException" => crate::error::PutMethodResponseError {
                    meta: generic,
                    kind: crate::error::PutMethodResponseErrorKind::NotFoundError({
                        #[allow(unused_mut)]
                        let mut output = crate::error::not_found_error::Builder::default();
                        let _ = response;

                        let body_slice = response.body().as_ref();

                        let parsed_body: crate::error::NotFoundError = if body_slice.is_empty() {
                            // To enable JSON parsing to succeed, replace an empty body
                            // with an empty JSON body. If a member was required, it will fail slightly later
                            // during the operation construction phase.
                            serde_json::from_slice(b"{}")
                                .map_err(crate::error::PutMethodResponseError::unhandled)?
                        } else {
                            serde_json::from_slice(response.body().as_ref())
                                .map_err(crate::error::PutMethodResponseError::unhandled)?
                        };

                        output = output.set_message(parsed_body.message);
                        output.build()
                    }),
                },
                "TooManyRequestsException" => crate::error::PutMethodResponseError {
                    meta: generic,
                    kind: crate::error::PutMethodResponseErrorKind::TooManyRequestsError({
                        #[allow(unused_mut)]
                        let mut output = crate::error::too_many_requests_error::Builder::default();
                        let _ = response;

                        let body_slice = response.body().as_ref();

                        let parsed_body: crate::error::TooManyRequestsError =
                            if body_slice.is_empty() {
                                // To enable JSON parsing to succeed, replace an empty body
                                // with an empty JSON body. If a member was required, it will fail slightly later
                                // during the operation construction phase.
                                serde_json::from_slice(b"{}")
                                    .map_err(crate::error::PutMethodResponseError::unhandled)?
                            } else {
                                serde_json::from_slice(response.body().as_ref())
                                    .map_err(crate::error::PutMethodResponseError::unhandled)?
                            };

                        output = output.set_retry_after_seconds(
                        
                                                crate::http_serde::deser_header_put_method_response_retry_after_seconds(response.headers())
                                                    .map_err(|_|crate::error::PutMethodResponseError::unhandled("Failed to parse retryAfterSeconds from header `Retry-After"))?
                                                
                    );
                        output = output.set_message(parsed_body.message);
                        output.build()
                    }),
                },
                "UnauthorizedException" => crate::error::PutMethodResponseError {
                    meta: generic,
                    kind: crate::error::PutMethodResponseErrorKind::UnauthorizedError({
                        #[allow(unused_mut)]
                        let mut output = crate::error::unauthorized_error::Builder::default();
                        let _ = response;

                        let body_slice = response.body().as_ref();

                        let parsed_body: crate::error::UnauthorizedError = if body_slice.is_empty()
                        {
                            // To enable JSON parsing to succeed, replace an empty body
                            // with an empty JSON body. If a member was required, it will fail slightly later
                            // during the operation construction phase.
                            serde_json::from_slice(b"{}")
                                .map_err(crate::error::PutMethodResponseError::unhandled)?
                        } else {
                            serde_json::from_slice(response.body().as_ref())
                                .map_err(crate::error::PutMethodResponseError::unhandled)?
                        };

                        output = output.set_message(parsed_body.message);
                        output.build()
                    }),
                },
                _ => crate::error::PutMethodResponseError::generic(generic),
            });
        }
        Ok({
            #[allow(unused_mut)]
            let mut output = crate::output::put_method_response_output::Builder::default();
            let _ = response;

            let body_slice = response.body().as_ref();

            let parsed_body: crate::serializer::PutMethodResponseOutputBody =
                if body_slice.is_empty() {
                    // To enable JSON parsing to succeed, replace an empty body
                    // with an empty JSON body. If a member was required, it will fail slightly later
                    // during the operation construction phase.
                    serde_json::from_slice(b"{}")
                        .map_err(crate::error::PutMethodResponseError::unhandled)?
                } else {
                    serde_json::from_slice(response.body().as_ref())
                        .map_err(crate::error::PutMethodResponseError::unhandled)?
                };

            output = output.set_status_code(parsed_body.status_code);
            output = output.set_response_parameters(parsed_body.response_parameters);
            output = output.set_response_models(parsed_body.response_models);
            output.build()
        })
    }
    pub fn parse_response(
        &self,
        response: &http::response::Response<impl AsRef<[u8]>>,
    ) -> Result<crate::output::PutMethodResponseOutput, crate::error::PutMethodResponseError> {
        Self::from_response(&response)
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}

impl smithy_http::response::ParseStrictResponse for PutMethodResponse {
    type Output =
        Result<crate::output::PutMethodResponseOutput, crate::error::PutMethodResponseError>;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        self.parse_response(response)
    }
}

/// <p>A feature of the API Gateway control service for updating an existing API with an input of external API definitions.
/// The update can take the form of merging the supplied definition into the existing API or overwriting the existing API.</p>
#[derive(std::clone::Clone)]
pub struct PutRestApi {
    _private: (),
}
impl PutRestApi {
    /// Creates a new builder-style object to manufacture [`PutRestApiInput`](crate::input::PutRestApiInput)
    pub fn builder() -> crate::input::put_rest_api_input::Builder {
        crate::input::put_rest_api_input::Builder::default()
    }
    #[allow(clippy::unnecessary_wraps)]
    fn from_response(
        response: &http::response::Response<impl AsRef<[u8]>>,
    ) -> Result<crate::output::PutRestApiOutput, crate::error::PutRestApiError> {
        if crate::aws_json_errors::is_error(&response) && response.status().as_u16() != 200 {
            let body = serde_json::from_slice(response.body().as_ref())
                .unwrap_or_else(|_| serde_json::json!({}));
            let generic = crate::aws_json_errors::parse_generic_error(&response, &body);

            let error_code = match generic.code() {
                Some(code) => code,
                None => return Err(crate::error::PutRestApiError::unhandled(generic)),
            };
            return Err(match error_code {
                "BadRequestException" => crate::error::PutRestApiError {
                    meta: generic,
                    kind: crate::error::PutRestApiErrorKind::BadRequestError({
                        #[allow(unused_mut)]
                        let mut output = crate::error::bad_request_error::Builder::default();
                        let _ = response;

                        let body_slice = response.body().as_ref();

                        let parsed_body: crate::error::BadRequestError = if body_slice.is_empty() {
                            // To enable JSON parsing to succeed, replace an empty body
                            // with an empty JSON body. If a member was required, it will fail slightly later
                            // during the operation construction phase.
                            serde_json::from_slice(b"{}")
                                .map_err(crate::error::PutRestApiError::unhandled)?
                        } else {
                            serde_json::from_slice(response.body().as_ref())
                                .map_err(crate::error::PutRestApiError::unhandled)?
                        };

                        output = output.set_message(parsed_body.message);
                        output.build()
                    }),
                },
                "ConflictException" => crate::error::PutRestApiError {
                    meta: generic,
                    kind: crate::error::PutRestApiErrorKind::ConflictError({
                        #[allow(unused_mut)]
                        let mut output = crate::error::conflict_error::Builder::default();
                        let _ = response;

                        let body_slice = response.body().as_ref();

                        let parsed_body: crate::error::ConflictError = if body_slice.is_empty() {
                            // To enable JSON parsing to succeed, replace an empty body
                            // with an empty JSON body. If a member was required, it will fail slightly later
                            // during the operation construction phase.
                            serde_json::from_slice(b"{}")
                                .map_err(crate::error::PutRestApiError::unhandled)?
                        } else {
                            serde_json::from_slice(response.body().as_ref())
                                .map_err(crate::error::PutRestApiError::unhandled)?
                        };

                        output = output.set_message(parsed_body.message);
                        output.build()
                    }),
                },
                "LimitExceededException" => {
                    crate::error::PutRestApiError {
                        meta: generic,
                        kind: crate::error::PutRestApiErrorKind::LimitExceededError({
                            #[allow(unused_mut)]
                            let mut output = crate::error::limit_exceeded_error::Builder::default();
                            let _ = response;

                            let body_slice = response.body().as_ref();

                            let parsed_body: crate::error::LimitExceededError =
                                if body_slice.is_empty() {
                                    // To enable JSON parsing to succeed, replace an empty body
                                    // with an empty JSON body. If a member was required, it will fail slightly later
                                    // during the operation construction phase.
                                    serde_json::from_slice(b"{}")
                                        .map_err(crate::error::PutRestApiError::unhandled)?
                                } else {
                                    serde_json::from_slice(response.body().as_ref())
                                        .map_err(crate::error::PutRestApiError::unhandled)?
                                };

                            output = output.set_retry_after_seconds(
                        
                                                crate::http_serde::deser_header_put_rest_api_retry_after_seconds(response.headers())
                                                    .map_err(|_|crate::error::PutRestApiError::unhandled("Failed to parse retryAfterSeconds from header `Retry-After"))?
                                                
                    );
                            output = output.set_message(parsed_body.message);
                            output.build()
                        }),
                    }
                }
                "NotFoundException" => crate::error::PutRestApiError {
                    meta: generic,
                    kind: crate::error::PutRestApiErrorKind::NotFoundError({
                        #[allow(unused_mut)]
                        let mut output = crate::error::not_found_error::Builder::default();
                        let _ = response;

                        let body_slice = response.body().as_ref();

                        let parsed_body: crate::error::NotFoundError = if body_slice.is_empty() {
                            // To enable JSON parsing to succeed, replace an empty body
                            // with an empty JSON body. If a member was required, it will fail slightly later
                            // during the operation construction phase.
                            serde_json::from_slice(b"{}")
                                .map_err(crate::error::PutRestApiError::unhandled)?
                        } else {
                            serde_json::from_slice(response.body().as_ref())
                                .map_err(crate::error::PutRestApiError::unhandled)?
                        };

                        output = output.set_message(parsed_body.message);
                        output.build()
                    }),
                },
                "TooManyRequestsException" => {
                    crate::error::PutRestApiError {
                        meta: generic,
                        kind: crate::error::PutRestApiErrorKind::TooManyRequestsError({
                            #[allow(unused_mut)]
                            let mut output =
                                crate::error::too_many_requests_error::Builder::default();
                            let _ = response;

                            let body_slice = response.body().as_ref();

                            let parsed_body: crate::error::TooManyRequestsError =
                                if body_slice.is_empty() {
                                    // To enable JSON parsing to succeed, replace an empty body
                                    // with an empty JSON body. If a member was required, it will fail slightly later
                                    // during the operation construction phase.
                                    serde_json::from_slice(b"{}")
                                        .map_err(crate::error::PutRestApiError::unhandled)?
                                } else {
                                    serde_json::from_slice(response.body().as_ref())
                                        .map_err(crate::error::PutRestApiError::unhandled)?
                                };

                            output = output.set_retry_after_seconds(
                        
                                                crate::http_serde::deser_header_put_rest_api_retry_after_seconds(response.headers())
                                                    .map_err(|_|crate::error::PutRestApiError::unhandled("Failed to parse retryAfterSeconds from header `Retry-After"))?
                                                
                    );
                            output = output.set_message(parsed_body.message);
                            output.build()
                        }),
                    }
                }
                "UnauthorizedException" => crate::error::PutRestApiError {
                    meta: generic,
                    kind: crate::error::PutRestApiErrorKind::UnauthorizedError({
                        #[allow(unused_mut)]
                        let mut output = crate::error::unauthorized_error::Builder::default();
                        let _ = response;

                        let body_slice = response.body().as_ref();

                        let parsed_body: crate::error::UnauthorizedError = if body_slice.is_empty()
                        {
                            // To enable JSON parsing to succeed, replace an empty body
                            // with an empty JSON body. If a member was required, it will fail slightly later
                            // during the operation construction phase.
                            serde_json::from_slice(b"{}")
                                .map_err(crate::error::PutRestApiError::unhandled)?
                        } else {
                            serde_json::from_slice(response.body().as_ref())
                                .map_err(crate::error::PutRestApiError::unhandled)?
                        };

                        output = output.set_message(parsed_body.message);
                        output.build()
                    }),
                },
                _ => crate::error::PutRestApiError::generic(generic),
            });
        }
        Ok({
            #[allow(unused_mut)]
            let mut output = crate::output::put_rest_api_output::Builder::default();
            let _ = response;

            let body_slice = response.body().as_ref();

            let parsed_body: crate::serializer::PutRestApiOutputBody = if body_slice.is_empty() {
                // To enable JSON parsing to succeed, replace an empty body
                // with an empty JSON body. If a member was required, it will fail slightly later
                // during the operation construction phase.
                serde_json::from_slice(b"{}").map_err(crate::error::PutRestApiError::unhandled)?
            } else {
                serde_json::from_slice(response.body().as_ref())
                    .map_err(crate::error::PutRestApiError::unhandled)?
            };

            output = output.set_id(parsed_body.id);
            output = output.set_name(parsed_body.name);
            output = output.set_description(parsed_body.description);
            output = output.set_created_date(parsed_body.created_date);
            output = output.set_version(parsed_body.version);
            output = output.set_warnings(parsed_body.warnings);
            output = output.set_binary_media_types(parsed_body.binary_media_types);
            output = output.set_minimum_compression_size(parsed_body.minimum_compression_size);
            output = output.set_api_key_source(parsed_body.api_key_source);
            output = output.set_endpoint_configuration(parsed_body.endpoint_configuration);
            output = output.set_policy(parsed_body.policy);
            output = output.set_tags(parsed_body.tags);
            output =
                output.set_disable_execute_api_endpoint(parsed_body.disable_execute_api_endpoint);
            output.build()
        })
    }
    pub fn parse_response(
        &self,
        response: &http::response::Response<impl AsRef<[u8]>>,
    ) -> Result<crate::output::PutRestApiOutput, crate::error::PutRestApiError> {
        Self::from_response(&response)
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}

impl smithy_http::response::ParseStrictResponse for PutRestApi {
    type Output = Result<crate::output::PutRestApiOutput, crate::error::PutRestApiError>;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        self.parse_response(response)
    }
}

/// <p>Adds or updates a tag on a given resource.</p>
#[derive(std::clone::Clone)]
pub struct TagResource {
    _private: (),
}
impl TagResource {
    /// Creates a new builder-style object to manufacture [`TagResourceInput`](crate::input::TagResourceInput)
    pub fn builder() -> crate::input::tag_resource_input::Builder {
        crate::input::tag_resource_input::Builder::default()
    }
    #[allow(clippy::unnecessary_wraps)]
    fn from_response(
        response: &http::response::Response<impl AsRef<[u8]>>,
    ) -> Result<crate::output::TagResourceOutput, crate::error::TagResourceError> {
        if crate::aws_json_errors::is_error(&response) && response.status().as_u16() != 204 {
            let body = serde_json::from_slice(response.body().as_ref())
                .unwrap_or_else(|_| serde_json::json!({}));
            let generic = crate::aws_json_errors::parse_generic_error(&response, &body);

            let error_code = match generic.code() {
                Some(code) => code,
                None => return Err(crate::error::TagResourceError::unhandled(generic)),
            };
            return Err(match error_code {
                "BadRequestException" => crate::error::TagResourceError {
                    meta: generic,
                    kind: crate::error::TagResourceErrorKind::BadRequestError({
                        #[allow(unused_mut)]
                        let mut output = crate::error::bad_request_error::Builder::default();
                        let _ = response;

                        let body_slice = response.body().as_ref();

                        let parsed_body: crate::error::BadRequestError = if body_slice.is_empty() {
                            // To enable JSON parsing to succeed, replace an empty body
                            // with an empty JSON body. If a member was required, it will fail slightly later
                            // during the operation construction phase.
                            serde_json::from_slice(b"{}")
                                .map_err(crate::error::TagResourceError::unhandled)?
                        } else {
                            serde_json::from_slice(response.body().as_ref())
                                .map_err(crate::error::TagResourceError::unhandled)?
                        };

                        output = output.set_message(parsed_body.message);
                        output.build()
                    }),
                },
                "ConflictException" => crate::error::TagResourceError {
                    meta: generic,
                    kind: crate::error::TagResourceErrorKind::ConflictError({
                        #[allow(unused_mut)]
                        let mut output = crate::error::conflict_error::Builder::default();
                        let _ = response;

                        let body_slice = response.body().as_ref();

                        let parsed_body: crate::error::ConflictError = if body_slice.is_empty() {
                            // To enable JSON parsing to succeed, replace an empty body
                            // with an empty JSON body. If a member was required, it will fail slightly later
                            // during the operation construction phase.
                            serde_json::from_slice(b"{}")
                                .map_err(crate::error::TagResourceError::unhandled)?
                        } else {
                            serde_json::from_slice(response.body().as_ref())
                                .map_err(crate::error::TagResourceError::unhandled)?
                        };

                        output = output.set_message(parsed_body.message);
                        output.build()
                    }),
                },
                "LimitExceededException" => {
                    crate::error::TagResourceError {
                        meta: generic,
                        kind: crate::error::TagResourceErrorKind::LimitExceededError({
                            #[allow(unused_mut)]
                            let mut output = crate::error::limit_exceeded_error::Builder::default();
                            let _ = response;

                            let body_slice = response.body().as_ref();

                            let parsed_body: crate::error::LimitExceededError =
                                if body_slice.is_empty() {
                                    // To enable JSON parsing to succeed, replace an empty body
                                    // with an empty JSON body. If a member was required, it will fail slightly later
                                    // during the operation construction phase.
                                    serde_json::from_slice(b"{}")
                                        .map_err(crate::error::TagResourceError::unhandled)?
                                } else {
                                    serde_json::from_slice(response.body().as_ref())
                                        .map_err(crate::error::TagResourceError::unhandled)?
                                };

                            output = output.set_retry_after_seconds(
                        
                                                crate::http_serde::deser_header_tag_resource_retry_after_seconds(response.headers())
                                                    .map_err(|_|crate::error::TagResourceError::unhandled("Failed to parse retryAfterSeconds from header `Retry-After"))?
                                                
                    );
                            output = output.set_message(parsed_body.message);
                            output.build()
                        }),
                    }
                }
                "NotFoundException" => crate::error::TagResourceError {
                    meta: generic,
                    kind: crate::error::TagResourceErrorKind::NotFoundError({
                        #[allow(unused_mut)]
                        let mut output = crate::error::not_found_error::Builder::default();
                        let _ = response;

                        let body_slice = response.body().as_ref();

                        let parsed_body: crate::error::NotFoundError = if body_slice.is_empty() {
                            // To enable JSON parsing to succeed, replace an empty body
                            // with an empty JSON body. If a member was required, it will fail slightly later
                            // during the operation construction phase.
                            serde_json::from_slice(b"{}")
                                .map_err(crate::error::TagResourceError::unhandled)?
                        } else {
                            serde_json::from_slice(response.body().as_ref())
                                .map_err(crate::error::TagResourceError::unhandled)?
                        };

                        output = output.set_message(parsed_body.message);
                        output.build()
                    }),
                },
                "TooManyRequestsException" => {
                    crate::error::TagResourceError {
                        meta: generic,
                        kind: crate::error::TagResourceErrorKind::TooManyRequestsError({
                            #[allow(unused_mut)]
                            let mut output =
                                crate::error::too_many_requests_error::Builder::default();
                            let _ = response;

                            let body_slice = response.body().as_ref();

                            let parsed_body: crate::error::TooManyRequestsError =
                                if body_slice.is_empty() {
                                    // To enable JSON parsing to succeed, replace an empty body
                                    // with an empty JSON body. If a member was required, it will fail slightly later
                                    // during the operation construction phase.
                                    serde_json::from_slice(b"{}")
                                        .map_err(crate::error::TagResourceError::unhandled)?
                                } else {
                                    serde_json::from_slice(response.body().as_ref())
                                        .map_err(crate::error::TagResourceError::unhandled)?
                                };

                            output = output.set_retry_after_seconds(
                        
                                                crate::http_serde::deser_header_tag_resource_retry_after_seconds(response.headers())
                                                    .map_err(|_|crate::error::TagResourceError::unhandled("Failed to parse retryAfterSeconds from header `Retry-After"))?
                                                
                    );
                            output = output.set_message(parsed_body.message);
                            output.build()
                        }),
                    }
                }
                "UnauthorizedException" => crate::error::TagResourceError {
                    meta: generic,
                    kind: crate::error::TagResourceErrorKind::UnauthorizedError({
                        #[allow(unused_mut)]
                        let mut output = crate::error::unauthorized_error::Builder::default();
                        let _ = response;

                        let body_slice = response.body().as_ref();

                        let parsed_body: crate::error::UnauthorizedError = if body_slice.is_empty()
                        {
                            // To enable JSON parsing to succeed, replace an empty body
                            // with an empty JSON body. If a member was required, it will fail slightly later
                            // during the operation construction phase.
                            serde_json::from_slice(b"{}")
                                .map_err(crate::error::TagResourceError::unhandled)?
                        } else {
                            serde_json::from_slice(response.body().as_ref())
                                .map_err(crate::error::TagResourceError::unhandled)?
                        };

                        output = output.set_message(parsed_body.message);
                        output.build()
                    }),
                },
                _ => crate::error::TagResourceError::generic(generic),
            });
        }
        Ok({
            #[allow(unused_mut)]
            let mut output = crate::output::tag_resource_output::Builder::default();
            let _ = response;
            output.build()
        })
    }
    pub fn parse_response(
        &self,
        response: &http::response::Response<impl AsRef<[u8]>>,
    ) -> Result<crate::output::TagResourceOutput, crate::error::TagResourceError> {
        Self::from_response(&response)
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}

impl smithy_http::response::ParseStrictResponse for TagResource {
    type Output = Result<crate::output::TagResourceOutput, crate::error::TagResourceError>;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        self.parse_response(response)
    }
}

/// <p>Simulate the execution of an <a>Authorizer</a> in your <a>RestApi</a> with headers, parameters, and an incoming request body.</p>
/// <div class="seeAlso">
/// <a href="https://docs.aws.amazon.com/apigateway/latest/developerguide/apigateway-use-lambda-authorizer.html">Use Lambda Function as Authorizer</a>
/// <a href="https://docs.aws.amazon.com/apigateway/latest/developerguide/apigateway-integrate-with-cognito.html">Use Cognito User Pool as Authorizer</a>
/// </div>
#[derive(std::clone::Clone)]
pub struct TestInvokeAuthorizer {
    _private: (),
}
impl TestInvokeAuthorizer {
    /// Creates a new builder-style object to manufacture [`TestInvokeAuthorizerInput`](crate::input::TestInvokeAuthorizerInput)
    pub fn builder() -> crate::input::test_invoke_authorizer_input::Builder {
        crate::input::test_invoke_authorizer_input::Builder::default()
    }
    #[allow(clippy::unnecessary_wraps)]
    fn from_response(
        response: &http::response::Response<impl AsRef<[u8]>>,
    ) -> Result<crate::output::TestInvokeAuthorizerOutput, crate::error::TestInvokeAuthorizerError>
    {
        if crate::aws_json_errors::is_error(&response) && response.status().as_u16() != 200 {
            let body = serde_json::from_slice(response.body().as_ref())
                .unwrap_or_else(|_| serde_json::json!({}));
            let generic = crate::aws_json_errors::parse_generic_error(&response, &body);

            let error_code = match generic.code() {
                Some(code) => code,
                None => return Err(crate::error::TestInvokeAuthorizerError::unhandled(generic)),
            };
            return Err(match error_code {
                "BadRequestException" => crate::error::TestInvokeAuthorizerError {
                    meta: generic,
                    kind: crate::error::TestInvokeAuthorizerErrorKind::BadRequestError({
                        #[allow(unused_mut)]
                        let mut output = crate::error::bad_request_error::Builder::default();
                        let _ = response;

                        let body_slice = response.body().as_ref();

                        let parsed_body: crate::error::BadRequestError = if body_slice.is_empty() {
                            // To enable JSON parsing to succeed, replace an empty body
                            // with an empty JSON body. If a member was required, it will fail slightly later
                            // during the operation construction phase.
                            serde_json::from_slice(b"{}")
                                .map_err(crate::error::TestInvokeAuthorizerError::unhandled)?
                        } else {
                            serde_json::from_slice(response.body().as_ref())
                                .map_err(crate::error::TestInvokeAuthorizerError::unhandled)?
                        };

                        output = output.set_message(parsed_body.message);
                        output.build()
                    }),
                },
                "NotFoundException" => crate::error::TestInvokeAuthorizerError {
                    meta: generic,
                    kind: crate::error::TestInvokeAuthorizerErrorKind::NotFoundError({
                        #[allow(unused_mut)]
                        let mut output = crate::error::not_found_error::Builder::default();
                        let _ = response;

                        let body_slice = response.body().as_ref();

                        let parsed_body: crate::error::NotFoundError = if body_slice.is_empty() {
                            // To enable JSON parsing to succeed, replace an empty body
                            // with an empty JSON body. If a member was required, it will fail slightly later
                            // during the operation construction phase.
                            serde_json::from_slice(b"{}")
                                .map_err(crate::error::TestInvokeAuthorizerError::unhandled)?
                        } else {
                            serde_json::from_slice(response.body().as_ref())
                                .map_err(crate::error::TestInvokeAuthorizerError::unhandled)?
                        };

                        output = output.set_message(parsed_body.message);
                        output.build()
                    }),
                },
                "TooManyRequestsException" => crate::error::TestInvokeAuthorizerError {
                    meta: generic,
                    kind: crate::error::TestInvokeAuthorizerErrorKind::TooManyRequestsError({
                        #[allow(unused_mut)]
                        let mut output = crate::error::too_many_requests_error::Builder::default();
                        let _ = response;

                        let body_slice = response.body().as_ref();

                        let parsed_body: crate::error::TooManyRequestsError =
                            if body_slice.is_empty() {
                                // To enable JSON parsing to succeed, replace an empty body
                                // with an empty JSON body. If a member was required, it will fail slightly later
                                // during the operation construction phase.
                                serde_json::from_slice(b"{}")
                                    .map_err(crate::error::TestInvokeAuthorizerError::unhandled)?
                            } else {
                                serde_json::from_slice(response.body().as_ref())
                                    .map_err(crate::error::TestInvokeAuthorizerError::unhandled)?
                            };

                        output = output.set_retry_after_seconds(
                        
                                                crate::http_serde::deser_header_test_invoke_authorizer_retry_after_seconds(response.headers())
                                                    .map_err(|_|crate::error::TestInvokeAuthorizerError::unhandled("Failed to parse retryAfterSeconds from header `Retry-After"))?
                                                
                    );
                        output = output.set_message(parsed_body.message);
                        output.build()
                    }),
                },
                "UnauthorizedException" => crate::error::TestInvokeAuthorizerError {
                    meta: generic,
                    kind: crate::error::TestInvokeAuthorizerErrorKind::UnauthorizedError({
                        #[allow(unused_mut)]
                        let mut output = crate::error::unauthorized_error::Builder::default();
                        let _ = response;

                        let body_slice = response.body().as_ref();

                        let parsed_body: crate::error::UnauthorizedError = if body_slice.is_empty()
                        {
                            // To enable JSON parsing to succeed, replace an empty body
                            // with an empty JSON body. If a member was required, it will fail slightly later
                            // during the operation construction phase.
                            serde_json::from_slice(b"{}")
                                .map_err(crate::error::TestInvokeAuthorizerError::unhandled)?
                        } else {
                            serde_json::from_slice(response.body().as_ref())
                                .map_err(crate::error::TestInvokeAuthorizerError::unhandled)?
                        };

                        output = output.set_message(parsed_body.message);
                        output.build()
                    }),
                },
                _ => crate::error::TestInvokeAuthorizerError::generic(generic),
            });
        }
        Ok({
            #[allow(unused_mut)]
            let mut output = crate::output::test_invoke_authorizer_output::Builder::default();
            let _ = response;

            let body_slice = response.body().as_ref();

            let parsed_body: crate::serializer::TestInvokeAuthorizerOutputBody =
                if body_slice.is_empty() {
                    // To enable JSON parsing to succeed, replace an empty body
                    // with an empty JSON body. If a member was required, it will fail slightly later
                    // during the operation construction phase.
                    serde_json::from_slice(b"{}")
                        .map_err(crate::error::TestInvokeAuthorizerError::unhandled)?
                } else {
                    serde_json::from_slice(response.body().as_ref())
                        .map_err(crate::error::TestInvokeAuthorizerError::unhandled)?
                };

            output = output.set_client_status(parsed_body.client_status);
            output = output.set_log(parsed_body.log);
            output = output.set_latency(parsed_body.latency);
            output = output.set_principal_id(parsed_body.principal_id);
            output = output.set_policy(parsed_body.policy);
            output = output.set_authorization(parsed_body.authorization);
            output = output.set_claims(parsed_body.claims);
            output.build()
        })
    }
    pub fn parse_response(
        &self,
        response: &http::response::Response<impl AsRef<[u8]>>,
    ) -> Result<crate::output::TestInvokeAuthorizerOutput, crate::error::TestInvokeAuthorizerError>
    {
        Self::from_response(&response)
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}

impl smithy_http::response::ParseStrictResponse for TestInvokeAuthorizer {
    type Output =
        Result<crate::output::TestInvokeAuthorizerOutput, crate::error::TestInvokeAuthorizerError>;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        self.parse_response(response)
    }
}

/// <p>Simulate the execution of a <a>Method</a> in your <a>RestApi</a> with headers, parameters, and an incoming request body.</p>
#[derive(std::clone::Clone)]
pub struct TestInvokeMethod {
    _private: (),
}
impl TestInvokeMethod {
    /// Creates a new builder-style object to manufacture [`TestInvokeMethodInput`](crate::input::TestInvokeMethodInput)
    pub fn builder() -> crate::input::test_invoke_method_input::Builder {
        crate::input::test_invoke_method_input::Builder::default()
    }
    #[allow(clippy::unnecessary_wraps)]
    fn from_response(
        response: &http::response::Response<impl AsRef<[u8]>>,
    ) -> Result<crate::output::TestInvokeMethodOutput, crate::error::TestInvokeMethodError> {
        if crate::aws_json_errors::is_error(&response) && response.status().as_u16() != 200 {
            let body = serde_json::from_slice(response.body().as_ref())
                .unwrap_or_else(|_| serde_json::json!({}));
            let generic = crate::aws_json_errors::parse_generic_error(&response, &body);

            let error_code = match generic.code() {
                Some(code) => code,
                None => return Err(crate::error::TestInvokeMethodError::unhandled(generic)),
            };
            return Err(match error_code {
                "BadRequestException" => crate::error::TestInvokeMethodError {
                    meta: generic,
                    kind: crate::error::TestInvokeMethodErrorKind::BadRequestError({
                        #[allow(unused_mut)]
                        let mut output = crate::error::bad_request_error::Builder::default();
                        let _ = response;

                        let body_slice = response.body().as_ref();

                        let parsed_body: crate::error::BadRequestError = if body_slice.is_empty() {
                            // To enable JSON parsing to succeed, replace an empty body
                            // with an empty JSON body. If a member was required, it will fail slightly later
                            // during the operation construction phase.
                            serde_json::from_slice(b"{}")
                                .map_err(crate::error::TestInvokeMethodError::unhandled)?
                        } else {
                            serde_json::from_slice(response.body().as_ref())
                                .map_err(crate::error::TestInvokeMethodError::unhandled)?
                        };

                        output = output.set_message(parsed_body.message);
                        output.build()
                    }),
                },
                "NotFoundException" => crate::error::TestInvokeMethodError {
                    meta: generic,
                    kind: crate::error::TestInvokeMethodErrorKind::NotFoundError({
                        #[allow(unused_mut)]
                        let mut output = crate::error::not_found_error::Builder::default();
                        let _ = response;

                        let body_slice = response.body().as_ref();

                        let parsed_body: crate::error::NotFoundError = if body_slice.is_empty() {
                            // To enable JSON parsing to succeed, replace an empty body
                            // with an empty JSON body. If a member was required, it will fail slightly later
                            // during the operation construction phase.
                            serde_json::from_slice(b"{}")
                                .map_err(crate::error::TestInvokeMethodError::unhandled)?
                        } else {
                            serde_json::from_slice(response.body().as_ref())
                                .map_err(crate::error::TestInvokeMethodError::unhandled)?
                        };

                        output = output.set_message(parsed_body.message);
                        output.build()
                    }),
                },
                "TooManyRequestsException" => {
                    crate::error::TestInvokeMethodError {
                        meta: generic,
                        kind: crate::error::TestInvokeMethodErrorKind::TooManyRequestsError({
                            #[allow(unused_mut)]
                            let mut output =
                                crate::error::too_many_requests_error::Builder::default();
                            let _ = response;

                            let body_slice = response.body().as_ref();

                            let parsed_body: crate::error::TooManyRequestsError =
                                if body_slice.is_empty() {
                                    // To enable JSON parsing to succeed, replace an empty body
                                    // with an empty JSON body. If a member was required, it will fail slightly later
                                    // during the operation construction phase.
                                    serde_json::from_slice(b"{}")
                                        .map_err(crate::error::TestInvokeMethodError::unhandled)?
                                } else {
                                    serde_json::from_slice(response.body().as_ref())
                                        .map_err(crate::error::TestInvokeMethodError::unhandled)?
                                };

                            output = output.set_retry_after_seconds(
                        
                                                crate::http_serde::deser_header_test_invoke_method_retry_after_seconds(response.headers())
                                                    .map_err(|_|crate::error::TestInvokeMethodError::unhandled("Failed to parse retryAfterSeconds from header `Retry-After"))?
                                                
                    );
                            output = output.set_message(parsed_body.message);
                            output.build()
                        }),
                    }
                }
                "UnauthorizedException" => crate::error::TestInvokeMethodError {
                    meta: generic,
                    kind: crate::error::TestInvokeMethodErrorKind::UnauthorizedError({
                        #[allow(unused_mut)]
                        let mut output = crate::error::unauthorized_error::Builder::default();
                        let _ = response;

                        let body_slice = response.body().as_ref();

                        let parsed_body: crate::error::UnauthorizedError = if body_slice.is_empty()
                        {
                            // To enable JSON parsing to succeed, replace an empty body
                            // with an empty JSON body. If a member was required, it will fail slightly later
                            // during the operation construction phase.
                            serde_json::from_slice(b"{}")
                                .map_err(crate::error::TestInvokeMethodError::unhandled)?
                        } else {
                            serde_json::from_slice(response.body().as_ref())
                                .map_err(crate::error::TestInvokeMethodError::unhandled)?
                        };

                        output = output.set_message(parsed_body.message);
                        output.build()
                    }),
                },
                _ => crate::error::TestInvokeMethodError::generic(generic),
            });
        }
        Ok({
            #[allow(unused_mut)]
            let mut output = crate::output::test_invoke_method_output::Builder::default();
            let _ = response;

            let body_slice = response.body().as_ref();

            let parsed_body: crate::serializer::TestInvokeMethodOutputBody =
                if body_slice.is_empty() {
                    // To enable JSON parsing to succeed, replace an empty body
                    // with an empty JSON body. If a member was required, it will fail slightly later
                    // during the operation construction phase.
                    serde_json::from_slice(b"{}")
                        .map_err(crate::error::TestInvokeMethodError::unhandled)?
                } else {
                    serde_json::from_slice(response.body().as_ref())
                        .map_err(crate::error::TestInvokeMethodError::unhandled)?
                };

            output = output.set_status(parsed_body.status);
            output = output.set_body(parsed_body.body);
            output = output.set_headers(parsed_body.headers);
            output = output.set_multi_value_headers(parsed_body.multi_value_headers);
            output = output.set_log(parsed_body.log);
            output = output.set_latency(parsed_body.latency);
            output.build()
        })
    }
    pub fn parse_response(
        &self,
        response: &http::response::Response<impl AsRef<[u8]>>,
    ) -> Result<crate::output::TestInvokeMethodOutput, crate::error::TestInvokeMethodError> {
        Self::from_response(&response)
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}

impl smithy_http::response::ParseStrictResponse for TestInvokeMethod {
    type Output =
        Result<crate::output::TestInvokeMethodOutput, crate::error::TestInvokeMethodError>;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        self.parse_response(response)
    }
}

/// <p>Removes a tag from a given resource.</p>
#[derive(std::clone::Clone)]
pub struct UntagResource {
    _private: (),
}
impl UntagResource {
    /// Creates a new builder-style object to manufacture [`UntagResourceInput`](crate::input::UntagResourceInput)
    pub fn builder() -> crate::input::untag_resource_input::Builder {
        crate::input::untag_resource_input::Builder::default()
    }
    #[allow(clippy::unnecessary_wraps)]
    fn from_response(
        response: &http::response::Response<impl AsRef<[u8]>>,
    ) -> Result<crate::output::UntagResourceOutput, crate::error::UntagResourceError> {
        if crate::aws_json_errors::is_error(&response) && response.status().as_u16() != 204 {
            let body = serde_json::from_slice(response.body().as_ref())
                .unwrap_or_else(|_| serde_json::json!({}));
            let generic = crate::aws_json_errors::parse_generic_error(&response, &body);

            let error_code = match generic.code() {
                Some(code) => code,
                None => return Err(crate::error::UntagResourceError::unhandled(generic)),
            };
            return Err(match error_code {
                "BadRequestException" => crate::error::UntagResourceError {
                    meta: generic,
                    kind: crate::error::UntagResourceErrorKind::BadRequestError({
                        #[allow(unused_mut)]
                        let mut output = crate::error::bad_request_error::Builder::default();
                        let _ = response;

                        let body_slice = response.body().as_ref();

                        let parsed_body: crate::error::BadRequestError = if body_slice.is_empty() {
                            // To enable JSON parsing to succeed, replace an empty body
                            // with an empty JSON body. If a member was required, it will fail slightly later
                            // during the operation construction phase.
                            serde_json::from_slice(b"{}")
                                .map_err(crate::error::UntagResourceError::unhandled)?
                        } else {
                            serde_json::from_slice(response.body().as_ref())
                                .map_err(crate::error::UntagResourceError::unhandled)?
                        };

                        output = output.set_message(parsed_body.message);
                        output.build()
                    }),
                },
                "ConflictException" => crate::error::UntagResourceError {
                    meta: generic,
                    kind: crate::error::UntagResourceErrorKind::ConflictError({
                        #[allow(unused_mut)]
                        let mut output = crate::error::conflict_error::Builder::default();
                        let _ = response;

                        let body_slice = response.body().as_ref();

                        let parsed_body: crate::error::ConflictError = if body_slice.is_empty() {
                            // To enable JSON parsing to succeed, replace an empty body
                            // with an empty JSON body. If a member was required, it will fail slightly later
                            // during the operation construction phase.
                            serde_json::from_slice(b"{}")
                                .map_err(crate::error::UntagResourceError::unhandled)?
                        } else {
                            serde_json::from_slice(response.body().as_ref())
                                .map_err(crate::error::UntagResourceError::unhandled)?
                        };

                        output = output.set_message(parsed_body.message);
                        output.build()
                    }),
                },
                "NotFoundException" => crate::error::UntagResourceError {
                    meta: generic,
                    kind: crate::error::UntagResourceErrorKind::NotFoundError({
                        #[allow(unused_mut)]
                        let mut output = crate::error::not_found_error::Builder::default();
                        let _ = response;

                        let body_slice = response.body().as_ref();

                        let parsed_body: crate::error::NotFoundError = if body_slice.is_empty() {
                            // To enable JSON parsing to succeed, replace an empty body
                            // with an empty JSON body. If a member was required, it will fail slightly later
                            // during the operation construction phase.
                            serde_json::from_slice(b"{}")
                                .map_err(crate::error::UntagResourceError::unhandled)?
                        } else {
                            serde_json::from_slice(response.body().as_ref())
                                .map_err(crate::error::UntagResourceError::unhandled)?
                        };

                        output = output.set_message(parsed_body.message);
                        output.build()
                    }),
                },
                "TooManyRequestsException" => {
                    crate::error::UntagResourceError {
                        meta: generic,
                        kind: crate::error::UntagResourceErrorKind::TooManyRequestsError({
                            #[allow(unused_mut)]
                            let mut output =
                                crate::error::too_many_requests_error::Builder::default();
                            let _ = response;

                            let body_slice = response.body().as_ref();

                            let parsed_body: crate::error::TooManyRequestsError =
                                if body_slice.is_empty() {
                                    // To enable JSON parsing to succeed, replace an empty body
                                    // with an empty JSON body. If a member was required, it will fail slightly later
                                    // during the operation construction phase.
                                    serde_json::from_slice(b"{}")
                                        .map_err(crate::error::UntagResourceError::unhandled)?
                                } else {
                                    serde_json::from_slice(response.body().as_ref())
                                        .map_err(crate::error::UntagResourceError::unhandled)?
                                };

                            output = output.set_retry_after_seconds(
                        
                                                crate::http_serde::deser_header_untag_resource_retry_after_seconds(response.headers())
                                                    .map_err(|_|crate::error::UntagResourceError::unhandled("Failed to parse retryAfterSeconds from header `Retry-After"))?
                                                
                    );
                            output = output.set_message(parsed_body.message);
                            output.build()
                        }),
                    }
                }
                "UnauthorizedException" => crate::error::UntagResourceError {
                    meta: generic,
                    kind: crate::error::UntagResourceErrorKind::UnauthorizedError({
                        #[allow(unused_mut)]
                        let mut output = crate::error::unauthorized_error::Builder::default();
                        let _ = response;

                        let body_slice = response.body().as_ref();

                        let parsed_body: crate::error::UnauthorizedError = if body_slice.is_empty()
                        {
                            // To enable JSON parsing to succeed, replace an empty body
                            // with an empty JSON body. If a member was required, it will fail slightly later
                            // during the operation construction phase.
                            serde_json::from_slice(b"{}")
                                .map_err(crate::error::UntagResourceError::unhandled)?
                        } else {
                            serde_json::from_slice(response.body().as_ref())
                                .map_err(crate::error::UntagResourceError::unhandled)?
                        };

                        output = output.set_message(parsed_body.message);
                        output.build()
                    }),
                },
                _ => crate::error::UntagResourceError::generic(generic),
            });
        }
        Ok({
            #[allow(unused_mut)]
            let mut output = crate::output::untag_resource_output::Builder::default();
            let _ = response;
            output.build()
        })
    }
    pub fn parse_response(
        &self,
        response: &http::response::Response<impl AsRef<[u8]>>,
    ) -> Result<crate::output::UntagResourceOutput, crate::error::UntagResourceError> {
        Self::from_response(&response)
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}

impl smithy_http::response::ParseStrictResponse for UntagResource {
    type Output = Result<crate::output::UntagResourceOutput, crate::error::UntagResourceError>;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        self.parse_response(response)
    }
}

/// <p>Changes information about the current <a>Account</a> resource.</p>
#[derive(std::clone::Clone)]
pub struct UpdateAccount {
    _private: (),
}
impl UpdateAccount {
    /// Creates a new builder-style object to manufacture [`UpdateAccountInput`](crate::input::UpdateAccountInput)
    pub fn builder() -> crate::input::update_account_input::Builder {
        crate::input::update_account_input::Builder::default()
    }
    #[allow(clippy::unnecessary_wraps)]
    fn from_response(
        response: &http::response::Response<impl AsRef<[u8]>>,
    ) -> Result<crate::output::UpdateAccountOutput, crate::error::UpdateAccountError> {
        if crate::aws_json_errors::is_error(&response) && response.status().as_u16() != 200 {
            let body = serde_json::from_slice(response.body().as_ref())
                .unwrap_or_else(|_| serde_json::json!({}));
            let generic = crate::aws_json_errors::parse_generic_error(&response, &body);

            let error_code = match generic.code() {
                Some(code) => code,
                None => return Err(crate::error::UpdateAccountError::unhandled(generic)),
            };
            return Err(match error_code {
                "BadRequestException" => crate::error::UpdateAccountError {
                    meta: generic,
                    kind: crate::error::UpdateAccountErrorKind::BadRequestError({
                        #[allow(unused_mut)]
                        let mut output = crate::error::bad_request_error::Builder::default();
                        let _ = response;

                        let body_slice = response.body().as_ref();

                        let parsed_body: crate::error::BadRequestError = if body_slice.is_empty() {
                            // To enable JSON parsing to succeed, replace an empty body
                            // with an empty JSON body. If a member was required, it will fail slightly later
                            // during the operation construction phase.
                            serde_json::from_slice(b"{}")
                                .map_err(crate::error::UpdateAccountError::unhandled)?
                        } else {
                            serde_json::from_slice(response.body().as_ref())
                                .map_err(crate::error::UpdateAccountError::unhandled)?
                        };

                        output = output.set_message(parsed_body.message);
                        output.build()
                    }),
                },
                "NotFoundException" => crate::error::UpdateAccountError {
                    meta: generic,
                    kind: crate::error::UpdateAccountErrorKind::NotFoundError({
                        #[allow(unused_mut)]
                        let mut output = crate::error::not_found_error::Builder::default();
                        let _ = response;

                        let body_slice = response.body().as_ref();

                        let parsed_body: crate::error::NotFoundError = if body_slice.is_empty() {
                            // To enable JSON parsing to succeed, replace an empty body
                            // with an empty JSON body. If a member was required, it will fail slightly later
                            // during the operation construction phase.
                            serde_json::from_slice(b"{}")
                                .map_err(crate::error::UpdateAccountError::unhandled)?
                        } else {
                            serde_json::from_slice(response.body().as_ref())
                                .map_err(crate::error::UpdateAccountError::unhandled)?
                        };

                        output = output.set_message(parsed_body.message);
                        output.build()
                    }),
                },
                "TooManyRequestsException" => {
                    crate::error::UpdateAccountError {
                        meta: generic,
                        kind: crate::error::UpdateAccountErrorKind::TooManyRequestsError({
                            #[allow(unused_mut)]
                            let mut output =
                                crate::error::too_many_requests_error::Builder::default();
                            let _ = response;

                            let body_slice = response.body().as_ref();

                            let parsed_body: crate::error::TooManyRequestsError =
                                if body_slice.is_empty() {
                                    // To enable JSON parsing to succeed, replace an empty body
                                    // with an empty JSON body. If a member was required, it will fail slightly later
                                    // during the operation construction phase.
                                    serde_json::from_slice(b"{}")
                                        .map_err(crate::error::UpdateAccountError::unhandled)?
                                } else {
                                    serde_json::from_slice(response.body().as_ref())
                                        .map_err(crate::error::UpdateAccountError::unhandled)?
                                };

                            output = output.set_retry_after_seconds(
                        
                                                crate::http_serde::deser_header_update_account_retry_after_seconds(response.headers())
                                                    .map_err(|_|crate::error::UpdateAccountError::unhandled("Failed to parse retryAfterSeconds from header `Retry-After"))?
                                                
                    );
                            output = output.set_message(parsed_body.message);
                            output.build()
                        }),
                    }
                }
                "UnauthorizedException" => crate::error::UpdateAccountError {
                    meta: generic,
                    kind: crate::error::UpdateAccountErrorKind::UnauthorizedError({
                        #[allow(unused_mut)]
                        let mut output = crate::error::unauthorized_error::Builder::default();
                        let _ = response;

                        let body_slice = response.body().as_ref();

                        let parsed_body: crate::error::UnauthorizedError = if body_slice.is_empty()
                        {
                            // To enable JSON parsing to succeed, replace an empty body
                            // with an empty JSON body. If a member was required, it will fail slightly later
                            // during the operation construction phase.
                            serde_json::from_slice(b"{}")
                                .map_err(crate::error::UpdateAccountError::unhandled)?
                        } else {
                            serde_json::from_slice(response.body().as_ref())
                                .map_err(crate::error::UpdateAccountError::unhandled)?
                        };

                        output = output.set_message(parsed_body.message);
                        output.build()
                    }),
                },
                _ => crate::error::UpdateAccountError::generic(generic),
            });
        }
        Ok({
            #[allow(unused_mut)]
            let mut output = crate::output::update_account_output::Builder::default();
            let _ = response;

            let body_slice = response.body().as_ref();

            let parsed_body: crate::serializer::UpdateAccountOutputBody = if body_slice.is_empty() {
                // To enable JSON parsing to succeed, replace an empty body
                // with an empty JSON body. If a member was required, it will fail slightly later
                // during the operation construction phase.
                serde_json::from_slice(b"{}")
                    .map_err(crate::error::UpdateAccountError::unhandled)?
            } else {
                serde_json::from_slice(response.body().as_ref())
                    .map_err(crate::error::UpdateAccountError::unhandled)?
            };

            output = output.set_cloudwatch_role_arn(parsed_body.cloudwatch_role_arn);
            output = output.set_throttle_settings(parsed_body.throttle_settings);
            output = output.set_features(parsed_body.features);
            output = output.set_api_key_version(parsed_body.api_key_version);
            output.build()
        })
    }
    pub fn parse_response(
        &self,
        response: &http::response::Response<impl AsRef<[u8]>>,
    ) -> Result<crate::output::UpdateAccountOutput, crate::error::UpdateAccountError> {
        Self::from_response(&response)
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}

impl smithy_http::response::ParseStrictResponse for UpdateAccount {
    type Output = Result<crate::output::UpdateAccountOutput, crate::error::UpdateAccountError>;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        self.parse_response(response)
    }
}

/// <p>Changes information about an <a>ApiKey</a> resource.</p>
#[derive(std::clone::Clone)]
pub struct UpdateApiKey {
    _private: (),
}
impl UpdateApiKey {
    /// Creates a new builder-style object to manufacture [`UpdateApiKeyInput`](crate::input::UpdateApiKeyInput)
    pub fn builder() -> crate::input::update_api_key_input::Builder {
        crate::input::update_api_key_input::Builder::default()
    }
    #[allow(clippy::unnecessary_wraps)]
    fn from_response(
        response: &http::response::Response<impl AsRef<[u8]>>,
    ) -> Result<crate::output::UpdateApiKeyOutput, crate::error::UpdateApiKeyError> {
        if crate::aws_json_errors::is_error(&response) && response.status().as_u16() != 200 {
            let body = serde_json::from_slice(response.body().as_ref())
                .unwrap_or_else(|_| serde_json::json!({}));
            let generic = crate::aws_json_errors::parse_generic_error(&response, &body);

            let error_code = match generic.code() {
                Some(code) => code,
                None => return Err(crate::error::UpdateApiKeyError::unhandled(generic)),
            };
            return Err(match error_code {
                "BadRequestException" => crate::error::UpdateApiKeyError {
                    meta: generic,
                    kind: crate::error::UpdateApiKeyErrorKind::BadRequestError({
                        #[allow(unused_mut)]
                        let mut output = crate::error::bad_request_error::Builder::default();
                        let _ = response;

                        let body_slice = response.body().as_ref();

                        let parsed_body: crate::error::BadRequestError = if body_slice.is_empty() {
                            // To enable JSON parsing to succeed, replace an empty body
                            // with an empty JSON body. If a member was required, it will fail slightly later
                            // during the operation construction phase.
                            serde_json::from_slice(b"{}")
                                .map_err(crate::error::UpdateApiKeyError::unhandled)?
                        } else {
                            serde_json::from_slice(response.body().as_ref())
                                .map_err(crate::error::UpdateApiKeyError::unhandled)?
                        };

                        output = output.set_message(parsed_body.message);
                        output.build()
                    }),
                },
                "ConflictException" => crate::error::UpdateApiKeyError {
                    meta: generic,
                    kind: crate::error::UpdateApiKeyErrorKind::ConflictError({
                        #[allow(unused_mut)]
                        let mut output = crate::error::conflict_error::Builder::default();
                        let _ = response;

                        let body_slice = response.body().as_ref();

                        let parsed_body: crate::error::ConflictError = if body_slice.is_empty() {
                            // To enable JSON parsing to succeed, replace an empty body
                            // with an empty JSON body. If a member was required, it will fail slightly later
                            // during the operation construction phase.
                            serde_json::from_slice(b"{}")
                                .map_err(crate::error::UpdateApiKeyError::unhandled)?
                        } else {
                            serde_json::from_slice(response.body().as_ref())
                                .map_err(crate::error::UpdateApiKeyError::unhandled)?
                        };

                        output = output.set_message(parsed_body.message);
                        output.build()
                    }),
                },
                "NotFoundException" => crate::error::UpdateApiKeyError {
                    meta: generic,
                    kind: crate::error::UpdateApiKeyErrorKind::NotFoundError({
                        #[allow(unused_mut)]
                        let mut output = crate::error::not_found_error::Builder::default();
                        let _ = response;

                        let body_slice = response.body().as_ref();

                        let parsed_body: crate::error::NotFoundError = if body_slice.is_empty() {
                            // To enable JSON parsing to succeed, replace an empty body
                            // with an empty JSON body. If a member was required, it will fail slightly later
                            // during the operation construction phase.
                            serde_json::from_slice(b"{}")
                                .map_err(crate::error::UpdateApiKeyError::unhandled)?
                        } else {
                            serde_json::from_slice(response.body().as_ref())
                                .map_err(crate::error::UpdateApiKeyError::unhandled)?
                        };

                        output = output.set_message(parsed_body.message);
                        output.build()
                    }),
                },
                "TooManyRequestsException" => {
                    crate::error::UpdateApiKeyError {
                        meta: generic,
                        kind: crate::error::UpdateApiKeyErrorKind::TooManyRequestsError({
                            #[allow(unused_mut)]
                            let mut output =
                                crate::error::too_many_requests_error::Builder::default();
                            let _ = response;

                            let body_slice = response.body().as_ref();

                            let parsed_body: crate::error::TooManyRequestsError =
                                if body_slice.is_empty() {
                                    // To enable JSON parsing to succeed, replace an empty body
                                    // with an empty JSON body. If a member was required, it will fail slightly later
                                    // during the operation construction phase.
                                    serde_json::from_slice(b"{}")
                                        .map_err(crate::error::UpdateApiKeyError::unhandled)?
                                } else {
                                    serde_json::from_slice(response.body().as_ref())
                                        .map_err(crate::error::UpdateApiKeyError::unhandled)?
                                };

                            output = output.set_retry_after_seconds(
                        
                                                crate::http_serde::deser_header_update_api_key_retry_after_seconds(response.headers())
                                                    .map_err(|_|crate::error::UpdateApiKeyError::unhandled("Failed to parse retryAfterSeconds from header `Retry-After"))?
                                                
                    );
                            output = output.set_message(parsed_body.message);
                            output.build()
                        }),
                    }
                }
                "UnauthorizedException" => crate::error::UpdateApiKeyError {
                    meta: generic,
                    kind: crate::error::UpdateApiKeyErrorKind::UnauthorizedError({
                        #[allow(unused_mut)]
                        let mut output = crate::error::unauthorized_error::Builder::default();
                        let _ = response;

                        let body_slice = response.body().as_ref();

                        let parsed_body: crate::error::UnauthorizedError = if body_slice.is_empty()
                        {
                            // To enable JSON parsing to succeed, replace an empty body
                            // with an empty JSON body. If a member was required, it will fail slightly later
                            // during the operation construction phase.
                            serde_json::from_slice(b"{}")
                                .map_err(crate::error::UpdateApiKeyError::unhandled)?
                        } else {
                            serde_json::from_slice(response.body().as_ref())
                                .map_err(crate::error::UpdateApiKeyError::unhandled)?
                        };

                        output = output.set_message(parsed_body.message);
                        output.build()
                    }),
                },
                _ => crate::error::UpdateApiKeyError::generic(generic),
            });
        }
        Ok({
            #[allow(unused_mut)]
            let mut output = crate::output::update_api_key_output::Builder::default();
            let _ = response;

            let body_slice = response.body().as_ref();

            let parsed_body: crate::serializer::UpdateApiKeyOutputBody = if body_slice.is_empty() {
                // To enable JSON parsing to succeed, replace an empty body
                // with an empty JSON body. If a member was required, it will fail slightly later
                // during the operation construction phase.
                serde_json::from_slice(b"{}").map_err(crate::error::UpdateApiKeyError::unhandled)?
            } else {
                serde_json::from_slice(response.body().as_ref())
                    .map_err(crate::error::UpdateApiKeyError::unhandled)?
            };

            output = output.set_id(parsed_body.id);
            output = output.set_value(parsed_body.value);
            output = output.set_name(parsed_body.name);
            output = output.set_customer_id(parsed_body.customer_id);
            output = output.set_description(parsed_body.description);
            output = output.set_enabled(parsed_body.enabled);
            output = output.set_created_date(parsed_body.created_date);
            output = output.set_last_updated_date(parsed_body.last_updated_date);
            output = output.set_stage_keys(parsed_body.stage_keys);
            output = output.set_tags(parsed_body.tags);
            output.build()
        })
    }
    pub fn parse_response(
        &self,
        response: &http::response::Response<impl AsRef<[u8]>>,
    ) -> Result<crate::output::UpdateApiKeyOutput, crate::error::UpdateApiKeyError> {
        Self::from_response(&response)
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}

impl smithy_http::response::ParseStrictResponse for UpdateApiKey {
    type Output = Result<crate::output::UpdateApiKeyOutput, crate::error::UpdateApiKeyError>;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        self.parse_response(response)
    }
}

/// <p>Updates an existing <a>Authorizer</a> resource.</p>
/// <div class="seeAlso"><a href="https://docs.aws.amazon.com/cli/latest/reference/apigateway/update-authorizer.html">AWS CLI</a></div>
#[derive(std::clone::Clone)]
pub struct UpdateAuthorizer {
    _private: (),
}
impl UpdateAuthorizer {
    /// Creates a new builder-style object to manufacture [`UpdateAuthorizerInput`](crate::input::UpdateAuthorizerInput)
    pub fn builder() -> crate::input::update_authorizer_input::Builder {
        crate::input::update_authorizer_input::Builder::default()
    }
    #[allow(clippy::unnecessary_wraps)]
    fn from_response(
        response: &http::response::Response<impl AsRef<[u8]>>,
    ) -> Result<crate::output::UpdateAuthorizerOutput, crate::error::UpdateAuthorizerError> {
        if crate::aws_json_errors::is_error(&response) && response.status().as_u16() != 200 {
            let body = serde_json::from_slice(response.body().as_ref())
                .unwrap_or_else(|_| serde_json::json!({}));
            let generic = crate::aws_json_errors::parse_generic_error(&response, &body);

            let error_code = match generic.code() {
                Some(code) => code,
                None => return Err(crate::error::UpdateAuthorizerError::unhandled(generic)),
            };
            return Err(match error_code {
                "BadRequestException" => crate::error::UpdateAuthorizerError {
                    meta: generic,
                    kind: crate::error::UpdateAuthorizerErrorKind::BadRequestError({
                        #[allow(unused_mut)]
                        let mut output = crate::error::bad_request_error::Builder::default();
                        let _ = response;

                        let body_slice = response.body().as_ref();

                        let parsed_body: crate::error::BadRequestError = if body_slice.is_empty() {
                            // To enable JSON parsing to succeed, replace an empty body
                            // with an empty JSON body. If a member was required, it will fail slightly later
                            // during the operation construction phase.
                            serde_json::from_slice(b"{}")
                                .map_err(crate::error::UpdateAuthorizerError::unhandled)?
                        } else {
                            serde_json::from_slice(response.body().as_ref())
                                .map_err(crate::error::UpdateAuthorizerError::unhandled)?
                        };

                        output = output.set_message(parsed_body.message);
                        output.build()
                    }),
                },
                "NotFoundException" => crate::error::UpdateAuthorizerError {
                    meta: generic,
                    kind: crate::error::UpdateAuthorizerErrorKind::NotFoundError({
                        #[allow(unused_mut)]
                        let mut output = crate::error::not_found_error::Builder::default();
                        let _ = response;

                        let body_slice = response.body().as_ref();

                        let parsed_body: crate::error::NotFoundError = if body_slice.is_empty() {
                            // To enable JSON parsing to succeed, replace an empty body
                            // with an empty JSON body. If a member was required, it will fail slightly later
                            // during the operation construction phase.
                            serde_json::from_slice(b"{}")
                                .map_err(crate::error::UpdateAuthorizerError::unhandled)?
                        } else {
                            serde_json::from_slice(response.body().as_ref())
                                .map_err(crate::error::UpdateAuthorizerError::unhandled)?
                        };

                        output = output.set_message(parsed_body.message);
                        output.build()
                    }),
                },
                "TooManyRequestsException" => {
                    crate::error::UpdateAuthorizerError {
                        meta: generic,
                        kind: crate::error::UpdateAuthorizerErrorKind::TooManyRequestsError({
                            #[allow(unused_mut)]
                            let mut output =
                                crate::error::too_many_requests_error::Builder::default();
                            let _ = response;

                            let body_slice = response.body().as_ref();

                            let parsed_body: crate::error::TooManyRequestsError =
                                if body_slice.is_empty() {
                                    // To enable JSON parsing to succeed, replace an empty body
                                    // with an empty JSON body. If a member was required, it will fail slightly later
                                    // during the operation construction phase.
                                    serde_json::from_slice(b"{}")
                                        .map_err(crate::error::UpdateAuthorizerError::unhandled)?
                                } else {
                                    serde_json::from_slice(response.body().as_ref())
                                        .map_err(crate::error::UpdateAuthorizerError::unhandled)?
                                };

                            output = output.set_retry_after_seconds(
                        
                                                crate::http_serde::deser_header_update_authorizer_retry_after_seconds(response.headers())
                                                    .map_err(|_|crate::error::UpdateAuthorizerError::unhandled("Failed to parse retryAfterSeconds from header `Retry-After"))?
                                                
                    );
                            output = output.set_message(parsed_body.message);
                            output.build()
                        }),
                    }
                }
                "UnauthorizedException" => crate::error::UpdateAuthorizerError {
                    meta: generic,
                    kind: crate::error::UpdateAuthorizerErrorKind::UnauthorizedError({
                        #[allow(unused_mut)]
                        let mut output = crate::error::unauthorized_error::Builder::default();
                        let _ = response;

                        let body_slice = response.body().as_ref();

                        let parsed_body: crate::error::UnauthorizedError = if body_slice.is_empty()
                        {
                            // To enable JSON parsing to succeed, replace an empty body
                            // with an empty JSON body. If a member was required, it will fail slightly later
                            // during the operation construction phase.
                            serde_json::from_slice(b"{}")
                                .map_err(crate::error::UpdateAuthorizerError::unhandled)?
                        } else {
                            serde_json::from_slice(response.body().as_ref())
                                .map_err(crate::error::UpdateAuthorizerError::unhandled)?
                        };

                        output = output.set_message(parsed_body.message);
                        output.build()
                    }),
                },
                _ => crate::error::UpdateAuthorizerError::generic(generic),
            });
        }
        Ok({
            #[allow(unused_mut)]
            let mut output = crate::output::update_authorizer_output::Builder::default();
            let _ = response;

            let body_slice = response.body().as_ref();

            let parsed_body: crate::serializer::UpdateAuthorizerOutputBody =
                if body_slice.is_empty() {
                    // To enable JSON parsing to succeed, replace an empty body
                    // with an empty JSON body. If a member was required, it will fail slightly later
                    // during the operation construction phase.
                    serde_json::from_slice(b"{}")
                        .map_err(crate::error::UpdateAuthorizerError::unhandled)?
                } else {
                    serde_json::from_slice(response.body().as_ref())
                        .map_err(crate::error::UpdateAuthorizerError::unhandled)?
                };

            output = output.set_id(parsed_body.id);
            output = output.set_name(parsed_body.name);
            output = output.set_type(parsed_body.r#type);
            output = output.set_provider_ar_ns(parsed_body.provider_ar_ns);
            output = output.set_auth_type(parsed_body.auth_type);
            output = output.set_authorizer_uri(parsed_body.authorizer_uri);
            output = output.set_authorizer_credentials(parsed_body.authorizer_credentials);
            output = output.set_identity_source(parsed_body.identity_source);
            output = output
                .set_identity_validation_expression(parsed_body.identity_validation_expression);
            output = output
                .set_authorizer_result_ttl_in_seconds(parsed_body.authorizer_result_ttl_in_seconds);
            output.build()
        })
    }
    pub fn parse_response(
        &self,
        response: &http::response::Response<impl AsRef<[u8]>>,
    ) -> Result<crate::output::UpdateAuthorizerOutput, crate::error::UpdateAuthorizerError> {
        Self::from_response(&response)
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}

impl smithy_http::response::ParseStrictResponse for UpdateAuthorizer {
    type Output =
        Result<crate::output::UpdateAuthorizerOutput, crate::error::UpdateAuthorizerError>;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        self.parse_response(response)
    }
}

/// <p>Changes information about the <a>BasePathMapping</a> resource.</p>
#[derive(std::clone::Clone)]
pub struct UpdateBasePathMapping {
    _private: (),
}
impl UpdateBasePathMapping {
    /// Creates a new builder-style object to manufacture [`UpdateBasePathMappingInput`](crate::input::UpdateBasePathMappingInput)
    pub fn builder() -> crate::input::update_base_path_mapping_input::Builder {
        crate::input::update_base_path_mapping_input::Builder::default()
    }
    #[allow(clippy::unnecessary_wraps)]
    fn from_response(
        response: &http::response::Response<impl AsRef<[u8]>>,
    ) -> Result<crate::output::UpdateBasePathMappingOutput, crate::error::UpdateBasePathMappingError>
    {
        if crate::aws_json_errors::is_error(&response) && response.status().as_u16() != 200 {
            let body = serde_json::from_slice(response.body().as_ref())
                .unwrap_or_else(|_| serde_json::json!({}));
            let generic = crate::aws_json_errors::parse_generic_error(&response, &body);

            let error_code = match generic.code() {
                Some(code) => code,
                None => return Err(crate::error::UpdateBasePathMappingError::unhandled(generic)),
            };
            return Err(match error_code {
                "BadRequestException" => crate::error::UpdateBasePathMappingError {
                    meta: generic,
                    kind: crate::error::UpdateBasePathMappingErrorKind::BadRequestError({
                        #[allow(unused_mut)]
                        let mut output = crate::error::bad_request_error::Builder::default();
                        let _ = response;

                        let body_slice = response.body().as_ref();

                        let parsed_body: crate::error::BadRequestError = if body_slice.is_empty() {
                            // To enable JSON parsing to succeed, replace an empty body
                            // with an empty JSON body. If a member was required, it will fail slightly later
                            // during the operation construction phase.
                            serde_json::from_slice(b"{}")
                                .map_err(crate::error::UpdateBasePathMappingError::unhandled)?
                        } else {
                            serde_json::from_slice(response.body().as_ref())
                                .map_err(crate::error::UpdateBasePathMappingError::unhandled)?
                        };

                        output = output.set_message(parsed_body.message);
                        output.build()
                    }),
                },
                "ConflictException" => crate::error::UpdateBasePathMappingError {
                    meta: generic,
                    kind: crate::error::UpdateBasePathMappingErrorKind::ConflictError({
                        #[allow(unused_mut)]
                        let mut output = crate::error::conflict_error::Builder::default();
                        let _ = response;

                        let body_slice = response.body().as_ref();

                        let parsed_body: crate::error::ConflictError = if body_slice.is_empty() {
                            // To enable JSON parsing to succeed, replace an empty body
                            // with an empty JSON body. If a member was required, it will fail slightly later
                            // during the operation construction phase.
                            serde_json::from_slice(b"{}")
                                .map_err(crate::error::UpdateBasePathMappingError::unhandled)?
                        } else {
                            serde_json::from_slice(response.body().as_ref())
                                .map_err(crate::error::UpdateBasePathMappingError::unhandled)?
                        };

                        output = output.set_message(parsed_body.message);
                        output.build()
                    }),
                },
                "NotFoundException" => crate::error::UpdateBasePathMappingError {
                    meta: generic,
                    kind: crate::error::UpdateBasePathMappingErrorKind::NotFoundError({
                        #[allow(unused_mut)]
                        let mut output = crate::error::not_found_error::Builder::default();
                        let _ = response;

                        let body_slice = response.body().as_ref();

                        let parsed_body: crate::error::NotFoundError = if body_slice.is_empty() {
                            // To enable JSON parsing to succeed, replace an empty body
                            // with an empty JSON body. If a member was required, it will fail slightly later
                            // during the operation construction phase.
                            serde_json::from_slice(b"{}")
                                .map_err(crate::error::UpdateBasePathMappingError::unhandled)?
                        } else {
                            serde_json::from_slice(response.body().as_ref())
                                .map_err(crate::error::UpdateBasePathMappingError::unhandled)?
                        };

                        output = output.set_message(parsed_body.message);
                        output.build()
                    }),
                },
                "TooManyRequestsException" => crate::error::UpdateBasePathMappingError {
                    meta: generic,
                    kind: crate::error::UpdateBasePathMappingErrorKind::TooManyRequestsError({
                        #[allow(unused_mut)]
                        let mut output = crate::error::too_many_requests_error::Builder::default();
                        let _ = response;

                        let body_slice = response.body().as_ref();

                        let parsed_body: crate::error::TooManyRequestsError =
                            if body_slice.is_empty() {
                                // To enable JSON parsing to succeed, replace an empty body
                                // with an empty JSON body. If a member was required, it will fail slightly later
                                // during the operation construction phase.
                                serde_json::from_slice(b"{}")
                                    .map_err(crate::error::UpdateBasePathMappingError::unhandled)?
                            } else {
                                serde_json::from_slice(response.body().as_ref())
                                    .map_err(crate::error::UpdateBasePathMappingError::unhandled)?
                            };

                        output = output.set_retry_after_seconds(
                        
                                                crate::http_serde::deser_header_update_base_path_mapping_retry_after_seconds(response.headers())
                                                    .map_err(|_|crate::error::UpdateBasePathMappingError::unhandled("Failed to parse retryAfterSeconds from header `Retry-After"))?
                                                
                    );
                        output = output.set_message(parsed_body.message);
                        output.build()
                    }),
                },
                "UnauthorizedException" => crate::error::UpdateBasePathMappingError {
                    meta: generic,
                    kind: crate::error::UpdateBasePathMappingErrorKind::UnauthorizedError({
                        #[allow(unused_mut)]
                        let mut output = crate::error::unauthorized_error::Builder::default();
                        let _ = response;

                        let body_slice = response.body().as_ref();

                        let parsed_body: crate::error::UnauthorizedError = if body_slice.is_empty()
                        {
                            // To enable JSON parsing to succeed, replace an empty body
                            // with an empty JSON body. If a member was required, it will fail slightly later
                            // during the operation construction phase.
                            serde_json::from_slice(b"{}")
                                .map_err(crate::error::UpdateBasePathMappingError::unhandled)?
                        } else {
                            serde_json::from_slice(response.body().as_ref())
                                .map_err(crate::error::UpdateBasePathMappingError::unhandled)?
                        };

                        output = output.set_message(parsed_body.message);
                        output.build()
                    }),
                },
                _ => crate::error::UpdateBasePathMappingError::generic(generic),
            });
        }
        Ok({
            #[allow(unused_mut)]
            let mut output = crate::output::update_base_path_mapping_output::Builder::default();
            let _ = response;

            let body_slice = response.body().as_ref();

            let parsed_body: crate::serializer::UpdateBasePathMappingOutputBody =
                if body_slice.is_empty() {
                    // To enable JSON parsing to succeed, replace an empty body
                    // with an empty JSON body. If a member was required, it will fail slightly later
                    // during the operation construction phase.
                    serde_json::from_slice(b"{}")
                        .map_err(crate::error::UpdateBasePathMappingError::unhandled)?
                } else {
                    serde_json::from_slice(response.body().as_ref())
                        .map_err(crate::error::UpdateBasePathMappingError::unhandled)?
                };

            output = output.set_base_path(parsed_body.base_path);
            output = output.set_rest_api_id(parsed_body.rest_api_id);
            output = output.set_stage(parsed_body.stage);
            output.build()
        })
    }
    pub fn parse_response(
        &self,
        response: &http::response::Response<impl AsRef<[u8]>>,
    ) -> Result<crate::output::UpdateBasePathMappingOutput, crate::error::UpdateBasePathMappingError>
    {
        Self::from_response(&response)
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}

impl smithy_http::response::ParseStrictResponse for UpdateBasePathMapping {
    type Output = Result<
        crate::output::UpdateBasePathMappingOutput,
        crate::error::UpdateBasePathMappingError,
    >;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        self.parse_response(response)
    }
}

/// <p>Changes information about an <a>ClientCertificate</a> resource.</p>
#[derive(std::clone::Clone)]
pub struct UpdateClientCertificate {
    _private: (),
}
impl UpdateClientCertificate {
    /// Creates a new builder-style object to manufacture [`UpdateClientCertificateInput`](crate::input::UpdateClientCertificateInput)
    pub fn builder() -> crate::input::update_client_certificate_input::Builder {
        crate::input::update_client_certificate_input::Builder::default()
    }
    #[allow(clippy::unnecessary_wraps)]
    fn from_response(
        response: &http::response::Response<impl AsRef<[u8]>>,
    ) -> Result<
        crate::output::UpdateClientCertificateOutput,
        crate::error::UpdateClientCertificateError,
    > {
        if crate::aws_json_errors::is_error(&response) && response.status().as_u16() != 200 {
            let body = serde_json::from_slice(response.body().as_ref())
                .unwrap_or_else(|_| serde_json::json!({}));
            let generic = crate::aws_json_errors::parse_generic_error(&response, &body);

            let error_code = match generic.code() {
                Some(code) => code,
                None => {
                    return Err(crate::error::UpdateClientCertificateError::unhandled(
                        generic,
                    ))
                }
            };
            return Err(match error_code {
                "BadRequestException" => crate::error::UpdateClientCertificateError {
                    meta: generic,
                    kind: crate::error::UpdateClientCertificateErrorKind::BadRequestError({
                        #[allow(unused_mut)]
                        let mut output = crate::error::bad_request_error::Builder::default();
                        let _ = response;

                        let body_slice = response.body().as_ref();

                        let parsed_body: crate::error::BadRequestError = if body_slice.is_empty() {
                            // To enable JSON parsing to succeed, replace an empty body
                            // with an empty JSON body. If a member was required, it will fail slightly later
                            // during the operation construction phase.
                            serde_json::from_slice(b"{}")
                                .map_err(crate::error::UpdateClientCertificateError::unhandled)?
                        } else {
                            serde_json::from_slice(response.body().as_ref())
                                .map_err(crate::error::UpdateClientCertificateError::unhandled)?
                        };

                        output = output.set_message(parsed_body.message);
                        output.build()
                    }),
                },
                "NotFoundException" => crate::error::UpdateClientCertificateError {
                    meta: generic,
                    kind: crate::error::UpdateClientCertificateErrorKind::NotFoundError({
                        #[allow(unused_mut)]
                        let mut output = crate::error::not_found_error::Builder::default();
                        let _ = response;

                        let body_slice = response.body().as_ref();

                        let parsed_body: crate::error::NotFoundError = if body_slice.is_empty() {
                            // To enable JSON parsing to succeed, replace an empty body
                            // with an empty JSON body. If a member was required, it will fail slightly later
                            // during the operation construction phase.
                            serde_json::from_slice(b"{}")
                                .map_err(crate::error::UpdateClientCertificateError::unhandled)?
                        } else {
                            serde_json::from_slice(response.body().as_ref())
                                .map_err(crate::error::UpdateClientCertificateError::unhandled)?
                        };

                        output = output.set_message(parsed_body.message);
                        output.build()
                    }),
                },
                "TooManyRequestsException" => crate::error::UpdateClientCertificateError {
                    meta: generic,
                    kind: crate::error::UpdateClientCertificateErrorKind::TooManyRequestsError({
                        #[allow(unused_mut)]
                        let mut output = crate::error::too_many_requests_error::Builder::default();
                        let _ = response;

                        let body_slice = response.body().as_ref();

                        let parsed_body: crate::error::TooManyRequestsError = if body_slice
                            .is_empty()
                        {
                            // To enable JSON parsing to succeed, replace an empty body
                            // with an empty JSON body. If a member was required, it will fail slightly later
                            // during the operation construction phase.
                            serde_json::from_slice(b"{}")
                                .map_err(crate::error::UpdateClientCertificateError::unhandled)?
                        } else {
                            serde_json::from_slice(response.body().as_ref())
                                .map_err(crate::error::UpdateClientCertificateError::unhandled)?
                        };

                        output = output.set_retry_after_seconds(
                        
                                                crate::http_serde::deser_header_update_client_certificate_retry_after_seconds(response.headers())
                                                    .map_err(|_|crate::error::UpdateClientCertificateError::unhandled("Failed to parse retryAfterSeconds from header `Retry-After"))?
                                                
                    );
                        output = output.set_message(parsed_body.message);
                        output.build()
                    }),
                },
                "UnauthorizedException" => crate::error::UpdateClientCertificateError {
                    meta: generic,
                    kind: crate::error::UpdateClientCertificateErrorKind::UnauthorizedError({
                        #[allow(unused_mut)]
                        let mut output = crate::error::unauthorized_error::Builder::default();
                        let _ = response;

                        let body_slice = response.body().as_ref();

                        let parsed_body: crate::error::UnauthorizedError = if body_slice.is_empty()
                        {
                            // To enable JSON parsing to succeed, replace an empty body
                            // with an empty JSON body. If a member was required, it will fail slightly later
                            // during the operation construction phase.
                            serde_json::from_slice(b"{}")
                                .map_err(crate::error::UpdateClientCertificateError::unhandled)?
                        } else {
                            serde_json::from_slice(response.body().as_ref())
                                .map_err(crate::error::UpdateClientCertificateError::unhandled)?
                        };

                        output = output.set_message(parsed_body.message);
                        output.build()
                    }),
                },
                _ => crate::error::UpdateClientCertificateError::generic(generic),
            });
        }
        Ok({
            #[allow(unused_mut)]
            let mut output = crate::output::update_client_certificate_output::Builder::default();
            let _ = response;

            let body_slice = response.body().as_ref();

            let parsed_body: crate::serializer::UpdateClientCertificateOutputBody =
                if body_slice.is_empty() {
                    // To enable JSON parsing to succeed, replace an empty body
                    // with an empty JSON body. If a member was required, it will fail slightly later
                    // during the operation construction phase.
                    serde_json::from_slice(b"{}")
                        .map_err(crate::error::UpdateClientCertificateError::unhandled)?
                } else {
                    serde_json::from_slice(response.body().as_ref())
                        .map_err(crate::error::UpdateClientCertificateError::unhandled)?
                };

            output = output.set_client_certificate_id(parsed_body.client_certificate_id);
            output = output.set_description(parsed_body.description);
            output = output.set_pem_encoded_certificate(parsed_body.pem_encoded_certificate);
            output = output.set_created_date(parsed_body.created_date);
            output = output.set_expiration_date(parsed_body.expiration_date);
            output = output.set_tags(parsed_body.tags);
            output.build()
        })
    }
    pub fn parse_response(
        &self,
        response: &http::response::Response<impl AsRef<[u8]>>,
    ) -> Result<
        crate::output::UpdateClientCertificateOutput,
        crate::error::UpdateClientCertificateError,
    > {
        Self::from_response(&response)
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}

impl smithy_http::response::ParseStrictResponse for UpdateClientCertificate {
    type Output = Result<
        crate::output::UpdateClientCertificateOutput,
        crate::error::UpdateClientCertificateError,
    >;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        self.parse_response(response)
    }
}

/// <p>Changes information about a <a>Deployment</a> resource.</p>
#[derive(std::clone::Clone)]
pub struct UpdateDeployment {
    _private: (),
}
impl UpdateDeployment {
    /// Creates a new builder-style object to manufacture [`UpdateDeploymentInput`](crate::input::UpdateDeploymentInput)
    pub fn builder() -> crate::input::update_deployment_input::Builder {
        crate::input::update_deployment_input::Builder::default()
    }
    #[allow(clippy::unnecessary_wraps)]
    fn from_response(
        response: &http::response::Response<impl AsRef<[u8]>>,
    ) -> Result<crate::output::UpdateDeploymentOutput, crate::error::UpdateDeploymentError> {
        if crate::aws_json_errors::is_error(&response) && response.status().as_u16() != 200 {
            let body = serde_json::from_slice(response.body().as_ref())
                .unwrap_or_else(|_| serde_json::json!({}));
            let generic = crate::aws_json_errors::parse_generic_error(&response, &body);

            let error_code = match generic.code() {
                Some(code) => code,
                None => return Err(crate::error::UpdateDeploymentError::unhandled(generic)),
            };
            return Err(match error_code {
                "BadRequestException" => crate::error::UpdateDeploymentError {
                    meta: generic,
                    kind: crate::error::UpdateDeploymentErrorKind::BadRequestError({
                        #[allow(unused_mut)]
                        let mut output = crate::error::bad_request_error::Builder::default();
                        let _ = response;

                        let body_slice = response.body().as_ref();

                        let parsed_body: crate::error::BadRequestError = if body_slice.is_empty() {
                            // To enable JSON parsing to succeed, replace an empty body
                            // with an empty JSON body. If a member was required, it will fail slightly later
                            // during the operation construction phase.
                            serde_json::from_slice(b"{}")
                                .map_err(crate::error::UpdateDeploymentError::unhandled)?
                        } else {
                            serde_json::from_slice(response.body().as_ref())
                                .map_err(crate::error::UpdateDeploymentError::unhandled)?
                        };

                        output = output.set_message(parsed_body.message);
                        output.build()
                    }),
                },
                "NotFoundException" => crate::error::UpdateDeploymentError {
                    meta: generic,
                    kind: crate::error::UpdateDeploymentErrorKind::NotFoundError({
                        #[allow(unused_mut)]
                        let mut output = crate::error::not_found_error::Builder::default();
                        let _ = response;

                        let body_slice = response.body().as_ref();

                        let parsed_body: crate::error::NotFoundError = if body_slice.is_empty() {
                            // To enable JSON parsing to succeed, replace an empty body
                            // with an empty JSON body. If a member was required, it will fail slightly later
                            // during the operation construction phase.
                            serde_json::from_slice(b"{}")
                                .map_err(crate::error::UpdateDeploymentError::unhandled)?
                        } else {
                            serde_json::from_slice(response.body().as_ref())
                                .map_err(crate::error::UpdateDeploymentError::unhandled)?
                        };

                        output = output.set_message(parsed_body.message);
                        output.build()
                    }),
                },
                "ServiceUnavailableException" => {
                    crate::error::UpdateDeploymentError {
                        meta: generic,
                        kind: crate::error::UpdateDeploymentErrorKind::ServiceUnavailableError({
                            #[allow(unused_mut)]
                            let mut output =
                                crate::error::service_unavailable_error::Builder::default();
                            let _ = response;

                            let body_slice = response.body().as_ref();

                            let parsed_body: crate::error::ServiceUnavailableError =
                                if body_slice.is_empty() {
                                    // To enable JSON parsing to succeed, replace an empty body
                                    // with an empty JSON body. If a member was required, it will fail slightly later
                                    // during the operation construction phase.
                                    serde_json::from_slice(b"{}")
                                        .map_err(crate::error::UpdateDeploymentError::unhandled)?
                                } else {
                                    serde_json::from_slice(response.body().as_ref())
                                        .map_err(crate::error::UpdateDeploymentError::unhandled)?
                                };

                            output = output.set_retry_after_seconds(
                        
                                                crate::http_serde::deser_header_update_deployment_retry_after_seconds(response.headers())
                                                    .map_err(|_|crate::error::UpdateDeploymentError::unhandled("Failed to parse retryAfterSeconds from header `Retry-After"))?
                                                
                    );
                            output = output.set_message(parsed_body.message);
                            output.build()
                        }),
                    }
                }
                "TooManyRequestsException" => {
                    crate::error::UpdateDeploymentError {
                        meta: generic,
                        kind: crate::error::UpdateDeploymentErrorKind::TooManyRequestsError({
                            #[allow(unused_mut)]
                            let mut output =
                                crate::error::too_many_requests_error::Builder::default();
                            let _ = response;

                            let body_slice = response.body().as_ref();

                            let parsed_body: crate::error::TooManyRequestsError =
                                if body_slice.is_empty() {
                                    // To enable JSON parsing to succeed, replace an empty body
                                    // with an empty JSON body. If a member was required, it will fail slightly later
                                    // during the operation construction phase.
                                    serde_json::from_slice(b"{}")
                                        .map_err(crate::error::UpdateDeploymentError::unhandled)?
                                } else {
                                    serde_json::from_slice(response.body().as_ref())
                                        .map_err(crate::error::UpdateDeploymentError::unhandled)?
                                };

                            output = output.set_retry_after_seconds(
                        
                                                crate::http_serde::deser_header_update_deployment_retry_after_seconds(response.headers())
                                                    .map_err(|_|crate::error::UpdateDeploymentError::unhandled("Failed to parse retryAfterSeconds from header `Retry-After"))?
                                                
                    );
                            output = output.set_message(parsed_body.message);
                            output.build()
                        }),
                    }
                }
                "UnauthorizedException" => crate::error::UpdateDeploymentError {
                    meta: generic,
                    kind: crate::error::UpdateDeploymentErrorKind::UnauthorizedError({
                        #[allow(unused_mut)]
                        let mut output = crate::error::unauthorized_error::Builder::default();
                        let _ = response;

                        let body_slice = response.body().as_ref();

                        let parsed_body: crate::error::UnauthorizedError = if body_slice.is_empty()
                        {
                            // To enable JSON parsing to succeed, replace an empty body
                            // with an empty JSON body. If a member was required, it will fail slightly later
                            // during the operation construction phase.
                            serde_json::from_slice(b"{}")
                                .map_err(crate::error::UpdateDeploymentError::unhandled)?
                        } else {
                            serde_json::from_slice(response.body().as_ref())
                                .map_err(crate::error::UpdateDeploymentError::unhandled)?
                        };

                        output = output.set_message(parsed_body.message);
                        output.build()
                    }),
                },
                _ => crate::error::UpdateDeploymentError::generic(generic),
            });
        }
        Ok({
            #[allow(unused_mut)]
            let mut output = crate::output::update_deployment_output::Builder::default();
            let _ = response;

            let body_slice = response.body().as_ref();

            let parsed_body: crate::serializer::UpdateDeploymentOutputBody =
                if body_slice.is_empty() {
                    // To enable JSON parsing to succeed, replace an empty body
                    // with an empty JSON body. If a member was required, it will fail slightly later
                    // during the operation construction phase.
                    serde_json::from_slice(b"{}")
                        .map_err(crate::error::UpdateDeploymentError::unhandled)?
                } else {
                    serde_json::from_slice(response.body().as_ref())
                        .map_err(crate::error::UpdateDeploymentError::unhandled)?
                };

            output = output.set_id(parsed_body.id);
            output = output.set_description(parsed_body.description);
            output = output.set_created_date(parsed_body.created_date);
            output = output.set_api_summary(parsed_body.api_summary);
            output.build()
        })
    }
    pub fn parse_response(
        &self,
        response: &http::response::Response<impl AsRef<[u8]>>,
    ) -> Result<crate::output::UpdateDeploymentOutput, crate::error::UpdateDeploymentError> {
        Self::from_response(&response)
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}

impl smithy_http::response::ParseStrictResponse for UpdateDeployment {
    type Output =
        Result<crate::output::UpdateDeploymentOutput, crate::error::UpdateDeploymentError>;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        self.parse_response(response)
    }
}

#[derive(std::clone::Clone)]
pub struct UpdateDocumentationPart {
    _private: (),
}
impl UpdateDocumentationPart {
    /// Creates a new builder-style object to manufacture [`UpdateDocumentationPartInput`](crate::input::UpdateDocumentationPartInput)
    pub fn builder() -> crate::input::update_documentation_part_input::Builder {
        crate::input::update_documentation_part_input::Builder::default()
    }
    #[allow(clippy::unnecessary_wraps)]
    fn from_response(
        response: &http::response::Response<impl AsRef<[u8]>>,
    ) -> Result<
        crate::output::UpdateDocumentationPartOutput,
        crate::error::UpdateDocumentationPartError,
    > {
        if crate::aws_json_errors::is_error(&response) && response.status().as_u16() != 200 {
            let body = serde_json::from_slice(response.body().as_ref())
                .unwrap_or_else(|_| serde_json::json!({}));
            let generic = crate::aws_json_errors::parse_generic_error(&response, &body);

            let error_code = match generic.code() {
                Some(code) => code,
                None => {
                    return Err(crate::error::UpdateDocumentationPartError::unhandled(
                        generic,
                    ))
                }
            };
            return Err(match error_code {
                "BadRequestException" => crate::error::UpdateDocumentationPartError {
                    meta: generic,
                    kind: crate::error::UpdateDocumentationPartErrorKind::BadRequestError({
                        #[allow(unused_mut)]
                        let mut output = crate::error::bad_request_error::Builder::default();
                        let _ = response;

                        let body_slice = response.body().as_ref();

                        let parsed_body: crate::error::BadRequestError = if body_slice.is_empty() {
                            // To enable JSON parsing to succeed, replace an empty body
                            // with an empty JSON body. If a member was required, it will fail slightly later
                            // during the operation construction phase.
                            serde_json::from_slice(b"{}")
                                .map_err(crate::error::UpdateDocumentationPartError::unhandled)?
                        } else {
                            serde_json::from_slice(response.body().as_ref())
                                .map_err(crate::error::UpdateDocumentationPartError::unhandled)?
                        };

                        output = output.set_message(parsed_body.message);
                        output.build()
                    }),
                },
                "ConflictException" => crate::error::UpdateDocumentationPartError {
                    meta: generic,
                    kind: crate::error::UpdateDocumentationPartErrorKind::ConflictError({
                        #[allow(unused_mut)]
                        let mut output = crate::error::conflict_error::Builder::default();
                        let _ = response;

                        let body_slice = response.body().as_ref();

                        let parsed_body: crate::error::ConflictError = if body_slice.is_empty() {
                            // To enable JSON parsing to succeed, replace an empty body
                            // with an empty JSON body. If a member was required, it will fail slightly later
                            // during the operation construction phase.
                            serde_json::from_slice(b"{}")
                                .map_err(crate::error::UpdateDocumentationPartError::unhandled)?
                        } else {
                            serde_json::from_slice(response.body().as_ref())
                                .map_err(crate::error::UpdateDocumentationPartError::unhandled)?
                        };

                        output = output.set_message(parsed_body.message);
                        output.build()
                    }),
                },
                "LimitExceededException" => crate::error::UpdateDocumentationPartError {
                    meta: generic,
                    kind: crate::error::UpdateDocumentationPartErrorKind::LimitExceededError({
                        #[allow(unused_mut)]
                        let mut output = crate::error::limit_exceeded_error::Builder::default();
                        let _ = response;

                        let body_slice = response.body().as_ref();

                        let parsed_body: crate::error::LimitExceededError = if body_slice.is_empty()
                        {
                            // To enable JSON parsing to succeed, replace an empty body
                            // with an empty JSON body. If a member was required, it will fail slightly later
                            // during the operation construction phase.
                            serde_json::from_slice(b"{}")
                                .map_err(crate::error::UpdateDocumentationPartError::unhandled)?
                        } else {
                            serde_json::from_slice(response.body().as_ref())
                                .map_err(crate::error::UpdateDocumentationPartError::unhandled)?
                        };

                        output = output.set_retry_after_seconds(
                        
                                                crate::http_serde::deser_header_update_documentation_part_retry_after_seconds(response.headers())
                                                    .map_err(|_|crate::error::UpdateDocumentationPartError::unhandled("Failed to parse retryAfterSeconds from header `Retry-After"))?
                                                
                    );
                        output = output.set_message(parsed_body.message);
                        output.build()
                    }),
                },
                "NotFoundException" => crate::error::UpdateDocumentationPartError {
                    meta: generic,
                    kind: crate::error::UpdateDocumentationPartErrorKind::NotFoundError({
                        #[allow(unused_mut)]
                        let mut output = crate::error::not_found_error::Builder::default();
                        let _ = response;

                        let body_slice = response.body().as_ref();

                        let parsed_body: crate::error::NotFoundError = if body_slice.is_empty() {
                            // To enable JSON parsing to succeed, replace an empty body
                            // with an empty JSON body. If a member was required, it will fail slightly later
                            // during the operation construction phase.
                            serde_json::from_slice(b"{}")
                                .map_err(crate::error::UpdateDocumentationPartError::unhandled)?
                        } else {
                            serde_json::from_slice(response.body().as_ref())
                                .map_err(crate::error::UpdateDocumentationPartError::unhandled)?
                        };

                        output = output.set_message(parsed_body.message);
                        output.build()
                    }),
                },
                "TooManyRequestsException" => crate::error::UpdateDocumentationPartError {
                    meta: generic,
                    kind: crate::error::UpdateDocumentationPartErrorKind::TooManyRequestsError({
                        #[allow(unused_mut)]
                        let mut output = crate::error::too_many_requests_error::Builder::default();
                        let _ = response;

                        let body_slice = response.body().as_ref();

                        let parsed_body: crate::error::TooManyRequestsError = if body_slice
                            .is_empty()
                        {
                            // To enable JSON parsing to succeed, replace an empty body
                            // with an empty JSON body. If a member was required, it will fail slightly later
                            // during the operation construction phase.
                            serde_json::from_slice(b"{}")
                                .map_err(crate::error::UpdateDocumentationPartError::unhandled)?
                        } else {
                            serde_json::from_slice(response.body().as_ref())
                                .map_err(crate::error::UpdateDocumentationPartError::unhandled)?
                        };

                        output = output.set_retry_after_seconds(
                        
                                                crate::http_serde::deser_header_update_documentation_part_retry_after_seconds(response.headers())
                                                    .map_err(|_|crate::error::UpdateDocumentationPartError::unhandled("Failed to parse retryAfterSeconds from header `Retry-After"))?
                                                
                    );
                        output = output.set_message(parsed_body.message);
                        output.build()
                    }),
                },
                "UnauthorizedException" => crate::error::UpdateDocumentationPartError {
                    meta: generic,
                    kind: crate::error::UpdateDocumentationPartErrorKind::UnauthorizedError({
                        #[allow(unused_mut)]
                        let mut output = crate::error::unauthorized_error::Builder::default();
                        let _ = response;

                        let body_slice = response.body().as_ref();

                        let parsed_body: crate::error::UnauthorizedError = if body_slice.is_empty()
                        {
                            // To enable JSON parsing to succeed, replace an empty body
                            // with an empty JSON body. If a member was required, it will fail slightly later
                            // during the operation construction phase.
                            serde_json::from_slice(b"{}")
                                .map_err(crate::error::UpdateDocumentationPartError::unhandled)?
                        } else {
                            serde_json::from_slice(response.body().as_ref())
                                .map_err(crate::error::UpdateDocumentationPartError::unhandled)?
                        };

                        output = output.set_message(parsed_body.message);
                        output.build()
                    }),
                },
                _ => crate::error::UpdateDocumentationPartError::generic(generic),
            });
        }
        Ok({
            #[allow(unused_mut)]
            let mut output = crate::output::update_documentation_part_output::Builder::default();
            let _ = response;

            let body_slice = response.body().as_ref();

            let parsed_body: crate::serializer::UpdateDocumentationPartOutputBody =
                if body_slice.is_empty() {
                    // To enable JSON parsing to succeed, replace an empty body
                    // with an empty JSON body. If a member was required, it will fail slightly later
                    // during the operation construction phase.
                    serde_json::from_slice(b"{}")
                        .map_err(crate::error::UpdateDocumentationPartError::unhandled)?
                } else {
                    serde_json::from_slice(response.body().as_ref())
                        .map_err(crate::error::UpdateDocumentationPartError::unhandled)?
                };

            output = output.set_id(parsed_body.id);
            output = output.set_location(parsed_body.location);
            output = output.set_properties(parsed_body.properties);
            output.build()
        })
    }
    pub fn parse_response(
        &self,
        response: &http::response::Response<impl AsRef<[u8]>>,
    ) -> Result<
        crate::output::UpdateDocumentationPartOutput,
        crate::error::UpdateDocumentationPartError,
    > {
        Self::from_response(&response)
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}

impl smithy_http::response::ParseStrictResponse for UpdateDocumentationPart {
    type Output = Result<
        crate::output::UpdateDocumentationPartOutput,
        crate::error::UpdateDocumentationPartError,
    >;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        self.parse_response(response)
    }
}

#[derive(std::clone::Clone)]
pub struct UpdateDocumentationVersion {
    _private: (),
}
impl UpdateDocumentationVersion {
    /// Creates a new builder-style object to manufacture [`UpdateDocumentationVersionInput`](crate::input::UpdateDocumentationVersionInput)
    pub fn builder() -> crate::input::update_documentation_version_input::Builder {
        crate::input::update_documentation_version_input::Builder::default()
    }
    #[allow(clippy::unnecessary_wraps)]
    fn from_response(
        response: &http::response::Response<impl AsRef<[u8]>>,
    ) -> Result<
        crate::output::UpdateDocumentationVersionOutput,
        crate::error::UpdateDocumentationVersionError,
    > {
        if crate::aws_json_errors::is_error(&response) && response.status().as_u16() != 200 {
            let body = serde_json::from_slice(response.body().as_ref())
                .unwrap_or_else(|_| serde_json::json!({}));
            let generic = crate::aws_json_errors::parse_generic_error(&response, &body);

            let error_code = match generic.code() {
                Some(code) => code,
                None => {
                    return Err(crate::error::UpdateDocumentationVersionError::unhandled(
                        generic,
                    ))
                }
            };
            return Err(match error_code {
                "BadRequestException" => crate::error::UpdateDocumentationVersionError {
                    meta: generic,
                    kind: crate::error::UpdateDocumentationVersionErrorKind::BadRequestError({
                        #[allow(unused_mut)]
                        let mut output = crate::error::bad_request_error::Builder::default();
                        let _ = response;

                        let body_slice = response.body().as_ref();

                        let parsed_body: crate::error::BadRequestError = if body_slice.is_empty() {
                            // To enable JSON parsing to succeed, replace an empty body
                            // with an empty JSON body. If a member was required, it will fail slightly later
                            // during the operation construction phase.
                            serde_json::from_slice(b"{}")
                                .map_err(crate::error::UpdateDocumentationVersionError::unhandled)?
                        } else {
                            serde_json::from_slice(response.body().as_ref())
                                .map_err(crate::error::UpdateDocumentationVersionError::unhandled)?
                        };

                        output = output.set_message(parsed_body.message);
                        output.build()
                    }),
                },
                "ConflictException" => crate::error::UpdateDocumentationVersionError {
                    meta: generic,
                    kind: crate::error::UpdateDocumentationVersionErrorKind::ConflictError({
                        #[allow(unused_mut)]
                        let mut output = crate::error::conflict_error::Builder::default();
                        let _ = response;

                        let body_slice = response.body().as_ref();

                        let parsed_body: crate::error::ConflictError = if body_slice.is_empty() {
                            // To enable JSON parsing to succeed, replace an empty body
                            // with an empty JSON body. If a member was required, it will fail slightly later
                            // during the operation construction phase.
                            serde_json::from_slice(b"{}")
                                .map_err(crate::error::UpdateDocumentationVersionError::unhandled)?
                        } else {
                            serde_json::from_slice(response.body().as_ref())
                                .map_err(crate::error::UpdateDocumentationVersionError::unhandled)?
                        };

                        output = output.set_message(parsed_body.message);
                        output.build()
                    }),
                },
                "NotFoundException" => crate::error::UpdateDocumentationVersionError {
                    meta: generic,
                    kind: crate::error::UpdateDocumentationVersionErrorKind::NotFoundError({
                        #[allow(unused_mut)]
                        let mut output = crate::error::not_found_error::Builder::default();
                        let _ = response;

                        let body_slice = response.body().as_ref();

                        let parsed_body: crate::error::NotFoundError = if body_slice.is_empty() {
                            // To enable JSON parsing to succeed, replace an empty body
                            // with an empty JSON body. If a member was required, it will fail slightly later
                            // during the operation construction phase.
                            serde_json::from_slice(b"{}")
                                .map_err(crate::error::UpdateDocumentationVersionError::unhandled)?
                        } else {
                            serde_json::from_slice(response.body().as_ref())
                                .map_err(crate::error::UpdateDocumentationVersionError::unhandled)?
                        };

                        output = output.set_message(parsed_body.message);
                        output.build()
                    }),
                },
                "TooManyRequestsException" => {
                    crate::error::UpdateDocumentationVersionError {
                        meta: generic,
                        kind:
                            crate::error::UpdateDocumentationVersionErrorKind::TooManyRequestsError(
                                {
                                    #[allow(unused_mut)]
                                    let mut output =
                                        crate::error::too_many_requests_error::Builder::default();
                                    let _ = response;

                                    let body_slice = response.body().as_ref();

                                    let parsed_body: crate::error::TooManyRequestsError =
                                        if body_slice.is_empty() {
                                            // To enable JSON parsing to succeed, replace an empty body
                                            // with an empty JSON body. If a member was required, it will fail slightly later
                                            // during the operation construction phase.
                                            serde_json::from_slice(b"{}").map_err(crate::error::UpdateDocumentationVersionError::unhandled)?
                                        } else {
                                            serde_json::from_slice(response.body().as_ref()).map_err(crate::error::UpdateDocumentationVersionError::unhandled)?
                                        };

                                    output = output.set_retry_after_seconds(
                        
                                                crate::http_serde::deser_header_update_documentation_version_retry_after_seconds(response.headers())
                                                    .map_err(|_|crate::error::UpdateDocumentationVersionError::unhandled("Failed to parse retryAfterSeconds from header `Retry-After"))?
                                                
                    );
                                    output = output.set_message(parsed_body.message);
                                    output.build()
                                },
                            ),
                    }
                }
                "UnauthorizedException" => crate::error::UpdateDocumentationVersionError {
                    meta: generic,
                    kind: crate::error::UpdateDocumentationVersionErrorKind::UnauthorizedError({
                        #[allow(unused_mut)]
                        let mut output = crate::error::unauthorized_error::Builder::default();
                        let _ = response;

                        let body_slice = response.body().as_ref();

                        let parsed_body: crate::error::UnauthorizedError = if body_slice.is_empty()
                        {
                            // To enable JSON parsing to succeed, replace an empty body
                            // with an empty JSON body. If a member was required, it will fail slightly later
                            // during the operation construction phase.
                            serde_json::from_slice(b"{}")
                                .map_err(crate::error::UpdateDocumentationVersionError::unhandled)?
                        } else {
                            serde_json::from_slice(response.body().as_ref())
                                .map_err(crate::error::UpdateDocumentationVersionError::unhandled)?
                        };

                        output = output.set_message(parsed_body.message);
                        output.build()
                    }),
                },
                _ => crate::error::UpdateDocumentationVersionError::generic(generic),
            });
        }
        Ok({
            #[allow(unused_mut)]
            let mut output = crate::output::update_documentation_version_output::Builder::default();
            let _ = response;

            let body_slice = response.body().as_ref();

            let parsed_body: crate::serializer::UpdateDocumentationVersionOutputBody =
                if body_slice.is_empty() {
                    // To enable JSON parsing to succeed, replace an empty body
                    // with an empty JSON body. If a member was required, it will fail slightly later
                    // during the operation construction phase.
                    serde_json::from_slice(b"{}")
                        .map_err(crate::error::UpdateDocumentationVersionError::unhandled)?
                } else {
                    serde_json::from_slice(response.body().as_ref())
                        .map_err(crate::error::UpdateDocumentationVersionError::unhandled)?
                };

            output = output.set_version(parsed_body.version);
            output = output.set_created_date(parsed_body.created_date);
            output = output.set_description(parsed_body.description);
            output.build()
        })
    }
    pub fn parse_response(
        &self,
        response: &http::response::Response<impl AsRef<[u8]>>,
    ) -> Result<
        crate::output::UpdateDocumentationVersionOutput,
        crate::error::UpdateDocumentationVersionError,
    > {
        Self::from_response(&response)
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}

impl smithy_http::response::ParseStrictResponse for UpdateDocumentationVersion {
    type Output = Result<
        crate::output::UpdateDocumentationVersionOutput,
        crate::error::UpdateDocumentationVersionError,
    >;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        self.parse_response(response)
    }
}

/// <p>Changes information about the <a>DomainName</a> resource.</p>
#[derive(std::clone::Clone)]
pub struct UpdateDomainName {
    _private: (),
}
impl UpdateDomainName {
    /// Creates a new builder-style object to manufacture [`UpdateDomainNameInput`](crate::input::UpdateDomainNameInput)
    pub fn builder() -> crate::input::update_domain_name_input::Builder {
        crate::input::update_domain_name_input::Builder::default()
    }
    #[allow(clippy::unnecessary_wraps)]
    fn from_response(
        response: &http::response::Response<impl AsRef<[u8]>>,
    ) -> Result<crate::output::UpdateDomainNameOutput, crate::error::UpdateDomainNameError> {
        if crate::aws_json_errors::is_error(&response) && response.status().as_u16() != 200 {
            let body = serde_json::from_slice(response.body().as_ref())
                .unwrap_or_else(|_| serde_json::json!({}));
            let generic = crate::aws_json_errors::parse_generic_error(&response, &body);

            let error_code = match generic.code() {
                Some(code) => code,
                None => return Err(crate::error::UpdateDomainNameError::unhandled(generic)),
            };
            return Err(match error_code {
                "BadRequestException" => crate::error::UpdateDomainNameError {
                    meta: generic,
                    kind: crate::error::UpdateDomainNameErrorKind::BadRequestError({
                        #[allow(unused_mut)]
                        let mut output = crate::error::bad_request_error::Builder::default();
                        let _ = response;

                        let body_slice = response.body().as_ref();

                        let parsed_body: crate::error::BadRequestError = if body_slice.is_empty() {
                            // To enable JSON parsing to succeed, replace an empty body
                            // with an empty JSON body. If a member was required, it will fail slightly later
                            // during the operation construction phase.
                            serde_json::from_slice(b"{}")
                                .map_err(crate::error::UpdateDomainNameError::unhandled)?
                        } else {
                            serde_json::from_slice(response.body().as_ref())
                                .map_err(crate::error::UpdateDomainNameError::unhandled)?
                        };

                        output = output.set_message(parsed_body.message);
                        output.build()
                    }),
                },
                "ConflictException" => crate::error::UpdateDomainNameError {
                    meta: generic,
                    kind: crate::error::UpdateDomainNameErrorKind::ConflictError({
                        #[allow(unused_mut)]
                        let mut output = crate::error::conflict_error::Builder::default();
                        let _ = response;

                        let body_slice = response.body().as_ref();

                        let parsed_body: crate::error::ConflictError = if body_slice.is_empty() {
                            // To enable JSON parsing to succeed, replace an empty body
                            // with an empty JSON body. If a member was required, it will fail slightly later
                            // during the operation construction phase.
                            serde_json::from_slice(b"{}")
                                .map_err(crate::error::UpdateDomainNameError::unhandled)?
                        } else {
                            serde_json::from_slice(response.body().as_ref())
                                .map_err(crate::error::UpdateDomainNameError::unhandled)?
                        };

                        output = output.set_message(parsed_body.message);
                        output.build()
                    }),
                },
                "NotFoundException" => crate::error::UpdateDomainNameError {
                    meta: generic,
                    kind: crate::error::UpdateDomainNameErrorKind::NotFoundError({
                        #[allow(unused_mut)]
                        let mut output = crate::error::not_found_error::Builder::default();
                        let _ = response;

                        let body_slice = response.body().as_ref();

                        let parsed_body: crate::error::NotFoundError = if body_slice.is_empty() {
                            // To enable JSON parsing to succeed, replace an empty body
                            // with an empty JSON body. If a member was required, it will fail slightly later
                            // during the operation construction phase.
                            serde_json::from_slice(b"{}")
                                .map_err(crate::error::UpdateDomainNameError::unhandled)?
                        } else {
                            serde_json::from_slice(response.body().as_ref())
                                .map_err(crate::error::UpdateDomainNameError::unhandled)?
                        };

                        output = output.set_message(parsed_body.message);
                        output.build()
                    }),
                },
                "TooManyRequestsException" => {
                    crate::error::UpdateDomainNameError {
                        meta: generic,
                        kind: crate::error::UpdateDomainNameErrorKind::TooManyRequestsError({
                            #[allow(unused_mut)]
                            let mut output =
                                crate::error::too_many_requests_error::Builder::default();
                            let _ = response;

                            let body_slice = response.body().as_ref();

                            let parsed_body: crate::error::TooManyRequestsError =
                                if body_slice.is_empty() {
                                    // To enable JSON parsing to succeed, replace an empty body
                                    // with an empty JSON body. If a member was required, it will fail slightly later
                                    // during the operation construction phase.
                                    serde_json::from_slice(b"{}")
                                        .map_err(crate::error::UpdateDomainNameError::unhandled)?
                                } else {
                                    serde_json::from_slice(response.body().as_ref())
                                        .map_err(crate::error::UpdateDomainNameError::unhandled)?
                                };

                            output = output.set_retry_after_seconds(
                        
                                                crate::http_serde::deser_header_update_domain_name_retry_after_seconds(response.headers())
                                                    .map_err(|_|crate::error::UpdateDomainNameError::unhandled("Failed to parse retryAfterSeconds from header `Retry-After"))?
                                                
                    );
                            output = output.set_message(parsed_body.message);
                            output.build()
                        }),
                    }
                }
                "UnauthorizedException" => crate::error::UpdateDomainNameError {
                    meta: generic,
                    kind: crate::error::UpdateDomainNameErrorKind::UnauthorizedError({
                        #[allow(unused_mut)]
                        let mut output = crate::error::unauthorized_error::Builder::default();
                        let _ = response;

                        let body_slice = response.body().as_ref();

                        let parsed_body: crate::error::UnauthorizedError = if body_slice.is_empty()
                        {
                            // To enable JSON parsing to succeed, replace an empty body
                            // with an empty JSON body. If a member was required, it will fail slightly later
                            // during the operation construction phase.
                            serde_json::from_slice(b"{}")
                                .map_err(crate::error::UpdateDomainNameError::unhandled)?
                        } else {
                            serde_json::from_slice(response.body().as_ref())
                                .map_err(crate::error::UpdateDomainNameError::unhandled)?
                        };

                        output = output.set_message(parsed_body.message);
                        output.build()
                    }),
                },
                _ => crate::error::UpdateDomainNameError::generic(generic),
            });
        }
        Ok({
            #[allow(unused_mut)]
            let mut output = crate::output::update_domain_name_output::Builder::default();
            let _ = response;

            let body_slice = response.body().as_ref();

            let parsed_body: crate::serializer::UpdateDomainNameOutputBody =
                if body_slice.is_empty() {
                    // To enable JSON parsing to succeed, replace an empty body
                    // with an empty JSON body. If a member was required, it will fail slightly later
                    // during the operation construction phase.
                    serde_json::from_slice(b"{}")
                        .map_err(crate::error::UpdateDomainNameError::unhandled)?
                } else {
                    serde_json::from_slice(response.body().as_ref())
                        .map_err(crate::error::UpdateDomainNameError::unhandled)?
                };

            output = output.set_domain_name(parsed_body.domain_name);
            output = output.set_certificate_name(parsed_body.certificate_name);
            output = output.set_certificate_arn(parsed_body.certificate_arn);
            output = output.set_certificate_upload_date(parsed_body.certificate_upload_date);
            output = output.set_regional_domain_name(parsed_body.regional_domain_name);
            output = output.set_regional_hosted_zone_id(parsed_body.regional_hosted_zone_id);
            output = output.set_regional_certificate_name(parsed_body.regional_certificate_name);
            output = output.set_regional_certificate_arn(parsed_body.regional_certificate_arn);
            output = output.set_distribution_domain_name(parsed_body.distribution_domain_name);
            output =
                output.set_distribution_hosted_zone_id(parsed_body.distribution_hosted_zone_id);
            output = output.set_endpoint_configuration(parsed_body.endpoint_configuration);
            output = output.set_domain_name_status(parsed_body.domain_name_status);
            output = output.set_domain_name_status_message(parsed_body.domain_name_status_message);
            output = output.set_security_policy(parsed_body.security_policy);
            output = output.set_tags(parsed_body.tags);
            output = output.set_mutual_tls_authentication(parsed_body.mutual_tls_authentication);
            output.build()
        })
    }
    pub fn parse_response(
        &self,
        response: &http::response::Response<impl AsRef<[u8]>>,
    ) -> Result<crate::output::UpdateDomainNameOutput, crate::error::UpdateDomainNameError> {
        Self::from_response(&response)
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}

impl smithy_http::response::ParseStrictResponse for UpdateDomainName {
    type Output =
        Result<crate::output::UpdateDomainNameOutput, crate::error::UpdateDomainNameError>;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        self.parse_response(response)
    }
}

/// <p>Updates a <a>GatewayResponse</a> of a specified response type on the given <a>RestApi</a>.</p>
#[derive(std::clone::Clone)]
pub struct UpdateGatewayResponse {
    _private: (),
}
impl UpdateGatewayResponse {
    /// Creates a new builder-style object to manufacture [`UpdateGatewayResponseInput`](crate::input::UpdateGatewayResponseInput)
    pub fn builder() -> crate::input::update_gateway_response_input::Builder {
        crate::input::update_gateway_response_input::Builder::default()
    }
    #[allow(clippy::unnecessary_wraps)]
    fn from_response(
        response: &http::response::Response<impl AsRef<[u8]>>,
    ) -> Result<crate::output::UpdateGatewayResponseOutput, crate::error::UpdateGatewayResponseError>
    {
        if crate::aws_json_errors::is_error(&response) && response.status().as_u16() != 200 {
            let body = serde_json::from_slice(response.body().as_ref())
                .unwrap_or_else(|_| serde_json::json!({}));
            let generic = crate::aws_json_errors::parse_generic_error(&response, &body);

            let error_code = match generic.code() {
                Some(code) => code,
                None => return Err(crate::error::UpdateGatewayResponseError::unhandled(generic)),
            };
            return Err(match error_code {
                "BadRequestException" => crate::error::UpdateGatewayResponseError {
                    meta: generic,
                    kind: crate::error::UpdateGatewayResponseErrorKind::BadRequestError({
                        #[allow(unused_mut)]
                        let mut output = crate::error::bad_request_error::Builder::default();
                        let _ = response;

                        let body_slice = response.body().as_ref();

                        let parsed_body: crate::error::BadRequestError = if body_slice.is_empty() {
                            // To enable JSON parsing to succeed, replace an empty body
                            // with an empty JSON body. If a member was required, it will fail slightly later
                            // during the operation construction phase.
                            serde_json::from_slice(b"{}")
                                .map_err(crate::error::UpdateGatewayResponseError::unhandled)?
                        } else {
                            serde_json::from_slice(response.body().as_ref())
                                .map_err(crate::error::UpdateGatewayResponseError::unhandled)?
                        };

                        output = output.set_message(parsed_body.message);
                        output.build()
                    }),
                },
                "NotFoundException" => crate::error::UpdateGatewayResponseError {
                    meta: generic,
                    kind: crate::error::UpdateGatewayResponseErrorKind::NotFoundError({
                        #[allow(unused_mut)]
                        let mut output = crate::error::not_found_error::Builder::default();
                        let _ = response;

                        let body_slice = response.body().as_ref();

                        let parsed_body: crate::error::NotFoundError = if body_slice.is_empty() {
                            // To enable JSON parsing to succeed, replace an empty body
                            // with an empty JSON body. If a member was required, it will fail slightly later
                            // during the operation construction phase.
                            serde_json::from_slice(b"{}")
                                .map_err(crate::error::UpdateGatewayResponseError::unhandled)?
                        } else {
                            serde_json::from_slice(response.body().as_ref())
                                .map_err(crate::error::UpdateGatewayResponseError::unhandled)?
                        };

                        output = output.set_message(parsed_body.message);
                        output.build()
                    }),
                },
                "TooManyRequestsException" => crate::error::UpdateGatewayResponseError {
                    meta: generic,
                    kind: crate::error::UpdateGatewayResponseErrorKind::TooManyRequestsError({
                        #[allow(unused_mut)]
                        let mut output = crate::error::too_many_requests_error::Builder::default();
                        let _ = response;

                        let body_slice = response.body().as_ref();

                        let parsed_body: crate::error::TooManyRequestsError =
                            if body_slice.is_empty() {
                                // To enable JSON parsing to succeed, replace an empty body
                                // with an empty JSON body. If a member was required, it will fail slightly later
                                // during the operation construction phase.
                                serde_json::from_slice(b"{}")
                                    .map_err(crate::error::UpdateGatewayResponseError::unhandled)?
                            } else {
                                serde_json::from_slice(response.body().as_ref())
                                    .map_err(crate::error::UpdateGatewayResponseError::unhandled)?
                            };

                        output = output.set_retry_after_seconds(
                        
                                                crate::http_serde::deser_header_update_gateway_response_retry_after_seconds(response.headers())
                                                    .map_err(|_|crate::error::UpdateGatewayResponseError::unhandled("Failed to parse retryAfterSeconds from header `Retry-After"))?
                                                
                    );
                        output = output.set_message(parsed_body.message);
                        output.build()
                    }),
                },
                "UnauthorizedException" => crate::error::UpdateGatewayResponseError {
                    meta: generic,
                    kind: crate::error::UpdateGatewayResponseErrorKind::UnauthorizedError({
                        #[allow(unused_mut)]
                        let mut output = crate::error::unauthorized_error::Builder::default();
                        let _ = response;

                        let body_slice = response.body().as_ref();

                        let parsed_body: crate::error::UnauthorizedError = if body_slice.is_empty()
                        {
                            // To enable JSON parsing to succeed, replace an empty body
                            // with an empty JSON body. If a member was required, it will fail slightly later
                            // during the operation construction phase.
                            serde_json::from_slice(b"{}")
                                .map_err(crate::error::UpdateGatewayResponseError::unhandled)?
                        } else {
                            serde_json::from_slice(response.body().as_ref())
                                .map_err(crate::error::UpdateGatewayResponseError::unhandled)?
                        };

                        output = output.set_message(parsed_body.message);
                        output.build()
                    }),
                },
                _ => crate::error::UpdateGatewayResponseError::generic(generic),
            });
        }
        Ok({
            #[allow(unused_mut)]
            let mut output = crate::output::update_gateway_response_output::Builder::default();
            let _ = response;

            let body_slice = response.body().as_ref();

            let parsed_body: crate::serializer::UpdateGatewayResponseOutputBody =
                if body_slice.is_empty() {
                    // To enable JSON parsing to succeed, replace an empty body
                    // with an empty JSON body. If a member was required, it will fail slightly later
                    // during the operation construction phase.
                    serde_json::from_slice(b"{}")
                        .map_err(crate::error::UpdateGatewayResponseError::unhandled)?
                } else {
                    serde_json::from_slice(response.body().as_ref())
                        .map_err(crate::error::UpdateGatewayResponseError::unhandled)?
                };

            output = output.set_response_type(parsed_body.response_type);
            output = output.set_status_code(parsed_body.status_code);
            output = output.set_response_parameters(parsed_body.response_parameters);
            output = output.set_response_templates(parsed_body.response_templates);
            output = output.set_default_response(parsed_body.default_response);
            output.build()
        })
    }
    pub fn parse_response(
        &self,
        response: &http::response::Response<impl AsRef<[u8]>>,
    ) -> Result<crate::output::UpdateGatewayResponseOutput, crate::error::UpdateGatewayResponseError>
    {
        Self::from_response(&response)
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}

impl smithy_http::response::ParseStrictResponse for UpdateGatewayResponse {
    type Output = Result<
        crate::output::UpdateGatewayResponseOutput,
        crate::error::UpdateGatewayResponseError,
    >;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        self.parse_response(response)
    }
}

/// <p>Represents an update integration.</p>
#[derive(std::clone::Clone)]
pub struct UpdateIntegration {
    _private: (),
}
impl UpdateIntegration {
    /// Creates a new builder-style object to manufacture [`UpdateIntegrationInput`](crate::input::UpdateIntegrationInput)
    pub fn builder() -> crate::input::update_integration_input::Builder {
        crate::input::update_integration_input::Builder::default()
    }
    #[allow(clippy::unnecessary_wraps)]
    fn from_response(
        response: &http::response::Response<impl AsRef<[u8]>>,
    ) -> Result<crate::output::UpdateIntegrationOutput, crate::error::UpdateIntegrationError> {
        if crate::aws_json_errors::is_error(&response) && response.status().as_u16() != 200 {
            let body = serde_json::from_slice(response.body().as_ref())
                .unwrap_or_else(|_| serde_json::json!({}));
            let generic = crate::aws_json_errors::parse_generic_error(&response, &body);

            let error_code = match generic.code() {
                Some(code) => code,
                None => return Err(crate::error::UpdateIntegrationError::unhandled(generic)),
            };
            return Err(match error_code {
                "BadRequestException" => crate::error::UpdateIntegrationError {
                    meta: generic,
                    kind: crate::error::UpdateIntegrationErrorKind::BadRequestError({
                        #[allow(unused_mut)]
                        let mut output = crate::error::bad_request_error::Builder::default();
                        let _ = response;

                        let body_slice = response.body().as_ref();

                        let parsed_body: crate::error::BadRequestError = if body_slice.is_empty() {
                            // To enable JSON parsing to succeed, replace an empty body
                            // with an empty JSON body. If a member was required, it will fail slightly later
                            // during the operation construction phase.
                            serde_json::from_slice(b"{}")
                                .map_err(crate::error::UpdateIntegrationError::unhandled)?
                        } else {
                            serde_json::from_slice(response.body().as_ref())
                                .map_err(crate::error::UpdateIntegrationError::unhandled)?
                        };

                        output = output.set_message(parsed_body.message);
                        output.build()
                    }),
                },
                "ConflictException" => crate::error::UpdateIntegrationError {
                    meta: generic,
                    kind: crate::error::UpdateIntegrationErrorKind::ConflictError({
                        #[allow(unused_mut)]
                        let mut output = crate::error::conflict_error::Builder::default();
                        let _ = response;

                        let body_slice = response.body().as_ref();

                        let parsed_body: crate::error::ConflictError = if body_slice.is_empty() {
                            // To enable JSON parsing to succeed, replace an empty body
                            // with an empty JSON body. If a member was required, it will fail slightly later
                            // during the operation construction phase.
                            serde_json::from_slice(b"{}")
                                .map_err(crate::error::UpdateIntegrationError::unhandled)?
                        } else {
                            serde_json::from_slice(response.body().as_ref())
                                .map_err(crate::error::UpdateIntegrationError::unhandled)?
                        };

                        output = output.set_message(parsed_body.message);
                        output.build()
                    }),
                },
                "NotFoundException" => crate::error::UpdateIntegrationError {
                    meta: generic,
                    kind: crate::error::UpdateIntegrationErrorKind::NotFoundError({
                        #[allow(unused_mut)]
                        let mut output = crate::error::not_found_error::Builder::default();
                        let _ = response;

                        let body_slice = response.body().as_ref();

                        let parsed_body: crate::error::NotFoundError = if body_slice.is_empty() {
                            // To enable JSON parsing to succeed, replace an empty body
                            // with an empty JSON body. If a member was required, it will fail slightly later
                            // during the operation construction phase.
                            serde_json::from_slice(b"{}")
                                .map_err(crate::error::UpdateIntegrationError::unhandled)?
                        } else {
                            serde_json::from_slice(response.body().as_ref())
                                .map_err(crate::error::UpdateIntegrationError::unhandled)?
                        };

                        output = output.set_message(parsed_body.message);
                        output.build()
                    }),
                },
                "TooManyRequestsException" => {
                    crate::error::UpdateIntegrationError {
                        meta: generic,
                        kind: crate::error::UpdateIntegrationErrorKind::TooManyRequestsError({
                            #[allow(unused_mut)]
                            let mut output =
                                crate::error::too_many_requests_error::Builder::default();
                            let _ = response;

                            let body_slice = response.body().as_ref();

                            let parsed_body: crate::error::TooManyRequestsError =
                                if body_slice.is_empty() {
                                    // To enable JSON parsing to succeed, replace an empty body
                                    // with an empty JSON body. If a member was required, it will fail slightly later
                                    // during the operation construction phase.
                                    serde_json::from_slice(b"{}")
                                        .map_err(crate::error::UpdateIntegrationError::unhandled)?
                                } else {
                                    serde_json::from_slice(response.body().as_ref())
                                        .map_err(crate::error::UpdateIntegrationError::unhandled)?
                                };

                            output = output.set_retry_after_seconds(
                        
                                                crate::http_serde::deser_header_update_integration_retry_after_seconds(response.headers())
                                                    .map_err(|_|crate::error::UpdateIntegrationError::unhandled("Failed to parse retryAfterSeconds from header `Retry-After"))?
                                                
                    );
                            output = output.set_message(parsed_body.message);
                            output.build()
                        }),
                    }
                }
                "UnauthorizedException" => crate::error::UpdateIntegrationError {
                    meta: generic,
                    kind: crate::error::UpdateIntegrationErrorKind::UnauthorizedError({
                        #[allow(unused_mut)]
                        let mut output = crate::error::unauthorized_error::Builder::default();
                        let _ = response;

                        let body_slice = response.body().as_ref();

                        let parsed_body: crate::error::UnauthorizedError = if body_slice.is_empty()
                        {
                            // To enable JSON parsing to succeed, replace an empty body
                            // with an empty JSON body. If a member was required, it will fail slightly later
                            // during the operation construction phase.
                            serde_json::from_slice(b"{}")
                                .map_err(crate::error::UpdateIntegrationError::unhandled)?
                        } else {
                            serde_json::from_slice(response.body().as_ref())
                                .map_err(crate::error::UpdateIntegrationError::unhandled)?
                        };

                        output = output.set_message(parsed_body.message);
                        output.build()
                    }),
                },
                _ => crate::error::UpdateIntegrationError::generic(generic),
            });
        }
        Ok({
            #[allow(unused_mut)]
            let mut output = crate::output::update_integration_output::Builder::default();
            let _ = response;

            let body_slice = response.body().as_ref();

            let parsed_body: crate::serializer::UpdateIntegrationOutputBody =
                if body_slice.is_empty() {
                    // To enable JSON parsing to succeed, replace an empty body
                    // with an empty JSON body. If a member was required, it will fail slightly later
                    // during the operation construction phase.
                    serde_json::from_slice(b"{}")
                        .map_err(crate::error::UpdateIntegrationError::unhandled)?
                } else {
                    serde_json::from_slice(response.body().as_ref())
                        .map_err(crate::error::UpdateIntegrationError::unhandled)?
                };

            output = output.set_type(parsed_body.r#type);
            output = output.set_http_method(parsed_body.http_method);
            output = output.set_uri(parsed_body.uri);
            output = output.set_connection_type(parsed_body.connection_type);
            output = output.set_connection_id(parsed_body.connection_id);
            output = output.set_credentials(parsed_body.credentials);
            output = output.set_request_parameters(parsed_body.request_parameters);
            output = output.set_request_templates(parsed_body.request_templates);
            output = output.set_passthrough_behavior(parsed_body.passthrough_behavior);
            output = output.set_content_handling(parsed_body.content_handling);
            output = output.set_timeout_in_millis(parsed_body.timeout_in_millis);
            output = output.set_cache_namespace(parsed_body.cache_namespace);
            output = output.set_cache_key_parameters(parsed_body.cache_key_parameters);
            output = output.set_integration_responses(parsed_body.integration_responses);
            output = output.set_tls_config(parsed_body.tls_config);
            output.build()
        })
    }
    pub fn parse_response(
        &self,
        response: &http::response::Response<impl AsRef<[u8]>>,
    ) -> Result<crate::output::UpdateIntegrationOutput, crate::error::UpdateIntegrationError> {
        Self::from_response(&response)
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}

impl smithy_http::response::ParseStrictResponse for UpdateIntegration {
    type Output =
        Result<crate::output::UpdateIntegrationOutput, crate::error::UpdateIntegrationError>;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        self.parse_response(response)
    }
}

/// <p>Represents an update integration response.</p>
#[derive(std::clone::Clone)]
pub struct UpdateIntegrationResponse {
    _private: (),
}
impl UpdateIntegrationResponse {
    /// Creates a new builder-style object to manufacture [`UpdateIntegrationResponseInput`](crate::input::UpdateIntegrationResponseInput)
    pub fn builder() -> crate::input::update_integration_response_input::Builder {
        crate::input::update_integration_response_input::Builder::default()
    }
    #[allow(clippy::unnecessary_wraps)]
    fn from_response(
        response: &http::response::Response<impl AsRef<[u8]>>,
    ) -> Result<
        crate::output::UpdateIntegrationResponseOutput,
        crate::error::UpdateIntegrationResponseError,
    > {
        if crate::aws_json_errors::is_error(&response) && response.status().as_u16() != 200 {
            let body = serde_json::from_slice(response.body().as_ref())
                .unwrap_or_else(|_| serde_json::json!({}));
            let generic = crate::aws_json_errors::parse_generic_error(&response, &body);

            let error_code = match generic.code() {
                Some(code) => code,
                None => {
                    return Err(crate::error::UpdateIntegrationResponseError::unhandled(
                        generic,
                    ))
                }
            };
            return Err(match error_code {
                "BadRequestException" => crate::error::UpdateIntegrationResponseError {
                    meta: generic,
                    kind: crate::error::UpdateIntegrationResponseErrorKind::BadRequestError({
                        #[allow(unused_mut)]
                        let mut output = crate::error::bad_request_error::Builder::default();
                        let _ = response;

                        let body_slice = response.body().as_ref();

                        let parsed_body: crate::error::BadRequestError = if body_slice.is_empty() {
                            // To enable JSON parsing to succeed, replace an empty body
                            // with an empty JSON body. If a member was required, it will fail slightly later
                            // during the operation construction phase.
                            serde_json::from_slice(b"{}")
                                .map_err(crate::error::UpdateIntegrationResponseError::unhandled)?
                        } else {
                            serde_json::from_slice(response.body().as_ref())
                                .map_err(crate::error::UpdateIntegrationResponseError::unhandled)?
                        };

                        output = output.set_message(parsed_body.message);
                        output.build()
                    }),
                },
                "ConflictException" => crate::error::UpdateIntegrationResponseError {
                    meta: generic,
                    kind: crate::error::UpdateIntegrationResponseErrorKind::ConflictError({
                        #[allow(unused_mut)]
                        let mut output = crate::error::conflict_error::Builder::default();
                        let _ = response;

                        let body_slice = response.body().as_ref();

                        let parsed_body: crate::error::ConflictError = if body_slice.is_empty() {
                            // To enable JSON parsing to succeed, replace an empty body
                            // with an empty JSON body. If a member was required, it will fail slightly later
                            // during the operation construction phase.
                            serde_json::from_slice(b"{}")
                                .map_err(crate::error::UpdateIntegrationResponseError::unhandled)?
                        } else {
                            serde_json::from_slice(response.body().as_ref())
                                .map_err(crate::error::UpdateIntegrationResponseError::unhandled)?
                        };

                        output = output.set_message(parsed_body.message);
                        output.build()
                    }),
                },
                "NotFoundException" => crate::error::UpdateIntegrationResponseError {
                    meta: generic,
                    kind: crate::error::UpdateIntegrationResponseErrorKind::NotFoundError({
                        #[allow(unused_mut)]
                        let mut output = crate::error::not_found_error::Builder::default();
                        let _ = response;

                        let body_slice = response.body().as_ref();

                        let parsed_body: crate::error::NotFoundError = if body_slice.is_empty() {
                            // To enable JSON parsing to succeed, replace an empty body
                            // with an empty JSON body. If a member was required, it will fail slightly later
                            // during the operation construction phase.
                            serde_json::from_slice(b"{}")
                                .map_err(crate::error::UpdateIntegrationResponseError::unhandled)?
                        } else {
                            serde_json::from_slice(response.body().as_ref())
                                .map_err(crate::error::UpdateIntegrationResponseError::unhandled)?
                        };

                        output = output.set_message(parsed_body.message);
                        output.build()
                    }),
                },
                "TooManyRequestsException" => crate::error::UpdateIntegrationResponseError {
                    meta: generic,
                    kind: crate::error::UpdateIntegrationResponseErrorKind::TooManyRequestsError({
                        #[allow(unused_mut)]
                        let mut output = crate::error::too_many_requests_error::Builder::default();
                        let _ = response;

                        let body_slice = response.body().as_ref();

                        let parsed_body: crate::error::TooManyRequestsError = if body_slice
                            .is_empty()
                        {
                            // To enable JSON parsing to succeed, replace an empty body
                            // with an empty JSON body. If a member was required, it will fail slightly later
                            // during the operation construction phase.
                            serde_json::from_slice(b"{}")
                                .map_err(crate::error::UpdateIntegrationResponseError::unhandled)?
                        } else {
                            serde_json::from_slice(response.body().as_ref())
                                .map_err(crate::error::UpdateIntegrationResponseError::unhandled)?
                        };

                        output = output.set_retry_after_seconds(
                        
                                                crate::http_serde::deser_header_update_integration_response_retry_after_seconds(response.headers())
                                                    .map_err(|_|crate::error::UpdateIntegrationResponseError::unhandled("Failed to parse retryAfterSeconds from header `Retry-After"))?
                                                
                    );
                        output = output.set_message(parsed_body.message);
                        output.build()
                    }),
                },
                "UnauthorizedException" => crate::error::UpdateIntegrationResponseError {
                    meta: generic,
                    kind: crate::error::UpdateIntegrationResponseErrorKind::UnauthorizedError({
                        #[allow(unused_mut)]
                        let mut output = crate::error::unauthorized_error::Builder::default();
                        let _ = response;

                        let body_slice = response.body().as_ref();

                        let parsed_body: crate::error::UnauthorizedError = if body_slice.is_empty()
                        {
                            // To enable JSON parsing to succeed, replace an empty body
                            // with an empty JSON body. If a member was required, it will fail slightly later
                            // during the operation construction phase.
                            serde_json::from_slice(b"{}")
                                .map_err(crate::error::UpdateIntegrationResponseError::unhandled)?
                        } else {
                            serde_json::from_slice(response.body().as_ref())
                                .map_err(crate::error::UpdateIntegrationResponseError::unhandled)?
                        };

                        output = output.set_message(parsed_body.message);
                        output.build()
                    }),
                },
                _ => crate::error::UpdateIntegrationResponseError::generic(generic),
            });
        }
        Ok({
            #[allow(unused_mut)]
            let mut output = crate::output::update_integration_response_output::Builder::default();
            let _ = response;

            let body_slice = response.body().as_ref();

            let parsed_body: crate::serializer::UpdateIntegrationResponseOutputBody =
                if body_slice.is_empty() {
                    // To enable JSON parsing to succeed, replace an empty body
                    // with an empty JSON body. If a member was required, it will fail slightly later
                    // during the operation construction phase.
                    serde_json::from_slice(b"{}")
                        .map_err(crate::error::UpdateIntegrationResponseError::unhandled)?
                } else {
                    serde_json::from_slice(response.body().as_ref())
                        .map_err(crate::error::UpdateIntegrationResponseError::unhandled)?
                };

            output = output.set_status_code(parsed_body.status_code);
            output = output.set_selection_pattern(parsed_body.selection_pattern);
            output = output.set_response_parameters(parsed_body.response_parameters);
            output = output.set_response_templates(parsed_body.response_templates);
            output = output.set_content_handling(parsed_body.content_handling);
            output.build()
        })
    }
    pub fn parse_response(
        &self,
        response: &http::response::Response<impl AsRef<[u8]>>,
    ) -> Result<
        crate::output::UpdateIntegrationResponseOutput,
        crate::error::UpdateIntegrationResponseError,
    > {
        Self::from_response(&response)
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}

impl smithy_http::response::ParseStrictResponse for UpdateIntegrationResponse {
    type Output = Result<
        crate::output::UpdateIntegrationResponseOutput,
        crate::error::UpdateIntegrationResponseError,
    >;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        self.parse_response(response)
    }
}

/// <p>Updates an existing <a>Method</a> resource.</p>
#[derive(std::clone::Clone)]
pub struct UpdateMethod {
    _private: (),
}
impl UpdateMethod {
    /// Creates a new builder-style object to manufacture [`UpdateMethodInput`](crate::input::UpdateMethodInput)
    pub fn builder() -> crate::input::update_method_input::Builder {
        crate::input::update_method_input::Builder::default()
    }
    #[allow(clippy::unnecessary_wraps)]
    fn from_response(
        response: &http::response::Response<impl AsRef<[u8]>>,
    ) -> Result<crate::output::UpdateMethodOutput, crate::error::UpdateMethodError> {
        if crate::aws_json_errors::is_error(&response) && response.status().as_u16() != 200 {
            let body = serde_json::from_slice(response.body().as_ref())
                .unwrap_or_else(|_| serde_json::json!({}));
            let generic = crate::aws_json_errors::parse_generic_error(&response, &body);

            let error_code = match generic.code() {
                Some(code) => code,
                None => return Err(crate::error::UpdateMethodError::unhandled(generic)),
            };
            return Err(match error_code {
                "BadRequestException" => crate::error::UpdateMethodError {
                    meta: generic,
                    kind: crate::error::UpdateMethodErrorKind::BadRequestError({
                        #[allow(unused_mut)]
                        let mut output = crate::error::bad_request_error::Builder::default();
                        let _ = response;

                        let body_slice = response.body().as_ref();

                        let parsed_body: crate::error::BadRequestError = if body_slice.is_empty() {
                            // To enable JSON parsing to succeed, replace an empty body
                            // with an empty JSON body. If a member was required, it will fail slightly later
                            // during the operation construction phase.
                            serde_json::from_slice(b"{}")
                                .map_err(crate::error::UpdateMethodError::unhandled)?
                        } else {
                            serde_json::from_slice(response.body().as_ref())
                                .map_err(crate::error::UpdateMethodError::unhandled)?
                        };

                        output = output.set_message(parsed_body.message);
                        output.build()
                    }),
                },
                "ConflictException" => crate::error::UpdateMethodError {
                    meta: generic,
                    kind: crate::error::UpdateMethodErrorKind::ConflictError({
                        #[allow(unused_mut)]
                        let mut output = crate::error::conflict_error::Builder::default();
                        let _ = response;

                        let body_slice = response.body().as_ref();

                        let parsed_body: crate::error::ConflictError = if body_slice.is_empty() {
                            // To enable JSON parsing to succeed, replace an empty body
                            // with an empty JSON body. If a member was required, it will fail slightly later
                            // during the operation construction phase.
                            serde_json::from_slice(b"{}")
                                .map_err(crate::error::UpdateMethodError::unhandled)?
                        } else {
                            serde_json::from_slice(response.body().as_ref())
                                .map_err(crate::error::UpdateMethodError::unhandled)?
                        };

                        output = output.set_message(parsed_body.message);
                        output.build()
                    }),
                },
                "NotFoundException" => crate::error::UpdateMethodError {
                    meta: generic,
                    kind: crate::error::UpdateMethodErrorKind::NotFoundError({
                        #[allow(unused_mut)]
                        let mut output = crate::error::not_found_error::Builder::default();
                        let _ = response;

                        let body_slice = response.body().as_ref();

                        let parsed_body: crate::error::NotFoundError = if body_slice.is_empty() {
                            // To enable JSON parsing to succeed, replace an empty body
                            // with an empty JSON body. If a member was required, it will fail slightly later
                            // during the operation construction phase.
                            serde_json::from_slice(b"{}")
                                .map_err(crate::error::UpdateMethodError::unhandled)?
                        } else {
                            serde_json::from_slice(response.body().as_ref())
                                .map_err(crate::error::UpdateMethodError::unhandled)?
                        };

                        output = output.set_message(parsed_body.message);
                        output.build()
                    }),
                },
                "TooManyRequestsException" => {
                    crate::error::UpdateMethodError {
                        meta: generic,
                        kind: crate::error::UpdateMethodErrorKind::TooManyRequestsError({
                            #[allow(unused_mut)]
                            let mut output =
                                crate::error::too_many_requests_error::Builder::default();
                            let _ = response;

                            let body_slice = response.body().as_ref();

                            let parsed_body: crate::error::TooManyRequestsError =
                                if body_slice.is_empty() {
                                    // To enable JSON parsing to succeed, replace an empty body
                                    // with an empty JSON body. If a member was required, it will fail slightly later
                                    // during the operation construction phase.
                                    serde_json::from_slice(b"{}")
                                        .map_err(crate::error::UpdateMethodError::unhandled)?
                                } else {
                                    serde_json::from_slice(response.body().as_ref())
                                        .map_err(crate::error::UpdateMethodError::unhandled)?
                                };

                            output = output.set_retry_after_seconds(
                        
                                                crate::http_serde::deser_header_update_method_retry_after_seconds(response.headers())
                                                    .map_err(|_|crate::error::UpdateMethodError::unhandled("Failed to parse retryAfterSeconds from header `Retry-After"))?
                                                
                    );
                            output = output.set_message(parsed_body.message);
                            output.build()
                        }),
                    }
                }
                "UnauthorizedException" => crate::error::UpdateMethodError {
                    meta: generic,
                    kind: crate::error::UpdateMethodErrorKind::UnauthorizedError({
                        #[allow(unused_mut)]
                        let mut output = crate::error::unauthorized_error::Builder::default();
                        let _ = response;

                        let body_slice = response.body().as_ref();

                        let parsed_body: crate::error::UnauthorizedError = if body_slice.is_empty()
                        {
                            // To enable JSON parsing to succeed, replace an empty body
                            // with an empty JSON body. If a member was required, it will fail slightly later
                            // during the operation construction phase.
                            serde_json::from_slice(b"{}")
                                .map_err(crate::error::UpdateMethodError::unhandled)?
                        } else {
                            serde_json::from_slice(response.body().as_ref())
                                .map_err(crate::error::UpdateMethodError::unhandled)?
                        };

                        output = output.set_message(parsed_body.message);
                        output.build()
                    }),
                },
                _ => crate::error::UpdateMethodError::generic(generic),
            });
        }
        Ok({
            #[allow(unused_mut)]
            let mut output = crate::output::update_method_output::Builder::default();
            let _ = response;

            let body_slice = response.body().as_ref();

            let parsed_body: crate::serializer::UpdateMethodOutputBody = if body_slice.is_empty() {
                // To enable JSON parsing to succeed, replace an empty body
                // with an empty JSON body. If a member was required, it will fail slightly later
                // during the operation construction phase.
                serde_json::from_slice(b"{}").map_err(crate::error::UpdateMethodError::unhandled)?
            } else {
                serde_json::from_slice(response.body().as_ref())
                    .map_err(crate::error::UpdateMethodError::unhandled)?
            };

            output = output.set_http_method(parsed_body.http_method);
            output = output.set_authorization_type(parsed_body.authorization_type);
            output = output.set_authorizer_id(parsed_body.authorizer_id);
            output = output.set_api_key_required(parsed_body.api_key_required);
            output = output.set_request_validator_id(parsed_body.request_validator_id);
            output = output.set_operation_name(parsed_body.operation_name);
            output = output.set_request_parameters(parsed_body.request_parameters);
            output = output.set_request_models(parsed_body.request_models);
            output = output.set_method_responses(parsed_body.method_responses);
            output = output.set_method_integration(parsed_body.method_integration);
            output = output.set_authorization_scopes(parsed_body.authorization_scopes);
            output.build()
        })
    }
    pub fn parse_response(
        &self,
        response: &http::response::Response<impl AsRef<[u8]>>,
    ) -> Result<crate::output::UpdateMethodOutput, crate::error::UpdateMethodError> {
        Self::from_response(&response)
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}

impl smithy_http::response::ParseStrictResponse for UpdateMethod {
    type Output = Result<crate::output::UpdateMethodOutput, crate::error::UpdateMethodError>;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        self.parse_response(response)
    }
}

/// <p>Updates an existing <a>MethodResponse</a> resource.</p>
#[derive(std::clone::Clone)]
pub struct UpdateMethodResponse {
    _private: (),
}
impl UpdateMethodResponse {
    /// Creates a new builder-style object to manufacture [`UpdateMethodResponseInput`](crate::input::UpdateMethodResponseInput)
    pub fn builder() -> crate::input::update_method_response_input::Builder {
        crate::input::update_method_response_input::Builder::default()
    }
    #[allow(clippy::unnecessary_wraps)]
    fn from_response(
        response: &http::response::Response<impl AsRef<[u8]>>,
    ) -> Result<crate::output::UpdateMethodResponseOutput, crate::error::UpdateMethodResponseError>
    {
        if crate::aws_json_errors::is_error(&response) && response.status().as_u16() != 201 {
            let body = serde_json::from_slice(response.body().as_ref())
                .unwrap_or_else(|_| serde_json::json!({}));
            let generic = crate::aws_json_errors::parse_generic_error(&response, &body);

            let error_code = match generic.code() {
                Some(code) => code,
                None => return Err(crate::error::UpdateMethodResponseError::unhandled(generic)),
            };
            return Err(match error_code {
                "BadRequestException" => crate::error::UpdateMethodResponseError {
                    meta: generic,
                    kind: crate::error::UpdateMethodResponseErrorKind::BadRequestError({
                        #[allow(unused_mut)]
                        let mut output = crate::error::bad_request_error::Builder::default();
                        let _ = response;

                        let body_slice = response.body().as_ref();

                        let parsed_body: crate::error::BadRequestError = if body_slice.is_empty() {
                            // To enable JSON parsing to succeed, replace an empty body
                            // with an empty JSON body. If a member was required, it will fail slightly later
                            // during the operation construction phase.
                            serde_json::from_slice(b"{}")
                                .map_err(crate::error::UpdateMethodResponseError::unhandled)?
                        } else {
                            serde_json::from_slice(response.body().as_ref())
                                .map_err(crate::error::UpdateMethodResponseError::unhandled)?
                        };

                        output = output.set_message(parsed_body.message);
                        output.build()
                    }),
                },
                "ConflictException" => crate::error::UpdateMethodResponseError {
                    meta: generic,
                    kind: crate::error::UpdateMethodResponseErrorKind::ConflictError({
                        #[allow(unused_mut)]
                        let mut output = crate::error::conflict_error::Builder::default();
                        let _ = response;

                        let body_slice = response.body().as_ref();

                        let parsed_body: crate::error::ConflictError = if body_slice.is_empty() {
                            // To enable JSON parsing to succeed, replace an empty body
                            // with an empty JSON body. If a member was required, it will fail slightly later
                            // during the operation construction phase.
                            serde_json::from_slice(b"{}")
                                .map_err(crate::error::UpdateMethodResponseError::unhandled)?
                        } else {
                            serde_json::from_slice(response.body().as_ref())
                                .map_err(crate::error::UpdateMethodResponseError::unhandled)?
                        };

                        output = output.set_message(parsed_body.message);
                        output.build()
                    }),
                },
                "LimitExceededException" => crate::error::UpdateMethodResponseError {
                    meta: generic,
                    kind: crate::error::UpdateMethodResponseErrorKind::LimitExceededError({
                        #[allow(unused_mut)]
                        let mut output = crate::error::limit_exceeded_error::Builder::default();
                        let _ = response;

                        let body_slice = response.body().as_ref();

                        let parsed_body: crate::error::LimitExceededError = if body_slice.is_empty()
                        {
                            // To enable JSON parsing to succeed, replace an empty body
                            // with an empty JSON body. If a member was required, it will fail slightly later
                            // during the operation construction phase.
                            serde_json::from_slice(b"{}")
                                .map_err(crate::error::UpdateMethodResponseError::unhandled)?
                        } else {
                            serde_json::from_slice(response.body().as_ref())
                                .map_err(crate::error::UpdateMethodResponseError::unhandled)?
                        };

                        output = output.set_retry_after_seconds(
                        
                                                crate::http_serde::deser_header_update_method_response_retry_after_seconds(response.headers())
                                                    .map_err(|_|crate::error::UpdateMethodResponseError::unhandled("Failed to parse retryAfterSeconds from header `Retry-After"))?
                                                
                    );
                        output = output.set_message(parsed_body.message);
                        output.build()
                    }),
                },
                "NotFoundException" => crate::error::UpdateMethodResponseError {
                    meta: generic,
                    kind: crate::error::UpdateMethodResponseErrorKind::NotFoundError({
                        #[allow(unused_mut)]
                        let mut output = crate::error::not_found_error::Builder::default();
                        let _ = response;

                        let body_slice = response.body().as_ref();

                        let parsed_body: crate::error::NotFoundError = if body_slice.is_empty() {
                            // To enable JSON parsing to succeed, replace an empty body
                            // with an empty JSON body. If a member was required, it will fail slightly later
                            // during the operation construction phase.
                            serde_json::from_slice(b"{}")
                                .map_err(crate::error::UpdateMethodResponseError::unhandled)?
                        } else {
                            serde_json::from_slice(response.body().as_ref())
                                .map_err(crate::error::UpdateMethodResponseError::unhandled)?
                        };

                        output = output.set_message(parsed_body.message);
                        output.build()
                    }),
                },
                "TooManyRequestsException" => crate::error::UpdateMethodResponseError {
                    meta: generic,
                    kind: crate::error::UpdateMethodResponseErrorKind::TooManyRequestsError({
                        #[allow(unused_mut)]
                        let mut output = crate::error::too_many_requests_error::Builder::default();
                        let _ = response;

                        let body_slice = response.body().as_ref();

                        let parsed_body: crate::error::TooManyRequestsError =
                            if body_slice.is_empty() {
                                // To enable JSON parsing to succeed, replace an empty body
                                // with an empty JSON body. If a member was required, it will fail slightly later
                                // during the operation construction phase.
                                serde_json::from_slice(b"{}")
                                    .map_err(crate::error::UpdateMethodResponseError::unhandled)?
                            } else {
                                serde_json::from_slice(response.body().as_ref())
                                    .map_err(crate::error::UpdateMethodResponseError::unhandled)?
                            };

                        output = output.set_retry_after_seconds(
                        
                                                crate::http_serde::deser_header_update_method_response_retry_after_seconds(response.headers())
                                                    .map_err(|_|crate::error::UpdateMethodResponseError::unhandled("Failed to parse retryAfterSeconds from header `Retry-After"))?
                                                
                    );
                        output = output.set_message(parsed_body.message);
                        output.build()
                    }),
                },
                "UnauthorizedException" => crate::error::UpdateMethodResponseError {
                    meta: generic,
                    kind: crate::error::UpdateMethodResponseErrorKind::UnauthorizedError({
                        #[allow(unused_mut)]
                        let mut output = crate::error::unauthorized_error::Builder::default();
                        let _ = response;

                        let body_slice = response.body().as_ref();

                        let parsed_body: crate::error::UnauthorizedError = if body_slice.is_empty()
                        {
                            // To enable JSON parsing to succeed, replace an empty body
                            // with an empty JSON body. If a member was required, it will fail slightly later
                            // during the operation construction phase.
                            serde_json::from_slice(b"{}")
                                .map_err(crate::error::UpdateMethodResponseError::unhandled)?
                        } else {
                            serde_json::from_slice(response.body().as_ref())
                                .map_err(crate::error::UpdateMethodResponseError::unhandled)?
                        };

                        output = output.set_message(parsed_body.message);
                        output.build()
                    }),
                },
                _ => crate::error::UpdateMethodResponseError::generic(generic),
            });
        }
        Ok({
            #[allow(unused_mut)]
            let mut output = crate::output::update_method_response_output::Builder::default();
            let _ = response;

            let body_slice = response.body().as_ref();

            let parsed_body: crate::serializer::UpdateMethodResponseOutputBody =
                if body_slice.is_empty() {
                    // To enable JSON parsing to succeed, replace an empty body
                    // with an empty JSON body. If a member was required, it will fail slightly later
                    // during the operation construction phase.
                    serde_json::from_slice(b"{}")
                        .map_err(crate::error::UpdateMethodResponseError::unhandled)?
                } else {
                    serde_json::from_slice(response.body().as_ref())
                        .map_err(crate::error::UpdateMethodResponseError::unhandled)?
                };

            output = output.set_status_code(parsed_body.status_code);
            output = output.set_response_parameters(parsed_body.response_parameters);
            output = output.set_response_models(parsed_body.response_models);
            output.build()
        })
    }
    pub fn parse_response(
        &self,
        response: &http::response::Response<impl AsRef<[u8]>>,
    ) -> Result<crate::output::UpdateMethodResponseOutput, crate::error::UpdateMethodResponseError>
    {
        Self::from_response(&response)
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}

impl smithy_http::response::ParseStrictResponse for UpdateMethodResponse {
    type Output =
        Result<crate::output::UpdateMethodResponseOutput, crate::error::UpdateMethodResponseError>;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        self.parse_response(response)
    }
}

/// <p>Changes information about a model.</p>
#[derive(std::clone::Clone)]
pub struct UpdateModel {
    _private: (),
}
impl UpdateModel {
    /// Creates a new builder-style object to manufacture [`UpdateModelInput`](crate::input::UpdateModelInput)
    pub fn builder() -> crate::input::update_model_input::Builder {
        crate::input::update_model_input::Builder::default()
    }
    #[allow(clippy::unnecessary_wraps)]
    fn from_response(
        response: &http::response::Response<impl AsRef<[u8]>>,
    ) -> Result<crate::output::UpdateModelOutput, crate::error::UpdateModelError> {
        if crate::aws_json_errors::is_error(&response) && response.status().as_u16() != 200 {
            let body = serde_json::from_slice(response.body().as_ref())
                .unwrap_or_else(|_| serde_json::json!({}));
            let generic = crate::aws_json_errors::parse_generic_error(&response, &body);

            let error_code = match generic.code() {
                Some(code) => code,
                None => return Err(crate::error::UpdateModelError::unhandled(generic)),
            };
            return Err(match error_code {
                "BadRequestException" => crate::error::UpdateModelError {
                    meta: generic,
                    kind: crate::error::UpdateModelErrorKind::BadRequestError({
                        #[allow(unused_mut)]
                        let mut output = crate::error::bad_request_error::Builder::default();
                        let _ = response;

                        let body_slice = response.body().as_ref();

                        let parsed_body: crate::error::BadRequestError = if body_slice.is_empty() {
                            // To enable JSON parsing to succeed, replace an empty body
                            // with an empty JSON body. If a member was required, it will fail slightly later
                            // during the operation construction phase.
                            serde_json::from_slice(b"{}")
                                .map_err(crate::error::UpdateModelError::unhandled)?
                        } else {
                            serde_json::from_slice(response.body().as_ref())
                                .map_err(crate::error::UpdateModelError::unhandled)?
                        };

                        output = output.set_message(parsed_body.message);
                        output.build()
                    }),
                },
                "ConflictException" => crate::error::UpdateModelError {
                    meta: generic,
                    kind: crate::error::UpdateModelErrorKind::ConflictError({
                        #[allow(unused_mut)]
                        let mut output = crate::error::conflict_error::Builder::default();
                        let _ = response;

                        let body_slice = response.body().as_ref();

                        let parsed_body: crate::error::ConflictError = if body_slice.is_empty() {
                            // To enable JSON parsing to succeed, replace an empty body
                            // with an empty JSON body. If a member was required, it will fail slightly later
                            // during the operation construction phase.
                            serde_json::from_slice(b"{}")
                                .map_err(crate::error::UpdateModelError::unhandled)?
                        } else {
                            serde_json::from_slice(response.body().as_ref())
                                .map_err(crate::error::UpdateModelError::unhandled)?
                        };

                        output = output.set_message(parsed_body.message);
                        output.build()
                    }),
                },
                "NotFoundException" => crate::error::UpdateModelError {
                    meta: generic,
                    kind: crate::error::UpdateModelErrorKind::NotFoundError({
                        #[allow(unused_mut)]
                        let mut output = crate::error::not_found_error::Builder::default();
                        let _ = response;

                        let body_slice = response.body().as_ref();

                        let parsed_body: crate::error::NotFoundError = if body_slice.is_empty() {
                            // To enable JSON parsing to succeed, replace an empty body
                            // with an empty JSON body. If a member was required, it will fail slightly later
                            // during the operation construction phase.
                            serde_json::from_slice(b"{}")
                                .map_err(crate::error::UpdateModelError::unhandled)?
                        } else {
                            serde_json::from_slice(response.body().as_ref())
                                .map_err(crate::error::UpdateModelError::unhandled)?
                        };

                        output = output.set_message(parsed_body.message);
                        output.build()
                    }),
                },
                "TooManyRequestsException" => {
                    crate::error::UpdateModelError {
                        meta: generic,
                        kind: crate::error::UpdateModelErrorKind::TooManyRequestsError({
                            #[allow(unused_mut)]
                            let mut output =
                                crate::error::too_many_requests_error::Builder::default();
                            let _ = response;

                            let body_slice = response.body().as_ref();

                            let parsed_body: crate::error::TooManyRequestsError =
                                if body_slice.is_empty() {
                                    // To enable JSON parsing to succeed, replace an empty body
                                    // with an empty JSON body. If a member was required, it will fail slightly later
                                    // during the operation construction phase.
                                    serde_json::from_slice(b"{}")
                                        .map_err(crate::error::UpdateModelError::unhandled)?
                                } else {
                                    serde_json::from_slice(response.body().as_ref())
                                        .map_err(crate::error::UpdateModelError::unhandled)?
                                };

                            output = output.set_retry_after_seconds(
                        
                                                crate::http_serde::deser_header_update_model_retry_after_seconds(response.headers())
                                                    .map_err(|_|crate::error::UpdateModelError::unhandled("Failed to parse retryAfterSeconds from header `Retry-After"))?
                                                
                    );
                            output = output.set_message(parsed_body.message);
                            output.build()
                        }),
                    }
                }
                "UnauthorizedException" => crate::error::UpdateModelError {
                    meta: generic,
                    kind: crate::error::UpdateModelErrorKind::UnauthorizedError({
                        #[allow(unused_mut)]
                        let mut output = crate::error::unauthorized_error::Builder::default();
                        let _ = response;

                        let body_slice = response.body().as_ref();

                        let parsed_body: crate::error::UnauthorizedError = if body_slice.is_empty()
                        {
                            // To enable JSON parsing to succeed, replace an empty body
                            // with an empty JSON body. If a member was required, it will fail slightly later
                            // during the operation construction phase.
                            serde_json::from_slice(b"{}")
                                .map_err(crate::error::UpdateModelError::unhandled)?
                        } else {
                            serde_json::from_slice(response.body().as_ref())
                                .map_err(crate::error::UpdateModelError::unhandled)?
                        };

                        output = output.set_message(parsed_body.message);
                        output.build()
                    }),
                },
                _ => crate::error::UpdateModelError::generic(generic),
            });
        }
        Ok({
            #[allow(unused_mut)]
            let mut output = crate::output::update_model_output::Builder::default();
            let _ = response;

            let body_slice = response.body().as_ref();

            let parsed_body: crate::serializer::UpdateModelOutputBody = if body_slice.is_empty() {
                // To enable JSON parsing to succeed, replace an empty body
                // with an empty JSON body. If a member was required, it will fail slightly later
                // during the operation construction phase.
                serde_json::from_slice(b"{}").map_err(crate::error::UpdateModelError::unhandled)?
            } else {
                serde_json::from_slice(response.body().as_ref())
                    .map_err(crate::error::UpdateModelError::unhandled)?
            };

            output = output.set_id(parsed_body.id);
            output = output.set_name(parsed_body.name);
            output = output.set_description(parsed_body.description);
            output = output.set_schema(parsed_body.schema);
            output = output.set_content_type(parsed_body.content_type);
            output.build()
        })
    }
    pub fn parse_response(
        &self,
        response: &http::response::Response<impl AsRef<[u8]>>,
    ) -> Result<crate::output::UpdateModelOutput, crate::error::UpdateModelError> {
        Self::from_response(&response)
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}

impl smithy_http::response::ParseStrictResponse for UpdateModel {
    type Output = Result<crate::output::UpdateModelOutput, crate::error::UpdateModelError>;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        self.parse_response(response)
    }
}

/// <p>Updates a <a>RequestValidator</a> of a given <a>RestApi</a>.</p>
#[derive(std::clone::Clone)]
pub struct UpdateRequestValidator {
    _private: (),
}
impl UpdateRequestValidator {
    /// Creates a new builder-style object to manufacture [`UpdateRequestValidatorInput`](crate::input::UpdateRequestValidatorInput)
    pub fn builder() -> crate::input::update_request_validator_input::Builder {
        crate::input::update_request_validator_input::Builder::default()
    }
    #[allow(clippy::unnecessary_wraps)]
    fn from_response(
        response: &http::response::Response<impl AsRef<[u8]>>,
    ) -> Result<
        crate::output::UpdateRequestValidatorOutput,
        crate::error::UpdateRequestValidatorError,
    > {
        if crate::aws_json_errors::is_error(&response) && response.status().as_u16() != 200 {
            let body = serde_json::from_slice(response.body().as_ref())
                .unwrap_or_else(|_| serde_json::json!({}));
            let generic = crate::aws_json_errors::parse_generic_error(&response, &body);

            let error_code = match generic.code() {
                Some(code) => code,
                None => {
                    return Err(crate::error::UpdateRequestValidatorError::unhandled(
                        generic,
                    ))
                }
            };
            return Err(match error_code {
                "BadRequestException" => crate::error::UpdateRequestValidatorError {
                    meta: generic,
                    kind: crate::error::UpdateRequestValidatorErrorKind::BadRequestError({
                        #[allow(unused_mut)]
                        let mut output = crate::error::bad_request_error::Builder::default();
                        let _ = response;

                        let body_slice = response.body().as_ref();

                        let parsed_body: crate::error::BadRequestError = if body_slice.is_empty() {
                            // To enable JSON parsing to succeed, replace an empty body
                            // with an empty JSON body. If a member was required, it will fail slightly later
                            // during the operation construction phase.
                            serde_json::from_slice(b"{}")
                                .map_err(crate::error::UpdateRequestValidatorError::unhandled)?
                        } else {
                            serde_json::from_slice(response.body().as_ref())
                                .map_err(crate::error::UpdateRequestValidatorError::unhandled)?
                        };

                        output = output.set_message(parsed_body.message);
                        output.build()
                    }),
                },
                "NotFoundException" => crate::error::UpdateRequestValidatorError {
                    meta: generic,
                    kind: crate::error::UpdateRequestValidatorErrorKind::NotFoundError({
                        #[allow(unused_mut)]
                        let mut output = crate::error::not_found_error::Builder::default();
                        let _ = response;

                        let body_slice = response.body().as_ref();

                        let parsed_body: crate::error::NotFoundError = if body_slice.is_empty() {
                            // To enable JSON parsing to succeed, replace an empty body
                            // with an empty JSON body. If a member was required, it will fail slightly later
                            // during the operation construction phase.
                            serde_json::from_slice(b"{}")
                                .map_err(crate::error::UpdateRequestValidatorError::unhandled)?
                        } else {
                            serde_json::from_slice(response.body().as_ref())
                                .map_err(crate::error::UpdateRequestValidatorError::unhandled)?
                        };

                        output = output.set_message(parsed_body.message);
                        output.build()
                    }),
                },
                "TooManyRequestsException" => crate::error::UpdateRequestValidatorError {
                    meta: generic,
                    kind: crate::error::UpdateRequestValidatorErrorKind::TooManyRequestsError({
                        #[allow(unused_mut)]
                        let mut output = crate::error::too_many_requests_error::Builder::default();
                        let _ = response;

                        let body_slice = response.body().as_ref();

                        let parsed_body: crate::error::TooManyRequestsError =
                            if body_slice.is_empty() {
                                // To enable JSON parsing to succeed, replace an empty body
                                // with an empty JSON body. If a member was required, it will fail slightly later
                                // during the operation construction phase.
                                serde_json::from_slice(b"{}")
                                    .map_err(crate::error::UpdateRequestValidatorError::unhandled)?
                            } else {
                                serde_json::from_slice(response.body().as_ref())
                                    .map_err(crate::error::UpdateRequestValidatorError::unhandled)?
                            };

                        output = output.set_retry_after_seconds(
                        
                                                crate::http_serde::deser_header_update_request_validator_retry_after_seconds(response.headers())
                                                    .map_err(|_|crate::error::UpdateRequestValidatorError::unhandled("Failed to parse retryAfterSeconds from header `Retry-After"))?
                                                
                    );
                        output = output.set_message(parsed_body.message);
                        output.build()
                    }),
                },
                "UnauthorizedException" => crate::error::UpdateRequestValidatorError {
                    meta: generic,
                    kind: crate::error::UpdateRequestValidatorErrorKind::UnauthorizedError({
                        #[allow(unused_mut)]
                        let mut output = crate::error::unauthorized_error::Builder::default();
                        let _ = response;

                        let body_slice = response.body().as_ref();

                        let parsed_body: crate::error::UnauthorizedError = if body_slice.is_empty()
                        {
                            // To enable JSON parsing to succeed, replace an empty body
                            // with an empty JSON body. If a member was required, it will fail slightly later
                            // during the operation construction phase.
                            serde_json::from_slice(b"{}")
                                .map_err(crate::error::UpdateRequestValidatorError::unhandled)?
                        } else {
                            serde_json::from_slice(response.body().as_ref())
                                .map_err(crate::error::UpdateRequestValidatorError::unhandled)?
                        };

                        output = output.set_message(parsed_body.message);
                        output.build()
                    }),
                },
                _ => crate::error::UpdateRequestValidatorError::generic(generic),
            });
        }
        Ok({
            #[allow(unused_mut)]
            let mut output = crate::output::update_request_validator_output::Builder::default();
            let _ = response;

            let body_slice = response.body().as_ref();

            let parsed_body: crate::serializer::UpdateRequestValidatorOutputBody =
                if body_slice.is_empty() {
                    // To enable JSON parsing to succeed, replace an empty body
                    // with an empty JSON body. If a member was required, it will fail slightly later
                    // during the operation construction phase.
                    serde_json::from_slice(b"{}")
                        .map_err(crate::error::UpdateRequestValidatorError::unhandled)?
                } else {
                    serde_json::from_slice(response.body().as_ref())
                        .map_err(crate::error::UpdateRequestValidatorError::unhandled)?
                };

            output = output.set_id(parsed_body.id);
            output = output.set_name(parsed_body.name);
            output = output.set_validate_request_body(parsed_body.validate_request_body);
            output =
                output.set_validate_request_parameters(parsed_body.validate_request_parameters);
            output.build()
        })
    }
    pub fn parse_response(
        &self,
        response: &http::response::Response<impl AsRef<[u8]>>,
    ) -> Result<
        crate::output::UpdateRequestValidatorOutput,
        crate::error::UpdateRequestValidatorError,
    > {
        Self::from_response(&response)
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}

impl smithy_http::response::ParseStrictResponse for UpdateRequestValidator {
    type Output = Result<
        crate::output::UpdateRequestValidatorOutput,
        crate::error::UpdateRequestValidatorError,
    >;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        self.parse_response(response)
    }
}

/// <p>Changes information about a <a>Resource</a> resource.</p>
#[derive(std::clone::Clone)]
pub struct UpdateResource {
    _private: (),
}
impl UpdateResource {
    /// Creates a new builder-style object to manufacture [`UpdateResourceInput`](crate::input::UpdateResourceInput)
    pub fn builder() -> crate::input::update_resource_input::Builder {
        crate::input::update_resource_input::Builder::default()
    }
    #[allow(clippy::unnecessary_wraps)]
    fn from_response(
        response: &http::response::Response<impl AsRef<[u8]>>,
    ) -> Result<crate::output::UpdateResourceOutput, crate::error::UpdateResourceError> {
        if crate::aws_json_errors::is_error(&response) && response.status().as_u16() != 200 {
            let body = serde_json::from_slice(response.body().as_ref())
                .unwrap_or_else(|_| serde_json::json!({}));
            let generic = crate::aws_json_errors::parse_generic_error(&response, &body);

            let error_code = match generic.code() {
                Some(code) => code,
                None => return Err(crate::error::UpdateResourceError::unhandled(generic)),
            };
            return Err(match error_code {
                "BadRequestException" => crate::error::UpdateResourceError {
                    meta: generic,
                    kind: crate::error::UpdateResourceErrorKind::BadRequestError({
                        #[allow(unused_mut)]
                        let mut output = crate::error::bad_request_error::Builder::default();
                        let _ = response;

                        let body_slice = response.body().as_ref();

                        let parsed_body: crate::error::BadRequestError = if body_slice.is_empty() {
                            // To enable JSON parsing to succeed, replace an empty body
                            // with an empty JSON body. If a member was required, it will fail slightly later
                            // during the operation construction phase.
                            serde_json::from_slice(b"{}")
                                .map_err(crate::error::UpdateResourceError::unhandled)?
                        } else {
                            serde_json::from_slice(response.body().as_ref())
                                .map_err(crate::error::UpdateResourceError::unhandled)?
                        };

                        output = output.set_message(parsed_body.message);
                        output.build()
                    }),
                },
                "ConflictException" => crate::error::UpdateResourceError {
                    meta: generic,
                    kind: crate::error::UpdateResourceErrorKind::ConflictError({
                        #[allow(unused_mut)]
                        let mut output = crate::error::conflict_error::Builder::default();
                        let _ = response;

                        let body_slice = response.body().as_ref();

                        let parsed_body: crate::error::ConflictError = if body_slice.is_empty() {
                            // To enable JSON parsing to succeed, replace an empty body
                            // with an empty JSON body. If a member was required, it will fail slightly later
                            // during the operation construction phase.
                            serde_json::from_slice(b"{}")
                                .map_err(crate::error::UpdateResourceError::unhandled)?
                        } else {
                            serde_json::from_slice(response.body().as_ref())
                                .map_err(crate::error::UpdateResourceError::unhandled)?
                        };

                        output = output.set_message(parsed_body.message);
                        output.build()
                    }),
                },
                "NotFoundException" => crate::error::UpdateResourceError {
                    meta: generic,
                    kind: crate::error::UpdateResourceErrorKind::NotFoundError({
                        #[allow(unused_mut)]
                        let mut output = crate::error::not_found_error::Builder::default();
                        let _ = response;

                        let body_slice = response.body().as_ref();

                        let parsed_body: crate::error::NotFoundError = if body_slice.is_empty() {
                            // To enable JSON parsing to succeed, replace an empty body
                            // with an empty JSON body. If a member was required, it will fail slightly later
                            // during the operation construction phase.
                            serde_json::from_slice(b"{}")
                                .map_err(crate::error::UpdateResourceError::unhandled)?
                        } else {
                            serde_json::from_slice(response.body().as_ref())
                                .map_err(crate::error::UpdateResourceError::unhandled)?
                        };

                        output = output.set_message(parsed_body.message);
                        output.build()
                    }),
                },
                "TooManyRequestsException" => {
                    crate::error::UpdateResourceError {
                        meta: generic,
                        kind: crate::error::UpdateResourceErrorKind::TooManyRequestsError({
                            #[allow(unused_mut)]
                            let mut output =
                                crate::error::too_many_requests_error::Builder::default();
                            let _ = response;

                            let body_slice = response.body().as_ref();

                            let parsed_body: crate::error::TooManyRequestsError =
                                if body_slice.is_empty() {
                                    // To enable JSON parsing to succeed, replace an empty body
                                    // with an empty JSON body. If a member was required, it will fail slightly later
                                    // during the operation construction phase.
                                    serde_json::from_slice(b"{}")
                                        .map_err(crate::error::UpdateResourceError::unhandled)?
                                } else {
                                    serde_json::from_slice(response.body().as_ref())
                                        .map_err(crate::error::UpdateResourceError::unhandled)?
                                };

                            output = output.set_retry_after_seconds(
                        
                                                crate::http_serde::deser_header_update_resource_retry_after_seconds(response.headers())
                                                    .map_err(|_|crate::error::UpdateResourceError::unhandled("Failed to parse retryAfterSeconds from header `Retry-After"))?
                                                
                    );
                            output = output.set_message(parsed_body.message);
                            output.build()
                        }),
                    }
                }
                "UnauthorizedException" => crate::error::UpdateResourceError {
                    meta: generic,
                    kind: crate::error::UpdateResourceErrorKind::UnauthorizedError({
                        #[allow(unused_mut)]
                        let mut output = crate::error::unauthorized_error::Builder::default();
                        let _ = response;

                        let body_slice = response.body().as_ref();

                        let parsed_body: crate::error::UnauthorizedError = if body_slice.is_empty()
                        {
                            // To enable JSON parsing to succeed, replace an empty body
                            // with an empty JSON body. If a member was required, it will fail slightly later
                            // during the operation construction phase.
                            serde_json::from_slice(b"{}")
                                .map_err(crate::error::UpdateResourceError::unhandled)?
                        } else {
                            serde_json::from_slice(response.body().as_ref())
                                .map_err(crate::error::UpdateResourceError::unhandled)?
                        };

                        output = output.set_message(parsed_body.message);
                        output.build()
                    }),
                },
                _ => crate::error::UpdateResourceError::generic(generic),
            });
        }
        Ok({
            #[allow(unused_mut)]
            let mut output = crate::output::update_resource_output::Builder::default();
            let _ = response;

            let body_slice = response.body().as_ref();

            let parsed_body: crate::serializer::UpdateResourceOutputBody = if body_slice.is_empty()
            {
                // To enable JSON parsing to succeed, replace an empty body
                // with an empty JSON body. If a member was required, it will fail slightly later
                // during the operation construction phase.
                serde_json::from_slice(b"{}")
                    .map_err(crate::error::UpdateResourceError::unhandled)?
            } else {
                serde_json::from_slice(response.body().as_ref())
                    .map_err(crate::error::UpdateResourceError::unhandled)?
            };

            output = output.set_id(parsed_body.id);
            output = output.set_parent_id(parsed_body.parent_id);
            output = output.set_path_part(parsed_body.path_part);
            output = output.set_path(parsed_body.path);
            output = output.set_resource_methods(parsed_body.resource_methods);
            output.build()
        })
    }
    pub fn parse_response(
        &self,
        response: &http::response::Response<impl AsRef<[u8]>>,
    ) -> Result<crate::output::UpdateResourceOutput, crate::error::UpdateResourceError> {
        Self::from_response(&response)
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}

impl smithy_http::response::ParseStrictResponse for UpdateResource {
    type Output = Result<crate::output::UpdateResourceOutput, crate::error::UpdateResourceError>;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        self.parse_response(response)
    }
}

/// <p>Changes information about the specified API.</p>
#[derive(std::clone::Clone)]
pub struct UpdateRestApi {
    _private: (),
}
impl UpdateRestApi {
    /// Creates a new builder-style object to manufacture [`UpdateRestApiInput`](crate::input::UpdateRestApiInput)
    pub fn builder() -> crate::input::update_rest_api_input::Builder {
        crate::input::update_rest_api_input::Builder::default()
    }
    #[allow(clippy::unnecessary_wraps)]
    fn from_response(
        response: &http::response::Response<impl AsRef<[u8]>>,
    ) -> Result<crate::output::UpdateRestApiOutput, crate::error::UpdateRestApiError> {
        if crate::aws_json_errors::is_error(&response) && response.status().as_u16() != 200 {
            let body = serde_json::from_slice(response.body().as_ref())
                .unwrap_or_else(|_| serde_json::json!({}));
            let generic = crate::aws_json_errors::parse_generic_error(&response, &body);

            let error_code = match generic.code() {
                Some(code) => code,
                None => return Err(crate::error::UpdateRestApiError::unhandled(generic)),
            };
            return Err(match error_code {
                "BadRequestException" => crate::error::UpdateRestApiError {
                    meta: generic,
                    kind: crate::error::UpdateRestApiErrorKind::BadRequestError({
                        #[allow(unused_mut)]
                        let mut output = crate::error::bad_request_error::Builder::default();
                        let _ = response;

                        let body_slice = response.body().as_ref();

                        let parsed_body: crate::error::BadRequestError = if body_slice.is_empty() {
                            // To enable JSON parsing to succeed, replace an empty body
                            // with an empty JSON body. If a member was required, it will fail slightly later
                            // during the operation construction phase.
                            serde_json::from_slice(b"{}")
                                .map_err(crate::error::UpdateRestApiError::unhandled)?
                        } else {
                            serde_json::from_slice(response.body().as_ref())
                                .map_err(crate::error::UpdateRestApiError::unhandled)?
                        };

                        output = output.set_message(parsed_body.message);
                        output.build()
                    }),
                },
                "ConflictException" => crate::error::UpdateRestApiError {
                    meta: generic,
                    kind: crate::error::UpdateRestApiErrorKind::ConflictError({
                        #[allow(unused_mut)]
                        let mut output = crate::error::conflict_error::Builder::default();
                        let _ = response;

                        let body_slice = response.body().as_ref();

                        let parsed_body: crate::error::ConflictError = if body_slice.is_empty() {
                            // To enable JSON parsing to succeed, replace an empty body
                            // with an empty JSON body. If a member was required, it will fail slightly later
                            // during the operation construction phase.
                            serde_json::from_slice(b"{}")
                                .map_err(crate::error::UpdateRestApiError::unhandled)?
                        } else {
                            serde_json::from_slice(response.body().as_ref())
                                .map_err(crate::error::UpdateRestApiError::unhandled)?
                        };

                        output = output.set_message(parsed_body.message);
                        output.build()
                    }),
                },
                "NotFoundException" => crate::error::UpdateRestApiError {
                    meta: generic,
                    kind: crate::error::UpdateRestApiErrorKind::NotFoundError({
                        #[allow(unused_mut)]
                        let mut output = crate::error::not_found_error::Builder::default();
                        let _ = response;

                        let body_slice = response.body().as_ref();

                        let parsed_body: crate::error::NotFoundError = if body_slice.is_empty() {
                            // To enable JSON parsing to succeed, replace an empty body
                            // with an empty JSON body. If a member was required, it will fail slightly later
                            // during the operation construction phase.
                            serde_json::from_slice(b"{}")
                                .map_err(crate::error::UpdateRestApiError::unhandled)?
                        } else {
                            serde_json::from_slice(response.body().as_ref())
                                .map_err(crate::error::UpdateRestApiError::unhandled)?
                        };

                        output = output.set_message(parsed_body.message);
                        output.build()
                    }),
                },
                "TooManyRequestsException" => {
                    crate::error::UpdateRestApiError {
                        meta: generic,
                        kind: crate::error::UpdateRestApiErrorKind::TooManyRequestsError({
                            #[allow(unused_mut)]
                            let mut output =
                                crate::error::too_many_requests_error::Builder::default();
                            let _ = response;

                            let body_slice = response.body().as_ref();

                            let parsed_body: crate::error::TooManyRequestsError =
                                if body_slice.is_empty() {
                                    // To enable JSON parsing to succeed, replace an empty body
                                    // with an empty JSON body. If a member was required, it will fail slightly later
                                    // during the operation construction phase.
                                    serde_json::from_slice(b"{}")
                                        .map_err(crate::error::UpdateRestApiError::unhandled)?
                                } else {
                                    serde_json::from_slice(response.body().as_ref())
                                        .map_err(crate::error::UpdateRestApiError::unhandled)?
                                };

                            output = output.set_retry_after_seconds(
                        
                                                crate::http_serde::deser_header_update_rest_api_retry_after_seconds(response.headers())
                                                    .map_err(|_|crate::error::UpdateRestApiError::unhandled("Failed to parse retryAfterSeconds from header `Retry-After"))?
                                                
                    );
                            output = output.set_message(parsed_body.message);
                            output.build()
                        }),
                    }
                }
                "UnauthorizedException" => crate::error::UpdateRestApiError {
                    meta: generic,
                    kind: crate::error::UpdateRestApiErrorKind::UnauthorizedError({
                        #[allow(unused_mut)]
                        let mut output = crate::error::unauthorized_error::Builder::default();
                        let _ = response;

                        let body_slice = response.body().as_ref();

                        let parsed_body: crate::error::UnauthorizedError = if body_slice.is_empty()
                        {
                            // To enable JSON parsing to succeed, replace an empty body
                            // with an empty JSON body. If a member was required, it will fail slightly later
                            // during the operation construction phase.
                            serde_json::from_slice(b"{}")
                                .map_err(crate::error::UpdateRestApiError::unhandled)?
                        } else {
                            serde_json::from_slice(response.body().as_ref())
                                .map_err(crate::error::UpdateRestApiError::unhandled)?
                        };

                        output = output.set_message(parsed_body.message);
                        output.build()
                    }),
                },
                _ => crate::error::UpdateRestApiError::generic(generic),
            });
        }
        Ok({
            #[allow(unused_mut)]
            let mut output = crate::output::update_rest_api_output::Builder::default();
            let _ = response;

            let body_slice = response.body().as_ref();

            let parsed_body: crate::serializer::UpdateRestApiOutputBody = if body_slice.is_empty() {
                // To enable JSON parsing to succeed, replace an empty body
                // with an empty JSON body. If a member was required, it will fail slightly later
                // during the operation construction phase.
                serde_json::from_slice(b"{}")
                    .map_err(crate::error::UpdateRestApiError::unhandled)?
            } else {
                serde_json::from_slice(response.body().as_ref())
                    .map_err(crate::error::UpdateRestApiError::unhandled)?
            };

            output = output.set_id(parsed_body.id);
            output = output.set_name(parsed_body.name);
            output = output.set_description(parsed_body.description);
            output = output.set_created_date(parsed_body.created_date);
            output = output.set_version(parsed_body.version);
            output = output.set_warnings(parsed_body.warnings);
            output = output.set_binary_media_types(parsed_body.binary_media_types);
            output = output.set_minimum_compression_size(parsed_body.minimum_compression_size);
            output = output.set_api_key_source(parsed_body.api_key_source);
            output = output.set_endpoint_configuration(parsed_body.endpoint_configuration);
            output = output.set_policy(parsed_body.policy);
            output = output.set_tags(parsed_body.tags);
            output =
                output.set_disable_execute_api_endpoint(parsed_body.disable_execute_api_endpoint);
            output.build()
        })
    }
    pub fn parse_response(
        &self,
        response: &http::response::Response<impl AsRef<[u8]>>,
    ) -> Result<crate::output::UpdateRestApiOutput, crate::error::UpdateRestApiError> {
        Self::from_response(&response)
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}

impl smithy_http::response::ParseStrictResponse for UpdateRestApi {
    type Output = Result<crate::output::UpdateRestApiOutput, crate::error::UpdateRestApiError>;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        self.parse_response(response)
    }
}

/// <p>Changes information about a <a>Stage</a> resource.</p>
#[derive(std::clone::Clone)]
pub struct UpdateStage {
    _private: (),
}
impl UpdateStage {
    /// Creates a new builder-style object to manufacture [`UpdateStageInput`](crate::input::UpdateStageInput)
    pub fn builder() -> crate::input::update_stage_input::Builder {
        crate::input::update_stage_input::Builder::default()
    }
    #[allow(clippy::unnecessary_wraps)]
    fn from_response(
        response: &http::response::Response<impl AsRef<[u8]>>,
    ) -> Result<crate::output::UpdateStageOutput, crate::error::UpdateStageError> {
        if crate::aws_json_errors::is_error(&response) && response.status().as_u16() != 200 {
            let body = serde_json::from_slice(response.body().as_ref())
                .unwrap_or_else(|_| serde_json::json!({}));
            let generic = crate::aws_json_errors::parse_generic_error(&response, &body);

            let error_code = match generic.code() {
                Some(code) => code,
                None => return Err(crate::error::UpdateStageError::unhandled(generic)),
            };
            return Err(match error_code {
                "BadRequestException" => crate::error::UpdateStageError {
                    meta: generic,
                    kind: crate::error::UpdateStageErrorKind::BadRequestError({
                        #[allow(unused_mut)]
                        let mut output = crate::error::bad_request_error::Builder::default();
                        let _ = response;

                        let body_slice = response.body().as_ref();

                        let parsed_body: crate::error::BadRequestError = if body_slice.is_empty() {
                            // To enable JSON parsing to succeed, replace an empty body
                            // with an empty JSON body. If a member was required, it will fail slightly later
                            // during the operation construction phase.
                            serde_json::from_slice(b"{}")
                                .map_err(crate::error::UpdateStageError::unhandled)?
                        } else {
                            serde_json::from_slice(response.body().as_ref())
                                .map_err(crate::error::UpdateStageError::unhandled)?
                        };

                        output = output.set_message(parsed_body.message);
                        output.build()
                    }),
                },
                "ConflictException" => crate::error::UpdateStageError {
                    meta: generic,
                    kind: crate::error::UpdateStageErrorKind::ConflictError({
                        #[allow(unused_mut)]
                        let mut output = crate::error::conflict_error::Builder::default();
                        let _ = response;

                        let body_slice = response.body().as_ref();

                        let parsed_body: crate::error::ConflictError = if body_slice.is_empty() {
                            // To enable JSON parsing to succeed, replace an empty body
                            // with an empty JSON body. If a member was required, it will fail slightly later
                            // during the operation construction phase.
                            serde_json::from_slice(b"{}")
                                .map_err(crate::error::UpdateStageError::unhandled)?
                        } else {
                            serde_json::from_slice(response.body().as_ref())
                                .map_err(crate::error::UpdateStageError::unhandled)?
                        };

                        output = output.set_message(parsed_body.message);
                        output.build()
                    }),
                },
                "NotFoundException" => crate::error::UpdateStageError {
                    meta: generic,
                    kind: crate::error::UpdateStageErrorKind::NotFoundError({
                        #[allow(unused_mut)]
                        let mut output = crate::error::not_found_error::Builder::default();
                        let _ = response;

                        let body_slice = response.body().as_ref();

                        let parsed_body: crate::error::NotFoundError = if body_slice.is_empty() {
                            // To enable JSON parsing to succeed, replace an empty body
                            // with an empty JSON body. If a member was required, it will fail slightly later
                            // during the operation construction phase.
                            serde_json::from_slice(b"{}")
                                .map_err(crate::error::UpdateStageError::unhandled)?
                        } else {
                            serde_json::from_slice(response.body().as_ref())
                                .map_err(crate::error::UpdateStageError::unhandled)?
                        };

                        output = output.set_message(parsed_body.message);
                        output.build()
                    }),
                },
                "TooManyRequestsException" => {
                    crate::error::UpdateStageError {
                        meta: generic,
                        kind: crate::error::UpdateStageErrorKind::TooManyRequestsError({
                            #[allow(unused_mut)]
                            let mut output =
                                crate::error::too_many_requests_error::Builder::default();
                            let _ = response;

                            let body_slice = response.body().as_ref();

                            let parsed_body: crate::error::TooManyRequestsError =
                                if body_slice.is_empty() {
                                    // To enable JSON parsing to succeed, replace an empty body
                                    // with an empty JSON body. If a member was required, it will fail slightly later
                                    // during the operation construction phase.
                                    serde_json::from_slice(b"{}")
                                        .map_err(crate::error::UpdateStageError::unhandled)?
                                } else {
                                    serde_json::from_slice(response.body().as_ref())
                                        .map_err(crate::error::UpdateStageError::unhandled)?
                                };

                            output = output.set_retry_after_seconds(
                        
                                                crate::http_serde::deser_header_update_stage_retry_after_seconds(response.headers())
                                                    .map_err(|_|crate::error::UpdateStageError::unhandled("Failed to parse retryAfterSeconds from header `Retry-After"))?
                                                
                    );
                            output = output.set_message(parsed_body.message);
                            output.build()
                        }),
                    }
                }
                "UnauthorizedException" => crate::error::UpdateStageError {
                    meta: generic,
                    kind: crate::error::UpdateStageErrorKind::UnauthorizedError({
                        #[allow(unused_mut)]
                        let mut output = crate::error::unauthorized_error::Builder::default();
                        let _ = response;

                        let body_slice = response.body().as_ref();

                        let parsed_body: crate::error::UnauthorizedError = if body_slice.is_empty()
                        {
                            // To enable JSON parsing to succeed, replace an empty body
                            // with an empty JSON body. If a member was required, it will fail slightly later
                            // during the operation construction phase.
                            serde_json::from_slice(b"{}")
                                .map_err(crate::error::UpdateStageError::unhandled)?
                        } else {
                            serde_json::from_slice(response.body().as_ref())
                                .map_err(crate::error::UpdateStageError::unhandled)?
                        };

                        output = output.set_message(parsed_body.message);
                        output.build()
                    }),
                },
                _ => crate::error::UpdateStageError::generic(generic),
            });
        }
        Ok({
            #[allow(unused_mut)]
            let mut output = crate::output::update_stage_output::Builder::default();
            let _ = response;

            let body_slice = response.body().as_ref();

            let parsed_body: crate::serializer::UpdateStageOutputBody = if body_slice.is_empty() {
                // To enable JSON parsing to succeed, replace an empty body
                // with an empty JSON body. If a member was required, it will fail slightly later
                // during the operation construction phase.
                serde_json::from_slice(b"{}").map_err(crate::error::UpdateStageError::unhandled)?
            } else {
                serde_json::from_slice(response.body().as_ref())
                    .map_err(crate::error::UpdateStageError::unhandled)?
            };

            output = output.set_deployment_id(parsed_body.deployment_id);
            output = output.set_client_certificate_id(parsed_body.client_certificate_id);
            output = output.set_stage_name(parsed_body.stage_name);
            output = output.set_description(parsed_body.description);
            output = output.set_cache_cluster_enabled(parsed_body.cache_cluster_enabled);
            output = output.set_cache_cluster_size(parsed_body.cache_cluster_size);
            output = output.set_cache_cluster_status(parsed_body.cache_cluster_status);
            output = output.set_method_settings(parsed_body.method_settings);
            output = output.set_variables(parsed_body.variables);
            output = output.set_documentation_version(parsed_body.documentation_version);
            output = output.set_access_log_settings(parsed_body.access_log_settings);
            output = output.set_canary_settings(parsed_body.canary_settings);
            output = output.set_tracing_enabled(parsed_body.tracing_enabled);
            output = output.set_web_acl_arn(parsed_body.web_acl_arn);
            output = output.set_tags(parsed_body.tags);
            output = output.set_created_date(parsed_body.created_date);
            output = output.set_last_updated_date(parsed_body.last_updated_date);
            output.build()
        })
    }
    pub fn parse_response(
        &self,
        response: &http::response::Response<impl AsRef<[u8]>>,
    ) -> Result<crate::output::UpdateStageOutput, crate::error::UpdateStageError> {
        Self::from_response(&response)
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}

impl smithy_http::response::ParseStrictResponse for UpdateStage {
    type Output = Result<crate::output::UpdateStageOutput, crate::error::UpdateStageError>;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        self.parse_response(response)
    }
}

/// <p>Grants a temporary extension to the remaining quota of a usage plan associated with a specified API key.</p>
#[derive(std::clone::Clone)]
pub struct UpdateUsage {
    _private: (),
}
impl UpdateUsage {
    /// Creates a new builder-style object to manufacture [`UpdateUsageInput`](crate::input::UpdateUsageInput)
    pub fn builder() -> crate::input::update_usage_input::Builder {
        crate::input::update_usage_input::Builder::default()
    }
    #[allow(clippy::unnecessary_wraps)]
    fn from_response(
        response: &http::response::Response<impl AsRef<[u8]>>,
    ) -> Result<crate::output::UpdateUsageOutput, crate::error::UpdateUsageError> {
        if crate::aws_json_errors::is_error(&response) && response.status().as_u16() != 200 {
            let body = serde_json::from_slice(response.body().as_ref())
                .unwrap_or_else(|_| serde_json::json!({}));
            let generic = crate::aws_json_errors::parse_generic_error(&response, &body);

            let error_code = match generic.code() {
                Some(code) => code,
                None => return Err(crate::error::UpdateUsageError::unhandled(generic)),
            };
            return Err(match error_code {
                "BadRequestException" => crate::error::UpdateUsageError {
                    meta: generic,
                    kind: crate::error::UpdateUsageErrorKind::BadRequestError({
                        #[allow(unused_mut)]
                        let mut output = crate::error::bad_request_error::Builder::default();
                        let _ = response;

                        let body_slice = response.body().as_ref();

                        let parsed_body: crate::error::BadRequestError = if body_slice.is_empty() {
                            // To enable JSON parsing to succeed, replace an empty body
                            // with an empty JSON body. If a member was required, it will fail slightly later
                            // during the operation construction phase.
                            serde_json::from_slice(b"{}")
                                .map_err(crate::error::UpdateUsageError::unhandled)?
                        } else {
                            serde_json::from_slice(response.body().as_ref())
                                .map_err(crate::error::UpdateUsageError::unhandled)?
                        };

                        output = output.set_message(parsed_body.message);
                        output.build()
                    }),
                },
                "NotFoundException" => crate::error::UpdateUsageError {
                    meta: generic,
                    kind: crate::error::UpdateUsageErrorKind::NotFoundError({
                        #[allow(unused_mut)]
                        let mut output = crate::error::not_found_error::Builder::default();
                        let _ = response;

                        let body_slice = response.body().as_ref();

                        let parsed_body: crate::error::NotFoundError = if body_slice.is_empty() {
                            // To enable JSON parsing to succeed, replace an empty body
                            // with an empty JSON body. If a member was required, it will fail slightly later
                            // during the operation construction phase.
                            serde_json::from_slice(b"{}")
                                .map_err(crate::error::UpdateUsageError::unhandled)?
                        } else {
                            serde_json::from_slice(response.body().as_ref())
                                .map_err(crate::error::UpdateUsageError::unhandled)?
                        };

                        output = output.set_message(parsed_body.message);
                        output.build()
                    }),
                },
                "TooManyRequestsException" => {
                    crate::error::UpdateUsageError {
                        meta: generic,
                        kind: crate::error::UpdateUsageErrorKind::TooManyRequestsError({
                            #[allow(unused_mut)]
                            let mut output =
                                crate::error::too_many_requests_error::Builder::default();
                            let _ = response;

                            let body_slice = response.body().as_ref();

                            let parsed_body: crate::error::TooManyRequestsError =
                                if body_slice.is_empty() {
                                    // To enable JSON parsing to succeed, replace an empty body
                                    // with an empty JSON body. If a member was required, it will fail slightly later
                                    // during the operation construction phase.
                                    serde_json::from_slice(b"{}")
                                        .map_err(crate::error::UpdateUsageError::unhandled)?
                                } else {
                                    serde_json::from_slice(response.body().as_ref())
                                        .map_err(crate::error::UpdateUsageError::unhandled)?
                                };

                            output = output.set_retry_after_seconds(
                        
                                                crate::http_serde::deser_header_update_usage_retry_after_seconds(response.headers())
                                                    .map_err(|_|crate::error::UpdateUsageError::unhandled("Failed to parse retryAfterSeconds from header `Retry-After"))?
                                                
                    );
                            output = output.set_message(parsed_body.message);
                            output.build()
                        }),
                    }
                }
                "UnauthorizedException" => crate::error::UpdateUsageError {
                    meta: generic,
                    kind: crate::error::UpdateUsageErrorKind::UnauthorizedError({
                        #[allow(unused_mut)]
                        let mut output = crate::error::unauthorized_error::Builder::default();
                        let _ = response;

                        let body_slice = response.body().as_ref();

                        let parsed_body: crate::error::UnauthorizedError = if body_slice.is_empty()
                        {
                            // To enable JSON parsing to succeed, replace an empty body
                            // with an empty JSON body. If a member was required, it will fail slightly later
                            // during the operation construction phase.
                            serde_json::from_slice(b"{}")
                                .map_err(crate::error::UpdateUsageError::unhandled)?
                        } else {
                            serde_json::from_slice(response.body().as_ref())
                                .map_err(crate::error::UpdateUsageError::unhandled)?
                        };

                        output = output.set_message(parsed_body.message);
                        output.build()
                    }),
                },
                _ => crate::error::UpdateUsageError::generic(generic),
            });
        }
        Ok({
            #[allow(unused_mut)]
            let mut output = crate::output::update_usage_output::Builder::default();
            let _ = response;

            let body_slice = response.body().as_ref();

            let parsed_body: crate::serializer::UpdateUsageOutputBody = if body_slice.is_empty() {
                // To enable JSON parsing to succeed, replace an empty body
                // with an empty JSON body. If a member was required, it will fail slightly later
                // during the operation construction phase.
                serde_json::from_slice(b"{}").map_err(crate::error::UpdateUsageError::unhandled)?
            } else {
                serde_json::from_slice(response.body().as_ref())
                    .map_err(crate::error::UpdateUsageError::unhandled)?
            };

            output = output.set_usage_plan_id(parsed_body.usage_plan_id);
            output = output.set_start_date(parsed_body.start_date);
            output = output.set_end_date(parsed_body.end_date);
            output = output.set_items(parsed_body.items);
            output = output.set_position(parsed_body.position);
            output.build()
        })
    }
    pub fn parse_response(
        &self,
        response: &http::response::Response<impl AsRef<[u8]>>,
    ) -> Result<crate::output::UpdateUsageOutput, crate::error::UpdateUsageError> {
        Self::from_response(&response)
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}

impl smithy_http::response::ParseStrictResponse for UpdateUsage {
    type Output = Result<crate::output::UpdateUsageOutput, crate::error::UpdateUsageError>;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        self.parse_response(response)
    }
}

/// <p>Updates a usage plan of a given plan Id.</p>
#[derive(std::clone::Clone)]
pub struct UpdateUsagePlan {
    _private: (),
}
impl UpdateUsagePlan {
    /// Creates a new builder-style object to manufacture [`UpdateUsagePlanInput`](crate::input::UpdateUsagePlanInput)
    pub fn builder() -> crate::input::update_usage_plan_input::Builder {
        crate::input::update_usage_plan_input::Builder::default()
    }
    #[allow(clippy::unnecessary_wraps)]
    fn from_response(
        response: &http::response::Response<impl AsRef<[u8]>>,
    ) -> Result<crate::output::UpdateUsagePlanOutput, crate::error::UpdateUsagePlanError> {
        if crate::aws_json_errors::is_error(&response) && response.status().as_u16() != 200 {
            let body = serde_json::from_slice(response.body().as_ref())
                .unwrap_or_else(|_| serde_json::json!({}));
            let generic = crate::aws_json_errors::parse_generic_error(&response, &body);

            let error_code = match generic.code() {
                Some(code) => code,
                None => return Err(crate::error::UpdateUsagePlanError::unhandled(generic)),
            };
            return Err(match error_code {
                "BadRequestException" => crate::error::UpdateUsagePlanError {
                    meta: generic,
                    kind: crate::error::UpdateUsagePlanErrorKind::BadRequestError({
                        #[allow(unused_mut)]
                        let mut output = crate::error::bad_request_error::Builder::default();
                        let _ = response;

                        let body_slice = response.body().as_ref();

                        let parsed_body: crate::error::BadRequestError = if body_slice.is_empty() {
                            // To enable JSON parsing to succeed, replace an empty body
                            // with an empty JSON body. If a member was required, it will fail slightly later
                            // during the operation construction phase.
                            serde_json::from_slice(b"{}")
                                .map_err(crate::error::UpdateUsagePlanError::unhandled)?
                        } else {
                            serde_json::from_slice(response.body().as_ref())
                                .map_err(crate::error::UpdateUsagePlanError::unhandled)?
                        };

                        output = output.set_message(parsed_body.message);
                        output.build()
                    }),
                },
                "ConflictException" => crate::error::UpdateUsagePlanError {
                    meta: generic,
                    kind: crate::error::UpdateUsagePlanErrorKind::ConflictError({
                        #[allow(unused_mut)]
                        let mut output = crate::error::conflict_error::Builder::default();
                        let _ = response;

                        let body_slice = response.body().as_ref();

                        let parsed_body: crate::error::ConflictError = if body_slice.is_empty() {
                            // To enable JSON parsing to succeed, replace an empty body
                            // with an empty JSON body. If a member was required, it will fail slightly later
                            // during the operation construction phase.
                            serde_json::from_slice(b"{}")
                                .map_err(crate::error::UpdateUsagePlanError::unhandled)?
                        } else {
                            serde_json::from_slice(response.body().as_ref())
                                .map_err(crate::error::UpdateUsagePlanError::unhandled)?
                        };

                        output = output.set_message(parsed_body.message);
                        output.build()
                    }),
                },
                "NotFoundException" => crate::error::UpdateUsagePlanError {
                    meta: generic,
                    kind: crate::error::UpdateUsagePlanErrorKind::NotFoundError({
                        #[allow(unused_mut)]
                        let mut output = crate::error::not_found_error::Builder::default();
                        let _ = response;

                        let body_slice = response.body().as_ref();

                        let parsed_body: crate::error::NotFoundError = if body_slice.is_empty() {
                            // To enable JSON parsing to succeed, replace an empty body
                            // with an empty JSON body. If a member was required, it will fail slightly later
                            // during the operation construction phase.
                            serde_json::from_slice(b"{}")
                                .map_err(crate::error::UpdateUsagePlanError::unhandled)?
                        } else {
                            serde_json::from_slice(response.body().as_ref())
                                .map_err(crate::error::UpdateUsagePlanError::unhandled)?
                        };

                        output = output.set_message(parsed_body.message);
                        output.build()
                    }),
                },
                "TooManyRequestsException" => {
                    crate::error::UpdateUsagePlanError {
                        meta: generic,
                        kind: crate::error::UpdateUsagePlanErrorKind::TooManyRequestsError({
                            #[allow(unused_mut)]
                            let mut output =
                                crate::error::too_many_requests_error::Builder::default();
                            let _ = response;

                            let body_slice = response.body().as_ref();

                            let parsed_body: crate::error::TooManyRequestsError =
                                if body_slice.is_empty() {
                                    // To enable JSON parsing to succeed, replace an empty body
                                    // with an empty JSON body. If a member was required, it will fail slightly later
                                    // during the operation construction phase.
                                    serde_json::from_slice(b"{}")
                                        .map_err(crate::error::UpdateUsagePlanError::unhandled)?
                                } else {
                                    serde_json::from_slice(response.body().as_ref())
                                        .map_err(crate::error::UpdateUsagePlanError::unhandled)?
                                };

                            output = output.set_retry_after_seconds(
                        
                                                crate::http_serde::deser_header_update_usage_plan_retry_after_seconds(response.headers())
                                                    .map_err(|_|crate::error::UpdateUsagePlanError::unhandled("Failed to parse retryAfterSeconds from header `Retry-After"))?
                                                
                    );
                            output = output.set_message(parsed_body.message);
                            output.build()
                        }),
                    }
                }
                "UnauthorizedException" => crate::error::UpdateUsagePlanError {
                    meta: generic,
                    kind: crate::error::UpdateUsagePlanErrorKind::UnauthorizedError({
                        #[allow(unused_mut)]
                        let mut output = crate::error::unauthorized_error::Builder::default();
                        let _ = response;

                        let body_slice = response.body().as_ref();

                        let parsed_body: crate::error::UnauthorizedError = if body_slice.is_empty()
                        {
                            // To enable JSON parsing to succeed, replace an empty body
                            // with an empty JSON body. If a member was required, it will fail slightly later
                            // during the operation construction phase.
                            serde_json::from_slice(b"{}")
                                .map_err(crate::error::UpdateUsagePlanError::unhandled)?
                        } else {
                            serde_json::from_slice(response.body().as_ref())
                                .map_err(crate::error::UpdateUsagePlanError::unhandled)?
                        };

                        output = output.set_message(parsed_body.message);
                        output.build()
                    }),
                },
                _ => crate::error::UpdateUsagePlanError::generic(generic),
            });
        }
        Ok({
            #[allow(unused_mut)]
            let mut output = crate::output::update_usage_plan_output::Builder::default();
            let _ = response;

            let body_slice = response.body().as_ref();

            let parsed_body: crate::serializer::UpdateUsagePlanOutputBody = if body_slice.is_empty()
            {
                // To enable JSON parsing to succeed, replace an empty body
                // with an empty JSON body. If a member was required, it will fail slightly later
                // during the operation construction phase.
                serde_json::from_slice(b"{}")
                    .map_err(crate::error::UpdateUsagePlanError::unhandled)?
            } else {
                serde_json::from_slice(response.body().as_ref())
                    .map_err(crate::error::UpdateUsagePlanError::unhandled)?
            };

            output = output.set_id(parsed_body.id);
            output = output.set_name(parsed_body.name);
            output = output.set_description(parsed_body.description);
            output = output.set_api_stages(parsed_body.api_stages);
            output = output.set_throttle(parsed_body.throttle);
            output = output.set_quota(parsed_body.quota);
            output = output.set_product_code(parsed_body.product_code);
            output = output.set_tags(parsed_body.tags);
            output.build()
        })
    }
    pub fn parse_response(
        &self,
        response: &http::response::Response<impl AsRef<[u8]>>,
    ) -> Result<crate::output::UpdateUsagePlanOutput, crate::error::UpdateUsagePlanError> {
        Self::from_response(&response)
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}

impl smithy_http::response::ParseStrictResponse for UpdateUsagePlan {
    type Output = Result<crate::output::UpdateUsagePlanOutput, crate::error::UpdateUsagePlanError>;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        self.parse_response(response)
    }
}

/// <p>Updates an existing <a>VpcLink</a> of a specified identifier.</p>
#[derive(std::clone::Clone)]
pub struct UpdateVpcLink {
    _private: (),
}
impl UpdateVpcLink {
    /// Creates a new builder-style object to manufacture [`UpdateVpcLinkInput`](crate::input::UpdateVpcLinkInput)
    pub fn builder() -> crate::input::update_vpc_link_input::Builder {
        crate::input::update_vpc_link_input::Builder::default()
    }
    #[allow(clippy::unnecessary_wraps)]
    fn from_response(
        response: &http::response::Response<impl AsRef<[u8]>>,
    ) -> Result<crate::output::UpdateVpcLinkOutput, crate::error::UpdateVpcLinkError> {
        if crate::aws_json_errors::is_error(&response) && response.status().as_u16() != 200 {
            let body = serde_json::from_slice(response.body().as_ref())
                .unwrap_or_else(|_| serde_json::json!({}));
            let generic = crate::aws_json_errors::parse_generic_error(&response, &body);

            let error_code = match generic.code() {
                Some(code) => code,
                None => return Err(crate::error::UpdateVpcLinkError::unhandled(generic)),
            };
            return Err(match error_code {
                "BadRequestException" => crate::error::UpdateVpcLinkError {
                    meta: generic,
                    kind: crate::error::UpdateVpcLinkErrorKind::BadRequestError({
                        #[allow(unused_mut)]
                        let mut output = crate::error::bad_request_error::Builder::default();
                        let _ = response;

                        let body_slice = response.body().as_ref();

                        let parsed_body: crate::error::BadRequestError = if body_slice.is_empty() {
                            // To enable JSON parsing to succeed, replace an empty body
                            // with an empty JSON body. If a member was required, it will fail slightly later
                            // during the operation construction phase.
                            serde_json::from_slice(b"{}")
                                .map_err(crate::error::UpdateVpcLinkError::unhandled)?
                        } else {
                            serde_json::from_slice(response.body().as_ref())
                                .map_err(crate::error::UpdateVpcLinkError::unhandled)?
                        };

                        output = output.set_message(parsed_body.message);
                        output.build()
                    }),
                },
                "ConflictException" => crate::error::UpdateVpcLinkError {
                    meta: generic,
                    kind: crate::error::UpdateVpcLinkErrorKind::ConflictError({
                        #[allow(unused_mut)]
                        let mut output = crate::error::conflict_error::Builder::default();
                        let _ = response;

                        let body_slice = response.body().as_ref();

                        let parsed_body: crate::error::ConflictError = if body_slice.is_empty() {
                            // To enable JSON parsing to succeed, replace an empty body
                            // with an empty JSON body. If a member was required, it will fail slightly later
                            // during the operation construction phase.
                            serde_json::from_slice(b"{}")
                                .map_err(crate::error::UpdateVpcLinkError::unhandled)?
                        } else {
                            serde_json::from_slice(response.body().as_ref())
                                .map_err(crate::error::UpdateVpcLinkError::unhandled)?
                        };

                        output = output.set_message(parsed_body.message);
                        output.build()
                    }),
                },
                "NotFoundException" => crate::error::UpdateVpcLinkError {
                    meta: generic,
                    kind: crate::error::UpdateVpcLinkErrorKind::NotFoundError({
                        #[allow(unused_mut)]
                        let mut output = crate::error::not_found_error::Builder::default();
                        let _ = response;

                        let body_slice = response.body().as_ref();

                        let parsed_body: crate::error::NotFoundError = if body_slice.is_empty() {
                            // To enable JSON parsing to succeed, replace an empty body
                            // with an empty JSON body. If a member was required, it will fail slightly later
                            // during the operation construction phase.
                            serde_json::from_slice(b"{}")
                                .map_err(crate::error::UpdateVpcLinkError::unhandled)?
                        } else {
                            serde_json::from_slice(response.body().as_ref())
                                .map_err(crate::error::UpdateVpcLinkError::unhandled)?
                        };

                        output = output.set_message(parsed_body.message);
                        output.build()
                    }),
                },
                "TooManyRequestsException" => {
                    crate::error::UpdateVpcLinkError {
                        meta: generic,
                        kind: crate::error::UpdateVpcLinkErrorKind::TooManyRequestsError({
                            #[allow(unused_mut)]
                            let mut output =
                                crate::error::too_many_requests_error::Builder::default();
                            let _ = response;

                            let body_slice = response.body().as_ref();

                            let parsed_body: crate::error::TooManyRequestsError =
                                if body_slice.is_empty() {
                                    // To enable JSON parsing to succeed, replace an empty body
                                    // with an empty JSON body. If a member was required, it will fail slightly later
                                    // during the operation construction phase.
                                    serde_json::from_slice(b"{}")
                                        .map_err(crate::error::UpdateVpcLinkError::unhandled)?
                                } else {
                                    serde_json::from_slice(response.body().as_ref())
                                        .map_err(crate::error::UpdateVpcLinkError::unhandled)?
                                };

                            output = output.set_retry_after_seconds(
                        
                                                crate::http_serde::deser_header_update_vpc_link_retry_after_seconds(response.headers())
                                                    .map_err(|_|crate::error::UpdateVpcLinkError::unhandled("Failed to parse retryAfterSeconds from header `Retry-After"))?
                                                
                    );
                            output = output.set_message(parsed_body.message);
                            output.build()
                        }),
                    }
                }
                "UnauthorizedException" => crate::error::UpdateVpcLinkError {
                    meta: generic,
                    kind: crate::error::UpdateVpcLinkErrorKind::UnauthorizedError({
                        #[allow(unused_mut)]
                        let mut output = crate::error::unauthorized_error::Builder::default();
                        let _ = response;

                        let body_slice = response.body().as_ref();

                        let parsed_body: crate::error::UnauthorizedError = if body_slice.is_empty()
                        {
                            // To enable JSON parsing to succeed, replace an empty body
                            // with an empty JSON body. If a member was required, it will fail slightly later
                            // during the operation construction phase.
                            serde_json::from_slice(b"{}")
                                .map_err(crate::error::UpdateVpcLinkError::unhandled)?
                        } else {
                            serde_json::from_slice(response.body().as_ref())
                                .map_err(crate::error::UpdateVpcLinkError::unhandled)?
                        };

                        output = output.set_message(parsed_body.message);
                        output.build()
                    }),
                },
                _ => crate::error::UpdateVpcLinkError::generic(generic),
            });
        }
        Ok({
            #[allow(unused_mut)]
            let mut output = crate::output::update_vpc_link_output::Builder::default();
            let _ = response;

            let body_slice = response.body().as_ref();

            let parsed_body: crate::serializer::UpdateVpcLinkOutputBody = if body_slice.is_empty() {
                // To enable JSON parsing to succeed, replace an empty body
                // with an empty JSON body. If a member was required, it will fail slightly later
                // during the operation construction phase.
                serde_json::from_slice(b"{}")
                    .map_err(crate::error::UpdateVpcLinkError::unhandled)?
            } else {
                serde_json::from_slice(response.body().as_ref())
                    .map_err(crate::error::UpdateVpcLinkError::unhandled)?
            };

            output = output.set_id(parsed_body.id);
            output = output.set_name(parsed_body.name);
            output = output.set_description(parsed_body.description);
            output = output.set_target_arns(parsed_body.target_arns);
            output = output.set_status(parsed_body.status);
            output = output.set_status_message(parsed_body.status_message);
            output = output.set_tags(parsed_body.tags);
            output.build()
        })
    }
    pub fn parse_response(
        &self,
        response: &http::response::Response<impl AsRef<[u8]>>,
    ) -> Result<crate::output::UpdateVpcLinkOutput, crate::error::UpdateVpcLinkError> {
        Self::from_response(&response)
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}

impl smithy_http::response::ParseStrictResponse for UpdateVpcLink {
    type Output = Result<crate::output::UpdateVpcLinkOutput, crate::error::UpdateVpcLinkError>;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        self.parse_response(response)
    }
}
