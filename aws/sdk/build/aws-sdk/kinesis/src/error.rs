// Code generated by software.amazon.smithy.rust.codegen.smithy-rs. DO NOT EDIT.

#[non_exhaustive]
#[derive(::std::fmt::Debug)]
pub enum AddTagsToStreamError {
    InvalidArgumentError(InvalidArgumentError),
    LimitExceededError(LimitExceededError),
    ResourceInUseError(ResourceInUseError),
    ResourceNotFoundError(ResourceNotFoundError),

    /// An unexpected error, eg. invalid JSON returned by the service
    Unhandled(Box<dyn ::std::error::Error>),
}
impl ::std::fmt::Display for AddTagsToStreamError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match self {
            AddTagsToStreamError::InvalidArgumentError(_inner) => _inner.fmt(f),
            AddTagsToStreamError::LimitExceededError(_inner) => _inner.fmt(f),
            AddTagsToStreamError::ResourceInUseError(_inner) => _inner.fmt(f),
            AddTagsToStreamError::ResourceNotFoundError(_inner) => _inner.fmt(f),
            AddTagsToStreamError::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl ::smithy_types::retry::ProvideErrorKind for AddTagsToStreamError {
    fn code(&self) -> Option<&str> {
        AddTagsToStreamError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<::smithy_types::retry::ErrorKind> {
        match self {
            AddTagsToStreamError::InvalidArgumentError(_inner) => None,
            AddTagsToStreamError::LimitExceededError(_inner) => None,
            AddTagsToStreamError::ResourceInUseError(_inner) => None,
            AddTagsToStreamError::ResourceNotFoundError(_inner) => None,
            AddTagsToStreamError::Unhandled(_inner) => {
                match _inner.downcast_ref::<::smithy_types::Error>() {
                    Some(_inner) => _inner.retryable_error_kind(),
                    None => None,
                }
            }
        }
    }
}
impl AddTagsToStreamError {
    pub fn unhandled<E: Into<Box<dyn ::std::error::Error>>>(err: E) -> Self {
        AddTagsToStreamError::Unhandled(err.into())
    }
    pub fn message(&self) -> Option<&str> {
        match self {
            AddTagsToStreamError::InvalidArgumentError(_inner) => _inner.message(),
            AddTagsToStreamError::LimitExceededError(_inner) => _inner.message(),
            AddTagsToStreamError::ResourceInUseError(_inner) => _inner.message(),
            AddTagsToStreamError::ResourceNotFoundError(_inner) => _inner.message(),
            AddTagsToStreamError::Unhandled(_inner) => {
                match _inner.downcast_ref::<::smithy_types::Error>() {
                    Some(_inner) => _inner.message(),
                    None => None,
                }
            }
        }
    }
    pub fn code(&self) -> Option<&str> {
        match self {
            AddTagsToStreamError::InvalidArgumentError(_inner) => Some(_inner.code()),
            AddTagsToStreamError::LimitExceededError(_inner) => Some(_inner.code()),
            AddTagsToStreamError::ResourceInUseError(_inner) => Some(_inner.code()),
            AddTagsToStreamError::ResourceNotFoundError(_inner) => Some(_inner.code()),
            AddTagsToStreamError::Unhandled(_inner) => {
                match _inner.downcast_ref::<::smithy_types::Error>() {
                    Some(_inner) => _inner.code(),
                    None => None,
                }
            }
        }
    }
}
impl ::std::error::Error for AddTagsToStreamError {
    fn source(&self) -> Option<&(dyn ::std::error::Error + 'static)> {
        match self {
            AddTagsToStreamError::InvalidArgumentError(_inner) => Some(_inner),
            AddTagsToStreamError::LimitExceededError(_inner) => Some(_inner),
            AddTagsToStreamError::ResourceInUseError(_inner) => Some(_inner),
            AddTagsToStreamError::ResourceNotFoundError(_inner) => Some(_inner),
            AddTagsToStreamError::Unhandled(_inner) => {
                match _inner.downcast_ref::<::smithy_types::Error>() {
                    Some(_inner) => Some(_inner),
                    None => Some(_inner.as_ref()),
                }
            }
        }
    }
}

#[non_exhaustive]
#[derive(::std::fmt::Debug)]
pub enum CreateStreamError {
    InvalidArgumentError(InvalidArgumentError),
    LimitExceededError(LimitExceededError),
    ResourceInUseError(ResourceInUseError),

    /// An unexpected error, eg. invalid JSON returned by the service
    Unhandled(Box<dyn ::std::error::Error>),
}
impl ::std::fmt::Display for CreateStreamError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match self {
            CreateStreamError::InvalidArgumentError(_inner) => _inner.fmt(f),
            CreateStreamError::LimitExceededError(_inner) => _inner.fmt(f),
            CreateStreamError::ResourceInUseError(_inner) => _inner.fmt(f),
            CreateStreamError::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl ::smithy_types::retry::ProvideErrorKind for CreateStreamError {
    fn code(&self) -> Option<&str> {
        CreateStreamError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<::smithy_types::retry::ErrorKind> {
        match self {
            CreateStreamError::InvalidArgumentError(_inner) => None,
            CreateStreamError::LimitExceededError(_inner) => None,
            CreateStreamError::ResourceInUseError(_inner) => None,
            CreateStreamError::Unhandled(_inner) => {
                match _inner.downcast_ref::<::smithy_types::Error>() {
                    Some(_inner) => _inner.retryable_error_kind(),
                    None => None,
                }
            }
        }
    }
}
impl CreateStreamError {
    pub fn unhandled<E: Into<Box<dyn ::std::error::Error>>>(err: E) -> Self {
        CreateStreamError::Unhandled(err.into())
    }
    pub fn message(&self) -> Option<&str> {
        match self {
            CreateStreamError::InvalidArgumentError(_inner) => _inner.message(),
            CreateStreamError::LimitExceededError(_inner) => _inner.message(),
            CreateStreamError::ResourceInUseError(_inner) => _inner.message(),
            CreateStreamError::Unhandled(_inner) => {
                match _inner.downcast_ref::<::smithy_types::Error>() {
                    Some(_inner) => _inner.message(),
                    None => None,
                }
            }
        }
    }
    pub fn code(&self) -> Option<&str> {
        match self {
            CreateStreamError::InvalidArgumentError(_inner) => Some(_inner.code()),
            CreateStreamError::LimitExceededError(_inner) => Some(_inner.code()),
            CreateStreamError::ResourceInUseError(_inner) => Some(_inner.code()),
            CreateStreamError::Unhandled(_inner) => {
                match _inner.downcast_ref::<::smithy_types::Error>() {
                    Some(_inner) => _inner.code(),
                    None => None,
                }
            }
        }
    }
}
impl ::std::error::Error for CreateStreamError {
    fn source(&self) -> Option<&(dyn ::std::error::Error + 'static)> {
        match self {
            CreateStreamError::InvalidArgumentError(_inner) => Some(_inner),
            CreateStreamError::LimitExceededError(_inner) => Some(_inner),
            CreateStreamError::ResourceInUseError(_inner) => Some(_inner),
            CreateStreamError::Unhandled(_inner) => {
                match _inner.downcast_ref::<::smithy_types::Error>() {
                    Some(_inner) => Some(_inner),
                    None => Some(_inner.as_ref()),
                }
            }
        }
    }
}

#[non_exhaustive]
#[derive(::std::fmt::Debug)]
pub enum DecreaseStreamRetentionPeriodError {
    InvalidArgumentError(InvalidArgumentError),
    LimitExceededError(LimitExceededError),
    ResourceInUseError(ResourceInUseError),
    ResourceNotFoundError(ResourceNotFoundError),

    /// An unexpected error, eg. invalid JSON returned by the service
    Unhandled(Box<dyn ::std::error::Error>),
}
impl ::std::fmt::Display for DecreaseStreamRetentionPeriodError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match self {
            DecreaseStreamRetentionPeriodError::InvalidArgumentError(_inner) => _inner.fmt(f),
            DecreaseStreamRetentionPeriodError::LimitExceededError(_inner) => _inner.fmt(f),
            DecreaseStreamRetentionPeriodError::ResourceInUseError(_inner) => _inner.fmt(f),
            DecreaseStreamRetentionPeriodError::ResourceNotFoundError(_inner) => _inner.fmt(f),
            DecreaseStreamRetentionPeriodError::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl ::smithy_types::retry::ProvideErrorKind for DecreaseStreamRetentionPeriodError {
    fn code(&self) -> Option<&str> {
        DecreaseStreamRetentionPeriodError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<::smithy_types::retry::ErrorKind> {
        match self {
            DecreaseStreamRetentionPeriodError::InvalidArgumentError(_inner) => None,
            DecreaseStreamRetentionPeriodError::LimitExceededError(_inner) => None,
            DecreaseStreamRetentionPeriodError::ResourceInUseError(_inner) => None,
            DecreaseStreamRetentionPeriodError::ResourceNotFoundError(_inner) => None,
            DecreaseStreamRetentionPeriodError::Unhandled(_inner) => {
                match _inner.downcast_ref::<::smithy_types::Error>() {
                    Some(_inner) => _inner.retryable_error_kind(),
                    None => None,
                }
            }
        }
    }
}
impl DecreaseStreamRetentionPeriodError {
    pub fn unhandled<E: Into<Box<dyn ::std::error::Error>>>(err: E) -> Self {
        DecreaseStreamRetentionPeriodError::Unhandled(err.into())
    }
    pub fn message(&self) -> Option<&str> {
        match self {
            DecreaseStreamRetentionPeriodError::InvalidArgumentError(_inner) => _inner.message(),
            DecreaseStreamRetentionPeriodError::LimitExceededError(_inner) => _inner.message(),
            DecreaseStreamRetentionPeriodError::ResourceInUseError(_inner) => _inner.message(),
            DecreaseStreamRetentionPeriodError::ResourceNotFoundError(_inner) => _inner.message(),
            DecreaseStreamRetentionPeriodError::Unhandled(_inner) => {
                match _inner.downcast_ref::<::smithy_types::Error>() {
                    Some(_inner) => _inner.message(),
                    None => None,
                }
            }
        }
    }
    pub fn code(&self) -> Option<&str> {
        match self {
            DecreaseStreamRetentionPeriodError::InvalidArgumentError(_inner) => Some(_inner.code()),
            DecreaseStreamRetentionPeriodError::LimitExceededError(_inner) => Some(_inner.code()),
            DecreaseStreamRetentionPeriodError::ResourceInUseError(_inner) => Some(_inner.code()),
            DecreaseStreamRetentionPeriodError::ResourceNotFoundError(_inner) => {
                Some(_inner.code())
            }
            DecreaseStreamRetentionPeriodError::Unhandled(_inner) => {
                match _inner.downcast_ref::<::smithy_types::Error>() {
                    Some(_inner) => _inner.code(),
                    None => None,
                }
            }
        }
    }
}
impl ::std::error::Error for DecreaseStreamRetentionPeriodError {
    fn source(&self) -> Option<&(dyn ::std::error::Error + 'static)> {
        match self {
            DecreaseStreamRetentionPeriodError::InvalidArgumentError(_inner) => Some(_inner),
            DecreaseStreamRetentionPeriodError::LimitExceededError(_inner) => Some(_inner),
            DecreaseStreamRetentionPeriodError::ResourceInUseError(_inner) => Some(_inner),
            DecreaseStreamRetentionPeriodError::ResourceNotFoundError(_inner) => Some(_inner),
            DecreaseStreamRetentionPeriodError::Unhandled(_inner) => {
                match _inner.downcast_ref::<::smithy_types::Error>() {
                    Some(_inner) => Some(_inner),
                    None => Some(_inner.as_ref()),
                }
            }
        }
    }
}

#[non_exhaustive]
#[derive(::std::fmt::Debug)]
pub enum DeleteStreamError {
    LimitExceededError(LimitExceededError),
    ResourceInUseError(ResourceInUseError),
    ResourceNotFoundError(ResourceNotFoundError),

    /// An unexpected error, eg. invalid JSON returned by the service
    Unhandled(Box<dyn ::std::error::Error>),
}
impl ::std::fmt::Display for DeleteStreamError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match self {
            DeleteStreamError::LimitExceededError(_inner) => _inner.fmt(f),
            DeleteStreamError::ResourceInUseError(_inner) => _inner.fmt(f),
            DeleteStreamError::ResourceNotFoundError(_inner) => _inner.fmt(f),
            DeleteStreamError::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl ::smithy_types::retry::ProvideErrorKind for DeleteStreamError {
    fn code(&self) -> Option<&str> {
        DeleteStreamError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<::smithy_types::retry::ErrorKind> {
        match self {
            DeleteStreamError::LimitExceededError(_inner) => None,
            DeleteStreamError::ResourceInUseError(_inner) => None,
            DeleteStreamError::ResourceNotFoundError(_inner) => None,
            DeleteStreamError::Unhandled(_inner) => {
                match _inner.downcast_ref::<::smithy_types::Error>() {
                    Some(_inner) => _inner.retryable_error_kind(),
                    None => None,
                }
            }
        }
    }
}
impl DeleteStreamError {
    pub fn unhandled<E: Into<Box<dyn ::std::error::Error>>>(err: E) -> Self {
        DeleteStreamError::Unhandled(err.into())
    }
    pub fn message(&self) -> Option<&str> {
        match self {
            DeleteStreamError::LimitExceededError(_inner) => _inner.message(),
            DeleteStreamError::ResourceInUseError(_inner) => _inner.message(),
            DeleteStreamError::ResourceNotFoundError(_inner) => _inner.message(),
            DeleteStreamError::Unhandled(_inner) => {
                match _inner.downcast_ref::<::smithy_types::Error>() {
                    Some(_inner) => _inner.message(),
                    None => None,
                }
            }
        }
    }
    pub fn code(&self) -> Option<&str> {
        match self {
            DeleteStreamError::LimitExceededError(_inner) => Some(_inner.code()),
            DeleteStreamError::ResourceInUseError(_inner) => Some(_inner.code()),
            DeleteStreamError::ResourceNotFoundError(_inner) => Some(_inner.code()),
            DeleteStreamError::Unhandled(_inner) => {
                match _inner.downcast_ref::<::smithy_types::Error>() {
                    Some(_inner) => _inner.code(),
                    None => None,
                }
            }
        }
    }
}
impl ::std::error::Error for DeleteStreamError {
    fn source(&self) -> Option<&(dyn ::std::error::Error + 'static)> {
        match self {
            DeleteStreamError::LimitExceededError(_inner) => Some(_inner),
            DeleteStreamError::ResourceInUseError(_inner) => Some(_inner),
            DeleteStreamError::ResourceNotFoundError(_inner) => Some(_inner),
            DeleteStreamError::Unhandled(_inner) => {
                match _inner.downcast_ref::<::smithy_types::Error>() {
                    Some(_inner) => Some(_inner),
                    None => Some(_inner.as_ref()),
                }
            }
        }
    }
}

#[non_exhaustive]
#[derive(::std::fmt::Debug)]
pub enum DeregisterStreamConsumerError {
    InvalidArgumentError(InvalidArgumentError),
    LimitExceededError(LimitExceededError),
    ResourceNotFoundError(ResourceNotFoundError),

    /// An unexpected error, eg. invalid JSON returned by the service
    Unhandled(Box<dyn ::std::error::Error>),
}
impl ::std::fmt::Display for DeregisterStreamConsumerError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match self {
            DeregisterStreamConsumerError::InvalidArgumentError(_inner) => _inner.fmt(f),
            DeregisterStreamConsumerError::LimitExceededError(_inner) => _inner.fmt(f),
            DeregisterStreamConsumerError::ResourceNotFoundError(_inner) => _inner.fmt(f),
            DeregisterStreamConsumerError::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl ::smithy_types::retry::ProvideErrorKind for DeregisterStreamConsumerError {
    fn code(&self) -> Option<&str> {
        DeregisterStreamConsumerError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<::smithy_types::retry::ErrorKind> {
        match self {
            DeregisterStreamConsumerError::InvalidArgumentError(_inner) => None,
            DeregisterStreamConsumerError::LimitExceededError(_inner) => None,
            DeregisterStreamConsumerError::ResourceNotFoundError(_inner) => None,
            DeregisterStreamConsumerError::Unhandled(_inner) => {
                match _inner.downcast_ref::<::smithy_types::Error>() {
                    Some(_inner) => _inner.retryable_error_kind(),
                    None => None,
                }
            }
        }
    }
}
impl DeregisterStreamConsumerError {
    pub fn unhandled<E: Into<Box<dyn ::std::error::Error>>>(err: E) -> Self {
        DeregisterStreamConsumerError::Unhandled(err.into())
    }
    pub fn message(&self) -> Option<&str> {
        match self {
            DeregisterStreamConsumerError::InvalidArgumentError(_inner) => _inner.message(),
            DeregisterStreamConsumerError::LimitExceededError(_inner) => _inner.message(),
            DeregisterStreamConsumerError::ResourceNotFoundError(_inner) => _inner.message(),
            DeregisterStreamConsumerError::Unhandled(_inner) => {
                match _inner.downcast_ref::<::smithy_types::Error>() {
                    Some(_inner) => _inner.message(),
                    None => None,
                }
            }
        }
    }
    pub fn code(&self) -> Option<&str> {
        match self {
            DeregisterStreamConsumerError::InvalidArgumentError(_inner) => Some(_inner.code()),
            DeregisterStreamConsumerError::LimitExceededError(_inner) => Some(_inner.code()),
            DeregisterStreamConsumerError::ResourceNotFoundError(_inner) => Some(_inner.code()),
            DeregisterStreamConsumerError::Unhandled(_inner) => {
                match _inner.downcast_ref::<::smithy_types::Error>() {
                    Some(_inner) => _inner.code(),
                    None => None,
                }
            }
        }
    }
}
impl ::std::error::Error for DeregisterStreamConsumerError {
    fn source(&self) -> Option<&(dyn ::std::error::Error + 'static)> {
        match self {
            DeregisterStreamConsumerError::InvalidArgumentError(_inner) => Some(_inner),
            DeregisterStreamConsumerError::LimitExceededError(_inner) => Some(_inner),
            DeregisterStreamConsumerError::ResourceNotFoundError(_inner) => Some(_inner),
            DeregisterStreamConsumerError::Unhandled(_inner) => {
                match _inner.downcast_ref::<::smithy_types::Error>() {
                    Some(_inner) => Some(_inner),
                    None => Some(_inner.as_ref()),
                }
            }
        }
    }
}

#[non_exhaustive]
#[derive(::std::fmt::Debug)]
pub enum DescribeLimitsError {
    LimitExceededError(LimitExceededError),

    /// An unexpected error, eg. invalid JSON returned by the service
    Unhandled(Box<dyn ::std::error::Error>),
}
impl ::std::fmt::Display for DescribeLimitsError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match self {
            DescribeLimitsError::LimitExceededError(_inner) => _inner.fmt(f),
            DescribeLimitsError::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl ::smithy_types::retry::ProvideErrorKind for DescribeLimitsError {
    fn code(&self) -> Option<&str> {
        DescribeLimitsError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<::smithy_types::retry::ErrorKind> {
        match self {
            DescribeLimitsError::LimitExceededError(_inner) => None,
            DescribeLimitsError::Unhandled(_inner) => {
                match _inner.downcast_ref::<::smithy_types::Error>() {
                    Some(_inner) => _inner.retryable_error_kind(),
                    None => None,
                }
            }
        }
    }
}
impl DescribeLimitsError {
    pub fn unhandled<E: Into<Box<dyn ::std::error::Error>>>(err: E) -> Self {
        DescribeLimitsError::Unhandled(err.into())
    }
    pub fn message(&self) -> Option<&str> {
        match self {
            DescribeLimitsError::LimitExceededError(_inner) => _inner.message(),
            DescribeLimitsError::Unhandled(_inner) => {
                match _inner.downcast_ref::<::smithy_types::Error>() {
                    Some(_inner) => _inner.message(),
                    None => None,
                }
            }
        }
    }
    pub fn code(&self) -> Option<&str> {
        match self {
            DescribeLimitsError::LimitExceededError(_inner) => Some(_inner.code()),
            DescribeLimitsError::Unhandled(_inner) => {
                match _inner.downcast_ref::<::smithy_types::Error>() {
                    Some(_inner) => _inner.code(),
                    None => None,
                }
            }
        }
    }
}
impl ::std::error::Error for DescribeLimitsError {
    fn source(&self) -> Option<&(dyn ::std::error::Error + 'static)> {
        match self {
            DescribeLimitsError::LimitExceededError(_inner) => Some(_inner),
            DescribeLimitsError::Unhandled(_inner) => {
                match _inner.downcast_ref::<::smithy_types::Error>() {
                    Some(_inner) => Some(_inner),
                    None => Some(_inner.as_ref()),
                }
            }
        }
    }
}

#[non_exhaustive]
#[derive(::std::fmt::Debug)]
pub enum DescribeStreamError {
    LimitExceededError(LimitExceededError),
    ResourceNotFoundError(ResourceNotFoundError),

    /// An unexpected error, eg. invalid JSON returned by the service
    Unhandled(Box<dyn ::std::error::Error>),
}
impl ::std::fmt::Display for DescribeStreamError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match self {
            DescribeStreamError::LimitExceededError(_inner) => _inner.fmt(f),
            DescribeStreamError::ResourceNotFoundError(_inner) => _inner.fmt(f),
            DescribeStreamError::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl ::smithy_types::retry::ProvideErrorKind for DescribeStreamError {
    fn code(&self) -> Option<&str> {
        DescribeStreamError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<::smithy_types::retry::ErrorKind> {
        match self {
            DescribeStreamError::LimitExceededError(_inner) => None,
            DescribeStreamError::ResourceNotFoundError(_inner) => None,
            DescribeStreamError::Unhandled(_inner) => {
                match _inner.downcast_ref::<::smithy_types::Error>() {
                    Some(_inner) => _inner.retryable_error_kind(),
                    None => None,
                }
            }
        }
    }
}
impl DescribeStreamError {
    pub fn unhandled<E: Into<Box<dyn ::std::error::Error>>>(err: E) -> Self {
        DescribeStreamError::Unhandled(err.into())
    }
    pub fn message(&self) -> Option<&str> {
        match self {
            DescribeStreamError::LimitExceededError(_inner) => _inner.message(),
            DescribeStreamError::ResourceNotFoundError(_inner) => _inner.message(),
            DescribeStreamError::Unhandled(_inner) => {
                match _inner.downcast_ref::<::smithy_types::Error>() {
                    Some(_inner) => _inner.message(),
                    None => None,
                }
            }
        }
    }
    pub fn code(&self) -> Option<&str> {
        match self {
            DescribeStreamError::LimitExceededError(_inner) => Some(_inner.code()),
            DescribeStreamError::ResourceNotFoundError(_inner) => Some(_inner.code()),
            DescribeStreamError::Unhandled(_inner) => {
                match _inner.downcast_ref::<::smithy_types::Error>() {
                    Some(_inner) => _inner.code(),
                    None => None,
                }
            }
        }
    }
}
impl ::std::error::Error for DescribeStreamError {
    fn source(&self) -> Option<&(dyn ::std::error::Error + 'static)> {
        match self {
            DescribeStreamError::LimitExceededError(_inner) => Some(_inner),
            DescribeStreamError::ResourceNotFoundError(_inner) => Some(_inner),
            DescribeStreamError::Unhandled(_inner) => {
                match _inner.downcast_ref::<::smithy_types::Error>() {
                    Some(_inner) => Some(_inner),
                    None => Some(_inner.as_ref()),
                }
            }
        }
    }
}

#[non_exhaustive]
#[derive(::std::fmt::Debug)]
pub enum DescribeStreamConsumerError {
    InvalidArgumentError(InvalidArgumentError),
    LimitExceededError(LimitExceededError),
    ResourceNotFoundError(ResourceNotFoundError),

    /// An unexpected error, eg. invalid JSON returned by the service
    Unhandled(Box<dyn ::std::error::Error>),
}
impl ::std::fmt::Display for DescribeStreamConsumerError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match self {
            DescribeStreamConsumerError::InvalidArgumentError(_inner) => _inner.fmt(f),
            DescribeStreamConsumerError::LimitExceededError(_inner) => _inner.fmt(f),
            DescribeStreamConsumerError::ResourceNotFoundError(_inner) => _inner.fmt(f),
            DescribeStreamConsumerError::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl ::smithy_types::retry::ProvideErrorKind for DescribeStreamConsumerError {
    fn code(&self) -> Option<&str> {
        DescribeStreamConsumerError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<::smithy_types::retry::ErrorKind> {
        match self {
            DescribeStreamConsumerError::InvalidArgumentError(_inner) => None,
            DescribeStreamConsumerError::LimitExceededError(_inner) => None,
            DescribeStreamConsumerError::ResourceNotFoundError(_inner) => None,
            DescribeStreamConsumerError::Unhandled(_inner) => {
                match _inner.downcast_ref::<::smithy_types::Error>() {
                    Some(_inner) => _inner.retryable_error_kind(),
                    None => None,
                }
            }
        }
    }
}
impl DescribeStreamConsumerError {
    pub fn unhandled<E: Into<Box<dyn ::std::error::Error>>>(err: E) -> Self {
        DescribeStreamConsumerError::Unhandled(err.into())
    }
    pub fn message(&self) -> Option<&str> {
        match self {
            DescribeStreamConsumerError::InvalidArgumentError(_inner) => _inner.message(),
            DescribeStreamConsumerError::LimitExceededError(_inner) => _inner.message(),
            DescribeStreamConsumerError::ResourceNotFoundError(_inner) => _inner.message(),
            DescribeStreamConsumerError::Unhandled(_inner) => {
                match _inner.downcast_ref::<::smithy_types::Error>() {
                    Some(_inner) => _inner.message(),
                    None => None,
                }
            }
        }
    }
    pub fn code(&self) -> Option<&str> {
        match self {
            DescribeStreamConsumerError::InvalidArgumentError(_inner) => Some(_inner.code()),
            DescribeStreamConsumerError::LimitExceededError(_inner) => Some(_inner.code()),
            DescribeStreamConsumerError::ResourceNotFoundError(_inner) => Some(_inner.code()),
            DescribeStreamConsumerError::Unhandled(_inner) => {
                match _inner.downcast_ref::<::smithy_types::Error>() {
                    Some(_inner) => _inner.code(),
                    None => None,
                }
            }
        }
    }
}
impl ::std::error::Error for DescribeStreamConsumerError {
    fn source(&self) -> Option<&(dyn ::std::error::Error + 'static)> {
        match self {
            DescribeStreamConsumerError::InvalidArgumentError(_inner) => Some(_inner),
            DescribeStreamConsumerError::LimitExceededError(_inner) => Some(_inner),
            DescribeStreamConsumerError::ResourceNotFoundError(_inner) => Some(_inner),
            DescribeStreamConsumerError::Unhandled(_inner) => {
                match _inner.downcast_ref::<::smithy_types::Error>() {
                    Some(_inner) => Some(_inner),
                    None => Some(_inner.as_ref()),
                }
            }
        }
    }
}

#[non_exhaustive]
#[derive(::std::fmt::Debug)]
pub enum DescribeStreamSummaryError {
    LimitExceededError(LimitExceededError),
    ResourceNotFoundError(ResourceNotFoundError),

    /// An unexpected error, eg. invalid JSON returned by the service
    Unhandled(Box<dyn ::std::error::Error>),
}
impl ::std::fmt::Display for DescribeStreamSummaryError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match self {
            DescribeStreamSummaryError::LimitExceededError(_inner) => _inner.fmt(f),
            DescribeStreamSummaryError::ResourceNotFoundError(_inner) => _inner.fmt(f),
            DescribeStreamSummaryError::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl ::smithy_types::retry::ProvideErrorKind for DescribeStreamSummaryError {
    fn code(&self) -> Option<&str> {
        DescribeStreamSummaryError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<::smithy_types::retry::ErrorKind> {
        match self {
            DescribeStreamSummaryError::LimitExceededError(_inner) => None,
            DescribeStreamSummaryError::ResourceNotFoundError(_inner) => None,
            DescribeStreamSummaryError::Unhandled(_inner) => {
                match _inner.downcast_ref::<::smithy_types::Error>() {
                    Some(_inner) => _inner.retryable_error_kind(),
                    None => None,
                }
            }
        }
    }
}
impl DescribeStreamSummaryError {
    pub fn unhandled<E: Into<Box<dyn ::std::error::Error>>>(err: E) -> Self {
        DescribeStreamSummaryError::Unhandled(err.into())
    }
    pub fn message(&self) -> Option<&str> {
        match self {
            DescribeStreamSummaryError::LimitExceededError(_inner) => _inner.message(),
            DescribeStreamSummaryError::ResourceNotFoundError(_inner) => _inner.message(),
            DescribeStreamSummaryError::Unhandled(_inner) => {
                match _inner.downcast_ref::<::smithy_types::Error>() {
                    Some(_inner) => _inner.message(),
                    None => None,
                }
            }
        }
    }
    pub fn code(&self) -> Option<&str> {
        match self {
            DescribeStreamSummaryError::LimitExceededError(_inner) => Some(_inner.code()),
            DescribeStreamSummaryError::ResourceNotFoundError(_inner) => Some(_inner.code()),
            DescribeStreamSummaryError::Unhandled(_inner) => {
                match _inner.downcast_ref::<::smithy_types::Error>() {
                    Some(_inner) => _inner.code(),
                    None => None,
                }
            }
        }
    }
}
impl ::std::error::Error for DescribeStreamSummaryError {
    fn source(&self) -> Option<&(dyn ::std::error::Error + 'static)> {
        match self {
            DescribeStreamSummaryError::LimitExceededError(_inner) => Some(_inner),
            DescribeStreamSummaryError::ResourceNotFoundError(_inner) => Some(_inner),
            DescribeStreamSummaryError::Unhandled(_inner) => {
                match _inner.downcast_ref::<::smithy_types::Error>() {
                    Some(_inner) => Some(_inner),
                    None => Some(_inner.as_ref()),
                }
            }
        }
    }
}

#[non_exhaustive]
#[derive(::std::fmt::Debug)]
pub enum DisableEnhancedMonitoringError {
    InvalidArgumentError(InvalidArgumentError),
    LimitExceededError(LimitExceededError),
    ResourceInUseError(ResourceInUseError),
    ResourceNotFoundError(ResourceNotFoundError),

    /// An unexpected error, eg. invalid JSON returned by the service
    Unhandled(Box<dyn ::std::error::Error>),
}
impl ::std::fmt::Display for DisableEnhancedMonitoringError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match self {
            DisableEnhancedMonitoringError::InvalidArgumentError(_inner) => _inner.fmt(f),
            DisableEnhancedMonitoringError::LimitExceededError(_inner) => _inner.fmt(f),
            DisableEnhancedMonitoringError::ResourceInUseError(_inner) => _inner.fmt(f),
            DisableEnhancedMonitoringError::ResourceNotFoundError(_inner) => _inner.fmt(f),
            DisableEnhancedMonitoringError::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl ::smithy_types::retry::ProvideErrorKind for DisableEnhancedMonitoringError {
    fn code(&self) -> Option<&str> {
        DisableEnhancedMonitoringError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<::smithy_types::retry::ErrorKind> {
        match self {
            DisableEnhancedMonitoringError::InvalidArgumentError(_inner) => None,
            DisableEnhancedMonitoringError::LimitExceededError(_inner) => None,
            DisableEnhancedMonitoringError::ResourceInUseError(_inner) => None,
            DisableEnhancedMonitoringError::ResourceNotFoundError(_inner) => None,
            DisableEnhancedMonitoringError::Unhandled(_inner) => {
                match _inner.downcast_ref::<::smithy_types::Error>() {
                    Some(_inner) => _inner.retryable_error_kind(),
                    None => None,
                }
            }
        }
    }
}
impl DisableEnhancedMonitoringError {
    pub fn unhandled<E: Into<Box<dyn ::std::error::Error>>>(err: E) -> Self {
        DisableEnhancedMonitoringError::Unhandled(err.into())
    }
    pub fn message(&self) -> Option<&str> {
        match self {
            DisableEnhancedMonitoringError::InvalidArgumentError(_inner) => _inner.message(),
            DisableEnhancedMonitoringError::LimitExceededError(_inner) => _inner.message(),
            DisableEnhancedMonitoringError::ResourceInUseError(_inner) => _inner.message(),
            DisableEnhancedMonitoringError::ResourceNotFoundError(_inner) => _inner.message(),
            DisableEnhancedMonitoringError::Unhandled(_inner) => {
                match _inner.downcast_ref::<::smithy_types::Error>() {
                    Some(_inner) => _inner.message(),
                    None => None,
                }
            }
        }
    }
    pub fn code(&self) -> Option<&str> {
        match self {
            DisableEnhancedMonitoringError::InvalidArgumentError(_inner) => Some(_inner.code()),
            DisableEnhancedMonitoringError::LimitExceededError(_inner) => Some(_inner.code()),
            DisableEnhancedMonitoringError::ResourceInUseError(_inner) => Some(_inner.code()),
            DisableEnhancedMonitoringError::ResourceNotFoundError(_inner) => Some(_inner.code()),
            DisableEnhancedMonitoringError::Unhandled(_inner) => {
                match _inner.downcast_ref::<::smithy_types::Error>() {
                    Some(_inner) => _inner.code(),
                    None => None,
                }
            }
        }
    }
}
impl ::std::error::Error for DisableEnhancedMonitoringError {
    fn source(&self) -> Option<&(dyn ::std::error::Error + 'static)> {
        match self {
            DisableEnhancedMonitoringError::InvalidArgumentError(_inner) => Some(_inner),
            DisableEnhancedMonitoringError::LimitExceededError(_inner) => Some(_inner),
            DisableEnhancedMonitoringError::ResourceInUseError(_inner) => Some(_inner),
            DisableEnhancedMonitoringError::ResourceNotFoundError(_inner) => Some(_inner),
            DisableEnhancedMonitoringError::Unhandled(_inner) => {
                match _inner.downcast_ref::<::smithy_types::Error>() {
                    Some(_inner) => Some(_inner),
                    None => Some(_inner.as_ref()),
                }
            }
        }
    }
}

#[non_exhaustive]
#[derive(::std::fmt::Debug)]
pub enum EnableEnhancedMonitoringError {
    InvalidArgumentError(InvalidArgumentError),
    LimitExceededError(LimitExceededError),
    ResourceInUseError(ResourceInUseError),
    ResourceNotFoundError(ResourceNotFoundError),

    /// An unexpected error, eg. invalid JSON returned by the service
    Unhandled(Box<dyn ::std::error::Error>),
}
impl ::std::fmt::Display for EnableEnhancedMonitoringError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match self {
            EnableEnhancedMonitoringError::InvalidArgumentError(_inner) => _inner.fmt(f),
            EnableEnhancedMonitoringError::LimitExceededError(_inner) => _inner.fmt(f),
            EnableEnhancedMonitoringError::ResourceInUseError(_inner) => _inner.fmt(f),
            EnableEnhancedMonitoringError::ResourceNotFoundError(_inner) => _inner.fmt(f),
            EnableEnhancedMonitoringError::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl ::smithy_types::retry::ProvideErrorKind for EnableEnhancedMonitoringError {
    fn code(&self) -> Option<&str> {
        EnableEnhancedMonitoringError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<::smithy_types::retry::ErrorKind> {
        match self {
            EnableEnhancedMonitoringError::InvalidArgumentError(_inner) => None,
            EnableEnhancedMonitoringError::LimitExceededError(_inner) => None,
            EnableEnhancedMonitoringError::ResourceInUseError(_inner) => None,
            EnableEnhancedMonitoringError::ResourceNotFoundError(_inner) => None,
            EnableEnhancedMonitoringError::Unhandled(_inner) => {
                match _inner.downcast_ref::<::smithy_types::Error>() {
                    Some(_inner) => _inner.retryable_error_kind(),
                    None => None,
                }
            }
        }
    }
}
impl EnableEnhancedMonitoringError {
    pub fn unhandled<E: Into<Box<dyn ::std::error::Error>>>(err: E) -> Self {
        EnableEnhancedMonitoringError::Unhandled(err.into())
    }
    pub fn message(&self) -> Option<&str> {
        match self {
            EnableEnhancedMonitoringError::InvalidArgumentError(_inner) => _inner.message(),
            EnableEnhancedMonitoringError::LimitExceededError(_inner) => _inner.message(),
            EnableEnhancedMonitoringError::ResourceInUseError(_inner) => _inner.message(),
            EnableEnhancedMonitoringError::ResourceNotFoundError(_inner) => _inner.message(),
            EnableEnhancedMonitoringError::Unhandled(_inner) => {
                match _inner.downcast_ref::<::smithy_types::Error>() {
                    Some(_inner) => _inner.message(),
                    None => None,
                }
            }
        }
    }
    pub fn code(&self) -> Option<&str> {
        match self {
            EnableEnhancedMonitoringError::InvalidArgumentError(_inner) => Some(_inner.code()),
            EnableEnhancedMonitoringError::LimitExceededError(_inner) => Some(_inner.code()),
            EnableEnhancedMonitoringError::ResourceInUseError(_inner) => Some(_inner.code()),
            EnableEnhancedMonitoringError::ResourceNotFoundError(_inner) => Some(_inner.code()),
            EnableEnhancedMonitoringError::Unhandled(_inner) => {
                match _inner.downcast_ref::<::smithy_types::Error>() {
                    Some(_inner) => _inner.code(),
                    None => None,
                }
            }
        }
    }
}
impl ::std::error::Error for EnableEnhancedMonitoringError {
    fn source(&self) -> Option<&(dyn ::std::error::Error + 'static)> {
        match self {
            EnableEnhancedMonitoringError::InvalidArgumentError(_inner) => Some(_inner),
            EnableEnhancedMonitoringError::LimitExceededError(_inner) => Some(_inner),
            EnableEnhancedMonitoringError::ResourceInUseError(_inner) => Some(_inner),
            EnableEnhancedMonitoringError::ResourceNotFoundError(_inner) => Some(_inner),
            EnableEnhancedMonitoringError::Unhandled(_inner) => {
                match _inner.downcast_ref::<::smithy_types::Error>() {
                    Some(_inner) => Some(_inner),
                    None => Some(_inner.as_ref()),
                }
            }
        }
    }
}

#[non_exhaustive]
#[derive(::std::fmt::Debug)]
pub enum GetRecordsError {
    ExpiredIteratorError(ExpiredIteratorError),
    InvalidArgumentError(InvalidArgumentError),
    KMSAccessDeniedError(KMSAccessDeniedError),
    KMSDisabledError(KMSDisabledError),
    KMSInvalidStateError(KMSInvalidStateError),
    KMSNotFoundError(KMSNotFoundError),
    KMSOptInRequired(KMSOptInRequired),
    KMSThrottlingError(KMSThrottlingError),
    ProvisionedThroughputExceededError(ProvisionedThroughputExceededError),
    ResourceNotFoundError(ResourceNotFoundError),

    /// An unexpected error, eg. invalid JSON returned by the service
    Unhandled(Box<dyn ::std::error::Error>),
}
impl ::std::fmt::Display for GetRecordsError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match self {
            GetRecordsError::ExpiredIteratorError(_inner) => _inner.fmt(f),
            GetRecordsError::InvalidArgumentError(_inner) => _inner.fmt(f),
            GetRecordsError::KMSAccessDeniedError(_inner) => _inner.fmt(f),
            GetRecordsError::KMSDisabledError(_inner) => _inner.fmt(f),
            GetRecordsError::KMSInvalidStateError(_inner) => _inner.fmt(f),
            GetRecordsError::KMSNotFoundError(_inner) => _inner.fmt(f),
            GetRecordsError::KMSOptInRequired(_inner) => _inner.fmt(f),
            GetRecordsError::KMSThrottlingError(_inner) => _inner.fmt(f),
            GetRecordsError::ProvisionedThroughputExceededError(_inner) => _inner.fmt(f),
            GetRecordsError::ResourceNotFoundError(_inner) => _inner.fmt(f),
            GetRecordsError::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl ::smithy_types::retry::ProvideErrorKind for GetRecordsError {
    fn code(&self) -> Option<&str> {
        GetRecordsError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<::smithy_types::retry::ErrorKind> {
        match self {
            GetRecordsError::ExpiredIteratorError(_inner) => None,
            GetRecordsError::InvalidArgumentError(_inner) => None,
            GetRecordsError::KMSAccessDeniedError(_inner) => None,
            GetRecordsError::KMSDisabledError(_inner) => None,
            GetRecordsError::KMSInvalidStateError(_inner) => None,
            GetRecordsError::KMSNotFoundError(_inner) => None,
            GetRecordsError::KMSOptInRequired(_inner) => None,
            GetRecordsError::KMSThrottlingError(_inner) => None,
            GetRecordsError::ProvisionedThroughputExceededError(_inner) => None,
            GetRecordsError::ResourceNotFoundError(_inner) => None,
            GetRecordsError::Unhandled(_inner) => {
                match _inner.downcast_ref::<::smithy_types::Error>() {
                    Some(_inner) => _inner.retryable_error_kind(),
                    None => None,
                }
            }
        }
    }
}
impl GetRecordsError {
    pub fn unhandled<E: Into<Box<dyn ::std::error::Error>>>(err: E) -> Self {
        GetRecordsError::Unhandled(err.into())
    }
    pub fn message(&self) -> Option<&str> {
        match self {
            GetRecordsError::ExpiredIteratorError(_inner) => _inner.message(),
            GetRecordsError::InvalidArgumentError(_inner) => _inner.message(),
            GetRecordsError::KMSAccessDeniedError(_inner) => _inner.message(),
            GetRecordsError::KMSDisabledError(_inner) => _inner.message(),
            GetRecordsError::KMSInvalidStateError(_inner) => _inner.message(),
            GetRecordsError::KMSNotFoundError(_inner) => _inner.message(),
            GetRecordsError::KMSOptInRequired(_inner) => _inner.message(),
            GetRecordsError::KMSThrottlingError(_inner) => _inner.message(),
            GetRecordsError::ProvisionedThroughputExceededError(_inner) => _inner.message(),
            GetRecordsError::ResourceNotFoundError(_inner) => _inner.message(),
            GetRecordsError::Unhandled(_inner) => {
                match _inner.downcast_ref::<::smithy_types::Error>() {
                    Some(_inner) => _inner.message(),
                    None => None,
                }
            }
        }
    }
    pub fn code(&self) -> Option<&str> {
        match self {
            GetRecordsError::ExpiredIteratorError(_inner) => Some(_inner.code()),
            GetRecordsError::InvalidArgumentError(_inner) => Some(_inner.code()),
            GetRecordsError::KMSAccessDeniedError(_inner) => Some(_inner.code()),
            GetRecordsError::KMSDisabledError(_inner) => Some(_inner.code()),
            GetRecordsError::KMSInvalidStateError(_inner) => Some(_inner.code()),
            GetRecordsError::KMSNotFoundError(_inner) => Some(_inner.code()),
            GetRecordsError::KMSOptInRequired(_inner) => Some(_inner.code()),
            GetRecordsError::KMSThrottlingError(_inner) => Some(_inner.code()),
            GetRecordsError::ProvisionedThroughputExceededError(_inner) => Some(_inner.code()),
            GetRecordsError::ResourceNotFoundError(_inner) => Some(_inner.code()),
            GetRecordsError::Unhandled(_inner) => {
                match _inner.downcast_ref::<::smithy_types::Error>() {
                    Some(_inner) => _inner.code(),
                    None => None,
                }
            }
        }
    }
}
impl ::std::error::Error for GetRecordsError {
    fn source(&self) -> Option<&(dyn ::std::error::Error + 'static)> {
        match self {
            GetRecordsError::ExpiredIteratorError(_inner) => Some(_inner),
            GetRecordsError::InvalidArgumentError(_inner) => Some(_inner),
            GetRecordsError::KMSAccessDeniedError(_inner) => Some(_inner),
            GetRecordsError::KMSDisabledError(_inner) => Some(_inner),
            GetRecordsError::KMSInvalidStateError(_inner) => Some(_inner),
            GetRecordsError::KMSNotFoundError(_inner) => Some(_inner),
            GetRecordsError::KMSOptInRequired(_inner) => Some(_inner),
            GetRecordsError::KMSThrottlingError(_inner) => Some(_inner),
            GetRecordsError::ProvisionedThroughputExceededError(_inner) => Some(_inner),
            GetRecordsError::ResourceNotFoundError(_inner) => Some(_inner),
            GetRecordsError::Unhandled(_inner) => {
                match _inner.downcast_ref::<::smithy_types::Error>() {
                    Some(_inner) => Some(_inner),
                    None => Some(_inner.as_ref()),
                }
            }
        }
    }
}

#[non_exhaustive]
#[derive(::std::fmt::Debug)]
pub enum GetShardIteratorError {
    InvalidArgumentError(InvalidArgumentError),
    ProvisionedThroughputExceededError(ProvisionedThroughputExceededError),
    ResourceNotFoundError(ResourceNotFoundError),

    /// An unexpected error, eg. invalid JSON returned by the service
    Unhandled(Box<dyn ::std::error::Error>),
}
impl ::std::fmt::Display for GetShardIteratorError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match self {
            GetShardIteratorError::InvalidArgumentError(_inner) => _inner.fmt(f),
            GetShardIteratorError::ProvisionedThroughputExceededError(_inner) => _inner.fmt(f),
            GetShardIteratorError::ResourceNotFoundError(_inner) => _inner.fmt(f),
            GetShardIteratorError::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl ::smithy_types::retry::ProvideErrorKind for GetShardIteratorError {
    fn code(&self) -> Option<&str> {
        GetShardIteratorError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<::smithy_types::retry::ErrorKind> {
        match self {
            GetShardIteratorError::InvalidArgumentError(_inner) => None,
            GetShardIteratorError::ProvisionedThroughputExceededError(_inner) => None,
            GetShardIteratorError::ResourceNotFoundError(_inner) => None,
            GetShardIteratorError::Unhandled(_inner) => {
                match _inner.downcast_ref::<::smithy_types::Error>() {
                    Some(_inner) => _inner.retryable_error_kind(),
                    None => None,
                }
            }
        }
    }
}
impl GetShardIteratorError {
    pub fn unhandled<E: Into<Box<dyn ::std::error::Error>>>(err: E) -> Self {
        GetShardIteratorError::Unhandled(err.into())
    }
    pub fn message(&self) -> Option<&str> {
        match self {
            GetShardIteratorError::InvalidArgumentError(_inner) => _inner.message(),
            GetShardIteratorError::ProvisionedThroughputExceededError(_inner) => _inner.message(),
            GetShardIteratorError::ResourceNotFoundError(_inner) => _inner.message(),
            GetShardIteratorError::Unhandled(_inner) => {
                match _inner.downcast_ref::<::smithy_types::Error>() {
                    Some(_inner) => _inner.message(),
                    None => None,
                }
            }
        }
    }
    pub fn code(&self) -> Option<&str> {
        match self {
            GetShardIteratorError::InvalidArgumentError(_inner) => Some(_inner.code()),
            GetShardIteratorError::ProvisionedThroughputExceededError(_inner) => {
                Some(_inner.code())
            }
            GetShardIteratorError::ResourceNotFoundError(_inner) => Some(_inner.code()),
            GetShardIteratorError::Unhandled(_inner) => {
                match _inner.downcast_ref::<::smithy_types::Error>() {
                    Some(_inner) => _inner.code(),
                    None => None,
                }
            }
        }
    }
}
impl ::std::error::Error for GetShardIteratorError {
    fn source(&self) -> Option<&(dyn ::std::error::Error + 'static)> {
        match self {
            GetShardIteratorError::InvalidArgumentError(_inner) => Some(_inner),
            GetShardIteratorError::ProvisionedThroughputExceededError(_inner) => Some(_inner),
            GetShardIteratorError::ResourceNotFoundError(_inner) => Some(_inner),
            GetShardIteratorError::Unhandled(_inner) => {
                match _inner.downcast_ref::<::smithy_types::Error>() {
                    Some(_inner) => Some(_inner),
                    None => Some(_inner.as_ref()),
                }
            }
        }
    }
}

#[non_exhaustive]
#[derive(::std::fmt::Debug)]
pub enum IncreaseStreamRetentionPeriodError {
    InvalidArgumentError(InvalidArgumentError),
    LimitExceededError(LimitExceededError),
    ResourceInUseError(ResourceInUseError),
    ResourceNotFoundError(ResourceNotFoundError),

    /// An unexpected error, eg. invalid JSON returned by the service
    Unhandled(Box<dyn ::std::error::Error>),
}
impl ::std::fmt::Display for IncreaseStreamRetentionPeriodError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match self {
            IncreaseStreamRetentionPeriodError::InvalidArgumentError(_inner) => _inner.fmt(f),
            IncreaseStreamRetentionPeriodError::LimitExceededError(_inner) => _inner.fmt(f),
            IncreaseStreamRetentionPeriodError::ResourceInUseError(_inner) => _inner.fmt(f),
            IncreaseStreamRetentionPeriodError::ResourceNotFoundError(_inner) => _inner.fmt(f),
            IncreaseStreamRetentionPeriodError::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl ::smithy_types::retry::ProvideErrorKind for IncreaseStreamRetentionPeriodError {
    fn code(&self) -> Option<&str> {
        IncreaseStreamRetentionPeriodError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<::smithy_types::retry::ErrorKind> {
        match self {
            IncreaseStreamRetentionPeriodError::InvalidArgumentError(_inner) => None,
            IncreaseStreamRetentionPeriodError::LimitExceededError(_inner) => None,
            IncreaseStreamRetentionPeriodError::ResourceInUseError(_inner) => None,
            IncreaseStreamRetentionPeriodError::ResourceNotFoundError(_inner) => None,
            IncreaseStreamRetentionPeriodError::Unhandled(_inner) => {
                match _inner.downcast_ref::<::smithy_types::Error>() {
                    Some(_inner) => _inner.retryable_error_kind(),
                    None => None,
                }
            }
        }
    }
}
impl IncreaseStreamRetentionPeriodError {
    pub fn unhandled<E: Into<Box<dyn ::std::error::Error>>>(err: E) -> Self {
        IncreaseStreamRetentionPeriodError::Unhandled(err.into())
    }
    pub fn message(&self) -> Option<&str> {
        match self {
            IncreaseStreamRetentionPeriodError::InvalidArgumentError(_inner) => _inner.message(),
            IncreaseStreamRetentionPeriodError::LimitExceededError(_inner) => _inner.message(),
            IncreaseStreamRetentionPeriodError::ResourceInUseError(_inner) => _inner.message(),
            IncreaseStreamRetentionPeriodError::ResourceNotFoundError(_inner) => _inner.message(),
            IncreaseStreamRetentionPeriodError::Unhandled(_inner) => {
                match _inner.downcast_ref::<::smithy_types::Error>() {
                    Some(_inner) => _inner.message(),
                    None => None,
                }
            }
        }
    }
    pub fn code(&self) -> Option<&str> {
        match self {
            IncreaseStreamRetentionPeriodError::InvalidArgumentError(_inner) => Some(_inner.code()),
            IncreaseStreamRetentionPeriodError::LimitExceededError(_inner) => Some(_inner.code()),
            IncreaseStreamRetentionPeriodError::ResourceInUseError(_inner) => Some(_inner.code()),
            IncreaseStreamRetentionPeriodError::ResourceNotFoundError(_inner) => {
                Some(_inner.code())
            }
            IncreaseStreamRetentionPeriodError::Unhandled(_inner) => {
                match _inner.downcast_ref::<::smithy_types::Error>() {
                    Some(_inner) => _inner.code(),
                    None => None,
                }
            }
        }
    }
}
impl ::std::error::Error for IncreaseStreamRetentionPeriodError {
    fn source(&self) -> Option<&(dyn ::std::error::Error + 'static)> {
        match self {
            IncreaseStreamRetentionPeriodError::InvalidArgumentError(_inner) => Some(_inner),
            IncreaseStreamRetentionPeriodError::LimitExceededError(_inner) => Some(_inner),
            IncreaseStreamRetentionPeriodError::ResourceInUseError(_inner) => Some(_inner),
            IncreaseStreamRetentionPeriodError::ResourceNotFoundError(_inner) => Some(_inner),
            IncreaseStreamRetentionPeriodError::Unhandled(_inner) => {
                match _inner.downcast_ref::<::smithy_types::Error>() {
                    Some(_inner) => Some(_inner),
                    None => Some(_inner.as_ref()),
                }
            }
        }
    }
}

#[non_exhaustive]
#[derive(::std::fmt::Debug)]
pub enum ListShardsError {
    ExpiredNextTokenError(ExpiredNextTokenError),
    InvalidArgumentError(InvalidArgumentError),
    LimitExceededError(LimitExceededError),
    ResourceInUseError(ResourceInUseError),
    ResourceNotFoundError(ResourceNotFoundError),

    /// An unexpected error, eg. invalid JSON returned by the service
    Unhandled(Box<dyn ::std::error::Error>),
}
impl ::std::fmt::Display for ListShardsError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match self {
            ListShardsError::ExpiredNextTokenError(_inner) => _inner.fmt(f),
            ListShardsError::InvalidArgumentError(_inner) => _inner.fmt(f),
            ListShardsError::LimitExceededError(_inner) => _inner.fmt(f),
            ListShardsError::ResourceInUseError(_inner) => _inner.fmt(f),
            ListShardsError::ResourceNotFoundError(_inner) => _inner.fmt(f),
            ListShardsError::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl ::smithy_types::retry::ProvideErrorKind for ListShardsError {
    fn code(&self) -> Option<&str> {
        ListShardsError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<::smithy_types::retry::ErrorKind> {
        match self {
            ListShardsError::ExpiredNextTokenError(_inner) => None,
            ListShardsError::InvalidArgumentError(_inner) => None,
            ListShardsError::LimitExceededError(_inner) => None,
            ListShardsError::ResourceInUseError(_inner) => None,
            ListShardsError::ResourceNotFoundError(_inner) => None,
            ListShardsError::Unhandled(_inner) => {
                match _inner.downcast_ref::<::smithy_types::Error>() {
                    Some(_inner) => _inner.retryable_error_kind(),
                    None => None,
                }
            }
        }
    }
}
impl ListShardsError {
    pub fn unhandled<E: Into<Box<dyn ::std::error::Error>>>(err: E) -> Self {
        ListShardsError::Unhandled(err.into())
    }
    pub fn message(&self) -> Option<&str> {
        match self {
            ListShardsError::ExpiredNextTokenError(_inner) => _inner.message(),
            ListShardsError::InvalidArgumentError(_inner) => _inner.message(),
            ListShardsError::LimitExceededError(_inner) => _inner.message(),
            ListShardsError::ResourceInUseError(_inner) => _inner.message(),
            ListShardsError::ResourceNotFoundError(_inner) => _inner.message(),
            ListShardsError::Unhandled(_inner) => {
                match _inner.downcast_ref::<::smithy_types::Error>() {
                    Some(_inner) => _inner.message(),
                    None => None,
                }
            }
        }
    }
    pub fn code(&self) -> Option<&str> {
        match self {
            ListShardsError::ExpiredNextTokenError(_inner) => Some(_inner.code()),
            ListShardsError::InvalidArgumentError(_inner) => Some(_inner.code()),
            ListShardsError::LimitExceededError(_inner) => Some(_inner.code()),
            ListShardsError::ResourceInUseError(_inner) => Some(_inner.code()),
            ListShardsError::ResourceNotFoundError(_inner) => Some(_inner.code()),
            ListShardsError::Unhandled(_inner) => {
                match _inner.downcast_ref::<::smithy_types::Error>() {
                    Some(_inner) => _inner.code(),
                    None => None,
                }
            }
        }
    }
}
impl ::std::error::Error for ListShardsError {
    fn source(&self) -> Option<&(dyn ::std::error::Error + 'static)> {
        match self {
            ListShardsError::ExpiredNextTokenError(_inner) => Some(_inner),
            ListShardsError::InvalidArgumentError(_inner) => Some(_inner),
            ListShardsError::LimitExceededError(_inner) => Some(_inner),
            ListShardsError::ResourceInUseError(_inner) => Some(_inner),
            ListShardsError::ResourceNotFoundError(_inner) => Some(_inner),
            ListShardsError::Unhandled(_inner) => {
                match _inner.downcast_ref::<::smithy_types::Error>() {
                    Some(_inner) => Some(_inner),
                    None => Some(_inner.as_ref()),
                }
            }
        }
    }
}

#[non_exhaustive]
#[derive(::std::fmt::Debug)]
pub enum ListStreamConsumersError {
    ExpiredNextTokenError(ExpiredNextTokenError),
    InvalidArgumentError(InvalidArgumentError),
    LimitExceededError(LimitExceededError),
    ResourceInUseError(ResourceInUseError),
    ResourceNotFoundError(ResourceNotFoundError),

    /// An unexpected error, eg. invalid JSON returned by the service
    Unhandled(Box<dyn ::std::error::Error>),
}
impl ::std::fmt::Display for ListStreamConsumersError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match self {
            ListStreamConsumersError::ExpiredNextTokenError(_inner) => _inner.fmt(f),
            ListStreamConsumersError::InvalidArgumentError(_inner) => _inner.fmt(f),
            ListStreamConsumersError::LimitExceededError(_inner) => _inner.fmt(f),
            ListStreamConsumersError::ResourceInUseError(_inner) => _inner.fmt(f),
            ListStreamConsumersError::ResourceNotFoundError(_inner) => _inner.fmt(f),
            ListStreamConsumersError::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl ::smithy_types::retry::ProvideErrorKind for ListStreamConsumersError {
    fn code(&self) -> Option<&str> {
        ListStreamConsumersError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<::smithy_types::retry::ErrorKind> {
        match self {
            ListStreamConsumersError::ExpiredNextTokenError(_inner) => None,
            ListStreamConsumersError::InvalidArgumentError(_inner) => None,
            ListStreamConsumersError::LimitExceededError(_inner) => None,
            ListStreamConsumersError::ResourceInUseError(_inner) => None,
            ListStreamConsumersError::ResourceNotFoundError(_inner) => None,
            ListStreamConsumersError::Unhandled(_inner) => {
                match _inner.downcast_ref::<::smithy_types::Error>() {
                    Some(_inner) => _inner.retryable_error_kind(),
                    None => None,
                }
            }
        }
    }
}
impl ListStreamConsumersError {
    pub fn unhandled<E: Into<Box<dyn ::std::error::Error>>>(err: E) -> Self {
        ListStreamConsumersError::Unhandled(err.into())
    }
    pub fn message(&self) -> Option<&str> {
        match self {
            ListStreamConsumersError::ExpiredNextTokenError(_inner) => _inner.message(),
            ListStreamConsumersError::InvalidArgumentError(_inner) => _inner.message(),
            ListStreamConsumersError::LimitExceededError(_inner) => _inner.message(),
            ListStreamConsumersError::ResourceInUseError(_inner) => _inner.message(),
            ListStreamConsumersError::ResourceNotFoundError(_inner) => _inner.message(),
            ListStreamConsumersError::Unhandled(_inner) => {
                match _inner.downcast_ref::<::smithy_types::Error>() {
                    Some(_inner) => _inner.message(),
                    None => None,
                }
            }
        }
    }
    pub fn code(&self) -> Option<&str> {
        match self {
            ListStreamConsumersError::ExpiredNextTokenError(_inner) => Some(_inner.code()),
            ListStreamConsumersError::InvalidArgumentError(_inner) => Some(_inner.code()),
            ListStreamConsumersError::LimitExceededError(_inner) => Some(_inner.code()),
            ListStreamConsumersError::ResourceInUseError(_inner) => Some(_inner.code()),
            ListStreamConsumersError::ResourceNotFoundError(_inner) => Some(_inner.code()),
            ListStreamConsumersError::Unhandled(_inner) => {
                match _inner.downcast_ref::<::smithy_types::Error>() {
                    Some(_inner) => _inner.code(),
                    None => None,
                }
            }
        }
    }
}
impl ::std::error::Error for ListStreamConsumersError {
    fn source(&self) -> Option<&(dyn ::std::error::Error + 'static)> {
        match self {
            ListStreamConsumersError::ExpiredNextTokenError(_inner) => Some(_inner),
            ListStreamConsumersError::InvalidArgumentError(_inner) => Some(_inner),
            ListStreamConsumersError::LimitExceededError(_inner) => Some(_inner),
            ListStreamConsumersError::ResourceInUseError(_inner) => Some(_inner),
            ListStreamConsumersError::ResourceNotFoundError(_inner) => Some(_inner),
            ListStreamConsumersError::Unhandled(_inner) => {
                match _inner.downcast_ref::<::smithy_types::Error>() {
                    Some(_inner) => Some(_inner),
                    None => Some(_inner.as_ref()),
                }
            }
        }
    }
}

#[non_exhaustive]
#[derive(::std::fmt::Debug)]
pub enum ListStreamsError {
    LimitExceededError(LimitExceededError),

    /// An unexpected error, eg. invalid JSON returned by the service
    Unhandled(Box<dyn ::std::error::Error>),
}
impl ::std::fmt::Display for ListStreamsError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match self {
            ListStreamsError::LimitExceededError(_inner) => _inner.fmt(f),
            ListStreamsError::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl ::smithy_types::retry::ProvideErrorKind for ListStreamsError {
    fn code(&self) -> Option<&str> {
        ListStreamsError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<::smithy_types::retry::ErrorKind> {
        match self {
            ListStreamsError::LimitExceededError(_inner) => None,
            ListStreamsError::Unhandled(_inner) => {
                match _inner.downcast_ref::<::smithy_types::Error>() {
                    Some(_inner) => _inner.retryable_error_kind(),
                    None => None,
                }
            }
        }
    }
}
impl ListStreamsError {
    pub fn unhandled<E: Into<Box<dyn ::std::error::Error>>>(err: E) -> Self {
        ListStreamsError::Unhandled(err.into())
    }
    pub fn message(&self) -> Option<&str> {
        match self {
            ListStreamsError::LimitExceededError(_inner) => _inner.message(),
            ListStreamsError::Unhandled(_inner) => {
                match _inner.downcast_ref::<::smithy_types::Error>() {
                    Some(_inner) => _inner.message(),
                    None => None,
                }
            }
        }
    }
    pub fn code(&self) -> Option<&str> {
        match self {
            ListStreamsError::LimitExceededError(_inner) => Some(_inner.code()),
            ListStreamsError::Unhandled(_inner) => {
                match _inner.downcast_ref::<::smithy_types::Error>() {
                    Some(_inner) => _inner.code(),
                    None => None,
                }
            }
        }
    }
}
impl ::std::error::Error for ListStreamsError {
    fn source(&self) -> Option<&(dyn ::std::error::Error + 'static)> {
        match self {
            ListStreamsError::LimitExceededError(_inner) => Some(_inner),
            ListStreamsError::Unhandled(_inner) => {
                match _inner.downcast_ref::<::smithy_types::Error>() {
                    Some(_inner) => Some(_inner),
                    None => Some(_inner.as_ref()),
                }
            }
        }
    }
}

#[non_exhaustive]
#[derive(::std::fmt::Debug)]
pub enum ListTagsForStreamError {
    InvalidArgumentError(InvalidArgumentError),
    LimitExceededError(LimitExceededError),
    ResourceNotFoundError(ResourceNotFoundError),

    /// An unexpected error, eg. invalid JSON returned by the service
    Unhandled(Box<dyn ::std::error::Error>),
}
impl ::std::fmt::Display for ListTagsForStreamError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match self {
            ListTagsForStreamError::InvalidArgumentError(_inner) => _inner.fmt(f),
            ListTagsForStreamError::LimitExceededError(_inner) => _inner.fmt(f),
            ListTagsForStreamError::ResourceNotFoundError(_inner) => _inner.fmt(f),
            ListTagsForStreamError::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl ::smithy_types::retry::ProvideErrorKind for ListTagsForStreamError {
    fn code(&self) -> Option<&str> {
        ListTagsForStreamError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<::smithy_types::retry::ErrorKind> {
        match self {
            ListTagsForStreamError::InvalidArgumentError(_inner) => None,
            ListTagsForStreamError::LimitExceededError(_inner) => None,
            ListTagsForStreamError::ResourceNotFoundError(_inner) => None,
            ListTagsForStreamError::Unhandled(_inner) => {
                match _inner.downcast_ref::<::smithy_types::Error>() {
                    Some(_inner) => _inner.retryable_error_kind(),
                    None => None,
                }
            }
        }
    }
}
impl ListTagsForStreamError {
    pub fn unhandled<E: Into<Box<dyn ::std::error::Error>>>(err: E) -> Self {
        ListTagsForStreamError::Unhandled(err.into())
    }
    pub fn message(&self) -> Option<&str> {
        match self {
            ListTagsForStreamError::InvalidArgumentError(_inner) => _inner.message(),
            ListTagsForStreamError::LimitExceededError(_inner) => _inner.message(),
            ListTagsForStreamError::ResourceNotFoundError(_inner) => _inner.message(),
            ListTagsForStreamError::Unhandled(_inner) => {
                match _inner.downcast_ref::<::smithy_types::Error>() {
                    Some(_inner) => _inner.message(),
                    None => None,
                }
            }
        }
    }
    pub fn code(&self) -> Option<&str> {
        match self {
            ListTagsForStreamError::InvalidArgumentError(_inner) => Some(_inner.code()),
            ListTagsForStreamError::LimitExceededError(_inner) => Some(_inner.code()),
            ListTagsForStreamError::ResourceNotFoundError(_inner) => Some(_inner.code()),
            ListTagsForStreamError::Unhandled(_inner) => {
                match _inner.downcast_ref::<::smithy_types::Error>() {
                    Some(_inner) => _inner.code(),
                    None => None,
                }
            }
        }
    }
}
impl ::std::error::Error for ListTagsForStreamError {
    fn source(&self) -> Option<&(dyn ::std::error::Error + 'static)> {
        match self {
            ListTagsForStreamError::InvalidArgumentError(_inner) => Some(_inner),
            ListTagsForStreamError::LimitExceededError(_inner) => Some(_inner),
            ListTagsForStreamError::ResourceNotFoundError(_inner) => Some(_inner),
            ListTagsForStreamError::Unhandled(_inner) => {
                match _inner.downcast_ref::<::smithy_types::Error>() {
                    Some(_inner) => Some(_inner),
                    None => Some(_inner.as_ref()),
                }
            }
        }
    }
}

#[non_exhaustive]
#[derive(::std::fmt::Debug)]
pub enum MergeShardsError {
    InvalidArgumentError(InvalidArgumentError),
    LimitExceededError(LimitExceededError),
    ResourceInUseError(ResourceInUseError),
    ResourceNotFoundError(ResourceNotFoundError),

    /// An unexpected error, eg. invalid JSON returned by the service
    Unhandled(Box<dyn ::std::error::Error>),
}
impl ::std::fmt::Display for MergeShardsError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match self {
            MergeShardsError::InvalidArgumentError(_inner) => _inner.fmt(f),
            MergeShardsError::LimitExceededError(_inner) => _inner.fmt(f),
            MergeShardsError::ResourceInUseError(_inner) => _inner.fmt(f),
            MergeShardsError::ResourceNotFoundError(_inner) => _inner.fmt(f),
            MergeShardsError::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl ::smithy_types::retry::ProvideErrorKind for MergeShardsError {
    fn code(&self) -> Option<&str> {
        MergeShardsError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<::smithy_types::retry::ErrorKind> {
        match self {
            MergeShardsError::InvalidArgumentError(_inner) => None,
            MergeShardsError::LimitExceededError(_inner) => None,
            MergeShardsError::ResourceInUseError(_inner) => None,
            MergeShardsError::ResourceNotFoundError(_inner) => None,
            MergeShardsError::Unhandled(_inner) => {
                match _inner.downcast_ref::<::smithy_types::Error>() {
                    Some(_inner) => _inner.retryable_error_kind(),
                    None => None,
                }
            }
        }
    }
}
impl MergeShardsError {
    pub fn unhandled<E: Into<Box<dyn ::std::error::Error>>>(err: E) -> Self {
        MergeShardsError::Unhandled(err.into())
    }
    pub fn message(&self) -> Option<&str> {
        match self {
            MergeShardsError::InvalidArgumentError(_inner) => _inner.message(),
            MergeShardsError::LimitExceededError(_inner) => _inner.message(),
            MergeShardsError::ResourceInUseError(_inner) => _inner.message(),
            MergeShardsError::ResourceNotFoundError(_inner) => _inner.message(),
            MergeShardsError::Unhandled(_inner) => {
                match _inner.downcast_ref::<::smithy_types::Error>() {
                    Some(_inner) => _inner.message(),
                    None => None,
                }
            }
        }
    }
    pub fn code(&self) -> Option<&str> {
        match self {
            MergeShardsError::InvalidArgumentError(_inner) => Some(_inner.code()),
            MergeShardsError::LimitExceededError(_inner) => Some(_inner.code()),
            MergeShardsError::ResourceInUseError(_inner) => Some(_inner.code()),
            MergeShardsError::ResourceNotFoundError(_inner) => Some(_inner.code()),
            MergeShardsError::Unhandled(_inner) => {
                match _inner.downcast_ref::<::smithy_types::Error>() {
                    Some(_inner) => _inner.code(),
                    None => None,
                }
            }
        }
    }
}
impl ::std::error::Error for MergeShardsError {
    fn source(&self) -> Option<&(dyn ::std::error::Error + 'static)> {
        match self {
            MergeShardsError::InvalidArgumentError(_inner) => Some(_inner),
            MergeShardsError::LimitExceededError(_inner) => Some(_inner),
            MergeShardsError::ResourceInUseError(_inner) => Some(_inner),
            MergeShardsError::ResourceNotFoundError(_inner) => Some(_inner),
            MergeShardsError::Unhandled(_inner) => {
                match _inner.downcast_ref::<::smithy_types::Error>() {
                    Some(_inner) => Some(_inner),
                    None => Some(_inner.as_ref()),
                }
            }
        }
    }
}

#[non_exhaustive]
#[derive(::std::fmt::Debug)]
pub enum PutRecordError {
    InvalidArgumentError(InvalidArgumentError),
    KMSAccessDeniedError(KMSAccessDeniedError),
    KMSDisabledError(KMSDisabledError),
    KMSInvalidStateError(KMSInvalidStateError),
    KMSNotFoundError(KMSNotFoundError),
    KMSOptInRequired(KMSOptInRequired),
    KMSThrottlingError(KMSThrottlingError),
    ProvisionedThroughputExceededError(ProvisionedThroughputExceededError),
    ResourceNotFoundError(ResourceNotFoundError),

    /// An unexpected error, eg. invalid JSON returned by the service
    Unhandled(Box<dyn ::std::error::Error>),
}
impl ::std::fmt::Display for PutRecordError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match self {
            PutRecordError::InvalidArgumentError(_inner) => _inner.fmt(f),
            PutRecordError::KMSAccessDeniedError(_inner) => _inner.fmt(f),
            PutRecordError::KMSDisabledError(_inner) => _inner.fmt(f),
            PutRecordError::KMSInvalidStateError(_inner) => _inner.fmt(f),
            PutRecordError::KMSNotFoundError(_inner) => _inner.fmt(f),
            PutRecordError::KMSOptInRequired(_inner) => _inner.fmt(f),
            PutRecordError::KMSThrottlingError(_inner) => _inner.fmt(f),
            PutRecordError::ProvisionedThroughputExceededError(_inner) => _inner.fmt(f),
            PutRecordError::ResourceNotFoundError(_inner) => _inner.fmt(f),
            PutRecordError::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl ::smithy_types::retry::ProvideErrorKind for PutRecordError {
    fn code(&self) -> Option<&str> {
        PutRecordError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<::smithy_types::retry::ErrorKind> {
        match self {
            PutRecordError::InvalidArgumentError(_inner) => None,
            PutRecordError::KMSAccessDeniedError(_inner) => None,
            PutRecordError::KMSDisabledError(_inner) => None,
            PutRecordError::KMSInvalidStateError(_inner) => None,
            PutRecordError::KMSNotFoundError(_inner) => None,
            PutRecordError::KMSOptInRequired(_inner) => None,
            PutRecordError::KMSThrottlingError(_inner) => None,
            PutRecordError::ProvisionedThroughputExceededError(_inner) => None,
            PutRecordError::ResourceNotFoundError(_inner) => None,
            PutRecordError::Unhandled(_inner) => {
                match _inner.downcast_ref::<::smithy_types::Error>() {
                    Some(_inner) => _inner.retryable_error_kind(),
                    None => None,
                }
            }
        }
    }
}
impl PutRecordError {
    pub fn unhandled<E: Into<Box<dyn ::std::error::Error>>>(err: E) -> Self {
        PutRecordError::Unhandled(err.into())
    }
    pub fn message(&self) -> Option<&str> {
        match self {
            PutRecordError::InvalidArgumentError(_inner) => _inner.message(),
            PutRecordError::KMSAccessDeniedError(_inner) => _inner.message(),
            PutRecordError::KMSDisabledError(_inner) => _inner.message(),
            PutRecordError::KMSInvalidStateError(_inner) => _inner.message(),
            PutRecordError::KMSNotFoundError(_inner) => _inner.message(),
            PutRecordError::KMSOptInRequired(_inner) => _inner.message(),
            PutRecordError::KMSThrottlingError(_inner) => _inner.message(),
            PutRecordError::ProvisionedThroughputExceededError(_inner) => _inner.message(),
            PutRecordError::ResourceNotFoundError(_inner) => _inner.message(),
            PutRecordError::Unhandled(_inner) => {
                match _inner.downcast_ref::<::smithy_types::Error>() {
                    Some(_inner) => _inner.message(),
                    None => None,
                }
            }
        }
    }
    pub fn code(&self) -> Option<&str> {
        match self {
            PutRecordError::InvalidArgumentError(_inner) => Some(_inner.code()),
            PutRecordError::KMSAccessDeniedError(_inner) => Some(_inner.code()),
            PutRecordError::KMSDisabledError(_inner) => Some(_inner.code()),
            PutRecordError::KMSInvalidStateError(_inner) => Some(_inner.code()),
            PutRecordError::KMSNotFoundError(_inner) => Some(_inner.code()),
            PutRecordError::KMSOptInRequired(_inner) => Some(_inner.code()),
            PutRecordError::KMSThrottlingError(_inner) => Some(_inner.code()),
            PutRecordError::ProvisionedThroughputExceededError(_inner) => Some(_inner.code()),
            PutRecordError::ResourceNotFoundError(_inner) => Some(_inner.code()),
            PutRecordError::Unhandled(_inner) => {
                match _inner.downcast_ref::<::smithy_types::Error>() {
                    Some(_inner) => _inner.code(),
                    None => None,
                }
            }
        }
    }
}
impl ::std::error::Error for PutRecordError {
    fn source(&self) -> Option<&(dyn ::std::error::Error + 'static)> {
        match self {
            PutRecordError::InvalidArgumentError(_inner) => Some(_inner),
            PutRecordError::KMSAccessDeniedError(_inner) => Some(_inner),
            PutRecordError::KMSDisabledError(_inner) => Some(_inner),
            PutRecordError::KMSInvalidStateError(_inner) => Some(_inner),
            PutRecordError::KMSNotFoundError(_inner) => Some(_inner),
            PutRecordError::KMSOptInRequired(_inner) => Some(_inner),
            PutRecordError::KMSThrottlingError(_inner) => Some(_inner),
            PutRecordError::ProvisionedThroughputExceededError(_inner) => Some(_inner),
            PutRecordError::ResourceNotFoundError(_inner) => Some(_inner),
            PutRecordError::Unhandled(_inner) => {
                match _inner.downcast_ref::<::smithy_types::Error>() {
                    Some(_inner) => Some(_inner),
                    None => Some(_inner.as_ref()),
                }
            }
        }
    }
}

#[non_exhaustive]
#[derive(::std::fmt::Debug)]
pub enum PutRecordsError {
    InvalidArgumentError(InvalidArgumentError),
    KMSAccessDeniedError(KMSAccessDeniedError),
    KMSDisabledError(KMSDisabledError),
    KMSInvalidStateError(KMSInvalidStateError),
    KMSNotFoundError(KMSNotFoundError),
    KMSOptInRequired(KMSOptInRequired),
    KMSThrottlingError(KMSThrottlingError),
    ProvisionedThroughputExceededError(ProvisionedThroughputExceededError),
    ResourceNotFoundError(ResourceNotFoundError),

    /// An unexpected error, eg. invalid JSON returned by the service
    Unhandled(Box<dyn ::std::error::Error>),
}
impl ::std::fmt::Display for PutRecordsError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match self {
            PutRecordsError::InvalidArgumentError(_inner) => _inner.fmt(f),
            PutRecordsError::KMSAccessDeniedError(_inner) => _inner.fmt(f),
            PutRecordsError::KMSDisabledError(_inner) => _inner.fmt(f),
            PutRecordsError::KMSInvalidStateError(_inner) => _inner.fmt(f),
            PutRecordsError::KMSNotFoundError(_inner) => _inner.fmt(f),
            PutRecordsError::KMSOptInRequired(_inner) => _inner.fmt(f),
            PutRecordsError::KMSThrottlingError(_inner) => _inner.fmt(f),
            PutRecordsError::ProvisionedThroughputExceededError(_inner) => _inner.fmt(f),
            PutRecordsError::ResourceNotFoundError(_inner) => _inner.fmt(f),
            PutRecordsError::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl ::smithy_types::retry::ProvideErrorKind for PutRecordsError {
    fn code(&self) -> Option<&str> {
        PutRecordsError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<::smithy_types::retry::ErrorKind> {
        match self {
            PutRecordsError::InvalidArgumentError(_inner) => None,
            PutRecordsError::KMSAccessDeniedError(_inner) => None,
            PutRecordsError::KMSDisabledError(_inner) => None,
            PutRecordsError::KMSInvalidStateError(_inner) => None,
            PutRecordsError::KMSNotFoundError(_inner) => None,
            PutRecordsError::KMSOptInRequired(_inner) => None,
            PutRecordsError::KMSThrottlingError(_inner) => None,
            PutRecordsError::ProvisionedThroughputExceededError(_inner) => None,
            PutRecordsError::ResourceNotFoundError(_inner) => None,
            PutRecordsError::Unhandled(_inner) => {
                match _inner.downcast_ref::<::smithy_types::Error>() {
                    Some(_inner) => _inner.retryable_error_kind(),
                    None => None,
                }
            }
        }
    }
}
impl PutRecordsError {
    pub fn unhandled<E: Into<Box<dyn ::std::error::Error>>>(err: E) -> Self {
        PutRecordsError::Unhandled(err.into())
    }
    pub fn message(&self) -> Option<&str> {
        match self {
            PutRecordsError::InvalidArgumentError(_inner) => _inner.message(),
            PutRecordsError::KMSAccessDeniedError(_inner) => _inner.message(),
            PutRecordsError::KMSDisabledError(_inner) => _inner.message(),
            PutRecordsError::KMSInvalidStateError(_inner) => _inner.message(),
            PutRecordsError::KMSNotFoundError(_inner) => _inner.message(),
            PutRecordsError::KMSOptInRequired(_inner) => _inner.message(),
            PutRecordsError::KMSThrottlingError(_inner) => _inner.message(),
            PutRecordsError::ProvisionedThroughputExceededError(_inner) => _inner.message(),
            PutRecordsError::ResourceNotFoundError(_inner) => _inner.message(),
            PutRecordsError::Unhandled(_inner) => {
                match _inner.downcast_ref::<::smithy_types::Error>() {
                    Some(_inner) => _inner.message(),
                    None => None,
                }
            }
        }
    }
    pub fn code(&self) -> Option<&str> {
        match self {
            PutRecordsError::InvalidArgumentError(_inner) => Some(_inner.code()),
            PutRecordsError::KMSAccessDeniedError(_inner) => Some(_inner.code()),
            PutRecordsError::KMSDisabledError(_inner) => Some(_inner.code()),
            PutRecordsError::KMSInvalidStateError(_inner) => Some(_inner.code()),
            PutRecordsError::KMSNotFoundError(_inner) => Some(_inner.code()),
            PutRecordsError::KMSOptInRequired(_inner) => Some(_inner.code()),
            PutRecordsError::KMSThrottlingError(_inner) => Some(_inner.code()),
            PutRecordsError::ProvisionedThroughputExceededError(_inner) => Some(_inner.code()),
            PutRecordsError::ResourceNotFoundError(_inner) => Some(_inner.code()),
            PutRecordsError::Unhandled(_inner) => {
                match _inner.downcast_ref::<::smithy_types::Error>() {
                    Some(_inner) => _inner.code(),
                    None => None,
                }
            }
        }
    }
}
impl ::std::error::Error for PutRecordsError {
    fn source(&self) -> Option<&(dyn ::std::error::Error + 'static)> {
        match self {
            PutRecordsError::InvalidArgumentError(_inner) => Some(_inner),
            PutRecordsError::KMSAccessDeniedError(_inner) => Some(_inner),
            PutRecordsError::KMSDisabledError(_inner) => Some(_inner),
            PutRecordsError::KMSInvalidStateError(_inner) => Some(_inner),
            PutRecordsError::KMSNotFoundError(_inner) => Some(_inner),
            PutRecordsError::KMSOptInRequired(_inner) => Some(_inner),
            PutRecordsError::KMSThrottlingError(_inner) => Some(_inner),
            PutRecordsError::ProvisionedThroughputExceededError(_inner) => Some(_inner),
            PutRecordsError::ResourceNotFoundError(_inner) => Some(_inner),
            PutRecordsError::Unhandled(_inner) => {
                match _inner.downcast_ref::<::smithy_types::Error>() {
                    Some(_inner) => Some(_inner),
                    None => Some(_inner.as_ref()),
                }
            }
        }
    }
}

#[non_exhaustive]
#[derive(::std::fmt::Debug)]
pub enum RegisterStreamConsumerError {
    InvalidArgumentError(InvalidArgumentError),
    LimitExceededError(LimitExceededError),
    ResourceInUseError(ResourceInUseError),
    ResourceNotFoundError(ResourceNotFoundError),

    /// An unexpected error, eg. invalid JSON returned by the service
    Unhandled(Box<dyn ::std::error::Error>),
}
impl ::std::fmt::Display for RegisterStreamConsumerError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match self {
            RegisterStreamConsumerError::InvalidArgumentError(_inner) => _inner.fmt(f),
            RegisterStreamConsumerError::LimitExceededError(_inner) => _inner.fmt(f),
            RegisterStreamConsumerError::ResourceInUseError(_inner) => _inner.fmt(f),
            RegisterStreamConsumerError::ResourceNotFoundError(_inner) => _inner.fmt(f),
            RegisterStreamConsumerError::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl ::smithy_types::retry::ProvideErrorKind for RegisterStreamConsumerError {
    fn code(&self) -> Option<&str> {
        RegisterStreamConsumerError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<::smithy_types::retry::ErrorKind> {
        match self {
            RegisterStreamConsumerError::InvalidArgumentError(_inner) => None,
            RegisterStreamConsumerError::LimitExceededError(_inner) => None,
            RegisterStreamConsumerError::ResourceInUseError(_inner) => None,
            RegisterStreamConsumerError::ResourceNotFoundError(_inner) => None,
            RegisterStreamConsumerError::Unhandled(_inner) => {
                match _inner.downcast_ref::<::smithy_types::Error>() {
                    Some(_inner) => _inner.retryable_error_kind(),
                    None => None,
                }
            }
        }
    }
}
impl RegisterStreamConsumerError {
    pub fn unhandled<E: Into<Box<dyn ::std::error::Error>>>(err: E) -> Self {
        RegisterStreamConsumerError::Unhandled(err.into())
    }
    pub fn message(&self) -> Option<&str> {
        match self {
            RegisterStreamConsumerError::InvalidArgumentError(_inner) => _inner.message(),
            RegisterStreamConsumerError::LimitExceededError(_inner) => _inner.message(),
            RegisterStreamConsumerError::ResourceInUseError(_inner) => _inner.message(),
            RegisterStreamConsumerError::ResourceNotFoundError(_inner) => _inner.message(),
            RegisterStreamConsumerError::Unhandled(_inner) => {
                match _inner.downcast_ref::<::smithy_types::Error>() {
                    Some(_inner) => _inner.message(),
                    None => None,
                }
            }
        }
    }
    pub fn code(&self) -> Option<&str> {
        match self {
            RegisterStreamConsumerError::InvalidArgumentError(_inner) => Some(_inner.code()),
            RegisterStreamConsumerError::LimitExceededError(_inner) => Some(_inner.code()),
            RegisterStreamConsumerError::ResourceInUseError(_inner) => Some(_inner.code()),
            RegisterStreamConsumerError::ResourceNotFoundError(_inner) => Some(_inner.code()),
            RegisterStreamConsumerError::Unhandled(_inner) => {
                match _inner.downcast_ref::<::smithy_types::Error>() {
                    Some(_inner) => _inner.code(),
                    None => None,
                }
            }
        }
    }
}
impl ::std::error::Error for RegisterStreamConsumerError {
    fn source(&self) -> Option<&(dyn ::std::error::Error + 'static)> {
        match self {
            RegisterStreamConsumerError::InvalidArgumentError(_inner) => Some(_inner),
            RegisterStreamConsumerError::LimitExceededError(_inner) => Some(_inner),
            RegisterStreamConsumerError::ResourceInUseError(_inner) => Some(_inner),
            RegisterStreamConsumerError::ResourceNotFoundError(_inner) => Some(_inner),
            RegisterStreamConsumerError::Unhandled(_inner) => {
                match _inner.downcast_ref::<::smithy_types::Error>() {
                    Some(_inner) => Some(_inner),
                    None => Some(_inner.as_ref()),
                }
            }
        }
    }
}

#[non_exhaustive]
#[derive(::std::fmt::Debug)]
pub enum RemoveTagsFromStreamError {
    InvalidArgumentError(InvalidArgumentError),
    LimitExceededError(LimitExceededError),
    ResourceInUseError(ResourceInUseError),
    ResourceNotFoundError(ResourceNotFoundError),

    /// An unexpected error, eg. invalid JSON returned by the service
    Unhandled(Box<dyn ::std::error::Error>),
}
impl ::std::fmt::Display for RemoveTagsFromStreamError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match self {
            RemoveTagsFromStreamError::InvalidArgumentError(_inner) => _inner.fmt(f),
            RemoveTagsFromStreamError::LimitExceededError(_inner) => _inner.fmt(f),
            RemoveTagsFromStreamError::ResourceInUseError(_inner) => _inner.fmt(f),
            RemoveTagsFromStreamError::ResourceNotFoundError(_inner) => _inner.fmt(f),
            RemoveTagsFromStreamError::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl ::smithy_types::retry::ProvideErrorKind for RemoveTagsFromStreamError {
    fn code(&self) -> Option<&str> {
        RemoveTagsFromStreamError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<::smithy_types::retry::ErrorKind> {
        match self {
            RemoveTagsFromStreamError::InvalidArgumentError(_inner) => None,
            RemoveTagsFromStreamError::LimitExceededError(_inner) => None,
            RemoveTagsFromStreamError::ResourceInUseError(_inner) => None,
            RemoveTagsFromStreamError::ResourceNotFoundError(_inner) => None,
            RemoveTagsFromStreamError::Unhandled(_inner) => {
                match _inner.downcast_ref::<::smithy_types::Error>() {
                    Some(_inner) => _inner.retryable_error_kind(),
                    None => None,
                }
            }
        }
    }
}
impl RemoveTagsFromStreamError {
    pub fn unhandled<E: Into<Box<dyn ::std::error::Error>>>(err: E) -> Self {
        RemoveTagsFromStreamError::Unhandled(err.into())
    }
    pub fn message(&self) -> Option<&str> {
        match self {
            RemoveTagsFromStreamError::InvalidArgumentError(_inner) => _inner.message(),
            RemoveTagsFromStreamError::LimitExceededError(_inner) => _inner.message(),
            RemoveTagsFromStreamError::ResourceInUseError(_inner) => _inner.message(),
            RemoveTagsFromStreamError::ResourceNotFoundError(_inner) => _inner.message(),
            RemoveTagsFromStreamError::Unhandled(_inner) => {
                match _inner.downcast_ref::<::smithy_types::Error>() {
                    Some(_inner) => _inner.message(),
                    None => None,
                }
            }
        }
    }
    pub fn code(&self) -> Option<&str> {
        match self {
            RemoveTagsFromStreamError::InvalidArgumentError(_inner) => Some(_inner.code()),
            RemoveTagsFromStreamError::LimitExceededError(_inner) => Some(_inner.code()),
            RemoveTagsFromStreamError::ResourceInUseError(_inner) => Some(_inner.code()),
            RemoveTagsFromStreamError::ResourceNotFoundError(_inner) => Some(_inner.code()),
            RemoveTagsFromStreamError::Unhandled(_inner) => {
                match _inner.downcast_ref::<::smithy_types::Error>() {
                    Some(_inner) => _inner.code(),
                    None => None,
                }
            }
        }
    }
}
impl ::std::error::Error for RemoveTagsFromStreamError {
    fn source(&self) -> Option<&(dyn ::std::error::Error + 'static)> {
        match self {
            RemoveTagsFromStreamError::InvalidArgumentError(_inner) => Some(_inner),
            RemoveTagsFromStreamError::LimitExceededError(_inner) => Some(_inner),
            RemoveTagsFromStreamError::ResourceInUseError(_inner) => Some(_inner),
            RemoveTagsFromStreamError::ResourceNotFoundError(_inner) => Some(_inner),
            RemoveTagsFromStreamError::Unhandled(_inner) => {
                match _inner.downcast_ref::<::smithy_types::Error>() {
                    Some(_inner) => Some(_inner),
                    None => Some(_inner.as_ref()),
                }
            }
        }
    }
}

#[non_exhaustive]
#[derive(::std::fmt::Debug)]
pub enum SplitShardError {
    InvalidArgumentError(InvalidArgumentError),
    LimitExceededError(LimitExceededError),
    ResourceInUseError(ResourceInUseError),
    ResourceNotFoundError(ResourceNotFoundError),

    /// An unexpected error, eg. invalid JSON returned by the service
    Unhandled(Box<dyn ::std::error::Error>),
}
impl ::std::fmt::Display for SplitShardError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match self {
            SplitShardError::InvalidArgumentError(_inner) => _inner.fmt(f),
            SplitShardError::LimitExceededError(_inner) => _inner.fmt(f),
            SplitShardError::ResourceInUseError(_inner) => _inner.fmt(f),
            SplitShardError::ResourceNotFoundError(_inner) => _inner.fmt(f),
            SplitShardError::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl ::smithy_types::retry::ProvideErrorKind for SplitShardError {
    fn code(&self) -> Option<&str> {
        SplitShardError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<::smithy_types::retry::ErrorKind> {
        match self {
            SplitShardError::InvalidArgumentError(_inner) => None,
            SplitShardError::LimitExceededError(_inner) => None,
            SplitShardError::ResourceInUseError(_inner) => None,
            SplitShardError::ResourceNotFoundError(_inner) => None,
            SplitShardError::Unhandled(_inner) => {
                match _inner.downcast_ref::<::smithy_types::Error>() {
                    Some(_inner) => _inner.retryable_error_kind(),
                    None => None,
                }
            }
        }
    }
}
impl SplitShardError {
    pub fn unhandled<E: Into<Box<dyn ::std::error::Error>>>(err: E) -> Self {
        SplitShardError::Unhandled(err.into())
    }
    pub fn message(&self) -> Option<&str> {
        match self {
            SplitShardError::InvalidArgumentError(_inner) => _inner.message(),
            SplitShardError::LimitExceededError(_inner) => _inner.message(),
            SplitShardError::ResourceInUseError(_inner) => _inner.message(),
            SplitShardError::ResourceNotFoundError(_inner) => _inner.message(),
            SplitShardError::Unhandled(_inner) => {
                match _inner.downcast_ref::<::smithy_types::Error>() {
                    Some(_inner) => _inner.message(),
                    None => None,
                }
            }
        }
    }
    pub fn code(&self) -> Option<&str> {
        match self {
            SplitShardError::InvalidArgumentError(_inner) => Some(_inner.code()),
            SplitShardError::LimitExceededError(_inner) => Some(_inner.code()),
            SplitShardError::ResourceInUseError(_inner) => Some(_inner.code()),
            SplitShardError::ResourceNotFoundError(_inner) => Some(_inner.code()),
            SplitShardError::Unhandled(_inner) => {
                match _inner.downcast_ref::<::smithy_types::Error>() {
                    Some(_inner) => _inner.code(),
                    None => None,
                }
            }
        }
    }
}
impl ::std::error::Error for SplitShardError {
    fn source(&self) -> Option<&(dyn ::std::error::Error + 'static)> {
        match self {
            SplitShardError::InvalidArgumentError(_inner) => Some(_inner),
            SplitShardError::LimitExceededError(_inner) => Some(_inner),
            SplitShardError::ResourceInUseError(_inner) => Some(_inner),
            SplitShardError::ResourceNotFoundError(_inner) => Some(_inner),
            SplitShardError::Unhandled(_inner) => {
                match _inner.downcast_ref::<::smithy_types::Error>() {
                    Some(_inner) => Some(_inner),
                    None => Some(_inner.as_ref()),
                }
            }
        }
    }
}

#[non_exhaustive]
#[derive(::std::fmt::Debug)]
pub enum StartStreamEncryptionError {
    InvalidArgumentError(InvalidArgumentError),
    KMSAccessDeniedError(KMSAccessDeniedError),
    KMSDisabledError(KMSDisabledError),
    KMSInvalidStateError(KMSInvalidStateError),
    KMSNotFoundError(KMSNotFoundError),
    KMSOptInRequired(KMSOptInRequired),
    KMSThrottlingError(KMSThrottlingError),
    LimitExceededError(LimitExceededError),
    ResourceInUseError(ResourceInUseError),
    ResourceNotFoundError(ResourceNotFoundError),

    /// An unexpected error, eg. invalid JSON returned by the service
    Unhandled(Box<dyn ::std::error::Error>),
}
impl ::std::fmt::Display for StartStreamEncryptionError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match self {
            StartStreamEncryptionError::InvalidArgumentError(_inner) => _inner.fmt(f),
            StartStreamEncryptionError::KMSAccessDeniedError(_inner) => _inner.fmt(f),
            StartStreamEncryptionError::KMSDisabledError(_inner) => _inner.fmt(f),
            StartStreamEncryptionError::KMSInvalidStateError(_inner) => _inner.fmt(f),
            StartStreamEncryptionError::KMSNotFoundError(_inner) => _inner.fmt(f),
            StartStreamEncryptionError::KMSOptInRequired(_inner) => _inner.fmt(f),
            StartStreamEncryptionError::KMSThrottlingError(_inner) => _inner.fmt(f),
            StartStreamEncryptionError::LimitExceededError(_inner) => _inner.fmt(f),
            StartStreamEncryptionError::ResourceInUseError(_inner) => _inner.fmt(f),
            StartStreamEncryptionError::ResourceNotFoundError(_inner) => _inner.fmt(f),
            StartStreamEncryptionError::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl ::smithy_types::retry::ProvideErrorKind for StartStreamEncryptionError {
    fn code(&self) -> Option<&str> {
        StartStreamEncryptionError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<::smithy_types::retry::ErrorKind> {
        match self {
            StartStreamEncryptionError::InvalidArgumentError(_inner) => None,
            StartStreamEncryptionError::KMSAccessDeniedError(_inner) => None,
            StartStreamEncryptionError::KMSDisabledError(_inner) => None,
            StartStreamEncryptionError::KMSInvalidStateError(_inner) => None,
            StartStreamEncryptionError::KMSNotFoundError(_inner) => None,
            StartStreamEncryptionError::KMSOptInRequired(_inner) => None,
            StartStreamEncryptionError::KMSThrottlingError(_inner) => None,
            StartStreamEncryptionError::LimitExceededError(_inner) => None,
            StartStreamEncryptionError::ResourceInUseError(_inner) => None,
            StartStreamEncryptionError::ResourceNotFoundError(_inner) => None,
            StartStreamEncryptionError::Unhandled(_inner) => {
                match _inner.downcast_ref::<::smithy_types::Error>() {
                    Some(_inner) => _inner.retryable_error_kind(),
                    None => None,
                }
            }
        }
    }
}
impl StartStreamEncryptionError {
    pub fn unhandled<E: Into<Box<dyn ::std::error::Error>>>(err: E) -> Self {
        StartStreamEncryptionError::Unhandled(err.into())
    }
    pub fn message(&self) -> Option<&str> {
        match self {
            StartStreamEncryptionError::InvalidArgumentError(_inner) => _inner.message(),
            StartStreamEncryptionError::KMSAccessDeniedError(_inner) => _inner.message(),
            StartStreamEncryptionError::KMSDisabledError(_inner) => _inner.message(),
            StartStreamEncryptionError::KMSInvalidStateError(_inner) => _inner.message(),
            StartStreamEncryptionError::KMSNotFoundError(_inner) => _inner.message(),
            StartStreamEncryptionError::KMSOptInRequired(_inner) => _inner.message(),
            StartStreamEncryptionError::KMSThrottlingError(_inner) => _inner.message(),
            StartStreamEncryptionError::LimitExceededError(_inner) => _inner.message(),
            StartStreamEncryptionError::ResourceInUseError(_inner) => _inner.message(),
            StartStreamEncryptionError::ResourceNotFoundError(_inner) => _inner.message(),
            StartStreamEncryptionError::Unhandled(_inner) => {
                match _inner.downcast_ref::<::smithy_types::Error>() {
                    Some(_inner) => _inner.message(),
                    None => None,
                }
            }
        }
    }
    pub fn code(&self) -> Option<&str> {
        match self {
            StartStreamEncryptionError::InvalidArgumentError(_inner) => Some(_inner.code()),
            StartStreamEncryptionError::KMSAccessDeniedError(_inner) => Some(_inner.code()),
            StartStreamEncryptionError::KMSDisabledError(_inner) => Some(_inner.code()),
            StartStreamEncryptionError::KMSInvalidStateError(_inner) => Some(_inner.code()),
            StartStreamEncryptionError::KMSNotFoundError(_inner) => Some(_inner.code()),
            StartStreamEncryptionError::KMSOptInRequired(_inner) => Some(_inner.code()),
            StartStreamEncryptionError::KMSThrottlingError(_inner) => Some(_inner.code()),
            StartStreamEncryptionError::LimitExceededError(_inner) => Some(_inner.code()),
            StartStreamEncryptionError::ResourceInUseError(_inner) => Some(_inner.code()),
            StartStreamEncryptionError::ResourceNotFoundError(_inner) => Some(_inner.code()),
            StartStreamEncryptionError::Unhandled(_inner) => {
                match _inner.downcast_ref::<::smithy_types::Error>() {
                    Some(_inner) => _inner.code(),
                    None => None,
                }
            }
        }
    }
}
impl ::std::error::Error for StartStreamEncryptionError {
    fn source(&self) -> Option<&(dyn ::std::error::Error + 'static)> {
        match self {
            StartStreamEncryptionError::InvalidArgumentError(_inner) => Some(_inner),
            StartStreamEncryptionError::KMSAccessDeniedError(_inner) => Some(_inner),
            StartStreamEncryptionError::KMSDisabledError(_inner) => Some(_inner),
            StartStreamEncryptionError::KMSInvalidStateError(_inner) => Some(_inner),
            StartStreamEncryptionError::KMSNotFoundError(_inner) => Some(_inner),
            StartStreamEncryptionError::KMSOptInRequired(_inner) => Some(_inner),
            StartStreamEncryptionError::KMSThrottlingError(_inner) => Some(_inner),
            StartStreamEncryptionError::LimitExceededError(_inner) => Some(_inner),
            StartStreamEncryptionError::ResourceInUseError(_inner) => Some(_inner),
            StartStreamEncryptionError::ResourceNotFoundError(_inner) => Some(_inner),
            StartStreamEncryptionError::Unhandled(_inner) => {
                match _inner.downcast_ref::<::smithy_types::Error>() {
                    Some(_inner) => Some(_inner),
                    None => Some(_inner.as_ref()),
                }
            }
        }
    }
}

#[non_exhaustive]
#[derive(::std::fmt::Debug)]
pub enum StopStreamEncryptionError {
    InvalidArgumentError(InvalidArgumentError),
    LimitExceededError(LimitExceededError),
    ResourceInUseError(ResourceInUseError),
    ResourceNotFoundError(ResourceNotFoundError),

    /// An unexpected error, eg. invalid JSON returned by the service
    Unhandled(Box<dyn ::std::error::Error>),
}
impl ::std::fmt::Display for StopStreamEncryptionError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match self {
            StopStreamEncryptionError::InvalidArgumentError(_inner) => _inner.fmt(f),
            StopStreamEncryptionError::LimitExceededError(_inner) => _inner.fmt(f),
            StopStreamEncryptionError::ResourceInUseError(_inner) => _inner.fmt(f),
            StopStreamEncryptionError::ResourceNotFoundError(_inner) => _inner.fmt(f),
            StopStreamEncryptionError::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl ::smithy_types::retry::ProvideErrorKind for StopStreamEncryptionError {
    fn code(&self) -> Option<&str> {
        StopStreamEncryptionError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<::smithy_types::retry::ErrorKind> {
        match self {
            StopStreamEncryptionError::InvalidArgumentError(_inner) => None,
            StopStreamEncryptionError::LimitExceededError(_inner) => None,
            StopStreamEncryptionError::ResourceInUseError(_inner) => None,
            StopStreamEncryptionError::ResourceNotFoundError(_inner) => None,
            StopStreamEncryptionError::Unhandled(_inner) => {
                match _inner.downcast_ref::<::smithy_types::Error>() {
                    Some(_inner) => _inner.retryable_error_kind(),
                    None => None,
                }
            }
        }
    }
}
impl StopStreamEncryptionError {
    pub fn unhandled<E: Into<Box<dyn ::std::error::Error>>>(err: E) -> Self {
        StopStreamEncryptionError::Unhandled(err.into())
    }
    pub fn message(&self) -> Option<&str> {
        match self {
            StopStreamEncryptionError::InvalidArgumentError(_inner) => _inner.message(),
            StopStreamEncryptionError::LimitExceededError(_inner) => _inner.message(),
            StopStreamEncryptionError::ResourceInUseError(_inner) => _inner.message(),
            StopStreamEncryptionError::ResourceNotFoundError(_inner) => _inner.message(),
            StopStreamEncryptionError::Unhandled(_inner) => {
                match _inner.downcast_ref::<::smithy_types::Error>() {
                    Some(_inner) => _inner.message(),
                    None => None,
                }
            }
        }
    }
    pub fn code(&self) -> Option<&str> {
        match self {
            StopStreamEncryptionError::InvalidArgumentError(_inner) => Some(_inner.code()),
            StopStreamEncryptionError::LimitExceededError(_inner) => Some(_inner.code()),
            StopStreamEncryptionError::ResourceInUseError(_inner) => Some(_inner.code()),
            StopStreamEncryptionError::ResourceNotFoundError(_inner) => Some(_inner.code()),
            StopStreamEncryptionError::Unhandled(_inner) => {
                match _inner.downcast_ref::<::smithy_types::Error>() {
                    Some(_inner) => _inner.code(),
                    None => None,
                }
            }
        }
    }
}
impl ::std::error::Error for StopStreamEncryptionError {
    fn source(&self) -> Option<&(dyn ::std::error::Error + 'static)> {
        match self {
            StopStreamEncryptionError::InvalidArgumentError(_inner) => Some(_inner),
            StopStreamEncryptionError::LimitExceededError(_inner) => Some(_inner),
            StopStreamEncryptionError::ResourceInUseError(_inner) => Some(_inner),
            StopStreamEncryptionError::ResourceNotFoundError(_inner) => Some(_inner),
            StopStreamEncryptionError::Unhandled(_inner) => {
                match _inner.downcast_ref::<::smithy_types::Error>() {
                    Some(_inner) => Some(_inner),
                    None => Some(_inner.as_ref()),
                }
            }
        }
    }
}

#[non_exhaustive]
#[derive(::std::fmt::Debug)]
pub enum SubscribeToShardError {
    InvalidArgumentError(InvalidArgumentError),
    LimitExceededError(LimitExceededError),
    ResourceInUseError(ResourceInUseError),
    ResourceNotFoundError(ResourceNotFoundError),

    /// An unexpected error, eg. invalid JSON returned by the service
    Unhandled(Box<dyn ::std::error::Error>),
}
impl ::std::fmt::Display for SubscribeToShardError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match self {
            SubscribeToShardError::InvalidArgumentError(_inner) => _inner.fmt(f),
            SubscribeToShardError::LimitExceededError(_inner) => _inner.fmt(f),
            SubscribeToShardError::ResourceInUseError(_inner) => _inner.fmt(f),
            SubscribeToShardError::ResourceNotFoundError(_inner) => _inner.fmt(f),
            SubscribeToShardError::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl ::smithy_types::retry::ProvideErrorKind for SubscribeToShardError {
    fn code(&self) -> Option<&str> {
        SubscribeToShardError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<::smithy_types::retry::ErrorKind> {
        match self {
            SubscribeToShardError::InvalidArgumentError(_inner) => None,
            SubscribeToShardError::LimitExceededError(_inner) => None,
            SubscribeToShardError::ResourceInUseError(_inner) => None,
            SubscribeToShardError::ResourceNotFoundError(_inner) => None,
            SubscribeToShardError::Unhandled(_inner) => {
                match _inner.downcast_ref::<::smithy_types::Error>() {
                    Some(_inner) => _inner.retryable_error_kind(),
                    None => None,
                }
            }
        }
    }
}
impl SubscribeToShardError {
    pub fn unhandled<E: Into<Box<dyn ::std::error::Error>>>(err: E) -> Self {
        SubscribeToShardError::Unhandled(err.into())
    }
    pub fn message(&self) -> Option<&str> {
        match self {
            SubscribeToShardError::InvalidArgumentError(_inner) => _inner.message(),
            SubscribeToShardError::LimitExceededError(_inner) => _inner.message(),
            SubscribeToShardError::ResourceInUseError(_inner) => _inner.message(),
            SubscribeToShardError::ResourceNotFoundError(_inner) => _inner.message(),
            SubscribeToShardError::Unhandled(_inner) => {
                match _inner.downcast_ref::<::smithy_types::Error>() {
                    Some(_inner) => _inner.message(),
                    None => None,
                }
            }
        }
    }
    pub fn code(&self) -> Option<&str> {
        match self {
            SubscribeToShardError::InvalidArgumentError(_inner) => Some(_inner.code()),
            SubscribeToShardError::LimitExceededError(_inner) => Some(_inner.code()),
            SubscribeToShardError::ResourceInUseError(_inner) => Some(_inner.code()),
            SubscribeToShardError::ResourceNotFoundError(_inner) => Some(_inner.code()),
            SubscribeToShardError::Unhandled(_inner) => {
                match _inner.downcast_ref::<::smithy_types::Error>() {
                    Some(_inner) => _inner.code(),
                    None => None,
                }
            }
        }
    }
}
impl ::std::error::Error for SubscribeToShardError {
    fn source(&self) -> Option<&(dyn ::std::error::Error + 'static)> {
        match self {
            SubscribeToShardError::InvalidArgumentError(_inner) => Some(_inner),
            SubscribeToShardError::LimitExceededError(_inner) => Some(_inner),
            SubscribeToShardError::ResourceInUseError(_inner) => Some(_inner),
            SubscribeToShardError::ResourceNotFoundError(_inner) => Some(_inner),
            SubscribeToShardError::Unhandled(_inner) => {
                match _inner.downcast_ref::<::smithy_types::Error>() {
                    Some(_inner) => Some(_inner),
                    None => Some(_inner.as_ref()),
                }
            }
        }
    }
}

#[non_exhaustive]
#[derive(::std::fmt::Debug)]
pub enum UpdateShardCountError {
    InvalidArgumentError(InvalidArgumentError),
    LimitExceededError(LimitExceededError),
    ResourceInUseError(ResourceInUseError),
    ResourceNotFoundError(ResourceNotFoundError),

    /// An unexpected error, eg. invalid JSON returned by the service
    Unhandled(Box<dyn ::std::error::Error>),
}
impl ::std::fmt::Display for UpdateShardCountError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match self {
            UpdateShardCountError::InvalidArgumentError(_inner) => _inner.fmt(f),
            UpdateShardCountError::LimitExceededError(_inner) => _inner.fmt(f),
            UpdateShardCountError::ResourceInUseError(_inner) => _inner.fmt(f),
            UpdateShardCountError::ResourceNotFoundError(_inner) => _inner.fmt(f),
            UpdateShardCountError::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl ::smithy_types::retry::ProvideErrorKind for UpdateShardCountError {
    fn code(&self) -> Option<&str> {
        UpdateShardCountError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<::smithy_types::retry::ErrorKind> {
        match self {
            UpdateShardCountError::InvalidArgumentError(_inner) => None,
            UpdateShardCountError::LimitExceededError(_inner) => None,
            UpdateShardCountError::ResourceInUseError(_inner) => None,
            UpdateShardCountError::ResourceNotFoundError(_inner) => None,
            UpdateShardCountError::Unhandled(_inner) => {
                match _inner.downcast_ref::<::smithy_types::Error>() {
                    Some(_inner) => _inner.retryable_error_kind(),
                    None => None,
                }
            }
        }
    }
}
impl UpdateShardCountError {
    pub fn unhandled<E: Into<Box<dyn ::std::error::Error>>>(err: E) -> Self {
        UpdateShardCountError::Unhandled(err.into())
    }
    pub fn message(&self) -> Option<&str> {
        match self {
            UpdateShardCountError::InvalidArgumentError(_inner) => _inner.message(),
            UpdateShardCountError::LimitExceededError(_inner) => _inner.message(),
            UpdateShardCountError::ResourceInUseError(_inner) => _inner.message(),
            UpdateShardCountError::ResourceNotFoundError(_inner) => _inner.message(),
            UpdateShardCountError::Unhandled(_inner) => {
                match _inner.downcast_ref::<::smithy_types::Error>() {
                    Some(_inner) => _inner.message(),
                    None => None,
                }
            }
        }
    }
    pub fn code(&self) -> Option<&str> {
        match self {
            UpdateShardCountError::InvalidArgumentError(_inner) => Some(_inner.code()),
            UpdateShardCountError::LimitExceededError(_inner) => Some(_inner.code()),
            UpdateShardCountError::ResourceInUseError(_inner) => Some(_inner.code()),
            UpdateShardCountError::ResourceNotFoundError(_inner) => Some(_inner.code()),
            UpdateShardCountError::Unhandled(_inner) => {
                match _inner.downcast_ref::<::smithy_types::Error>() {
                    Some(_inner) => _inner.code(),
                    None => None,
                }
            }
        }
    }
}
impl ::std::error::Error for UpdateShardCountError {
    fn source(&self) -> Option<&(dyn ::std::error::Error + 'static)> {
        match self {
            UpdateShardCountError::InvalidArgumentError(_inner) => Some(_inner),
            UpdateShardCountError::LimitExceededError(_inner) => Some(_inner),
            UpdateShardCountError::ResourceInUseError(_inner) => Some(_inner),
            UpdateShardCountError::ResourceNotFoundError(_inner) => Some(_inner),
            UpdateShardCountError::Unhandled(_inner) => {
                match _inner.downcast_ref::<::smithy_types::Error>() {
                    Some(_inner) => Some(_inner),
                    None => Some(_inner.as_ref()),
                }
            }
        }
    }
}

/// <p>The requested resource could not be found. The stream might not be specified
/// correctly.</p>
#[non_exhaustive]
#[derive(::serde::Deserialize, ::serde::Serialize, ::std::clone::Clone, ::std::cmp::PartialEq)]
pub struct ResourceNotFoundError {
    /// <p>A message that provides information about the error.</p>
    #[serde(rename = "message")]
    #[serde(skip_serializing_if = "Option::is_none")]
    #[serde(default)]
    pub message: ::std::option::Option<::std::string::String>,
}
impl ::std::fmt::Debug for ResourceNotFoundError {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        let mut formatter = f.debug_struct("ResourceNotFoundError");
        formatter.field("message", &self.message);
        formatter.finish()
    }
}
impl ResourceNotFoundError {
    pub fn code(&self) -> &str {
        "ResourceNotFoundException"
    }
    pub fn message(&self) -> Option<&str> {
        self.message.as_deref()
    }
}
impl ::std::fmt::Display for ResourceNotFoundError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "ResourceNotFoundError")?;
        if let Some(inner_1) = &self.message {
            write!(f, ": {}", inner_1)?;
        }
        Ok(())
    }
}
impl ::std::error::Error for ResourceNotFoundError {}
/// See [`ResourceNotFoundError`](crate::error::ResourceNotFoundError)
pub mod resource_not_found_error {

    use crate::error::ResourceNotFoundError;
    /// A builder for [`ResourceNotFoundError`](crate::error::ResourceNotFoundError)
    #[non_exhaustive]
    #[derive(Debug, Clone, Default)]
    pub struct Builder {
        message: ::std::option::Option<::std::string::String>,
    }
    impl Builder {
        /// <p>A message that provides information about the error.</p>
        pub fn message(mut self, inp: impl Into<::std::string::String>) -> Self {
            self.message = Some(inp.into());
            self
        }
        /// Consumes the builder and constructs a [`ResourceNotFoundError`](crate::error::ResourceNotFoundError)
        pub fn build(self) -> ResourceNotFoundError {
            ResourceNotFoundError {
                message: self.message,
            }
        }
    }
}
impl ResourceNotFoundError {
    /// Creates a new builder-style object to manufacture [`ResourceNotFoundError`](crate::error::ResourceNotFoundError)
    pub fn builder() -> crate::error::resource_not_found_error::Builder {
        crate::error::resource_not_found_error::Builder::default()
    }
}

/// <p>The resource is not available for this operation. For successful operation, the
/// resource must be in the <code>ACTIVE</code> state.</p>
#[non_exhaustive]
#[derive(::serde::Deserialize, ::serde::Serialize, ::std::clone::Clone, ::std::cmp::PartialEq)]
pub struct ResourceInUseError {
    /// <p>A message that provides information about the error.</p>
    #[serde(rename = "message")]
    #[serde(skip_serializing_if = "Option::is_none")]
    #[serde(default)]
    pub message: ::std::option::Option<::std::string::String>,
}
impl ::std::fmt::Debug for ResourceInUseError {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        let mut formatter = f.debug_struct("ResourceInUseError");
        formatter.field("message", &self.message);
        formatter.finish()
    }
}
impl ResourceInUseError {
    pub fn code(&self) -> &str {
        "ResourceInUseException"
    }
    pub fn message(&self) -> Option<&str> {
        self.message.as_deref()
    }
}
impl ::std::fmt::Display for ResourceInUseError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "ResourceInUseError")?;
        if let Some(inner_2) = &self.message {
            write!(f, ": {}", inner_2)?;
        }
        Ok(())
    }
}
impl ::std::error::Error for ResourceInUseError {}
/// See [`ResourceInUseError`](crate::error::ResourceInUseError)
pub mod resource_in_use_error {

    use crate::error::ResourceInUseError;
    /// A builder for [`ResourceInUseError`](crate::error::ResourceInUseError)
    #[non_exhaustive]
    #[derive(Debug, Clone, Default)]
    pub struct Builder {
        message: ::std::option::Option<::std::string::String>,
    }
    impl Builder {
        /// <p>A message that provides information about the error.</p>
        pub fn message(mut self, inp: impl Into<::std::string::String>) -> Self {
            self.message = Some(inp.into());
            self
        }
        /// Consumes the builder and constructs a [`ResourceInUseError`](crate::error::ResourceInUseError)
        pub fn build(self) -> ResourceInUseError {
            ResourceInUseError {
                message: self.message,
            }
        }
    }
}
impl ResourceInUseError {
    /// Creates a new builder-style object to manufacture [`ResourceInUseError`](crate::error::ResourceInUseError)
    pub fn builder() -> crate::error::resource_in_use_error::Builder {
        crate::error::resource_in_use_error::Builder::default()
    }
}

/// <p>The requested resource exceeds the maximum number allowed, or the number of
/// concurrent stream requests exceeds the maximum number allowed. </p>
#[non_exhaustive]
#[derive(::serde::Deserialize, ::serde::Serialize, ::std::clone::Clone, ::std::cmp::PartialEq)]
pub struct LimitExceededError {
    /// <p>A message that provides information about the error.</p>
    #[serde(rename = "message")]
    #[serde(skip_serializing_if = "Option::is_none")]
    #[serde(default)]
    pub message: ::std::option::Option<::std::string::String>,
}
impl ::std::fmt::Debug for LimitExceededError {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        let mut formatter = f.debug_struct("LimitExceededError");
        formatter.field("message", &self.message);
        formatter.finish()
    }
}
impl LimitExceededError {
    pub fn code(&self) -> &str {
        "LimitExceededException"
    }
    pub fn message(&self) -> Option<&str> {
        self.message.as_deref()
    }
}
impl ::std::fmt::Display for LimitExceededError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "LimitExceededError")?;
        if let Some(inner_3) = &self.message {
            write!(f, ": {}", inner_3)?;
        }
        Ok(())
    }
}
impl ::std::error::Error for LimitExceededError {}
/// See [`LimitExceededError`](crate::error::LimitExceededError)
pub mod limit_exceeded_error {

    use crate::error::LimitExceededError;
    /// A builder for [`LimitExceededError`](crate::error::LimitExceededError)
    #[non_exhaustive]
    #[derive(Debug, Clone, Default)]
    pub struct Builder {
        message: ::std::option::Option<::std::string::String>,
    }
    impl Builder {
        /// <p>A message that provides information about the error.</p>
        pub fn message(mut self, inp: impl Into<::std::string::String>) -> Self {
            self.message = Some(inp.into());
            self
        }
        /// Consumes the builder and constructs a [`LimitExceededError`](crate::error::LimitExceededError)
        pub fn build(self) -> LimitExceededError {
            LimitExceededError {
                message: self.message,
            }
        }
    }
}
impl LimitExceededError {
    /// Creates a new builder-style object to manufacture [`LimitExceededError`](crate::error::LimitExceededError)
    pub fn builder() -> crate::error::limit_exceeded_error::Builder {
        crate::error::limit_exceeded_error::Builder::default()
    }
}

/// <p>A specified parameter exceeds its restrictions, is not supported, or can't be used.
/// For more information, see the returned message.</p>
#[non_exhaustive]
#[derive(::serde::Deserialize, ::serde::Serialize, ::std::clone::Clone, ::std::cmp::PartialEq)]
pub struct InvalidArgumentError {
    /// <p>A message that provides information about the error.</p>
    #[serde(rename = "message")]
    #[serde(skip_serializing_if = "Option::is_none")]
    #[serde(default)]
    pub message: ::std::option::Option<::std::string::String>,
}
impl ::std::fmt::Debug for InvalidArgumentError {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        let mut formatter = f.debug_struct("InvalidArgumentError");
        formatter.field("message", &self.message);
        formatter.finish()
    }
}
impl InvalidArgumentError {
    pub fn code(&self) -> &str {
        "InvalidArgumentException"
    }
    pub fn message(&self) -> Option<&str> {
        self.message.as_deref()
    }
}
impl ::std::fmt::Display for InvalidArgumentError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "InvalidArgumentError")?;
        if let Some(inner_4) = &self.message {
            write!(f, ": {}", inner_4)?;
        }
        Ok(())
    }
}
impl ::std::error::Error for InvalidArgumentError {}
/// See [`InvalidArgumentError`](crate::error::InvalidArgumentError)
pub mod invalid_argument_error {

    use crate::error::InvalidArgumentError;
    /// A builder for [`InvalidArgumentError`](crate::error::InvalidArgumentError)
    #[non_exhaustive]
    #[derive(Debug, Clone, Default)]
    pub struct Builder {
        message: ::std::option::Option<::std::string::String>,
    }
    impl Builder {
        /// <p>A message that provides information about the error.</p>
        pub fn message(mut self, inp: impl Into<::std::string::String>) -> Self {
            self.message = Some(inp.into());
            self
        }
        /// Consumes the builder and constructs a [`InvalidArgumentError`](crate::error::InvalidArgumentError)
        pub fn build(self) -> InvalidArgumentError {
            InvalidArgumentError {
                message: self.message,
            }
        }
    }
}
impl InvalidArgumentError {
    /// Creates a new builder-style object to manufacture [`InvalidArgumentError`](crate::error::InvalidArgumentError)
    pub fn builder() -> crate::error::invalid_argument_error::Builder {
        crate::error::invalid_argument_error::Builder::default()
    }
}

/// <p>The request was rejected because the specified entity or resource can't be
/// found.</p>
#[non_exhaustive]
#[derive(::serde::Deserialize, ::serde::Serialize, ::std::clone::Clone, ::std::cmp::PartialEq)]
pub struct KMSNotFoundError {
    /// <p>A message that provides information about the error.</p>
    #[serde(rename = "message")]
    #[serde(skip_serializing_if = "Option::is_none")]
    #[serde(default)]
    pub message: ::std::option::Option<::std::string::String>,
}
impl ::std::fmt::Debug for KMSNotFoundError {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        let mut formatter = f.debug_struct("KMSNotFoundError");
        formatter.field("message", &self.message);
        formatter.finish()
    }
}
impl KMSNotFoundError {
    pub fn code(&self) -> &str {
        "KMSNotFoundException"
    }
    pub fn message(&self) -> Option<&str> {
        self.message.as_deref()
    }
}
impl ::std::fmt::Display for KMSNotFoundError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "KMSNotFoundError")?;
        if let Some(inner_5) = &self.message {
            write!(f, ": {}", inner_5)?;
        }
        Ok(())
    }
}
impl ::std::error::Error for KMSNotFoundError {}
/// See [`KMSNotFoundError`](crate::error::KMSNotFoundError)
pub mod kms_not_found_error {

    use crate::error::KMSNotFoundError;
    /// A builder for [`KMSNotFoundError`](crate::error::KMSNotFoundError)
    #[non_exhaustive]
    #[derive(Debug, Clone, Default)]
    pub struct Builder {
        message: ::std::option::Option<::std::string::String>,
    }
    impl Builder {
        /// <p>A message that provides information about the error.</p>
        pub fn message(mut self, inp: impl Into<::std::string::String>) -> Self {
            self.message = Some(inp.into());
            self
        }
        /// Consumes the builder and constructs a [`KMSNotFoundError`](crate::error::KMSNotFoundError)
        pub fn build(self) -> KMSNotFoundError {
            KMSNotFoundError {
                message: self.message,
            }
        }
    }
}
impl KMSNotFoundError {
    /// Creates a new builder-style object to manufacture [`KMSNotFoundError`](crate::error::KMSNotFoundError)
    pub fn builder() -> crate::error::kms_not_found_error::Builder {
        crate::error::kms_not_found_error::Builder::default()
    }
}

/// <p>The request was rejected because the state of the specified resource isn't valid
/// for this request. For more information, see <a href="https://docs.aws.amazon.com/kms/latest/developerguide/key-state.html">How Key State Affects Use of a
/// Customer Master Key</a> in the <i>AWS Key Management Service Developer
/// Guide</i>.</p>
#[non_exhaustive]
#[derive(::serde::Deserialize, ::serde::Serialize, ::std::clone::Clone, ::std::cmp::PartialEq)]
pub struct KMSInvalidStateError {
    /// <p>A message that provides information about the error.</p>
    #[serde(rename = "message")]
    #[serde(skip_serializing_if = "Option::is_none")]
    #[serde(default)]
    pub message: ::std::option::Option<::std::string::String>,
}
impl ::std::fmt::Debug for KMSInvalidStateError {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        let mut formatter = f.debug_struct("KMSInvalidStateError");
        formatter.field("message", &self.message);
        formatter.finish()
    }
}
impl KMSInvalidStateError {
    pub fn code(&self) -> &str {
        "KMSInvalidStateException"
    }
    pub fn message(&self) -> Option<&str> {
        self.message.as_deref()
    }
}
impl ::std::fmt::Display for KMSInvalidStateError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "KMSInvalidStateError")?;
        if let Some(inner_6) = &self.message {
            write!(f, ": {}", inner_6)?;
        }
        Ok(())
    }
}
impl ::std::error::Error for KMSInvalidStateError {}
/// See [`KMSInvalidStateError`](crate::error::KMSInvalidStateError)
pub mod kms_invalid_state_error {

    use crate::error::KMSInvalidStateError;
    /// A builder for [`KMSInvalidStateError`](crate::error::KMSInvalidStateError)
    #[non_exhaustive]
    #[derive(Debug, Clone, Default)]
    pub struct Builder {
        message: ::std::option::Option<::std::string::String>,
    }
    impl Builder {
        /// <p>A message that provides information about the error.</p>
        pub fn message(mut self, inp: impl Into<::std::string::String>) -> Self {
            self.message = Some(inp.into());
            self
        }
        /// Consumes the builder and constructs a [`KMSInvalidStateError`](crate::error::KMSInvalidStateError)
        pub fn build(self) -> KMSInvalidStateError {
            KMSInvalidStateError {
                message: self.message,
            }
        }
    }
}
impl KMSInvalidStateError {
    /// Creates a new builder-style object to manufacture [`KMSInvalidStateError`](crate::error::KMSInvalidStateError)
    pub fn builder() -> crate::error::kms_invalid_state_error::Builder {
        crate::error::kms_invalid_state_error::Builder::default()
    }
}

/// <p>The ciphertext references a key that doesn't exist or that you don't have access
/// to.</p>
#[non_exhaustive]
#[derive(::serde::Deserialize, ::serde::Serialize, ::std::clone::Clone, ::std::cmp::PartialEq)]
pub struct KMSAccessDeniedError {
    /// <p>A message that provides information about the error.</p>
    #[serde(rename = "message")]
    #[serde(skip_serializing_if = "Option::is_none")]
    #[serde(default)]
    pub message: ::std::option::Option<::std::string::String>,
}
impl ::std::fmt::Debug for KMSAccessDeniedError {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        let mut formatter = f.debug_struct("KMSAccessDeniedError");
        formatter.field("message", &self.message);
        formatter.finish()
    }
}
impl KMSAccessDeniedError {
    pub fn code(&self) -> &str {
        "KMSAccessDeniedException"
    }
    pub fn message(&self) -> Option<&str> {
        self.message.as_deref()
    }
}
impl ::std::fmt::Display for KMSAccessDeniedError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "KMSAccessDeniedError")?;
        if let Some(inner_7) = &self.message {
            write!(f, ": {}", inner_7)?;
        }
        Ok(())
    }
}
impl ::std::error::Error for KMSAccessDeniedError {}
/// See [`KMSAccessDeniedError`](crate::error::KMSAccessDeniedError)
pub mod kms_access_denied_error {

    use crate::error::KMSAccessDeniedError;
    /// A builder for [`KMSAccessDeniedError`](crate::error::KMSAccessDeniedError)
    #[non_exhaustive]
    #[derive(Debug, Clone, Default)]
    pub struct Builder {
        message: ::std::option::Option<::std::string::String>,
    }
    impl Builder {
        /// <p>A message that provides information about the error.</p>
        pub fn message(mut self, inp: impl Into<::std::string::String>) -> Self {
            self.message = Some(inp.into());
            self
        }
        /// Consumes the builder and constructs a [`KMSAccessDeniedError`](crate::error::KMSAccessDeniedError)
        pub fn build(self) -> KMSAccessDeniedError {
            KMSAccessDeniedError {
                message: self.message,
            }
        }
    }
}
impl KMSAccessDeniedError {
    /// Creates a new builder-style object to manufacture [`KMSAccessDeniedError`](crate::error::KMSAccessDeniedError)
    pub fn builder() -> crate::error::kms_access_denied_error::Builder {
        crate::error::kms_access_denied_error::Builder::default()
    }
}

/// <p>The request was rejected because the specified customer master key (CMK) isn't
/// enabled.</p>
#[non_exhaustive]
#[derive(::serde::Deserialize, ::serde::Serialize, ::std::clone::Clone, ::std::cmp::PartialEq)]
pub struct KMSDisabledError {
    /// <p>A message that provides information about the error.</p>
    #[serde(rename = "message")]
    #[serde(skip_serializing_if = "Option::is_none")]
    #[serde(default)]
    pub message: ::std::option::Option<::std::string::String>,
}
impl ::std::fmt::Debug for KMSDisabledError {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        let mut formatter = f.debug_struct("KMSDisabledError");
        formatter.field("message", &self.message);
        formatter.finish()
    }
}
impl KMSDisabledError {
    pub fn code(&self) -> &str {
        "KMSDisabledException"
    }
    pub fn message(&self) -> Option<&str> {
        self.message.as_deref()
    }
}
impl ::std::fmt::Display for KMSDisabledError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "KMSDisabledError")?;
        if let Some(inner_8) = &self.message {
            write!(f, ": {}", inner_8)?;
        }
        Ok(())
    }
}
impl ::std::error::Error for KMSDisabledError {}
/// See [`KMSDisabledError`](crate::error::KMSDisabledError)
pub mod kms_disabled_error {

    use crate::error::KMSDisabledError;
    /// A builder for [`KMSDisabledError`](crate::error::KMSDisabledError)
    #[non_exhaustive]
    #[derive(Debug, Clone, Default)]
    pub struct Builder {
        message: ::std::option::Option<::std::string::String>,
    }
    impl Builder {
        /// <p>A message that provides information about the error.</p>
        pub fn message(mut self, inp: impl Into<::std::string::String>) -> Self {
            self.message = Some(inp.into());
            self
        }
        /// Consumes the builder and constructs a [`KMSDisabledError`](crate::error::KMSDisabledError)
        pub fn build(self) -> KMSDisabledError {
            KMSDisabledError {
                message: self.message,
            }
        }
    }
}
impl KMSDisabledError {
    /// Creates a new builder-style object to manufacture [`KMSDisabledError`](crate::error::KMSDisabledError)
    pub fn builder() -> crate::error::kms_disabled_error::Builder {
        crate::error::kms_disabled_error::Builder::default()
    }
}

/// <p>The AWS access key ID needs a subscription for the service.</p>
#[non_exhaustive]
#[derive(::serde::Deserialize, ::serde::Serialize, ::std::clone::Clone, ::std::cmp::PartialEq)]
pub struct KMSOptInRequired {
    /// <p>A message that provides information about the error.</p>
    #[serde(rename = "message")]
    #[serde(skip_serializing_if = "Option::is_none")]
    #[serde(default)]
    pub message: ::std::option::Option<::std::string::String>,
}
impl ::std::fmt::Debug for KMSOptInRequired {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        let mut formatter = f.debug_struct("KMSOptInRequired");
        formatter.field("message", &self.message);
        formatter.finish()
    }
}
impl KMSOptInRequired {
    pub fn code(&self) -> &str {
        "KMSOptInRequired"
    }
    pub fn message(&self) -> Option<&str> {
        self.message.as_deref()
    }
}
impl ::std::fmt::Display for KMSOptInRequired {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "KMSOptInRequired")?;
        if let Some(inner_9) = &self.message {
            write!(f, ": {}", inner_9)?;
        }
        Ok(())
    }
}
impl ::std::error::Error for KMSOptInRequired {}
/// See [`KMSOptInRequired`](crate::error::KMSOptInRequired)
pub mod kms_opt_in_required {

    use crate::error::KMSOptInRequired;
    /// A builder for [`KMSOptInRequired`](crate::error::KMSOptInRequired)
    #[non_exhaustive]
    #[derive(Debug, Clone, Default)]
    pub struct Builder {
        message: ::std::option::Option<::std::string::String>,
    }
    impl Builder {
        /// <p>A message that provides information about the error.</p>
        pub fn message(mut self, inp: impl Into<::std::string::String>) -> Self {
            self.message = Some(inp.into());
            self
        }
        /// Consumes the builder and constructs a [`KMSOptInRequired`](crate::error::KMSOptInRequired)
        pub fn build(self) -> KMSOptInRequired {
            KMSOptInRequired {
                message: self.message,
            }
        }
    }
}
impl KMSOptInRequired {
    /// Creates a new builder-style object to manufacture [`KMSOptInRequired`](crate::error::KMSOptInRequired)
    pub fn builder() -> crate::error::kms_opt_in_required::Builder {
        crate::error::kms_opt_in_required::Builder::default()
    }
}

/// <p>The processing of the request failed because of an unknown error, exception, or
/// failure.</p>
#[non_exhaustive]
#[derive(::serde::Deserialize, ::serde::Serialize, ::std::clone::Clone, ::std::cmp::PartialEq)]
pub struct InternalFailureError {
    #[serde(rename = "message")]
    #[serde(skip_serializing_if = "Option::is_none")]
    #[serde(default)]
    pub message: ::std::option::Option<::std::string::String>,
}
impl ::std::fmt::Debug for InternalFailureError {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        let mut formatter = f.debug_struct("InternalFailureError");
        formatter.field("message", &self.message);
        formatter.finish()
    }
}
impl InternalFailureError {
    pub fn code(&self) -> &str {
        "InternalFailureException"
    }
    pub fn message(&self) -> Option<&str> {
        self.message.as_deref()
    }
}
impl ::std::fmt::Display for InternalFailureError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "InternalFailureError")?;
        if let Some(inner_10) = &self.message {
            write!(f, ": {}", inner_10)?;
        }
        Ok(())
    }
}
impl ::std::error::Error for InternalFailureError {}
/// See [`InternalFailureError`](crate::error::InternalFailureError)
pub mod internal_failure_error {

    use crate::error::InternalFailureError;
    /// A builder for [`InternalFailureError`](crate::error::InternalFailureError)
    #[non_exhaustive]
    #[derive(Debug, Clone, Default)]
    pub struct Builder {
        message: ::std::option::Option<::std::string::String>,
    }
    impl Builder {
        pub fn message(mut self, inp: impl Into<::std::string::String>) -> Self {
            self.message = Some(inp.into());
            self
        }
        /// Consumes the builder and constructs a [`InternalFailureError`](crate::error::InternalFailureError)
        pub fn build(self) -> InternalFailureError {
            InternalFailureError {
                message: self.message,
            }
        }
    }
}
impl InternalFailureError {
    /// Creates a new builder-style object to manufacture [`InternalFailureError`](crate::error::InternalFailureError)
    pub fn builder() -> crate::error::internal_failure_error::Builder {
        crate::error::internal_failure_error::Builder::default()
    }
}

/// <p>The request was denied due to request throttling. For more information about
/// throttling, see <a href="https://docs.aws.amazon.com/kms/latest/developerguide/limits.html#requests-per-second">Limits</a> in
/// the <i>AWS Key Management Service Developer Guide</i>.</p>
#[non_exhaustive]
#[derive(::serde::Deserialize, ::serde::Serialize, ::std::clone::Clone, ::std::cmp::PartialEq)]
pub struct KMSThrottlingError {
    /// <p>A message that provides information about the error.</p>
    #[serde(rename = "message")]
    #[serde(skip_serializing_if = "Option::is_none")]
    #[serde(default)]
    pub message: ::std::option::Option<::std::string::String>,
}
impl ::std::fmt::Debug for KMSThrottlingError {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        let mut formatter = f.debug_struct("KMSThrottlingError");
        formatter.field("message", &self.message);
        formatter.finish()
    }
}
impl KMSThrottlingError {
    pub fn code(&self) -> &str {
        "KMSThrottlingException"
    }
    pub fn message(&self) -> Option<&str> {
        self.message.as_deref()
    }
}
impl ::std::fmt::Display for KMSThrottlingError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "KMSThrottlingError")?;
        if let Some(inner_11) = &self.message {
            write!(f, ": {}", inner_11)?;
        }
        Ok(())
    }
}
impl ::std::error::Error for KMSThrottlingError {}
/// See [`KMSThrottlingError`](crate::error::KMSThrottlingError)
pub mod kms_throttling_error {

    use crate::error::KMSThrottlingError;
    /// A builder for [`KMSThrottlingError`](crate::error::KMSThrottlingError)
    #[non_exhaustive]
    #[derive(Debug, Clone, Default)]
    pub struct Builder {
        message: ::std::option::Option<::std::string::String>,
    }
    impl Builder {
        /// <p>A message that provides information about the error.</p>
        pub fn message(mut self, inp: impl Into<::std::string::String>) -> Self {
            self.message = Some(inp.into());
            self
        }
        /// Consumes the builder and constructs a [`KMSThrottlingError`](crate::error::KMSThrottlingError)
        pub fn build(self) -> KMSThrottlingError {
            KMSThrottlingError {
                message: self.message,
            }
        }
    }
}
impl KMSThrottlingError {
    /// Creates a new builder-style object to manufacture [`KMSThrottlingError`](crate::error::KMSThrottlingError)
    pub fn builder() -> crate::error::kms_throttling_error::Builder {
        crate::error::kms_throttling_error::Builder::default()
    }
}

/// <p>The request rate for the stream is too high, or the requested data is too large for
/// the available throughput. Reduce the frequency or size of your requests. For more
/// information, see <a href="https://docs.aws.amazon.com/kinesis/latest/dev/service-sizes-and-limits.html">Streams Limits</a> in the
/// <i>Amazon Kinesis Data Streams Developer Guide</i>, and <a href="https://docs.aws.amazon.com/general/latest/gr/api-retries.html">Error Retries and
/// Exponential Backoff in AWS</a> in the <i>AWS General
/// Reference</i>.</p>
#[non_exhaustive]
#[derive(::serde::Deserialize, ::serde::Serialize, ::std::clone::Clone, ::std::cmp::PartialEq)]
pub struct ProvisionedThroughputExceededError {
    /// <p>A message that provides information about the error.</p>
    #[serde(rename = "message")]
    #[serde(skip_serializing_if = "Option::is_none")]
    #[serde(default)]
    pub message: ::std::option::Option<::std::string::String>,
}
impl ::std::fmt::Debug for ProvisionedThroughputExceededError {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        let mut formatter = f.debug_struct("ProvisionedThroughputExceededError");
        formatter.field("message", &self.message);
        formatter.finish()
    }
}
impl ProvisionedThroughputExceededError {
    pub fn code(&self) -> &str {
        "ProvisionedThroughputExceededException"
    }
    pub fn message(&self) -> Option<&str> {
        self.message.as_deref()
    }
}
impl ::std::fmt::Display for ProvisionedThroughputExceededError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "ProvisionedThroughputExceededError")?;
        if let Some(inner_12) = &self.message {
            write!(f, ": {}", inner_12)?;
        }
        Ok(())
    }
}
impl ::std::error::Error for ProvisionedThroughputExceededError {}
/// See [`ProvisionedThroughputExceededError`](crate::error::ProvisionedThroughputExceededError)
pub mod provisioned_throughput_exceeded_error {

    use crate::error::ProvisionedThroughputExceededError;
    /// A builder for [`ProvisionedThroughputExceededError`](crate::error::ProvisionedThroughputExceededError)
    #[non_exhaustive]
    #[derive(Debug, Clone, Default)]
    pub struct Builder {
        message: ::std::option::Option<::std::string::String>,
    }
    impl Builder {
        /// <p>A message that provides information about the error.</p>
        pub fn message(mut self, inp: impl Into<::std::string::String>) -> Self {
            self.message = Some(inp.into());
            self
        }
        /// Consumes the builder and constructs a [`ProvisionedThroughputExceededError`](crate::error::ProvisionedThroughputExceededError)
        pub fn build(self) -> ProvisionedThroughputExceededError {
            ProvisionedThroughputExceededError {
                message: self.message,
            }
        }
    }
}
impl ProvisionedThroughputExceededError {
    /// Creates a new builder-style object to manufacture [`ProvisionedThroughputExceededError`](crate::error::ProvisionedThroughputExceededError)
    pub fn builder() -> crate::error::provisioned_throughput_exceeded_error::Builder {
        crate::error::provisioned_throughput_exceeded_error::Builder::default()
    }
}

/// <p>The pagination token passed to the operation is expired.</p>
#[non_exhaustive]
#[derive(::serde::Deserialize, ::serde::Serialize, ::std::clone::Clone, ::std::cmp::PartialEq)]
pub struct ExpiredNextTokenError {
    #[serde(rename = "message")]
    #[serde(skip_serializing_if = "Option::is_none")]
    #[serde(default)]
    pub message: ::std::option::Option<::std::string::String>,
}
impl ::std::fmt::Debug for ExpiredNextTokenError {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        let mut formatter = f.debug_struct("ExpiredNextTokenError");
        formatter.field("message", &self.message);
        formatter.finish()
    }
}
impl ExpiredNextTokenError {
    pub fn code(&self) -> &str {
        "ExpiredNextTokenException"
    }
    pub fn message(&self) -> Option<&str> {
        self.message.as_deref()
    }
}
impl ::std::fmt::Display for ExpiredNextTokenError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "ExpiredNextTokenError")?;
        if let Some(inner_13) = &self.message {
            write!(f, ": {}", inner_13)?;
        }
        Ok(())
    }
}
impl ::std::error::Error for ExpiredNextTokenError {}
/// See [`ExpiredNextTokenError`](crate::error::ExpiredNextTokenError)
pub mod expired_next_token_error {

    use crate::error::ExpiredNextTokenError;
    /// A builder for [`ExpiredNextTokenError`](crate::error::ExpiredNextTokenError)
    #[non_exhaustive]
    #[derive(Debug, Clone, Default)]
    pub struct Builder {
        message: ::std::option::Option<::std::string::String>,
    }
    impl Builder {
        pub fn message(mut self, inp: impl Into<::std::string::String>) -> Self {
            self.message = Some(inp.into());
            self
        }
        /// Consumes the builder and constructs a [`ExpiredNextTokenError`](crate::error::ExpiredNextTokenError)
        pub fn build(self) -> ExpiredNextTokenError {
            ExpiredNextTokenError {
                message: self.message,
            }
        }
    }
}
impl ExpiredNextTokenError {
    /// Creates a new builder-style object to manufacture [`ExpiredNextTokenError`](crate::error::ExpiredNextTokenError)
    pub fn builder() -> crate::error::expired_next_token_error::Builder {
        crate::error::expired_next_token_error::Builder::default()
    }
}

/// <p>The provided iterator exceeds the maximum age allowed.</p>
#[non_exhaustive]
#[derive(::serde::Deserialize, ::serde::Serialize, ::std::clone::Clone, ::std::cmp::PartialEq)]
pub struct ExpiredIteratorError {
    /// <p>A message that provides information about the error.</p>
    #[serde(rename = "message")]
    #[serde(skip_serializing_if = "Option::is_none")]
    #[serde(default)]
    pub message: ::std::option::Option<::std::string::String>,
}
impl ::std::fmt::Debug for ExpiredIteratorError {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        let mut formatter = f.debug_struct("ExpiredIteratorError");
        formatter.field("message", &self.message);
        formatter.finish()
    }
}
impl ExpiredIteratorError {
    pub fn code(&self) -> &str {
        "ExpiredIteratorException"
    }
    pub fn message(&self) -> Option<&str> {
        self.message.as_deref()
    }
}
impl ::std::fmt::Display for ExpiredIteratorError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "ExpiredIteratorError")?;
        if let Some(inner_14) = &self.message {
            write!(f, ": {}", inner_14)?;
        }
        Ok(())
    }
}
impl ::std::error::Error for ExpiredIteratorError {}
/// See [`ExpiredIteratorError`](crate::error::ExpiredIteratorError)
pub mod expired_iterator_error {

    use crate::error::ExpiredIteratorError;
    /// A builder for [`ExpiredIteratorError`](crate::error::ExpiredIteratorError)
    #[non_exhaustive]
    #[derive(Debug, Clone, Default)]
    pub struct Builder {
        message: ::std::option::Option<::std::string::String>,
    }
    impl Builder {
        /// <p>A message that provides information about the error.</p>
        pub fn message(mut self, inp: impl Into<::std::string::String>) -> Self {
            self.message = Some(inp.into());
            self
        }
        /// Consumes the builder and constructs a [`ExpiredIteratorError`](crate::error::ExpiredIteratorError)
        pub fn build(self) -> ExpiredIteratorError {
            ExpiredIteratorError {
                message: self.message,
            }
        }
    }
}
impl ExpiredIteratorError {
    /// Creates a new builder-style object to manufacture [`ExpiredIteratorError`](crate::error::ExpiredIteratorError)
    pub fn builder() -> crate::error::expired_iterator_error::Builder {
        crate::error::expired_iterator_error::Builder::default()
    }
}
