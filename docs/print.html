<!DOCTYPE HTML>
<html lang="en" class="sidebar-visible no-js light">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>AWS Rust SDK Design</title>

        <meta name="robots" content="noindex" />




        <!-- Custom HTML head -->



        <meta content="text/html; charset=utf-8" http-equiv="Content-Type">
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff" />


        <link rel="icon" href="favicon.svg">


        <link rel="shortcut icon" href="favicon.png">

        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        <link rel="stylesheet" href="css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">

        <link rel="stylesheet" href="fonts/fonts.css">


        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">
        <link rel="stylesheet" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->



    </head>
    <body>
        <!-- Provide site root to javascript -->
        <script type="text/javascript">
            var path_to_root = "";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script type="text/javascript">
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script type="text/javascript">
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('no-js')
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add('js');
        </script>

        <!-- Hide / unhide sidebar before it is displayed -->
        <script type="text/javascript">
            var html = document.querySelector('html');
            var sidebar = 'hidden';
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            }
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item expanded "><a href="overview.html"><strong aria-hidden="true">1.</strong> Design Overview</a></li><li class="chapter-item expanded "><a href="tenets.html"><strong aria-hidden="true">2.</strong> Tenets</a></li><li class="chapter-item expanded "><a href="faq.html"><strong aria-hidden="true">3.</strong> Design FAQ</a></li><li class="chapter-item expanded "><a href="transport/operation.html"><strong aria-hidden="true">4.</strong> Http Operations</a></li><li class="chapter-item expanded "><a href="endpoint.html"><strong aria-hidden="true">5.</strong> Endpoint Resolution</a></li><li class="chapter-item expanded "><a href="transport/middleware.html"><strong aria-hidden="true">6.</strong> HTTP middleware</a></li><li class="chapter-item expanded "><a href="smithy/overview.html"><strong aria-hidden="true">7.</strong> Smithy</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="smithy/simple_shapes.html"><strong aria-hidden="true">7.1.</strong> Simple Shapes</a></li></ol></li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle"></div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">

                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky bordered">
                    <div class="left-buttons">
                        <button id="sidebar-toggle" class="icon-button" type="button" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </button>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light (default)</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>

                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>

                    </div>

                    <h1 class="menu-title">AWS Rust SDK Design</h1>

                    <div class="right-buttons">
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>

                    </div>
                </div>


                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" name="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>


                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script type="text/javascript">
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1><a class="header" href="#design-overview" id="design-overview">Design Overview</a></h1>
<p>The AWS Rust SDK aims to provide an official, high quality &amp; complete interface to AWS services. We plan to eventually use the CRT to provide signing &amp; credential management. The Rust SDK will provide first-class support for the CRT as well as <a href="https://tokio.rs/">Tokio </a> &amp; <a href="https://hyper.rs">Hyper</a>. The Rust SDK empowers advanced customers to bring their own HTTP/IO implementations.</p>
<p>Our design choices are guided by our <a href="./tenets.html">Tenets</a>.</p>
<h2><a class="header" href="#acknowledgments" id="acknowledgments">Acknowledgments</a></h2>
<p>This design was vastly improved by countless hours of 1:1s with the members of the SDK org who generously gave their time to answer all my questions, sometimes multiple times. Outside the SDK org, David Barsky, iliana etaoin and Carl Lerche provided continuous feedback outside the scope of their day jobs that had a massive impact on the final design. And of course, the design builds on the learnings, ideas, and GitHub issues of the 142 Rusoto contributors who built this first and learned the hard way.</p>
<h2><a class="header" href="#external-api-overview" id="external-api-overview">External API Overview</a></h2>
<p>The Rust SDK is &quot;modular&quot; meaning that each AWS service is its own crate. Each crate provides two layers to access the service:</p>
<ol>
<li>The &quot;fluent&quot; API. For most use cases, a high level API that ties together connection management and serialization will be the quickest path to success.</li>
</ol>
<pre><pre class="playground"><code class="language-rust">#[tokio::main]
async fn main() {
    let client = dynamodb::Client::from_env();
    let tables = client
        .list_tables()
        .limit(10)
        .send()
        .await.expect(&quot;failed to load tables&quot;);
}
</code></pre></pre>
<ol start="2">
<li>The &quot;low-level&quot; API: It is also possible for customers to assemble the pieces themselves. This offers more control over operation construction &amp; dispatch semantics:</li>
</ol>
<pre><pre class="playground"><code class="language-rust">#[tokio::main]
async fn main() {
    let conf = dynamodb::Config::builder().build();
    let conn = aws_hyper::Client::https();
    let operation = dynamodb::ListTables::builder()
        .limit(10)
        .build(&amp;conf)
        .expect(&quot;invalid operation&quot;);
    let tables = conn.call(operation).await.expect(&quot;failed to list tables&quot;);
}
</code></pre></pre>
<p>The Fluent API is implemented as a thin wrapper around the core API to improve ergonomics.</p>
<h2><a class="header" href="#internals" id="internals">Internals</a></h2>
<p>Internally, the Rust SDK is built on Tower Middleware, Tokio &amp; Hyper. We're continuing to iterate on the internals to enable running the AWS SDK in other environments. As an example, you can see a demo of adding <code>reqwest</code> as a custom HTTP stack to gain access to its HTTP Proxy support!</p>
<p>For more details about the SDK internals see <a href="transport/operation.html">Operation Design</a></p>
<h2><a class="header" href="#code-generation" id="code-generation">Code Generation</a></h2>
<p>The Rust SDK is code generated from Smithy models, using Smithy codegeneration utilities. The Code generation is written in Kotlin. More details can be found in the <a href="./smithy/overview.html">Smithy</a> section.</p>
<h1><a class="header" href="#rust-sdk-design-tenets" id="rust-sdk-design-tenets">Rust SDK Design Tenets</a></h1>
<ol>
<li><strong>Batteries included, but replaceable.</strong> The Rust SDK should provide a best-in-class experience for many use cases, <strong>but</strong>, we can’t foresee all the situations the customer will use our software. <strong>Meet customers where they are;</strong> strive to be compatible with their tools. Provide escape hatches to allow customers make different choices.</li>
<li><strong>Dependencies must be a force multiplier for customers.</strong> Countless previous SDKs demonstrated risks of taking on third party dependencies. Using someone else’s code is high leverage for the SDK developers, but to be included, a dependency must also be high leverage for the customers.</li>
<li><strong>Customer experience &gt; our experience.</strong> Our experience developing the SDK is important, but we have limited resources and need to prioritize what makes the best possible SDK for the customer. Although our productivity is important, we must only prioritize ourselves over the customer deliberately and carefully.</li>
<li><strong>Make common problems easy to solve.</strong> Make uncommon problems solvable. Lead customers into <a href="https://blog.codinghorror.com/falling-into-the-pit-of-success/">the pit of success</a>.</li>
<li><strong>Design for the Future.</strong> We can’t know how APIs will evolve, what protocols will gain adoption, and what new service will be created. Don’t simplify or unify code today that prevents evolution tomorrow.</li>
</ol>
<h2><a class="header" href="#details-justification-and-ramifications" id="details-justification-and-ramifications">Details, Justification, and Ramifications</a></h2>
<h3><a class="header" href="#batteries-included-but-replaceable" id="batteries-included-but-replaceable">Batteries included, but replaceable.</a></h3>
<p>Some customers will use the Rust SDK as their first experience with async Rust, potentially <strong>any</strong> Rust. They aren't familiar with Tokio or the concept of an async executor. They don’t know that the ecosystem is fragmented. We shouldn't be afraid to have an opinion about the best solution for most customers.</p>
<p>Other customers will come to our SDK with specific requirements. Perhaps they’re integrating the SDK into a much larger project that uses <code>async_std</code>. Perhaps they need to set custom headers, modify the user agent, or audit every request. They should be able to use the Rust SDK without forking it to get what they need.</p>
<h3><a class="header" href="#customer-experience--our-experience" id="customer-experience--our-experience"><strong>Customer experience &gt; our experience</strong></a></h3>
<p>The choices that make the SDK easy to build may clash with decisions that make the best SDK for the customer. Although our productivity is important, we must only prioritize ourselves over the customer deliberately and carefully.</p>
<p>Although <em><strong>we</strong></em> may struggle to compile all 260 services at once, most customers will only compile one or two at a time. We cannot confuse problems that are easy to measure over problems that deliver the most customer value.</p>
<h3><a class="header" href="#make-common-problems-easy-to-solve" id="make-common-problems-easy-to-solve">Make common problems easy to solve</a></h3>
<p>If solving a common problem isn’t obvious from the API, it should be obvious from the documentation. Don’t let customers shoot themselves in foot. Especially, with async Rust, there are a <a href="https://github.com/rusoto/rusoto/issues/1726">number of footguns</a>. The first priority is providing tools to solve common problems in an idiomatic way. If this isn’t possible, provide easy-to-find authoritative documentation with numerous examples following best practices.</p>
<h3><a class="header" href="#design-for-the-future" id="design-for-the-future"><strong>Design for the Future</strong></a></h3>
<p>We can’t consider every potential future API evolution, so it’s crucial that we can add new modes for new services without breaking existing clients. This means limiting the blast radius of changes:</p>
<ul>
<li>Keeping the shared core as small &amp; opaque as possible.</li>
<li>Don’t leak our internal dependencies to customers</li>
</ul>
<p>This may fly in the face of DRY code, and that’s OK! Codegen is different than hand written code.</p>
<h1><a class="header" href="#design-faq" id="design-faq">Design FAQ</a></h1>
<h3><a class="header" href="#what-is-smithy" id="what-is-smithy">What is Smithy?</a></h3>
<p>Smithy is the interface design language used by AWS services. <code>smithy-rs</code> allows users to generate a Rust client for any Smithy based service (pending protocol support), including those outside of AWS.</p>
<h3><a class="header" href="#why-is-there-one-crate-per-service" id="why-is-there-one-crate-per-service">Why is there one crate per service?</a></h3>
<ol>
<li>
<p>Compilation time: Although it's possible to use cargo features to conditionally compile individual services, we decided that this added significant complexity to the generated code. In Rust the &quot;unit of compilation&quot; is a Crate, so by using smaller crates we can get better compilation parallelism.</p>
</li>
<li>
<p>Versioning: It is expected that over time we may major-version-bump individual services. New updates will be pushed for <em>some</em> AWS service nearly every day. Maintaining separate crates allows us to only increment versions for the relevant pieces that change.</p>
</li>
</ol>
<p>It is worth noting that this isn't a set-in-stone design decision. A parent crate may be even be created at some point!</p>
<h1><a class="header" href="#http-based-operations" id="http-based-operations">HTTP-based Operations</a></h1>
<p>The Smithy code generator for Rust (and by extension), the AWS SDK use an <code>Operation</code> abstraction to provide a unified
interface for dispatching requests. <code>Operation</code>s contain:</p>
<ul>
<li>A base HTTP request (with a potentially streaming body)</li>
<li>A typed property bag of configuration options</li>
<li>A fully generic response handler</li>
</ul>
<p>In the typical case, these configuration options include things like a <code>CredentialsProvider</code>, however, they can also be
full middleware layers that will get added by the dispatch stack.</p>
<h2><a class="header" href="#operation-phases" id="operation-phases">Operation Phases</a></h2>
<p>This section details the flow of a request through the SDK until a response is returned to the user.</p>
<h3><a class="header" href="#input-construction" id="input-construction">Input Construction</a></h3>
<p>A customer interacts with the SDK builders to construct an input. The <code>build()</code> method on an input returns
an <code>Operation&lt;Output&gt;</code>. This codifies the base HTTP request &amp; all the configuration and middleware layers required to modify and dispatch the request.</p>
<pre><code class="language-rust ignore">pub struct Operation&lt;H, R&gt; {
    request: Request,
    response_handler: H,
    _retry_policy: R,
}

pub struct Request {
    base: http::Request&lt;SdkBody&gt;,
    configuration: PropertyBag,
}
</code></pre>
<p>For most requests, <code>.build()</code> will NOT consume the input. A user can call <code>.build()</code> multiple times to produce multiple operations from the same input.</p>
<p>By using a property bag, we can define the <code>Operation</code> in Smithy core. AWS specific configuration can be added later in the stack.</p>
<h3><a class="header" href="#operation-construction" id="operation-construction">Operation Construction</a></h3>
<p>In order to construct an operation, the generated code injects appropriate middleware &amp; configuration via the configuration property bag. It does this by reading the configuration properties out of the service
config, copying them as necessary, and loading them into the <code>Request</code>:</p>
<pre><code class="language-rust ignore">// This is approximately the generated code, I've cleaned a few things up for readability.
pub fn build(self, config: &amp;dynamodb::config::Config) -&gt; Operation&lt;BatchExecuteStatement&gt; {
    let op = BatchExecuteStatement::new(BatchExecuteStatementInput {
        statements: self.statements,
    });
    let req = op.build_http_request().map(SdkBody::from);

    let mut req = operation::Request::new(req);
    let mut conf = req.config_mut();
    conf.insert_signing_config(config.signing_service());
    conf.insert_endpoint_resolver(config.endpoint_resolver.clone());
    Operation::new(req)
}
</code></pre>
<h3><a class="header" href="#operation-dispatch-and-middleware" id="operation-dispatch-and-middleware">Operation Dispatch and Middleware</a></h3>
<p>The Rust SDK endeavors to behave as predictably as possible. This means that if at all possible we will not dispatch extra HTTP requests during the dispatch of normal operation. Making this work is covered in more detail in the design of credentials providers &amp; endpoint resolution.</p>
<p>The upshot is that we will always prefer a design where the user has explicit control of when credentials are loaded and endpoints are resolved. This doesn't mean that users can't use easy-to-use options (We will provide an automatically refreshing credentials provider), however, the credential provider won't load requests during the dispatch of an individual request.</p>
<h2><a class="header" href="#operation-parsing-and-response-loading" id="operation-parsing-and-response-loading">Operation Parsing and Response Loading</a></h2>
<p>The fundamental trait for HTTP-based protocols is <code>ParseHttpResponse</code></p>
<h1><a class="header" href="#endpoint-resolution" id="endpoint-resolution">Endpoint Resolution</a></h1>
<h2><a class="header" href="#requirements" id="requirements">Requirements</a></h2>
<p>The core codegen generates HTTP requests that do not contain an authority, scheme or post. These properties must be set later based on configuration. Existing AWS services have a number of requirements that increase the complexity:</p>
<ol>
<li>Endpoints must support manual configuration by end users:</li>
</ol>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let config = dynamodb::Config::builder()
    .endpoint(StaticEndpoint::for_uri(&quot;http://localhost:8000&quot;))
<span class="boring">}
</span></code></pre></pre>
<p>When a user specifies a custom endpoint URI, <em>typically</em> they will want to avoid having this URI mutated by other endpoint discovery machinery.</p>
<ol start="2">
<li>
<p>Endpoints must support being customized on a per-operation basis by the endpoint trait. This will prefix the base endpoint, potentially driven by fields of the operation. <a href="https://awslabs.github.io/smithy/1.0/spec/core/endpoint-traits.html#endpoint-trait">Docs</a></p>
</li>
<li>
<p>Endpoints must support being customized by <a href="https://awslabs.github.io/smithy/1.0/spec/aws/aws-core.html#client-endpoint-discovery">endpoint discovery</a>. A request, customized by a predefined set of fields from the input operation is dispatched to a specific URI. That operation returns the endpoint that should be used. Endpoints must be cached by a cache key containing:</p>
</li>
</ol>
<pre><code>(access_key_id, [all input fields], operation)
</code></pre>
<p>Endpoints retrieved in this way specify a TTL.</p>
<ol start="4">
<li>Endpoints must be able to customize the signing (and other phases of the operation). For example, requests sent to a global region will have a region set by the endpoint provider.</li>
</ol>
<h2><a class="header" href="#design" id="design">Design</a></h2>
<p>Configuration objects for services <em>must</em> contain an <code>Endpoint</code>. This endpoint may be set by a user or it will default to the <code>endpointPrefix</code> from the service definition. In the case of endpoint discovery, <em>this</em> is the endpoint that we will start with.</p>
<p>During operation construction (see <a href="transport/operation.html#operation-construction">Operation Construction</a>) an <code>EndpointPrefix</code> may be set on the property bag. The eventual endpoint middleware will search for this in the property bag and (depending on the URI mutability) utilize this prefix when setting the endpoint.</p>
<p>In the case of endpoint discovery, we envision a different pattern:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// EndpointClient manages the endpoint cache
let (tx, rx) = dynamodb::EndpointClient::new();
let client = aws_hyper::Client::new();
// `endpoint_req` is an operation that can be dispatched to retrieve endpoints
// During operation construction, the endpoint resolver is configured to be `rx` instead static endpoint
// resolver provided by the service.
let (endpoint_req, req) = GetRecord::builder().endpoint_disco(rx).build_with_endpoint();
// depending on the duration of endpoint expiration, this may be spawned into a separate task to continuously
// refresh endpoints.
if tx.needs(endpoint_req) {
    let new_endpoint = client.
        call(endpoint_req)
        .await;
    tx.send(new_endpoint)
}
let rsp = client.call(req).await?;
<span class="boring">}
</span></code></pre></pre>
<p>We believe that this design results in an SDK that both offers customers more control &amp; reduces the likelihood of bugs from nested operation dispatch. Endpoint resolution is currently extremely rare in AWS services so this design may remain a prototype while we solidify other behaviors.</p>
<h1><a class="header" href="#http-middleware" id="http-middleware">HTTP middleware</a></h1>
<p>Signing, endpoint specification, and logging are all handled as middleware. The Rust SDK takes a minimalist approach to middleware:</p>
<p>Middleware is defined as minimally as possible, then adapted into the middleware system used by the IO layer. Tower is the de facto standard for HTTP middleware in Rust—we will probably use it. But we also want to make our middleware usable for users who aren't using Tower (or if we decide to not use Tower in the long run).</p>
<p>Because of this, rather than implementing all our middleware as &quot;Tower Middleware&quot;, we implement it narrowly (eg. as a function that operates on <code>operation::Request</code>), then define optional adapters to make our middleware tower compatible.</p>
<h1><a class="header" href="#smithy" id="smithy">Smithy</a></h1>
<p>The Rust SDK uses Smithy models and code generation tooling to generate an SDK. Smithy is an open source IDL (interface design language) developed by Amazon. Although the Rust SDK uses Smithy models for AWS services, smithy-rs and Smithy models in general are not AWS specific.</p>
<h2><a class="header" href="#internals-1" id="internals-1">Internals</a></h2>
<p>Smithy introduces a few concepts that are defined here:</p>
<ol>
<li>
<p>Shape: The core Smithy primitive. A smithy model is composed of nested shapes defining an API.</p>
</li>
<li>
<p><code>Symbol</code>: A Representation of a type including namespaces &amp; and any dependencies required to use a type. A shape can be converted into a symbol by a <code>SymbolVisitor</code>. A <code>SymbolVisitor</code> maps shapes to types in your programming language (eg. Rust). In the Rust SDK, see <a href="https://github.com/awslabs/smithy-rs/blob/c049a37f8cba5f9bec2e96c28db83e7efb2edc53/codegen/src/main/kotlin/software/amazon/smithy/rust/codegen/smithy/SymbolVisitor.kt">SymbolVisitor.kt</a>.</p>
</li>
<li>
<p><code>Writer</code>: Writers are code generation primitives that collect code prior to being written to a file. Writers enable language specific helpers to be added to simplify codegen for a given language. For example, <code>smithy-rs</code> adds <code>rustBlock</code> to <a href="https://github.com/awslabs/smithy-rs/blob/908dec558e26bbae6fe4b7d9d1c221dd81699b59/codegen/src/main/kotlin/software/amazon/smithy/rust/codegen/rustlang/RustWriter.kt"><code>RustWriter</code></a> to create a &quot;Rust block&quot; of code.</p>
<pre><code class="language-kotlin">writer.rustBlock(&quot;struct Model&quot;) {
    model.fields.forEach {
        write(&quot;${field.name}: #T&quot;, field.symbol)
    }
}
</code></pre>
<p>This would produce something like:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>struct Model {
   field1: u32,
   field2: String
}
<span class="boring">}
</span></code></pre></pre>
</li>
<li>
<p>Generators: A Generator, eg. <code>StructureGenerator</code>, <code>UnionGenerator</code> generates more complex Rust code from a Smithy model. Protocol generators pull these individual tools together to generate code for an entire service / protocol.</p>
</li>
</ol>
<h1><a class="header" href="#simple-shapes" id="simple-shapes">Simple Shapes</a></h1>
<table><thead><tr><th>Smithy Type (links to design discussions)</th><th>Rust Type (links to Rust documentation)</th></tr></thead><tbody>
<tr><td>blob</td><td><code>Vec&lt;u8&gt;</code></td></tr>
<tr><td>boolean</td><td><a href="https://doc.rust-lang.org/std/primitive.bool.html"><code>bool</code></a></td></tr>
<tr><td><a href="smithy/simple_shapes.html#strings">string</a></td><td><a href="https://doc.rust-lang.org/std/string/struct.String.html"><code>String</code></a></td></tr>
<tr><td>byte</td><td><code>i8</code></td></tr>
<tr><td>short</td><td><code>i16</code></td></tr>
<tr><td>integer</td><td><code>i32</code></td></tr>
<tr><td>long</td><td><code>i64</code></td></tr>
<tr><td>float</td><td><code>f32</code></td></tr>
<tr><td>double</td><td><code>f64</code></td></tr>
<tr><td><a href="smithy/simple_shapes.html#big-numbers">bigInteger</a></td><td><code>BigInteger</code> (Not implemented yet)</td></tr>
<tr><td><a href="smithy/simple_shapes.html#big-numbers">bigDecimal</a></td><td><code>BigDecimal</code> (Not implemented yet)</td></tr>
<tr><td><a href="smithy/simple_shapes.html#timestamps">timestamp</a></td><td><a href="https://github.com/awslabs/smithy-rs/blob/main/rust-runtime/smithy-types/src/instant/mod.rs"><code>Instant</code></a></td></tr>
<tr><td><a href="smithy/simple_shapes.html#documents">document</a></td><td><code>Document</code> (https://github.com/awslabs/smithy-rs/blob/v0.6-rc.1/rust-runtime/smithy-types/src/lib.rs#L33-L41)</td></tr>
</tbody></table>
<h3><a class="header" href="#big-numbers" id="big-numbers">Big Numbers</a></h3>
<p>Rust currently has no standard library or universally accepted large-number crate. Until one is stabilized, a string representation is a reasonable compromise:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub struct BigInteger(String);
pub struct BigDecimal(String);
<span class="boring">}
</span></code></pre></pre>
<p>This will enable us to add helpers over time as requested. Users will also be able to define their own conversions into their preferred large-number libraries.</p>
<p>As of 4/17/2021 BigInteger / BigDecimal are not included in AWS models. Implementation is tracked <a href="https://github.com/awslabs/smithy-rs/issues/312">here</a>.</p>
<h3><a class="header" href="#timestamps" id="timestamps">Timestamps</a></h3>
<p><a href="https://github.com/chronotope/chrono">chrono</a> is the current de facto library for datetime in Rust, but it is pre-1.0. Instants are represented by an SDK defined structure modeled on <code>std::time::Duration</code> from the Rust standard library.</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span>
<span class="boring">fn main() {
</span>#[derive(Debug, PartialEq, Clone, Copy)]
pub struct Instant {
    seconds: i64,
    subsecond_nanos: u32,
}

<span class="boring">}
</span></code></pre></pre>
<p>A <code>to_chrono()</code> method on <code>Instant</code> enables conversion from SDK instants to <code>chrono</code> dates.</p>
<h3><a class="header" href="#strings" id="strings">Strings</a></h3>
<p>Rust has two different String representations:</p>
<ul>
<li><code>String</code>, an owned, heap allocated string.</li>
<li><code>&amp;str</code>, a reference to a string, owned elsewhere.</li>
</ul>
<p>In ideal world, input shapes, where there is no reason for the strings to be owned would use <code>&amp;'a str</code>. Outputs would likely use <code>String</code>. However, Smithy does not provide a distinction between input and output shapes.</p>
<p>A third compromise could be storing <code>Arc&lt;String&gt;</code>, an atomic reference counted pointer to a <code>String</code>. This may be ideal for certain advanced users, but is likely to confuse most users and produces worse ergonomics. <em>This is an open design area where we will seek user feedback.</em> Rusoto uses <code>String</code> and there has been <a href="https://github.com/rusoto/rusoto/issues/1806">one feature request</a> to date to change that.</p>
<p>Current models represent strings as <code>String</code>.</p>
<h3><a class="header" href="#document-types" id="document-types">Document Types</a></h3>
<p>Smithy defines the concept of &quot;Document Types&quot;:</p>
<blockquote>
<p>[Documents represent] protocol-agnostic open content that is accessed like JSON data. Open content is useful for modeling unstructured data that has no schema, data that can't be modeled using rigid types, or data that has a schema that evolves outside of the purview of a model. The serialization format of a document is an implementation detail of a protocol and MUST NOT have any effect on the types exposed by tooling to represent a document value.</p>
</blockquote>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span>
<span class="boring">fn main() {
</span>/// Document Type
///
/// Document types represents protocol-agnostic open content that is accessed like JSON data.
/// Open content is useful for modeling unstructured data that has no schema, data that can't be
/// modeled using rigid types, or data that has a schema that evolves outside of the purview of a model.
/// The serialization format of a document is an implementation detail of a protocol.
#[derive(Debug, Clone, PartialEq)]
pub enum Document {
    Object(HashMap&lt;String, Document&gt;),
    Array(Vec&lt;Document&gt;),
    Number(Number),
    String(String),
    Bool(bool),
    Null,
}

/// A number type that implements Javascript / JSON semantics, modeled on serde_json:
/// https://docs.serde.rs/src/serde_json/number.rs.html#20-22
#[derive(Debug, Clone, Copy, PartialEq)]
pub enum Number {
    PosInt(u64),
    NegInt(i64),
    Float(f64),
}

<span class="boring">}
</span></code></pre></pre>
<p>Individual protocols define their own document serialization behavior, typically by creating a newtype around <code>Document</code> that implements <code>serde::Serialize/serde::Deserialize</code>. See <a href="https://github.com/awslabs/smithy-rs/blob/138320e99e6c7aaf14217d07cf996ba07349dd5e/rust-runtime/inlineable/src/doc_json.rs">Document Json Serialization</a></p>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->




                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">



            </nav>

        </div>








        <script type="text/javascript">
            window.playground_copyable = true;
        </script>





        <script src="elasticlunr.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="mark.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="searcher.js" type="text/javascript" charset="utf-8"></script>


        <script src="clipboard.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="highlight.js" type="text/javascript" charset="utf-8"></script>
        <script src="book.js" type="text/javascript" charset="utf-8"></script>

        <!-- Custom JS scripts -->




        <script type="text/javascript">
        window.addEventListener('load', function() {
            window.setTimeout(window.print, 100);
        });
        </script>



    </body>
</html>
